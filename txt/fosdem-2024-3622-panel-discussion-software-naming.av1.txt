Okay, so I think we're live now.
So thank you very much everyone for coming.
Today we're in for a bit of a treat as far as I'm concerned because we've got all the
experts in the various, three of the various formats, naming formats.
There's two hard problems in computer science.
One is cash invalidation and the other is naming.
And naming and how we actually refer to things is what we're going to be talking about today.
And so with that, I'd like to ask each of the panelists to introduce themselves and then
talk about the use case, other format that they're representing for naming and the use cases.
And if we could do a round robin and then want to open it up for questions between panelists
as well as the audience.
And we will try to make sure we repeat the questions for the stream.
And with that, I'll start off with Eva.
Thanks Kate.
Hello folks, hello stream.
Eva Black currently leading open source security at CISA in the US.
Only for about six months.
Please don't ask me any questions about government.
I've been an open source developer way, way longer starting in the late 90s.
Did some hashing and encryption stuff way back then.
Databases, cloud computing, infrastructure hardware security.
And about three years ago had this weird idea as S bombs were becoming popular or in the
sort of zeitgeistive discussion.
How do we really do supply chain traceability, artifact resolution across heterogeneous languages,
build tools, supply chains and open source without burdening developers.
Without going around and telling an unbounded set of open source projects, volunteers, hey
you need to adopt a bunch of new tools that will cost you either time or money to build
these S bombs.
Couldn't we find a finite set, a small set of projects to make changes in maybe GCC to
start with and then on up the chain from there to Docker build, RPM, etc.
To connect to the dots as it were.
So that the end state, you download a package from PyPy, you download a container from Dockerhub.
Whatever, that it has a signature and a graph and gosh we already have this technology, it's
called Git.
Underneath Git is a directed acyclic graph of hash identifier maps.
Couldn't we repurpose that?
Yeah, it turns out we can.
It wasn't that hard.
And you can build this hash map or what we call an artifact input manifest.
At each step in a build process and then chain it to the next step in someone else's build
process and if everyone did this automatically in our build tools, it wouldn't take more
developer effort after we modify the build tools but at the end of it you could trace
all the way back to the source files and the intermediate steps and the use case if we
know that these versions of the log for J package, these file hashes have a known vulnerability
and you have a Java binary, JVM.
You don't know if log for J is in there or what version.
You can do some composition analysis, maybe find it.
You can look at the S-bomb but today they're not deep enough to tell you that.
You can ask your vendor and wait for a response but if we had the full artifact dependency
graph you could just do a hash lookup.
Is this hash in this graph somewhere and then go oh, whoops, probably a problem here or
probably safe.
The goal is better fidelity information for defense teams.
That's my use case.
There are others.
Other people have come up with four omnibor.
That's it.
Thank you.
Thank you.
So Philippe and Wadan, for those we are in the room.
I've already introduced myself but the videos will be split.
So I'm the maintainer of many open source tools in the SES space and I'm the co-creator
and creator of something called package URL that I represent today.
In contrast with what Eva said, I think there's another way to look at things which is not
trying to change the world but just take it as it is and try to observe and very modestly
try to extract what we have for that.
Package URL, interestingly enough, was really introduced in this very room in 2018.
It was a package and dependency management dev room.
And it comes from work we did on scan code and the early version of vulnerable code where
we had a very simple problem.
We were collecting package data from many different package managers, parsing manifest,
we're collecting dependencies and it was a mess to figure out when the package is named
file as a Ruby package, is it the same as file in Debian?
Well, it happens, they're completely different.
And so what we said and say, well, Debian file version one, two, three is the name of
the package and that's essentially the essence of Perl and that's all there is to it, not
much more.
If it's on Ruby gem, you say gem file one, two, three.
And each of these ecosystems, we call package type, are the ones that are doing the hard
work to ensure that the names are mostly unique.
And the nice thing, I don't know how it happened, but eventually every tool in the space is
using that spec at some level or something which is very close to it.
And the NVD is considering something similar, for instance, database called OSV in part of
the Linux foundation of NSSF and Google is using also Perl, they're also using some of
the tools we built around Perl for version range.
So it's great.
I think it's awesome because it's a way to, even if we don't talk the same language, ensuring
that when we talk about a package, we mostly talk about the same thing.
Hello.
Yeah, I'm Alexios Alvarez.
You don't know me.
Let me see if I can plug this in again.
Right.
Right.
This slide I had prepared talks about things that you cannot see.
Names and locators and identifiers and all this stuff which might or not not be.
Yeah.
Okay.
We can do it without.
Can I?
You have.
Go speak.
I'm going to try to get yourself.
You know, wonderful.
Okay.
So when we're talking about the naming as Kate mentioned, right, we have to think about
name, locators and identifiers and the slide I was prepared to show was that there are
two different ways to refer to things.
First of all, why do we want to refer to things?
We want to refer to things in order to communicate and say, okay, we're all talking about this
thing, right?
We give them a name.
Right.
Okay.
You have an idea why?
Yeah, yeah, definitely things.
Okay.
It will be discussion.
It will be discussion.
Right.
So there are what we're calling intrinsic and extrinsic identifiers.
Right.
Oh, perfect.
Thank you, Phillip.
Oh, thank you, everyone.
I don't know.
Okay.
You know me.
You don't know that.
Yeah.
Right.
So there are, I wanted to show, I took some time to create pictures.
Right.
So there are extrinsic and intrinsic identifiers.
Extrinsic rely on a registry or catalog or directory, whatever you want to call it, which
keeps the correspondence between the name and the object.
Right.
And intrinsic, there is the connection of the object is inside the name.
Right.
Referring to non-digital world examples.
Right.
We have ISBNs.
Right.
So the ISBN is a number, but there is somewhere some database, registry, whatever you want
to call it.
Right.
That assign that corresponds a specific book to the ISBN.
Right.
Or a passport ID or something like that.
Somebody else keeps the correspondence between the name and the entity.
Right.
And there are intrinsic and in real, I mean, analog world, non-digital world.
Right.
We have chemical formulas.
Right.
When you're saying, nature chloride, sodium chloride, it's salt.
Right.
And this is actually what is the components of the object.
Right.
Or in musical notation, when you listen, when you see this one, you see that it goes,
da, da, da, da, and you understand it's bit of a truth.
Right.
And there is no registry or directory that gives you the correspondence between these
two.
Right.
And on the digital world, as we've already heard, examples are, you know, URLs, URIs,
DOIs, Perls that you just heard, and Omnibor, Ditoid, or whatever, software hash ID, these
are based on the content and there is no.
So I'm here because I'm involved with software hash ID, which is an attempt to produce unique
IDs for every digital artifact.
Right.
It's been used in software heritage and the largest archive of source in the world.
And it's on its way to become an ISO standard.
And it's based as we heard there ever before on hashies, on the content.
So you know, it uniquely identifies things based on the actual content.
So let me try to summarize here.
Okay.
The software hash IDs is referencing to a global archive and you have this starting
point.
No, it's not reference archive.
It's the content.
The content in the archive.
No.
The content of the...
It's the content of the object.
Right.
Where you find it, it's a completely different thing.
Right.
It's how do we call it.
Right.
There is an archive, software heritage archive, and you can find different things.
You can find them or maybe not find them.
It's not necessary that you will find it there.
Our discussion here is about naming.
Right.
Yeah.
Okay.
So this is a source of truth for a naming.
The omniborx Gidoids are...
Here is how things have intermediately been named as they've gone through the build tools.
Very close.
Okay.
Very close.
So each of the objects in a build chain, including the final one, get a hash ID.
A similar process, slightly different function, but same principle.
The difference is we, instead of using the identifier of the object, use the identifier
of the build tree behind it to identify it.
That's the only functional difference.
And then pearls are basically representing, oh, I found this and it may refer to things,
other things may refer to these and link the pearls to these.
It's a locator.
Locator.
Yeah.
It's a locator and it's also an identifier.
And we even summoned the authorities on URLs and URIs from W33 to ask whether it was a URL.
Okay.
And says, yes, it's a URL.
It's also an identifier.
The thing is that it's also something you observe when you have an NPM package called
React version 2.3.
That's what you have.
So it's not based strictly on the content, but it's based on the package manifest and
way of naming them there.
Okay.
We're starting to see the questions show up for questions.
So just say your question.
I'll repeat it for them.
On the one for hashes, is it...
Which one?
The hash map.
That's a false of them.
Okay.
So is it the case that anyone with a proper algorithm can come up with the same results?
Yes.
Independent later is no central authority.
So the question is, for the hash IDs, can anyone come up with the same result independent
and there's no central authority?
Short answer is yes.
Both of us use a published, widely known function to derive the hashes.
This is why it's called an intrinsic identifier.
Given an artifact, a file you found with any name, you can derive the identifier and then
look it up somewhere else.
Is the name part of the identifier?
Doesn't have to be.
Is that a...
Is the name part of the identifier?
With the question and not necessarily.
I can download something off of BitTorrent with a random name.
It could be named after a movie star.
It doesn't matter.
And I derive the identifier, look it up on some global database and realize it's actually
an NPN package.
Actually, it depends.
Right.
So do you want the name to be part?
If you're talking about...
Because this is about identifiers for digital artifacts.
So if it's a file, you probably don't care how it's called.
So you only look at the content.
But if it's a directory or a tree, do you care about the names or the things in there
or on the contents?
If it's not a directory, if it's only a commit or it's a revision or it's a package thing,
it's a release.
So in some cases you care, some cases you don't care.
But if we're talking about single files or snippets or something like that, yeah, you
don't care about some other names that it has.
Next question.
Governance.
Uh-huh.
Can somebody tell me about the governance about any of these things such as the Perl spec
on the door, how are these being governed, where are they being developed, who's issuing
them, et cetera?
Okay.
I can answer on Perl.
It's a loose coalition of volunteers.
I'm going to repeat the question.
So what's the governance for these different efforts and in particular I'll answer for
Perl.
It's the loose governance based on a coalition of willing participants, including folks originally
from Microsoft, there were folks from Google, there's folks from Sonatype, from the Cyclone
DX project and folks from ART and SPDX.
Yeah, no, no, no, I go there.
Eventually there's been a pressure to get more governance and process in place, which
is a good thing, but that's something I like to also do only at the last minute.
I'm a proponent of a bit less process whenever possible and I think most of the developers
appreciate a bit less process when possible.
So we're considering moving to a non-profit charity, potentially a wasp and that will
mean also adopting at the same time a bit more formalized process.
So that's the long answer.
Software Hush ID started from the people who built the software heritage, but right now
it's spun out of it.
It's run under the community spec governance model, SWHD.org, everyone can contribute,
everyone can help and it will follow the process for submitting a spec and becoming standard.
And Omnibor is in about the same place.
It's under the community specification license.
It's a website, a calendar, weekly meetings.
Anyone who shows up can participate, contribute.
The actual governance right now is mostly the regulars are Microsoft or X Microsoft and
Cisco or X Cisco and other folks from several other companies show up regularly, but there's
not a certain governance until it moves into a non-profit.
Okay, next.
Go ahead.
Yes, we have many identifiers.
Is there a way to convert between some of them or not?
Okay, so the question is we have many identifiers here.
Is there a way to convert between some of them or not?
What makes sense?
Okay, I'll let the beat start.
Okay, the short answer is yes.
And in the end, if you get a checksum on say a Zilibar archive, that's essentially observing
the content.
So that's what you would get in a much more sophisticated way with the SWHD or Omnibor.
If you know where you got it from, you can get a pearl.
If you have a packet manifest, you get a pearl.
The two are not in conflict, they're complementary.
And the last answer I make is that in the things we do on a bot code, we have this database
where we track in both the checksums.
We don't track SWHD, but we don't track yet Omnibor.
And we have the pearls for all the packages.
So eventually there will be public data available to get this kind of mapping and correspondence.
So as you can see from the table, they're two different.
It's not easy to always translate, right?
The same way, think of it, forget these things.
If it's a URL and the text file, right, maybe it's always the same, maybe it has changed.
Right, you don't know.
This relies on the registry.
We assume that the registry is responsible and it stays there.
These are all based on the content, right?
The nice thing is that I think we're using the same algorithm, so these are very easily
convertible to each other.
Right.
These are just for files or, I mean, the usual things.
I will borrow your phrase.
It's complicated, but in this case, I think the short answer is no.
Given a pearl, not all, but some pearls do not contain hash identifiers, only a location.
If the content at that location is gone or inaccessible to you for some reason, you
could not derive and could not translate that pearl into a hash ID.
In either of these hash IDs, you cannot give only the hash ID, say the omnivore ID or the
clever heritage ID.
You can't just transform it to the other one.
You have to go back to the original artifact and re-derive the other one.
It's math.
But there was a lovely research paper done recently on analyzing all of these.
The outcome of that is to say, we probably need both at the same time, because there
are certain benefits, use cases, needs that only can be answered from an extrinsic identifier
and some that can only be answered from an intrinsic identifier.
We've got to have a system that supports both at the same time to reference objects.
Just one quick word there.
We can do NPM install, react at 123.
We cannot do today NPM install ABCD 3625, and it's not super expressive.
We could.
In the end, you may need both.
Go ahead.
Go ahead.
So the question here is, really like the NPM, is there a way to do that?
So the question here is, really like the omnibore information, and it's good for the
compliance side of it, but will we have the information for the commercial components?
And will basically people be providing it when they're sending things out, S-bombs,
and so forth?
Do you have any perspective?
Right.
Yeah.
So things that are proprietary and commercial and they're not public, is it possible
to use them effectively, efficiently?
Okay.
So the artifact graph that omnibore uses is content opaque.
It's built out of the hash identifier of the content tree, but it doesn't tell you what
the source code is.
So hypothetically, a company which produces proprietary software could publish both the
identifier of the end result and the full hash map of all of its components without
telling you what's in it.
They could.
They could.
Do they today?
No, but they could.
And some vendors are looking into doing this.
Okay.
He's been patient here, so.
I would say the dinosaur I'm missing on the slide, there is this quote, CPE.
Yeah, thank you.
I was going to bring this.
What I would encourage you is to find similar to the aliases in the vulnerabilities area,
that you don't have just one system owning the truth, but you can digest multiple ones.
I see very much a similarity here.
Yeah, I do too.
It was like I say, it was very much an elephant in the room and we will let Philippe talk
to it because he's been dealing with it for a while.
So two things there.
First, we have to be grateful for CPE to exist.
And I remember maybe about a year ago, I was in a call with folks that include the creator
of CPE and he was apologetic saying, I'm really sorry for CPE.
He says, don't be sorry, man.
Nobody was doing anything before you.
So it doesn't have to be sorry.
So first, let's put things back in perspective.
The second thing that comes from an era where the things people cared for was is Microsoft
Office vulnerable is Adobe Acrobat vulnerable.
We moved away from that massively and things are evolving and that's why we're here.
The things about CPE versus other identifiers that you need to have knowledge that's external
to the code.
That makes it difficult.
Originally, GNU ZeeLib was the name for ZeeLib.
Nobody knows why GNU.
It's changed since, but there's the difficulty.
Each time you have something, you cannot observe the code.
It makes things difficult.
Okay.
I think we're having to wrap up right now.
We're getting pretty close.
So if everyone just wants to give me a one minute summary of what their perspective is
here and then I will let people meet up with the panelists outside the room, et cetera,
if they want further discussions.
Eva.
Thanks, Kate.
Moving on to what Philippe just pointed out and all of the conversations of the past few
days and the last year around the European Commission and the CRA, the world has changed.
Proprietary software is still super important, but we know that most software in the world,
including lots of hardware, the stack is predominantly open source today.
Open source is done by volunteers.
It's heterogeneous.
It's complex.
The supply chains are deep.
We try to do analysis.
Our analysis tools fail because of the fractal nature of our dependency trees.
I have yet to see any other proposals for identifiers that also give us visibility down
that fractal dependency tree.
I would love to see one.
Just to add on top of this, there's a thing, a number of things you can observe.
Other things you need to discover.
There's two tools which are very useful there, being able to have an index.
Index of omniboruses, the launched ID.
Software it is a small index which has a couple of petabytes of code for you there to play
with.
The other thing is being able to do lightweight reverse engineering of the binaries that are
built will go a very long way.
There's existing techniques.
I'm building a bunch of tools in this domain.
Eventually there's, I think there will be ways to tag and document in the binaries and
the more complex piece of code where the code comes from.
Rust does it.
There's a lot of binary tag also inside Go and other languages.
In the end, it's a bit of a wide, wide West right now.
There's transition as we said from proprietary only to mostly open source and this is difficult
and we'll figure out something.
Yeah.
Yeah.
I don't have much to add to this one.
We need identifiers definitely in order to understand that we're talking about the same
things.
Right.
We have seen there are different ways to approach it and there are different needs so you actually
need more than one type.
Don't think that you will ever get a single thing.
And we will figure it out in the end.
It's a problem for tomorrow.
Yes.
Well, yeah.
Let's start.
This afternoon.
Yeah.
Yeah.
What are you doing after lunch?
Yes.
I'm going to take the panelists.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
Yeah.
