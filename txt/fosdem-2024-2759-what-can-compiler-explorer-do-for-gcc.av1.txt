In parallel, let's get started here.
Up next we have Mark Boudiaz, if I pronounce it.
Yeah, that's mostly correct.
Yeah, another time.
Even for French people it's complicated.
He also worked on the GCC RAS front end for a bit,
and I think why are that got involved in the got called compiler explorer.
And now he's telling us what the compiler explorer can do for GCC developers.
Yeah, thank you.
So my name is Mark.
I'm a compiler engineer at Hidakor,
and today we'll talk about compiler explorer in the context of GCC.
So what's compiler explorer?
So for people who may not know what the compiler explorer is,
it's a website where you can enter a program in some language,
for example C on the left,
and you can pick one or more compilers and get the corresponding assembly.
So that's the very basic usage.
Compiler explorer was created mostly 10 years ago by Matt Godbold.
So that's why you may know the website as Godbold,
because he was hosting it on his own domain, and it stuck.
So now people are referring it as Godbold.
We are now a team of eight people.
We host like 2,000 compilers, support more like 60 languages.
We have around four million compilation jobs per week,
and thanks to our sponsors and patreons and stuff like that,
we are able to pay the bill every month of around $2,000.
In the interest of time,
I will only showcase a very small subset of what the website can do.
If maybe you should go and check out by yourself and experiment and see
if there's something that you can find useful on the website.
And at the end, I will answer questions and maybe get feedback or future ideas.
So basic use case.
So I'll try with the live site if it works.
It's not too slow.
Okay. So let's say you have a CC file,
then you can add a compiler like this.
So by default, it's TCC.
You can see that the assembly is color coded too much with the user source code on the left.
You can also execute the code.
So for example, here, you can see that the printf is displayed on the bottom.
You can also ask to stop after the assembler and get instead the option view of the object file.
So you can see here that you still have the relocation in the file.
Or you can also ask for a full link for the program.
Yeah, still. And you can see that the relocations are gone and it's resolved.
The last thing that I wanted to show is that you can share this by clicking on share.
You get a link.
And if you send this link to someone and they open it,
they will get the exact same setup and layout.
So it's very useful to share some code, bugs and stuff like that.
The next use case is if you need, for example, multiple files.
So that's the case, for example, in Ada where you have to have different files for the package.
For example, the full package is in the two files named foo.adb and ads.
And we have a main unit called example.
So this unit is using the foo package you can see here.
And you should see I'm also using an input file called input.
So you can also put like text file in it if you need that.
And then you can add as before a compiler.
So it's not compiling because I need Ada22 and you get the same features as before.
So you can execute, get the object files.
You can share the session. Everything works as before.
So that's the very basic use cases.
We support many more features.
You can build your program using CMake.
We have GPU support so you can execute code on actual GPUs.
You can see both the target and the host view of the code.
We have deep views for assembly so you can compare the output of different compilers
or the same compilers with different options.
We support libraries, environments.
There is documentation for some ISA and many more.
So please try it yourself and experiment.
Now the first feature that can be useful for compiler development is the conformance view.
So for example if you have a bug report, so in this case it's from the GCC bugzilla.
It's an internal compiler error.
You can use the conformance view to find when it started regressing.
So you add a conformance view and from there you can add some compilers.
So GCC, PX86, for example trunk.
So you can see this is red so there's an error.
If you hover on the right you can see the backtrace so it's an internal compiler error.
So from there you can just duplicate and check with a different compiler.
So GCC 13, so still failing.
And you can do that for all the compilers.
So I won't do this now because it's short of time.
But...
Okay.
I will skip this one and just use...
So this is local so there's only a subset of compilers but it's fast.
And you can see that you see quickly where the problem started, so around the 13 release.
And the nice part is if you want to modify the code and see if it changes anything,
the view will update itself so you can play around and see if you can have better ideas or things like that.
And again you can share the session and send it to anyone.
Something I used during my day job where I need to test against different compilers or targets or language.
I create empty templates meaning that I simply create the conformance view with the compilers.
I'm interested in for the given target and the language and I leave the code mostly empty.
And whenever I need to test something against C++ for x85 targets,
I click the link, the share link.
This opens up. I copy paste the code and I directly have the result.
I don't have to add the compilers by hand every time.
So that's it for the conformance view.
Very recently, Jeremy in the team added the support for the GIMPAL.
So it means that now you can use GIMPAL as any other language in the compiler explorer.
So maybe that's useful for some of you.
You can just copy paste and use any GCC starting from the nine release.
We also have support for the dumps Dave and Jeremy talked about previously.
So this is C.
I can add the compiler.
Then you can add GCC tree RTL.
And from there, you have access to all the dumps that GCC emits.
Like this.
If you need, you can filter between the tree, IPR, RTL.
And you have access to all the options that you would have from the command line.
And again, if you change something like the optimization, the view should refresh itself.
So believe me, it should work.
And that's for the most used dumps.
But if you have debug dumps from frontends, for example, I've added the one for the ADA.
We cannot support you.
Simply have to ask.
And maybe we can guide you or we can do this ourselves.
So just ask and we'll be happy to help.
Something else we offer are the nightly compilers.
For GCC, we build a subset of supported targets from the GCC master branch.
We also build from different repositories.
For example, the core ball or the Rust one for VikiTub.
We can build the topic branches if you have some that you would like to see on the public website.
Or we can build more complex stuff like the Rusty, Codgen GCC where you need to take Rusty,
build GCC and stuff like that and package and publish it on the website.
So again, ask and maybe we can help.
We provide an API where you have access to the basic feature, mostly compile and execute.
So you can use that from Shell Script to do tests or you can embed this in application, plug-in, IDE.
For example, this is a screenshot from the tool I've done for work using...
I can run against different compiler using filters from the command line so I find it very useful.
So maybe this could be for some help for you.
And the last thing I wanted to mention is how easy it is to create a local instance, private instance.
It's mostly heat clone, make and it will do some NPM magic for you.
And this will bind to local host so that's fine.
You can use it yourself but if you want to do that for a team, multi-user, please, please, you need to take extra care
because this is basically a remote execution as a service.
So you are from the web browser asking people to enter code and click execute and do everything.
So for yourself, easy, for multi-user, not so easy.
And we have ideas of new features we would like to have in the context of GCC.
For example, for Clang, we have a nice view where you have all the optimizer passes
and you can see how each pass is modifying the IR and with a nice div view.
So it would be nice to have the same thing for GCC.
Maybe a better div view where you can do divs on the RTL directly.
Someone has for more Windows Compiler so maybe you have other ideas.
So this is the end.
So again, that's only a very subset of features.
So go and experiment by yourself.
We accept any kind of contribution called feature request, anything.
So thank you and I'll be happy to answer.
So one question.
So one question.
There was one question.
How do you manage security?
I don't.
We have people working on this, mostly Matt Partouf and Austin.
They are doing very complex stuff.
I don't understand because that's really not my domain.
But everything is sandboxed.
The nodes where you are executing are mostly empty.
So even if you exit the sandbox, there's nothing to steal.
And if you crash the machine, we just reboot a new one.
So that's as far as I can give any details.
But you can contact them directly.
They'll be happy to answer that.
Okay.
Thank you.
Thank you.
