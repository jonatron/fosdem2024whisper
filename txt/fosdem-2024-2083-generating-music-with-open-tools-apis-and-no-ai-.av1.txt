Okay. Thank you everybody. As this part of the slide says, my name is Steve, and as this
part of the slide says, I'm a little bit of a geek. Now, if you've all turned up to the
correct room, this is a talk about generative music. Over the course of the next 20 minutes
or so, I'm going to be talking about some of the processes that I use to generate music
with algorithms. I'll be looking at some APIs, not all of them. I'll be looking at some tools,
not all of them. Doing some of the live coding environments that you may see around and talk
about some other ideas that you might like to apply. Also, what's not in the talk is
AI. There's a room downstairs for that. Everyone has been doing so much AI for the last year.
I just said, I'll do something completely different. It's not that I hate AI. Last year,
I wrote an album, five songs, four were co-written with AI, one wasn't. And I said, can you tell
the difference? The answer was, no one so far has told the difference. Therefore, AI is not
stealing our jobs. So, first off, who am I? What have I done to deserve a place on this
stage? Or is this slide should be called the ego slide? This is where the speaker brags
about themselves for 10 minutes. Everyone looks for the live streams of somewhere else in the
building. I'm a computer geek. I'm a developer. Essentially, I've never done marketing, never
done sales. I build stuff. I like building stuff. I build stuff in cloud. I build stuff on game
consoles. I wrote a book about old retro computers last year. It was reasonably well accepted. I
compose stuff. I've spoken at this conference a few times. And all that's really nice and fun
and interesting. But what's more interesting is what's not on that slide. I'm not a professional
composer. I make this stuff because I like it. I'm not a professional algorithm person. I do it
because it's fun. That's a nice long-winded way of saying, if I can do this, anyone can do this. So,
what is this? What are we going to do? So, the first thing up, I've got some audio on this, so I
will have to put my mic closer to the laptop. So, the first thing is, let's look at simulating tape
loops. Back in the 60s, there's a guy called Steve Reich, and he had this idea of having a piece of
tape that just went around in a complete loop and then again on another machine running at a very
slightly different speed. This calls sometimes the music would cry, sometimes it would separate
apart. And this was really quite interesting if you want to spend 18 minutes listening to a New
York preacher saying, it's going to rain, it's going to rain. So, it needs to say, no one has
actually listened to this the whole way through. But today's your lucky day. It's okay, maybe not,
we don't have time. So, this is a version of how to simulate a tape loop. And I'm going to do this
with HTML5 JavaScript because JavaScript is the best language. Excuse me, because JavaScript is the
best language. Correct answer. And it's all very simple. You create an audio context that just
says, I would like to do some audio, please. You then say, I need to load a sample. I use the fetch
library because everyone does. You bring it in, you do some munging of that data because you have
to. And then you just say, I want to play the sample. And that's it, the job's done. Now, you get
some additional things you can do once you've got that sample. You can say, right, well, I want to loop
it between the one second mark and the two second mark. Just a parameter. You say, oh, I want to play
it at the normal speed. Or if you change 1.0 to 1.1, you're playing it 10% faster. You change that to
0.9, you change it 10% slower. If you want to use semi-tones, then math power 2 to the power of 1 over
12 is the obvious mathematics you need to use. You can change the panning to move between the left
and the right speakers. And you're doing this connect thing. All of the system is just basically,
you connect this node to that node. You connect the sample node to your panning node. You connect the
panning node to your audio context on the output. And that's it. It's the sound of the thing, any kind
of pipelining system, you're doing it in the browser. So the first attempted audio, let's see how this
goes. And you can see they're slightly in time. Completely out of sync. And then after a while, they're
back in time again. And if anyone wants, that's an audio sample from Nine Inch Nails, which we'll
come back to later on. If anyone was interested about the math power 2 function, if you're looking at
the mathematics of music, every note and the note, an octave above it, is double the frequency. So you've
got to do those little pieces of mathematics if you want semi-tones, but that's just math. That's
easy enough, right? So let's create a remix. We know how to play sounds. We know how to load the sound
in. We know how to play it. We know how to change its pitch. So what we'll do is find some source
material. Nine Inch Nails, I think, for the seventh album called the slip, they made the album, I say
they trend made the album, and then released under Creative Commons license all of the individual
tracks from the album. So you could take any individual part, you could take the drums, you could
take the bass, you could take the synths and guitars, and you could then do whatever you want with them
under the Creative Commons license. So I did. I found some sounds that I liked. I chopped them up. I
decided two parameters. How long into the song before I start playing that sample? And then how
often after that do I play that sample? And that encode looks very, very simple. You load them in,
you have two numbers. I have used prime numbers here. All of these are prime. There's a reason for
that. I like prime numbers. I also know that because they're prime, they are going to clash less
frequently. If I had the numbers two and four, those sounds would always come together. But with
the primes, there's a longer time before they clash again. So in a lot of my music, you'll spot
that if you are so inclined. We then write a little loop. We play samples, we do intervals and all
the normal JavaScript loveliness, and we get an industrial remix that sounds like this.
Now, you may or may not consider that music, but I do. And I'm the one with the microphone.
So now we're playing samples, we're looping samples, we're doing all sorts of clever stuff. Now,
it's your turn to go and do it. I did that because I found some sounds that I like to use. How would
I describe to a room full of people how to build your own symphony? Well, first off, pick six notes
that work together musically. Doesn't matter if you're not musical. Go to the library. Find some
sheet music from some old white dude who's been dead 200 years, all out of copyright. Turn to the
very last page, because the last bit of the symphony is when all the instruments come together,
go da-da! So you know all of those notes are going to sound good together, whatever six you pick.
Pick any six of those notes. Go to Google and map the notes on that page to what you actually have
to play. Then go and find six sounds. They can be short sounds, they can be loop sounds, they can be
long sounds, it doesn't matter. Pick six sounds that you like. Then attach one of those notes to
one of those sounds. Pick a start point, pick a loop time, and congratulations! You've just written
the Brian Eno album. That's all there is to it. And let's face it, if just, if 10% of you go away
and try that now, next year we're going to have a full schedule of that music. And I can sit back
there drinking my beer in peace. So what if we don't want just sounds? What if we want to create
actual notes? And we want to decide what note goes where. So at that point we're moving to MIDI.
MIDI is a specification about notes, not sounds. MIDI says play the middle C, but it doesn't say
how the middle C should sound, because middle C on a piano sounds different to middle C on a violin.
I use these libraries because I wrote them, not because they're the best, it's that because I
wrote them I know how they work. That's the only reason. There are better libraries out there,
go use them, but just find some library that lets you generate a MIDI file. That's what you need
to do. Then you create an algorithm. Have an idea, doesn't matter what it is, have an idea,
generate a series of MIDI notes, let the sequencer play them, assign a different sound to each of the
notes and see what you come up with. And this is where I started. Back in 1996, I was reading a
book on modern music, and by modern we're talking 1950s, and there was a piece by Giorgio Sighetti
who poems symphonique. In this he said, this piece of music has 100 metronomes all ticking
slightly out of time with one another. And I lived in a small seaside town, in the words of the song
they should have closed down. They call it holiday resort. I live there, I call it a last resort.
Actually, I really hope we're not recording this because this might go back to someone I used to go
to school with. We had no record stores of any worth. I like the idea of poems on the field.
I was like, what on earth does 100 metronomes ticking out of time actually sound like? I had no idea.
And this is before Tintorwebs, Amazon, there were no record shops selling this stuff. So I just wrote a
MIDI library and I simulated it myself. But I thought, well, instead of doing a metronome, because
metronome being mechanical, will do exactly what you say. I said, well, I've got a computer. Back in
the 50s, they didn't have a computer. So what I'm going to do is I'm going to sign a different note.
I'm going to have one note that plays once a bar, which is that one at the top, then I'll have a note
that plays twice a bar, then a note that plays, you know where I'm going with this, right? A note that
plays four times and five times. And because I had a computer that could play 32 notes at once, I decided
I would build up to that. And the code is very, very simple. You pick a series of notes that work
together. You have a massive loop that just says play this note, wait an amount of time, then play the
note again, because MIDI is a serial protocol. It is all about time. You play a note, time happens, you
wait, play another note. That's what I did. And I created a piece of music with a bunch of channels
that sounds something like this. One note, two.
And it gets quite chaotic to the point of you can't hear any particular notes or beats anymore. And at the end,
you notice I've also changed the instrument because the important part here is the refining bit. I was going
through, I say this sounds very archaic. So what I did is I introduced every note individually. So you could
hear them coming in, hear them dropping out. I morphed the sound of the piano into the sound of a harp. And I
slowed the whole thing down. So as you get to the end, it just feels like very gentle and plucking. Completely different
to where you start the piece. And that's what I wanted to portray with the idea. So if you've got an idea, you just
generate music. You could use the digits of Pi. You could use gray codes. So gray codes is basically a binary system
where only one binary digit changes from one step to the next. So I've done this. Every melody is different.
Every single one of those is different to the one before. But it sounds identical, but it's not quite. Which means it
doesn't fall foul of stupid laws that say you are not allowed to play repetitive music. Because not one bar is repeated
for eight minutes. Everyone is different. Which you can only sense of being do if you're coding this stuff up. You can
use prime numbers. I've used prime numbers a lot. You've seen. I wrote a piece of music for an audio book. The audio
book talks about, it's a story about going to Mars and bringing a martian back to Earth. And I thought, what's the only
common language between Earth and Mars? I figured mathematics and prime numbers. So all the sounds on here are generated by
primes. Audio book bit. All generated by whatever the number happens to do. So I don't have control. I set this up and go,
off you go. And sometimes it doesn't work. Sometimes it's a load of junk. But that's where the human comes in. I edit this
stuff. I look at it and go, well, this did a bad job. That did an okay job. I keep going on. I've done something with all of these.
We'll come to these later. And the online encyclopedia of integer sequences, brilliant. You'll never get bored. But the Fibonacci
one on there is an interesting case in point. Fibonacci numbers generally shouldn't work for a music composition. Fibonacci
numbers, you have two numbers, you add them up, that's your next number. You add the last two numbers, you add them up, that's your next
number. And you go on like that. But very quickly, you run out of numbers. Or more precisely, you run out of keys on your piano.
Because after about two bars, you've just run out of notes. So I said, well, obviously Fibonacci is useless. We cannot use this for
music. Then I actually realized, well, what if you go backwards? What happens to Fibonacci numbers if you go the other way?
And this is what happens. They alternate between positive and negative. So okay, there's something that means they can't go out of a
range that quickly. So I said, okay, there's an idea here. But what is it? Do these notes represent semitones, tones? Are they going to be
part of a key? Are they not part of a key? What are they? I didn't know. So what do I do? I wrote an algorithm that processes all of them.
It just generated two hours of music essentially, using every combination of everything I could think of, until it produced this piano piece.
You can hear it's going up bits and down bits and up bits and down bits following the patterns.
And this is just me picking up the best bits of what it did. So naturally, it's not an AI here. It's a more artificial stupidity on my part.
But it sounds okay. It's not awful. I've heard worse. I've written worse, to be fair. And if you're wondering why I haven't gone into the
whole Web MIDI thing, I gave a talk on this a number of years ago. I refer you to the link if you're interested in the Web MIDI components.
So we've looked at taking samples, looping them, and doing funny things with samples. What if, and looking at the MIDI, how do we want to
generate actual notes? But what if we want to generate the sounds? Where there are a whole load of ways of generating sounds via little
algorithms that you code up. So, Mozzie, for example, if you like arduinos, you've got this nice little soft synth thing inside an arduino.
This was me building craft work out of four arduinos and another arduino to synchronize them all together.
The very raw 8-bit sounds. So if you like that crunchiness in that old techno, they've got a drum coming in a minute.
Very raw, very rough, but if that's the type of sound you're going for, all you need is an arduino. Synchronize them with I2C.
Jobs are good. If you've got a Raspberry Pi, you can get an entire DX7 synthesizer into a Raspberry Pi that boots up from the flashcard in
probably much zero seconds. In fact, if you've got a decent Raspberry Pi, you can get eight of them multiplexed on the same Raspberry Pi,
which means you can build yourself a portable DX7 synthesizer. It's fun, it's great fun. Sonic Pi is a lot of people use this for the live coding
thing, for its music. Fluid synths, if you're old school and you like the font synths, there's a synth font thing where instead of fonts being used for typography,
they had fonts for sounds. And there's a whole fluid synth thing that lets you create, you know, use your own fonts.
Super Collider, you'll probably recognize this as something that looks like code. That's something like a drum.
That's what it's doing. C-sound is a much more low level approach to the same idea. Here you can see I'm programming in various frequencies,
inputs and outputs, and at the end I just say make some tones. Or if you want them together. It's craft work in the box.
This is a new one on me, so I don't know if it's pronounced glikol or glycol. Again, it's another programming thing. You say, oh, I have a bass drum running at speed four,
I'm sequencing this 60 and this is how it works. And then you piece them all together at the bottom saying this is my output, and it sounds like this.
Mercury is another one that I haven't heard of. It's the same approach again. You say these are the type of sounds I want and this is how I want it working,
but the timbre is so different. Possibly a bit early in the day for this one. But it's all generated from those six lines of code.
So you can imagine generating that and then playing around with it in real time. If you're someone that likes to use desktop, there's a whole load of other stuff.
I did a thing inspired by a FOSDEM trip back in, I think, 2020. I gave a talk where I was talking about Web MIDI and someone said, you know what, wouldn't it be great if you could change the thing that you just did?
Because I'd written a piece of music that was a fractal. You have a melody line and if you play every other note of the melody line, you have exactly the same melody line again, just half as long.
And if you take every other note of that melody line, you've got the same melody line again, but just half as long and so on, all the way down to a single note.
And someone said, that's a really good idea. Could you do a whole bigger version of it? So I ended up doing that.
And I called it Symphony 1.1. I generated an interface which was using a graphics library. I generate the score using ABC, so you can actually see it, and then it plays in the web browser.
Which seems crazy. You're generating an entire symphony in a web browser. So that's obviously not going to work as a live demo, is it?
Yeah, okay, let's give it a go.
Now, is that actually... No, that's not going to be on the screen, so it's not...
So here we are. What we're saying is these are the notes where you're going to play every other.
Pick whatever you like. Generate the score. There we go. Programmed and actually generated the score, rendering, and then we just play.
And you can export that out as MIDI, play it with real humans or whatever you like. So with that in mind, I'm going to put this as some background music.
While I switch back to some actual slides, this is also generated algorithmically.
I'll say, thank you for your attention. This is me. I'm going to update my scorecard there. Okay, 23 postems. That's now 24. 24 talks. That's me done. Thank you all.
Now, is it time up or is there time up and time for questions?
Okay, yeah. So now I've told you how I do it. You probably want to know why. And I don't have an answer for that, so find another question.
There's a question at the back. Do we have a microphone or just shout? I'll repeat.
I'm wondering about what to do with harmony. Because the power is all the melodies, do you usually state a single key or do you have similar algorithms for harmonic modulation or stuff like that?
So the question is, what do I do about harmony? And my knowledge of harmony is very limited. So I am generally sticking to a key. I'm generally sticking to the basic major and minor chords in that key.
And then I will use a process that say, well, what note is in this key that fits the chord patterns that I'm going to use? And if I'm doing a basic CFG chord pattern, I'll go, right, well, I can use one of these three notes and I'll do that.
In the Fibonacci example, which I played earlier, I used a process called tintin' boole, where you look at the notes you're playing and you just say, okay, well, I'll play the next note down that is either a B and F or an F sharp.
And it just picks one. So I don't get to choose what the note is, I just get to choose the algorithm.
And this is something that a lot of composers started doing in the late 1940s, 50s, because they just come through a world war. They weren't happy with it. They didn't like the fact that the people of the time were saying, you cannot like music this way.
You have to do this with music. So they were saying, okay, well, how do I know what I'm doing? It might be subconscious. So they came up with a series of rules and they apply the rules and that's what I'm doing, just picking the rule and let's running with it.
So good question to end on.
