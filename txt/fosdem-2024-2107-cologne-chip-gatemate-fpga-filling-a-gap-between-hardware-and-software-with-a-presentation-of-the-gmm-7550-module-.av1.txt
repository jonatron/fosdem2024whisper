Okay, good morning everyone.
I'm glad it's my honor and pleasure to welcome you and to open this development room session.
And what I'm going to talk about is a gap between the hardware and software and why
FPGAs are capable and should fill this gap in.
What I see as a gap and what I see as a problem with it.
But before moving to the really interesting stuff, a few words about myself.
Just so you know who is in front of you.
A picture probably you've already recognized.
On the right hand side a few buzzwords I still can remember through my career.
Some of them perhaps a bit too ancient, but anyway.
And the reason and motivation why I've decided to come over here and talk about this
gap between the hardware and software between the FPGA and software development board is that
with years I feel more and more frustrated with the
pace of observing, mostly observing the pace of the software development, how new technologies
appear and disappear, so of course as well, how rapidly it's going, how many young new people
are coming to the software development boards who have no clue about the hardware under this
software and who do not know and doesn't care how to develop this hardware.
And I believe that this difference between the hardware and FPGA development
direction and modern software development environment is just widening with the years
and that is dangerous for the entire industry.
So short outline of the talk, the first part and introduction and we've almost through it already.
Then I will talk a bit or mostly ramble a bit the differences between the hardware FPGA and
software development as they are seen from the low end, from the hardware and FPGA part,
not from the very fancy high end software development board.
Then hopefully if it's still running I can show the live demo what is currently changing in the
world of the FPGA, what is new there and why I believe those changes can fill in the gap
and can brought more software-oriented people into the hardware, into the FPGA and hardware
development. Then of course it's just the very first steps I've been able to make or see them,
then I will talk about there.
Road to head and yeah more about the hardware, some backup sites, contact information and of
course what you can do after this talk or if it would be interesting enough for you.
Since we are done with the introduction and plans, first of all if software people are not
paying too much attention to the FPGA development why should they?
They are perfectly fine with the modern hardware, with the modern development and all the technologies
around it. Unfortunately for the last 10-15 years it's not exactly the case because the
general purpose CPUs are almost reached their capabilities and there is no clear way to progress
for them. For multiple reasons technological complexity, fundamental technological and physical
limitations and so on. The other reason is that the current software payloads are getting more
and more diverse and the very different high variety of different requirements and general
purpose CPUs while they are capable to run all of those payloads they are not well suited for any
single one of them. For the last 10 years with the rise of artificial intelligence and all those
neural networks somewhat unexpectedly GPUs came into the play but this type of neural networks
and modern architectures of neural networks are coming and going on the one hand side and on the
other hand side GPUs after all have not been designed for those kind of payloads and alternative
would be easier to design the new ethics for specific payloads but again there are too many
different variants, too many different architectures and requirements are changing every two, three years
with all the pace and speed of software development and no sensible hardware company is capable to
produce and use silicon every two, three years it will just not pay off for all the investment
especially on the modern technological nodes and with all the investments but there are very
flexible and nice chips which are manufactured in huge volumes on the most modern technologies
and which are suitable with proper programming and with proper support software support and
proper tooling support which are capable to efficiently execute any payload any imaginable
payload. So there unfortunately here we see another roadblock because all the software development
software for the FPGA world is still 40 years old at least if no of course there are new releases
every year or two releases a year but all the underlying technology and the design approach
is still 40 years old which is ages and of course as I've mentioned it seems to be a very boring
subject that not that many people are interested to look at it which I think I might be very wrong
looking at the number of people here and still coming so some people are still interested in the
FPGAs and development for them that's good and encouraging. I've already mentioned all the things
in the mid 80s rise of RTL register transfer layer design methodology was a huge breakthrough
in their ASIC and later on FPGA design and the two languages they are still around us and they
still are prime languages for such a development VHDL and VRIOHDL were developed I think in 1984-1986
and those two languages are still with us and most are actively used nowadays. How many software
development normal programming languages you remember from 80s which are still in active use
Fortran and Lisp they are even older than VHDL and VRIOHDL and probably nothing else but definitely
CER yes of course PDP 7 PDP 11 but also neither of them are on the top or own even 10 or 20 percent
of the development and VRIOHDL shares 46 50 percent with 3 to 4 percent for everything else
so it's quite a different picture compared to what it was about and after all those two languages and
the RTL design methodology were introduced primarily for the ASIC development and only later on they
were by coincidence because they were available new and fancy things at that time they were picked up by
then young FPGA market adopted and still there with more or less nothing new even all the
cheese sales, color, spindle, HDL, system, c, HLS all those new fancy technologies are going to
generate VRILOCH which goes through the custom proprietary VRILOCH synthesis tools which is
oh well you can say that LLVM and GCC are still can generate assembler but that's quite different
but those things which are pretty common and well recognized by the industry and by many
engineers working in the industry are well understood but they are not two main reasons for my
disappointment in the current development the problem as I say it is that the only way we are
programming FPGAs which are reconfigurable at any time you can change all the configuration in them
at runtime anytime any number of times and you can do it really reasonably or relatively fast
all the way we are still using and programming FPGAs is this exact way the IBM 402 or even the
previous generation of tabulators have been programmed you hand wire a bunch of wires you call
it a program then you plug it into the FPGA okay after synthesis and place and road things
then you just put those bunch of wires inside your FPGA and using it as a playing hardware
not changing a single wire at runtime uh partial reconfiguration is somewhat advertised by
both major vendors Xilinx and Altira now Intel and AMD now not Intel again
and they are advertised for 10 15 20 years but real support in either Vivado or Quartus is near zero
you can do it but in real applications it's very very rarely seen the other thing in this
same domain which is advertised for 20 years and still have some limited acceptance is of course
HLS high level synthesis but anyway we have their modern chips manufactured on the most
advanced technological nodes and we are still using them the way we used tabulators 70 80 years ago
just putting wires put them in hardware and using this bunch of wires and the second reason for
disappointment which probably just came from my experiences and embedded systems development
developer that all the development is cross development strictly cross you cannot
40 years ago you can take an xiloc z80 processor you have a machine built on this processor and you
have a c you have fort you have Pascal you have basic and you can program on the same chip you can
develop everything on the same chip nowadays we have an FPGAs which are two three orders of magnitude
more powerful than that 80 but you still need a huge x86 machine to program it to do anything to
even to blink an LED connected to FPGA you still need a somewhat powerful machine and I have to
admit that the modern FPGAs even the smallest of them are much more powerful than the machine on the
left hand side and this machine will not be even close to run anything of the modern FPGA design
tools. Vivado's latest download is something like 11 12 gigabytes, Quartus and Libero
are somewhat around 10 gigabytes as well so you need literally 10 gigabytes or for some proprietary
closed software to develop any application blinking LED for a one single tiny chip which is more
powerful than anything you used 40 years ago so those two things which forced me to look around
and to see if something is possible to change in this world and fortunately there is in 2020 so
almost it almost exactly four years ago I've seen a new FPGA chip appears on the market
then it was not even on the market but only on the show it was an gate made FPGA from Cologne
chip and now I will try to make a live demo it's just a screenshot now but it's always
better to see something live if it works
so what we have here and I will talk much more about the actual hardware we have here
in a few minutes but we have a console of the Raspberry Pi which is just a baseboard for the
Cologne chip based FPGA model with some LEDs connected to it and what I have as a demo here
is that the FPGA is pre-programmed configured with a default image a small software application
unfortunately at the moment written on C which is roughly the same age as the rest of the
technologies discussed here which exercise just a simple AND gate and then at runtime from
inside the chip overload this configuration of the chip exercise it again and I think we will
observe some bugs because the demo is relatively young it's something like two days old this
running version so we just power it up connect to the console stop out of boot then upload and demo image
okay I still remember the name of the image in the morning it's not always the case and trying to run it
at that point I would ask you to observe those LEDs running blinking not the blinking one on the
below but the LEDs on the top one it will show something like an AND gate behavior so two inputs
one output three LEDs blinking and the same will be printed out here the input to the signals and
output signal and then we will see if it works or not so okay for AND gate it's visible
now it will try for five time repeated for five times to configure and now the blinking pattern
is different it's now NOT AND gate and the bug I've announced before it's not intentional for the demo
so you see with two zeros on the inputs there is still an LED on so output is high output is one but
what is shown here is NOT AND AND so there are no changes here it illustrates the problem with
the tool chain and with the changes so what has happened the output which goes to the LED
are changed at runtime and it's observable but the outputs which are going to the internal CPU
subsystem are not modified they've split it through optimization and place and road
somewhere inside the chip and there is a bug so a demo is half running it's running on LEDs
but it doesn't run on their console unfortunately and I had no time to fix this part of the demo
but the most important part and essential thing about this column chip gate mate fpga is that it
allows to change the configuration at runtime but those things are available and have been around
for some years from the other fpga vendors that's so-called partial reconfiguration runtime partial
reconfiguration but what is important and what I have not ever seen in any other fpga maybe it's
available but a well-kept secret from the fpga vendors it's a possibility to change the configuration
and run time from inside the chip itself and it works here tool support and how well it's supported
with the current software is and the question remains to be answered not so good but everything is
well involved and there are much better perspective here for the column chip because the company it's
a small german company probably develop in this fpga and this fpga is their first programmable
solution product before that they were working in the sphere of communication chips and modems and
some asics design yes what was the intention to do this for as far as I know I have no association
with this company directly just know some good technical support people from there to have an
fpga developed one of the motivations to have an fpga developed outside of the us because two major
alterations latest micro chip most of the or all the other fpgs have their ip developed within the
states so the this column chip gate mate fpga is developed in cologne and it's manufactured in
germany near dresden its global founder is factory so to have a kind of technological independence
also to fill in the niche because major fpga players switched or have much more marketing and
economical interest in meat and high-range fpgas this fpga is relatively small so it's
small physically low power consumption and it fill is fill seen the low end of the fpga
market and the other interesting part which as far as I understand was
at least partially a motivation for this development is to have a free and open source
toolchain officially supported synthesis path is yosis so gate mate fpgas are officially supported
by yosis synthesis tools at the moment place and road is a proprietary binary from cologne chip
but the configuration bitstream format is not 100 but partially open and free so
and as far as I know there is a plan to provide the support for place and road for cologne chip
gate mate in next pnr and once it's available maybe well it has been expected in year year
half ago maybe it will be available this year they do have some limited resources working on it
for multiple reasons as usual everything is much more difficult than it seems to be
but once the next pnr support for the place and road for gate mate will be available it will be the
only fpga supported by full for which the full design road is supported by the vendor with free
and open software I know about the latest I see I know about the reverse engineering of cyclone 4
some parts for spartan 3 4 6 I do not remember I'm not that familiar with silence product line
those are available of course but they are not officially supported and provided by the
chip vendors themselves so you still once it's a reverse engineering you never know what other
hidden secrets are inside so I believe that was the motivation and you also have a question
available in non bga packages so I get reasonably sure
unfortunately no but there is a solution for that as well just in a few minutes please
I guess sure the question was if this package is available in something more suitable for
hand soldering not in a bga package unfortunately the answer is no the only available now is bga
324 volts 0.8 so not that good for hand soldering but the rest it used to be a there is a way to try
the chip without soldering it now I can say that there are multiple ways to do that relatively
approachable accessible just an outline perhaps every single person in this room already know what
or can imagine what can be done with those possibilities to change the configuration at
runtime from inside the chip itself with free and open tools but as I see it it's possible if you
have a soft core CPU at runtime you can change its instruction set architecture you can add
your custom instruction to it at runtime nowadays I think most many interpretive languages are running
in some sort of jit technology so they are measuring at runtime critical passes in the
code and compile them into the assembler or native machine code but now there is an
a door is open to make the next step after you compile to the assembly code for the
really critical part of your algorithm you can just add unnecessary instructions to accelerate it
or you can synthesize at runtime a necessary accelerator load it at runtime and use it after
that so it will be a jit not only to the machine level but to the hardware level to the next step
the other parts and I think I've already mentioned it several times this morning that it will allow
a speed up of the development because what the software people I as I see it are used to nowadays
is to have an immediate feedback you type some code interpreter is running it you have a web
browser with a page automatically updated and so on with fdga you write some rtl 40 years old code
then you synthesize it for some hours then hopefully next morning you see a feedback
which slows down the development process tremendously and with this possibility to change
everything at runtime from inside the chip itself it's possible to make an interactive
interactive iterative and incremental development you can just add part revoke some part change part
you don't like so I hope that those technologies will make an FPGA sound much more approachable
and more interesting to develop for them please
the question was if the changes are if it's possible to update just the part of the design or
how well the part changes are insulated from each other
on a stanza will be that I do not know exactly yet but as we as I we saw in this demo it was
possible to update just a single lookup table so just one gate or just one routing path between the
gates generally the configuration format allows to change on the single logic cell
unit of FPGA which makes something like an 18 ports two outputs two triggers plus minus some
routing logic so I would say that this level will be the minimal one but at the moment in the chip
there is no protection and I believe there will never be any kind of such a protection
so you are allowed to change everything and of course you can break the system you are running on
or break the part of the system you are running it that's a question of tool support on how well
the software will support those things of course since you can see the changes at runtime
interactively it makes the technology much more open you can more or less see what's going on inside
hopefully you can just wrote some signal from inside your design to the pin to the led to the scope
logic analyzer so it makes your design more transparent more explorable and I believe it will
encourage more people to try it out because it's not some magic box hidden by gigabytes of software
and of course since it's possible the dream is now seems to be more approachable a fully native
development after all you can instantiate a soft core CPU run your system this soft coins CPU it will
take ages but it's doable and then you can take this bit stream and update part of your design
so you can develop internally sorry there is another one question yes please would you recommend the
set that you are demonstrating for a complete beginner who has never seen any FPGA development
before I would be there enough to say yes and this it might be not easy or trivial for the first step
but it would be really good if this person even if she or he haven't seen an FPGA development
to have some electronic background at least to know or have some ideas about the trigger or logic
gate or Boolean algebra is so definitely not to school children's but there were some experiments
in this direction as well not on my part but I've read about them maybe not even to the first year
graduate students but after two or three semesters of basic discrete algebra and electronics yes
why not before the introduction of very low-quake deal and all those nice and useful industrial
things of course so first bullets are right here it's possible approachable and it's possible
to explore them right now the last one is still somewhat dream ahead and let's take a look what
made those innovations possible but before we have another question yes please
yes so the comment was that last year someone presented a self-hosted FPGA development platform
uh I believe I've read something about it and it was a Yosses running on risk five soft-core CPU
slow yes working for sure but here we can see the next step after it after you have
synthesized the bit stream on the FPGA how do you put it inside the same FPGA
and now it is so yeah that's the next step and I do not try and I am not trying to pretend that
it's something very unique I know that there are many people interested in it and working in
parallel same directions somewhat different directions and that's just good and should be
encouraged and it's nice to share those information and it's one of the reasons why I'm here at Osdame
where everything is open free and so on so what hardware made it possible a few words about the
FPGA itself it's as I said at the moment the only variant is available with 20 000 logic elements
cheap with 40 000 is also available physically in the same package pretty normal
mid or low range FPGA but as you see you can run a processor and it takes less than
20 percent the entire system with memory or reconfiguration control support
and CPU takes less than 20 percent of the available resources of this the smallest in the
chip in the family so there is a path to grow there are some nice programmable PLS 5G
service which allows to support USB 3 or PCI express gen 2 which is not so bad for low end
FPGA it's even good as I said low power unfortunately the only available variant is
in 324 volts bga so not hand solderable but let's wait for a moment for other options we have
FPGA itself has a very regular structure very simple one compared to the modern
edgy legs or ultra scale it's very simple transparent that makes it easier to support it
with the software easy to experiment with it as I said somewhat more transparent and
easy to understand and work with it here is their minimal
cologne programmable element which is as I believe the smallest unit you can change the
configuration for so it has not a conventional lookup table but a tree of two bit lookup tables
and trees depth as two or three steps of two bits lookup tables some fast carrying out passes
between the neighboring cells and input outputs to the global routing and to the chip block frames
which are available on those columns between them so it's very traditional in some parts
architecture what makes it different that it's an
transparent open and somewhat better documented than the proprietary logic cells of their high end FPGAs
and now the question was how to approach this if it's packed in the bga you cannot hand solder
for me this question was the first one I've asked it in 2020 in year 2020 right before the corona
and all the crises and since I am doing a hardware development for many years the easiest answer was
just to develop a model for it I believe that this FPGA is the best thing that happens to the
FPGA world since xc6600 which was open and very well accepted by academic community but then
suddenly died and was is not longer manufactured back when I started to play or when I wanted to
play with this FPGA eval and evolution key from cologne chip was not available yet so I've decided
to be in front of the chip vendor themselves something pretty stupid on my part I have to admit
of course when I develop a model for myself I have all the freedom to experiment with it
model is smaller than the evolution board and you can connect it to something else you can
combine several modulus for me the best way to get to know some new chip I am interested in is to
design some boards on this chip first one may not work or magic smoke will come out of it but then
you know exactly what is going on there and of course it was a fine and nice exercise with
key cat because I've just seldomly used it before that decided to go why not to try it it's a good
one then key cat switched from version six to version seven roughly at that time yes please
make before why I think I'm following everything I found that I sporty I found everything how did you
find it and
why did you take enough documentation to start doing uh document a uh the question was how do I
learn about the existence of this chip because it's relatively under the radars on the FPGA market
definitely not as well advertised as uh altera intel altera again xylings imd
still imd not sure i see and all other players uh first I saw it's mentioned on some mailing
list in earlier 2020 but I do not remember where it was and probably it's impossible to trace down
anymore but then I've just stopped by or at their booth at embedded world and it was uh the very
first time I've explicitly asked the question if it would be possible to change a configuration from
inside and I've got a definite answer yes but uh it's not working yet we do not have a board yet
but we have a chip uh and back then it was an mvp so it was not their custom wafers but mvp run
the very first one so embedded world uh let's say the first contact with the company and where I
learned about them and all the documentation for it available on their site it's free you can download
everything and of course you can learn a lot about the internal structure if you go to the
usis project and look into the sources for the support of it then you know all the internal
details or almost all of them uh what is the current status uh exactly four years from the first
contact this company uh three boards were designed instead of single model all three of them are here
combined in a system and all three of them are working uh the schematic symbol and pcb footprint
for uh gitmate fpga is included in official kikkat kikkat version seven libraries now and I've been
able to push it through which not always an easiest straightforward process um some software
application as you can as you've seen running on raspberry pi to control model to download
configuration into the model to exercise the interfaces of the model uh vhdl examples are
running soft core cpu's are running integration with their modern software-oriented fpga design
frameworks as light x fuses so few soak some others are walking progress so something is
available something is not working yet I think nothing is upstreamed yet completely and uh
as I said it was pretty dumb decision on my part because it took five time longer and the first
prototype board was running in 2022 so two years from the beginning instead of half year
and uh recently in december there is a new model from the bigger companies and myself
from trends electronics and there is an another evolution board from olimix so you
fasted how to start up development with the um uh gitmate fpga without soldering bga yourself
you can use this model you can use evolution kit from cologne chip you can use a model from
trends which is immediately available and you can use an evolution board from olimix when it is
available as far as I understand they are still in prototype production status
if you were late yes hopefully so
so uh model and its design is completely free and open source hardware so what you can do you
can go to github take all the manufacturing files and manufacture it yourself I've tried but it's not
started yet to launch a group gets campaigned so you can order online and if there are sufficient
number of orders it will be manufactured and orders fulfilled uh basically this model is universal
one what I've tried to do is not to prohibit any use of this fpga so most of the functionality
except for single i o bank is available on the external model connector so the other thing you
can do would be to design your own base board for it or just an i o extension board which is
perfectly hand solderable this memory board extension board is just two layers uh uh soldered
and that attached directly to the model so that's all possible uh raspberry pi uh hat adapter is the
only board current I currently have to exercise the model so it's uh connects the model to the
raspberry pi 40 pin gpo so I can power it on measure current consumption program configure the model
and so on uh another small one is just external memory so the soft core cpu inside the fpga is a
bit more happy than only with internal memories and it can boot from there so just a simple one
and it also has been designed as a part of a mechanical exercise because if you connect
all the extension models to this one then the gaps are something like half millimeter and it's a
little bit outside of the connector specification but it works so I need some real proof that it works
and you can see it here now it's available so if you'd like to do something with gate mate fpgs
at the moment once again I believe it's the only fpga which allows to change the configuration from
inside at runtime so it has to be a gate mate fpga but it doesn't have to be a risk five which is
currently there it can be an open spark it can be meeps it can be your own cpu or no cpu at all
all the freedom is yours uh it has not it doesn't have to be a c probably c was the worst choice
and my first intention was to use forth so you can interactively just type something change
configuration exercise it and I have it semi running but I'm not there enough to show it here
at all otherwise it will take another 50 minutes just to see some blink in the led first maybe longer
than that and of course uh yeah any language fourth luah micropython scheme leapscala whatever you
can fit inside you can run it you can change the configuration from this those software and
definitely software people know much more about different environments and how to make it attractive
interest in fast and of course it doesn't have to be a this model but I hope that this model
some weeks days weeks will be available for group gets for online orders currently you can get go to
the project website and there is a link to github with all the designs design examples support
software and from there there will be a new update link to the group gets campaign where you can
order the modulus if you'd like something immediately available then it will be an
get made evaluation kit from colon chip or trends model late on all the mix model so hardware is
coming on now but as I said this model is already running for a year those models are just two
months as they appear yes please uh light x system so in megan is
running but not upstream yet so it's just a set of pages or something but yes that's
oh sorry I haven't repeat the the question is if it's going to be supported by somehow
high level tools me and megan megan light x fuse soak yes those are plans for that and
if anybody is willing to contribute to it please everything is open feel free to do it because
I'm doing it but it takes as I said five times longer than plant sometimes 10 times longer
um I just repeated that everything is open so you are welcome to create a software running on
FPGA create a software for FPGA development to design hardware with FPGAs to design hardware
with FPGA modulus because it's much much easier and this one would be approachable even to people
with near zero hardware design experience that makes a model much more attractive all the complex
problems are already solved you just have to connect the power and some IOS and that's much
easier than the rest of the system design and of course if you find some problems there are
many of them please report send a feedback and share all your results it's open so not only open
source software it's open source hardware as well thank you for your attention and any questions
please
okay I see two three four questions five but I afraid that I overused all the time
please
it appears that writing software is easy it appears that logic gates is easy
you're like in the riddle where everything is probably very oh I wouldn't the question was that
it looks like writing software is easier and connecting gates is easier and that the
complexity starts in the beginning when all of them are mixed but I would only partially agree to that
uh writing software is extremely difficult writing good software and complex software
is amazingly complex problem uh working with the modern hardware connecting gates with modern
technologies and everything is also getting a harder day today uh FPGAs are very complex beasts
where those complexity are multiplied and that makes this area especially interesting
attractive and as with many many other places you have all the innovations and places to grow
where some things are intersecting intersecting and FPGAs are exactly the intersection of hardware
and software okay thank you very much thank you
