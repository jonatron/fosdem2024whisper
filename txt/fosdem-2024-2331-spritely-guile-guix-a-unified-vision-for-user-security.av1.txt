Well, we're sitting here waiting, and I got up here thanks to the previous speaker giving
a generous amount of time to set up.
I'm going to show off a little bit more of this wonderful thing that we have here called
Strigiform, a pun on the Latin name for owls, which is a space shooter written in scheme
compiled with Guile Hoot.
And you can play it in your web browser, sure enough.
And it's got, this was done by David Thompson for the last Lisp game jam, who did all the
code, and I did all the music.
And this is a real scheme application you're about to see in your browser, so let's start
it.
Oh, yeah.
Let's do this.
Ooh, we've got an alternate firing mode.
Make your ship move slower.
Oh, yeah, we got that.
All right.
Look, there's particle effects.
Particle effects in the browser.
Is this scheme?
It's scheme.
Parallax scrolling of stars.
Can't freaking believe it.
People said that we couldn't bring the scheme to the browser and we're doing it.
So look how good I am.
Now actually a fun fact about David Thompson, who we all adore at the Spritely Institute
and are incredibly grateful every day to be able to work with, is that Dave loves space
shooters as much as I do, and in fact makes, has made several space shooters for the Lisp
game jam in Gile, including one who ever heard, who here has ever heard of the game, Ekagura?
Raise your hand.
Oh, like, okay, like three people.
Okay.
Well, Dave built a version called Lispagura, and you know, it's pretty good.
But anyway, you can play this game yourself.
You can witness the power of scheme directly in the browser.
Oh, there we go.
It's bound to happen.
But you know, it's going pretty well.
You know, oh god, there we go.
The moment I start, it's getting harder.
Where are we at on time?
I'm full screen.
I can't see.
Do I still have a couple minutes?
Are we there?
Is it time to stop?
Time to stop?
Okay.
All right, okay.
Yeah, there we're right on the hour.
Here's the real thing about this game.
It also has a badass boss in it with like pulsing blood veins, like moving across like
its forehead and everything like that.
It looks awesome.
And I did the graphics.
Thank you very much for them.
And you look awesome.
But Dave made it work, so you know.
That's more important.
Anyway, hello.
My name is Christine Leverweber.
I am the CTO of the Spritely Institute.
I've recognized quite a few faces here, so maybe some of you have seen me before.
This talk is about Spritely, Gile and Geeks, a unified vision for user security.
And what is the Spritely Network Communities Institute?
Well, we are a research institution.
We are building the future of decentralized networks from a protocol perspective, from
a software perspective, from a strong consideration of how human beings interact.
And everything we do is free and open source software, and it's all in the public interest.
And we are a 501c3 nonprofit in the U.S.
And research means collaboration.
If you're excited by this, you happen to be working with some sort of organization that
you want to collaborate with us, that would be great.
If you're an individual and you want to collaborate with us, also great.
I'm going to talk for just a moment about network communities at a general level, because
we're the Spritely Network Communities Institute.
And some of you may know me for my previous work on Activity Pub.
In fact, Jessica Tallin, right there, raise your hand.
She won't want to, but there she is.
She's a co-author with me on this back.
We're not the only people who worked on it, but of Activity Pub, which if you're familiar
with Mastodon, etc., is what connects all those things together.
And so we have some background in social things.
And in fact, our background goes back even way further.
Here is Lucasfilm's habitat, first ever massively multiplayer virtual world, ran on the Commodore
freaking 64 with thousands of users.
That should not have been possible with the graphical virtual world at the time, and yet
they did it.
And we are building towards more social systems.
So here you see a mock-up of kind of what we're doing.
We have a series of these mock-ups, but this is not the right talk for that, even though
there's some interesting ideas that are kind of hidden in here of decentralized naming
ideas.
But because we are going to be talking about some more low-level details.
And so this time I'm really talking with this audience, so we should figure out what we want
to do, right?
So we want to bring user freedom to everyone.
We're at FOSDOM, makes sense.
We want to make computers safe for everybody.
We want to introduce network programming like you never seen before, and we're going to
take over the web and with a power of combining our powers together, we're going to take
over operating systems, and we'll hear about how.
So from a perspective of, we chose to use Gile Scheme, right?
Which is a Scheme, which is a Scheme, which is a list, which is a family of languages,
like not that many people use.
And why do we do this?
It's because we love it, but it's also because it's really powerful.
And actually if you go to the Gile website, you go to the documentation page, we're very
proud that the first link that you see on there is actually our tutorial, Scheme Primer,
which introduces somebody who's never used Scheme before, how to be able to, it's like
a compressed version of structure interpretation in computer programs in like 30 pages.
You go from knowing nothing to writing your own Scheme interpreter inside a Scheme at
the end.
And this has been pretty popular.
But the reason we're using this stuff is not to just show off all these parentheses and
how cool it is and everything, but it's because Lisp is clay.
We want a language foundation which allows us to be able to build and express ideas very
easily and very powerfully, and Lisp allows us to do that.
Lisp is a power of composable domain-specific languages, and that means the types of things
that we are building, of decentralized networks and et cetera, can also be composed with the
types of things that, for example, the Geeks community is doing, even though they seem
to be attacking something very different, because you can combine these together very
easily.
And so I'm going to talk about Spritely Goblins.
It's our distributed, cooperative, transactional programming environment.
We have versions for both Gile and for Racket.
Gile is the main version these days.
And it's based off of this family of computer science research called object capability
security, which sounds really intimidating, but it's actually the least intimidating thing
possible because it's distributed security you can understand.
If you don't have it, you can't use it.
It's just ordinary argument passing the way that developers do every day.
If you have a reference to something, then you're able to do it, and the references to
objects turn out to have very composable patterns.
And if you want to understand more about those patterns, and you are a schemer, this is a
wonderful paper.
It really helped me understand everything.
It's a security kernel bias done along the calculus.
It's by Jonathan Reese of R5RS Scheme and many other things.
And it explains how if you take a simple lexically-scoped language like Scheme and you treat it very
seriously as that thing, that's your security model.
LAMDA is your security model.
And it saves you from a lot of dangerous things like confused deputies and ambient authority
problems and heron and things like the access control list model, which most of us are familiar
with from Unix and et cetera.
Now when I say this rightly, Goblin's is really powerful and easy to do things in.
Here is something that our engineer, same one who did that Strigiform thing I was showing
off earlier, David Thompson did in his first week on the job.
He had never used Goblin's before.
He had read a little bit about it.
But you know, day three, I'm like, okay, you've had your deep dive into Goblin's.
All right.
Now I want you to build me a distributed game.
And since he's David Thompson, he can do the game part.
And so he programmed this collaborative, lovely little garden demo in one day.
And then wrote a blog post about it in day two because he's incredible in David Thompson.
But even though he's David Thompson, it's really amazing that you could do this in one
day.
And what's really interesting is that this was all written in one process on one computer.
And then when you hook it up, Goblin's has this thing called O-Cappen.
And it's very specifically integrated so that you do this ordinary programming that automatically
works over the network.
These are based off of ideas that have existed for decades, but have been forgotten.
And we've been pulling them off the shelf and trying to bring them back to life and
bringing them to the world of scheme.
And in fact, here it doesn't just work in one, across one language, runtime environment.
Here are two different runtime environments.
You can see two implementations of the guile version of this minimalist chatroom thing
we created called Goblin Chat.
Our distributed network thing can run over multiple networking substrates, including
Torrnian services, which is slow as molasses, which is why you'll notice a lot of lag, but
it can run over faster things too.
But what's interesting here is that this is end to end encrypted.
We can verify that the messages come from the user that they claim they did.
And the code for the user and for the chatroom is 150 lines of code, of understandable scheme
code.
And what's also really interesting is that this whole program was also written entirely
on one process, entirely on one computer, and then when we hooked it up to the network,
it just worked.
The distributed, the communication between the things just worked.
And that's the kind of power that Goblins gives you.
But that's not all the kind of power Goblins gives you, because we also are a transactional
programming environment.
Here is, in a very small amount of code that I won't get into, because it's very dense,
a implementation of a bank, actually, a very minimalist fiat bank.
And this is, you know, what's also interesting about this is that if something goes bad in
the middle of this, if somehow, somehow, one piece of state was being updated and then
it crashed before it updated the next piece of state that it needed to do both, that would
just roll back.
Because Goblins is automatically transactional, which is a really interesting and useful feature,
because building distributed programs that don't have their state corrupted is actually
really difficult.
And here's one of the first things that I did when I was testing out the design of Goblins.
This is an ASCII art space shooter running in a terminal, right?
And you'd think that's the coolest part, but what's really the coolest part is that, what
just happened there?
Moving backwards and forwards in time.
Because what is unlimited transactionality?
It's time travel, right?
This entire game, I programmed this entire game without even thinking about that I should
add, that we already had the time travel feature effectively, and then I just exposed it in
about an hour or two, just the gooey for it.
I didn't have to change a single line of code of the gameplay to be able to make this happen.
Because Goblins already comes with the fundamental abstractions for this.
And in fact, we use this to be able to make your life easier.
Debugging is one of the most important things you can do, especially in distributed systems,
which are notoriously difficult to understand.
So Goblins comes with a time traveling distributed debugger.
And you don't even have to leave your REPL for it.
You are able to use the tools directly within your REPL.
You are able to move back and forth in time to find out what's going on, what's wrong,
and actually debug objects at the time that the errors were occurring.
And not only that, but it can visualize what happened to you.
And this prints out right in the REPL.
You don't even have to leave your tool.
So this allows for a strong amount of developer productivity.
And now, maybe you're not a guile person, right?
Maybe you're like, well, this all sounds really cool, but I want this in Haskell or something
else like that, right?
Well, good news, because we are taking the designs that have been extrapolated from basically
the work of Goblins.
And actually, Jessica Tallin has done the hard work over this last year to write these
up, thank you in Elnette for funding Jessica, to take all of the core inner mechanics of
how the network protocol works and write them as specifications.
The same way that Activity Pub is a specification that many different implementations are able
to be members of the Fediverse, we would like to have many different implementations be
members of the distributed world.
But in order to be able to build this, in order to be able to understand this, the Lisp
is clay aspect allowed us to be able to get here and understand things and move very efficiently.
And also, it's just a delight to program it, right?
So you don't have to worry about these types of things.
These are details that we've solved for you so that the programmer can just focus on the
code, but also, you know, cool graphic, right?
So now that all sounds cool and well, but you know, you might say, Christian, and then
I take a sip of water, very dramatically, and you say, Christian, but how are users
going to use this?
Do they all have to run geeks?
Do they, you know, how do we get it to them, right?
You know, maybe we have geeks packed, maybe we can get things to them a little bit that
way, but you know, the GTK really work right on these other platforms, you know, what do
we do, right?
And what everybody has today is a browser, right?
Everyone has a browser, right?
So we want to be in the browser, right?
And that is why we launched the Hoot project, right?
And generously funded by the folks at Consensus and Mediasque who also like OCAP security.
This is an example, if you're here for Robin's talk, you've already seen this bit, but this
is a snippet of scheme code for a cellular automata called Wireworld, and it's a real
scheme code.
And what you see here is it actually executing and running in the browser, and it looks cool
as heck, right?
You know, but the other interesting thing is that, you know, you can do more than this.
We are increasingly working on things like a foreign function interface to be able to
make it so that you can integrate all sorts of things in the browser and be able to do,
interact with, you know, the Canvas, interact with HTML.
Dave wrote an example of a functional reactive programming app using nothing but scheme kind
of React like, and there's an example of that on our blog, and that's the type of stuff
that we're doing.
But let's talk about the SecureOS vision because we are here and there are many scheme people
in the audience, and surely you're dying to know what we are saying about combining
goblins and geeks.
Well, what happens if we combine goblins and geeks?
Well, we have many computers, many of us are running computers using geeks, and many of
us are running many computers using geeks, and since goblins is a distributed programming
environment, what if we had distributed fabric across our different geeks instances where
we can securely cooperate across multiple geeks instances?
Now this is something that's not only free software nerds doing something, you know,
and trying to catch up to everyone else, but this would be something really new that no
one else is doing right now, right?
This is, would be exciting territory.
And so for example, imagine if we switch the geeks build daemon over to using goblins.
You know, one machine could say, hey, I have a recipe for something I'd like to build,
and then I want to have it deployed on this other machine.
They can send it over to this other machine which builds it, and then it sends it over
to the next one which deploys it.
That's the type of thing we could do if we moved over to goblins' tech.
And it's very natural.
And in fact, geeks actually already is kind of moving down the Ocap-ish direction in slight,
slight ways, this lovely Least Authority wrapper, right?
You know, Least Authority and Ocap, you know, have a lot of shared history type stuff, maybe
even, you know, some amount of overlapping volt and diagram stuff, but also, right?
So, this is the right time to say, you know, if all this excited to you, the most important
thing you can do is make something cool.
We have these cool tools, and they've been just now, like, it's taken a while.
Like, people are like, oh, should I pick up and run with these things?
We've been kind of like, yeah, like, mostly.
But like, within the last couple releases, and especially the next two upcoming releases,
I think we'll really be reaching the point where this stuff is of both goblins and hood,
where we can feel much more comfortable saying, actually, you should be picking this up and
running with this.
And so, we are planning on doing some hackathons and things like that, and maybe even jointly
with the Geeks community.
We've had some vague conversations about that, maybe a Spritely and Geeks joint hackathon,
and we'd love to see whatever you're interested in making.
And you know, maybe if you're especially excited about the Geeks plus Goblins dream, maybe
you could participate in that.
So we are a, I said that we are a 501c3 non-profit.
We are a research institution.
We are working with these different organizations, but also, maybe we should be working with
you, right?
Maybe we should be working with your organization.
Maybe you'd love to give us money.
Hey, we don't mind that.
Maybe you'd like to be a technical partner.
Maybe you'd like to jointly apply for funding with us.
These are real opportunities that we can have, and so we should talk about them.
Also, you can donate.
We're a 501c3 non-profit.
Now, most of the people here seem to be from Europe, so maybe this doesn't excite you quite
as much.
If you're in the US, it's tax-exempt, you know, tax-exempt donations, but even if you're
not in the US, you're also donating to an organization with a mission that surely aligns
with you at this very moment, hearing this ridiculous woman up on stage waving her arms
around madly, and you must be thinking, gosh, I have to give them all the money, right?
So, but here's another thing you can do.
You can come up, if you are excited, come up and say hello and get some stickers.
We have the most amazing stickers you've ever seen.
It has our non-binary goblin mascot and a bunch of clothes you can dress them up in.
And it also has the owl, and you can also dress up the owl in some stuff, not quite
as many, but you can also dress up the owl.
And please, Spritely representatives, please raise your hands.
Jessica, Juliana, Robin, and myself, of course, we all have stickers come up, say hello, say
I would like some of these stickers, and if you don't mind, tell us what are you excited
about, right?
Maybe how you would like to work together.
And so, finally, I'm going to say let's build it all together.
We are the Spritely Network Communities Institute.
Communities are about collaboration.
They are about the building of trust.
Trust cannot be forced.
Trust is a consensually collaborative process between multiple parties.
That is the very foundation of the kind of route that we are looking at in our technology,
but also, we would like to build with you, if you are excited about this stuff, let's
build it together.
Let's make it happen in whatever way, shape, or form.
And that's it.
Questions or excitement about stickers?
By the way, take a look at this.
It's keeping the browser.
So who's got the first question?
Does it work when it's not plugged in?
Does what work when it's not plugged in?
No, I like that.
And the calculator presentation, like that, you put some numbers at the calculator.
Oh, you unplug it.
Well, okay, so actually, maybe are you asking if you're not hooked up to the network or
is this just a joke?
It's a joke, okay.
You know, actually, disconnect handling is one of the next major features in the next
version of, you heard me say that especially in the next version, one of the biggest things
that we need to work on actually is disconnect handling.
So this is, your joke has an appropriate thing.
When two different instances are talking to each other and something goes wrong, you
need to propagate the information and actually register a call back to what's happening,
we have part of it, we need to finish it, what's happening in the next release.
So your joke is actually pretty relevant.
Next question.
So I'm a bit afraid of the browser.
Okay.
Not very minimal.
Do you have any recommendations there?
So if you're afraid of the browser, it's not very minimal.
There's multiple things we can say about that.
Number one, WebAssembly is actually a very minimal virtual machine itself and it's increasingly
being used by things that are not just browsers, right?
So people are starting to use it as, so actually we did two versions hilariously of the wire
world thing because we're ridiculous.
This first version, it's actually kind of interesting, actually runs on top of something
called Wazm 4.
I don't know if you've ever heard of it, but it's a virtual machine, it's a fantasy console
like an old Game Boy.
That's very small, very tiny, but it runs on top of WebAssembly.
So this first version, one of the interesting things about Hoot is it actually includes
a full, doesn't use M script in, doesn't use LLVM, doesn't use any of that BS, comes with
its own assembler, its own disassembler, it comes with its own virtual machine seeking
to run the things, but for developer purposes it's not fast.
And you, and this is all included actually with Hoot, it's a full toolkit.
So for the first version of wire world, before we had proper scheme working, this was actually
written in handwritten WebAssembly, mostly by Robin, a very small amount by me, but right
at the end, but mostly by Robin.
And of course you can play this, you probably saw Robin do a little bit before, and it works,
right?
So, and you know, there you go.
But the other thing is that we have, we did a second one, which was the version that we
did in scheme, one scheme became available actually.
So, and this one, just to give you an idea, this one, here's a size of wire world here
as a scheme program, and it looks like scheme, right?
And that's it, right?
You know, and that powers that version of wire world, right?
So the reality is, WebAssembly is useful in contexts that are not just that, but also
goblins is not specific to the browser, right?
The browser is the way that we are planning on reaching people, but it does not necessarily,
if you're excited about goblins, but you're, the browser will not be required to be able
to get geeks to use goblins, for example.
We're not, we're not saying, okay, geeks has to be an electron app now, right?
You know, that's not an expectation, right?
So, yeah, other questions?
The thing is that aren't necessarily in the scheme yet.
Is there going to be interoperability with other language one time, or other ways of
reaching out to existing node bases, or other, just, if when you're building, just use it
as.
Yeah, yeah, so right now you can actually already, I have no idea what just happened, I think
this is development console, you can actually already speak with JavaScript stuff inside
of, inside of, sorry, I got distracted, I'll do that.
You can speak with other JavaScript applications when you're using Hoot, like the, there's
a full, like, bridge between those two worlds, and also, so that's from the Hoot perspective.
From the goblins perspective, there are multiple implementations being done of O'Cappen, none
of them, sorry, I'm going to be early to smug here, none of them are as cool as goblins
because they don't have time-transl and transactionality and all the cool crap we have.
But there's like somebody doing a Haskell implementation and somebody was kind of starting on a Rust
implementation and stuff like that, we would love to see more implementations of these things.
And it's, there's, we have a test suite that Jessica wrote that you can actually test against.
So if you would like to bring some of the ideas, we are a research institution, you know, kind
of the same way that the, when Jessica and I started on doing our work on Activity Pub,
it was for the purpose of something that we were working on called Media Goblin and Activity
Pub, which we were working on for Media Goblin, ended up being a bigger thing than Media Goblin.
In some ways we're kind of running with that, we're actually saying, well, we really want you to use our
software, but also more importantly, we want to change how computing works for everyone.
Any other questions? Is that it? One more there. One more? Wait, who was it? Okay, over there, go up.
Yeah.
So, so, so it actually does have a small talk link in that,
Goblins is heavily based on, it's basically like the e-programming language, but for Scheme.
And the e-programming language was heavily inspired by Smalltalk. Mark Miller and Dean Tribble and the folks who worked on that,
a bunch of them came from Xanadu, actually, and they worked on, and that group actually really loved Smalltalk
and they used a whole bunch of that stuff. And so, so yeah, Smalltalk has an influence on some of this stuff.
Through the family lineage, basically. And now I'm going to hand this over to my lovely friend, Hisham here.
Thank you.
