WEBVTT

00:00.000 --> 00:15.000
Alright, we have a real Fostin hero standing in for Lewis, Pierre Emmanuel again.

00:15.000 --> 00:24.000
We have two more heroes at the back who have also obviously fixed the audio.

00:24.000 --> 00:31.000
Thank you very much as well.

00:31.000 --> 00:34.000
Take it away please.

00:34.000 --> 00:44.000
Hello again. I'm still not Lewis, and I'm still not the original speaker.

00:44.000 --> 00:54.000
The talk will be even worse than the first one. Let's talk about the hardware pointer on the Cherry architecture.

00:54.000 --> 01:00.000
Before we get started, we'll cover what we'll be talking about.

01:00.000 --> 01:10.000
We'll be talking about mirror safety, capabilities, the Cherry design, digital security by design, as well as CyberLife Connect project.

01:10.000 --> 01:26.000
We'll then talk about the motivation, the Cherry and the rest, as well as the implementation and the different challenges and problems we found during this walk.

01:26.000 --> 01:30.000
So, mirror safety.

01:30.000 --> 01:43.000
Accessing memory pointer, what could go wrong? You're probably your read and answer if you're doing some rest, but is rest even safe about this?

01:43.000 --> 01:59.000
So, the problem with rest is once you tag a code with unsafe or something or you're in unsafe context, the hardware will not back you up.

01:59.000 --> 02:12.000
You will simply let you access to the hardware if you're lucky, you have a kernel which will give you a page fault, but that's all.

02:12.000 --> 02:20.000
So, the hardware will not protect you against user-free, out-of-bound data-scored, everything.

02:20.000 --> 02:31.000
But you may already know rest and it helps us. I mean, safe rest is cool.

02:31.000 --> 02:36.000
There might still be something that could go wrong.

02:36.000 --> 02:47.000
So, what are capabilities? Capabilities are some kind of metadata that we embed at the assembly level with pointers.

02:47.000 --> 03:03.000
This means every pointer will have a big field of metadata, whether it could be written, read or even just used and how could it be used?

03:03.000 --> 03:10.000
And the second part of the pointer will be the address itself.

03:10.000 --> 03:18.000
So, we can encode in this metadata bound permission in validation states, all those kind of things.

03:18.000 --> 03:36.000
And the helpers catch code that behaves badly even when a compiler thinks it is valid.

03:36.000 --> 03:39.000
So, let's talk about Cherry.

03:39.000 --> 03:44.000
So, Cherry is a project from Cambridge University.

03:44.000 --> 03:49.000
Cherry isn't an architecture itself. Cherry is more of a specification.

03:49.000 --> 03:55.000
It's a set of specifications for an hardware extension.

03:55.000 --> 04:10.000
It allows the creation of a capability-based system and the specification covers all capabilities required in order to make code cycle.

04:10.000 --> 04:16.000
So, I was talking about this metadata.

04:16.000 --> 04:24.000
So, here you can see in this slide the encoding of metadata on the Cherry specification.

04:24.000 --> 04:37.000
We've got the permission, the type as well as the bound of the address in order to check any out of bound or array indexing or things like this.

04:37.000 --> 04:45.000
And you've got the 64-bit address behind it.

04:45.000 --> 04:47.000
Okay.

04:47.000 --> 04:53.000
One note, pure cap on hybrid mode.

04:53.000 --> 04:56.000
Cherry provides two modes.

04:56.000 --> 05:01.000
Pure cap basically is every pointer as metadata.

05:01.000 --> 05:06.000
Every pointer is 128 bits.

05:06.000 --> 05:21.000
And the hybrid mode is here in order to ensure compatibility with order, not just not order, but capability-less systems.

05:21.000 --> 05:25.000
Okay.

05:25.000 --> 05:28.000
Okay.

05:28.000 --> 05:37.000
So, here you've got an example for an instruction with capabilities.

05:37.000 --> 05:49.000
So, it takes an address and it raises an exception if permissions are not correct or something is wrong.

05:49.000 --> 05:54.000
For example, let's say on the previous slide.

05:54.000 --> 05:57.000
Okay.

05:57.000 --> 06:00.000
So, we've got bound set here.

06:00.000 --> 06:17.000
This means we can use a pointer for an array on set bound and if we are trying to access this array out of bound, the machine will trap and give us an exception.

06:17.000 --> 06:19.000
Digital security by design.

06:19.000 --> 06:21.000
What is it?

06:21.000 --> 06:34.000
So, in the Kingdom Government Initiative, that want to expand the use of Cherry out of academia to the industry.

06:34.000 --> 06:45.000
Zephend, multiple work to demonstrate the application of Cherry and make it work in the real world in the industry.

06:45.000 --> 06:48.000
Initially, it revolved only around Morello.

06:48.000 --> 06:50.000
You may not know Morello.

06:50.000 --> 06:59.000
So, Morello is an extension for our system, ARM.

06:59.000 --> 07:12.000
Recently, they focused more on architecture such as Rix-Fi, for example.

07:12.000 --> 07:14.000
CyberHiveConnect.

07:14.000 --> 07:23.000
CyberHiveConnect is a security-critical application within the rest.

07:23.000 --> 07:28.000
It's one to implement end-to-end encryption of a mesh network.

07:28.000 --> 07:34.000
So, yeah, here you've got an example.

07:34.000 --> 07:41.000
This application is a security-critical application.

07:41.000 --> 07:46.000
And it is with a mesh network and end-to-end encryption.

07:46.000 --> 07:53.000
So, this means obviously there should not be vulnerabilities.

07:53.000 --> 08:07.000
Okay.

08:07.000 --> 08:09.000
So, why Cherry and Rust?

08:09.000 --> 08:16.000
So, Rust already provided the different restrictions.

08:16.000 --> 08:20.000
Some restrictions cannot be provided by Rust.

08:20.000 --> 08:30.000
For example, there are runtime enforcements that are provided by Rust,

08:30.000 --> 08:32.000
but that slows down the flow.

08:32.000 --> 08:38.000
You may have seen out-of-bound checks on your arrays when you index an array.

08:38.000 --> 08:40.000
You may have seen that kind of thing.

08:40.000 --> 08:46.000
And this kind of code is slow, but if you replace this kind of code with Cherry-based extension in switching,

08:46.000 --> 08:53.000
it can now be faster on an extension to access an array out-of-bound.

08:53.000 --> 08:54.000
We'll simply trap.

08:54.000 --> 08:56.000
You don't have to end-to-end it yourself.

08:56.000 --> 09:00.000
You just have to end-to-end the trap.

09:00.000 --> 09:04.000
So, when you need to connect an application with Rust code,

09:04.000 --> 09:09.000
for example, with the FFI, for instance, a function interface,

09:09.000 --> 09:15.000
you may be safer because the Cherry extension will be here to back you up

09:15.000 --> 09:19.000
and provide you the correct pointers.

09:19.000 --> 09:27.000
And you who are sure that the pointer you'll be using in Rust won't come from nowhere

09:27.000 --> 09:30.000
or aren't a pointer or whatever.

09:30.000 --> 09:39.000
So, yeah, unsafe can become in some way safer.

09:39.000 --> 09:42.000
Here's an example.

09:42.000 --> 09:43.000
We've got an array.

09:43.000 --> 09:46.000
We converted it to pointer.

09:46.000 --> 09:52.000
We make a string, and we try to read the same line and pass a number.

09:52.000 --> 09:58.000
And then, at the end, we try to add the index to the pointer.

09:58.000 --> 10:02.000
And as you may have seen, we are using the safe code.

10:02.000 --> 10:13.000
And the Rust compiler won't catch any of this because we told him to do so.

10:13.000 --> 10:17.000
So, here, Cherry might help us.

10:17.000 --> 10:32.000
And Cherry will provide an exception on this when we want to go out of bound in the array.

10:32.000 --> 10:40.000
Lewis provided two new targets for the Rust compiler, more or less known pure cap

10:40.000 --> 10:43.000
and more or less known through the PUDESD pure cap.

10:43.000 --> 10:45.000
As you may have seen, both are pure cap.

10:45.000 --> 10:49.000
This means those are not compatible with AI breadmode.

10:49.000 --> 10:56.000
This means those implementation are not compatible with standard pointer.

10:56.000 --> 11:05.000
As we may say it, all pointers should have capabilities enabled.

11:05.000 --> 11:08.000
So, here, we have a new type of pointer.

11:08.000 --> 11:11.000
It's coming in Rust 5.

11:11.000 --> 11:16.000
And all those files are available in the repository right here.

11:16.000 --> 11:20.000
There was different implementation challenges.

11:20.000 --> 11:25.000
We should provide a new pointer type with capabilities.

11:25.000 --> 11:32.000
There is something that's made the created debate a few months,

11:32.000 --> 11:36.000
slash years ago, is the size type.

11:36.000 --> 11:41.000
You size in Rust, what should it represent?

11:41.000 --> 11:45.000
Should it cover the entire addressable space?

11:45.000 --> 11:50.000
Should it be able to contain a whole pointer?

11:50.000 --> 11:52.000
That kind of thing.

11:52.000 --> 12:01.000
So, we chose to represent only the address part of the pointer within the size.

12:01.000 --> 12:07.000
Layout and address space differs for pointer on capabilities.

12:07.000 --> 12:09.000
More on that later.

12:09.000 --> 12:17.000
And we generate, we have to generate some cherry specific interesting for LLven and AI.

12:17.000 --> 12:23.000
Again, as I said, your size is not UN pointer.

12:23.000 --> 12:25.000
Okay.

12:25.000 --> 12:28.000
So, I should have been a demo but I haven't one.

12:28.000 --> 12:36.000
So, well, enjoy the screenshots.

12:36.000 --> 12:43.000
Okay, so here we get the segmentation fault when we make an out of bound access in our array,

12:43.000 --> 12:50.000
even if we don't hit a numlap page, for example.

12:50.000 --> 12:52.000
So, that's cool.

12:52.000 --> 12:55.000
I'll give the slide.

12:55.000 --> 12:58.000
Yeah.

13:02.000 --> 13:04.000
Sorry.

13:10.000 --> 13:13.000
Okay, future walk.

13:13.000 --> 13:14.000
Future walk.

13:14.000 --> 13:18.000
So, what will the WIS concentrate on in your studio?

13:18.000 --> 13:20.000
It will add more cherry targets.

13:20.000 --> 13:29.000
Hopefully, yeah, more possibly some hybrid model for the targets.

13:29.000 --> 13:32.000
We want the rest test suite to pass.

13:32.000 --> 13:38.000
For now, we have only 50% of the tests in the USC that pass,

13:38.000 --> 13:45.000
and refactor the code, document the code, and rebase on a newer version of Rust

13:45.000 --> 13:50.000
because right now it's on Rust 1.67.

13:50.000 --> 13:52.000
So, yeah.

13:52.000 --> 13:58.000
And Lewis would like to begin upstreaming his walk.

13:58.000 --> 14:01.000
Well, thank you.

14:01.000 --> 14:04.000
And sorry again for this whole talk.

14:04.000 --> 14:09.000
If you've got questions, I may be able to answer those questions,

14:09.000 --> 14:13.000
but to be fair, probably not.

14:15.000 --> 14:18.000
Thank you.

14:28.000 --> 14:31.000
What other targets are you looking for, then?

14:31.000 --> 14:35.000
Are there other targets besides Morello, which actually implement Cherry today?

14:35.000 --> 14:37.000
I'm sorry, you didn't hear.

14:37.000 --> 14:44.000
Are there actually targets which implement Cherry today besides the arm Morello thing you showed?

14:44.000 --> 14:46.000
I don't know.

14:46.000 --> 14:57.000
I mean, RISC talked about some RISC-5 extension, but a journey behind them might be able to answer.

14:57.000 --> 14:59.000
So thank you.

14:59.000 --> 15:01.000
I'm one of Pierre Emmanuel's colleagues.

15:01.000 --> 15:07.000
There are a number of RISC-5 implementations out there.

15:07.000 --> 15:12.000
Code of SIP demonstrated by the RISC-5 summit and Microsoft,

15:12.000 --> 15:15.000
and I believe low risk also have ones as well.

15:15.000 --> 15:25.000
So RISC-5 is actually running ahead of ARM, if anything.

15:25.000 --> 15:28.000
But is there RISC-5 implantations so far virtualized,

15:28.000 --> 15:35.000
or are there any boards which support Cherry?

15:35.000 --> 15:37.000
I'm sorry.

15:37.000 --> 15:42.000
Regarding RISC-5 implementation, are there so far any boards which support Cherry,

15:42.000 --> 15:52.000
like RISC-5 Cherry, or is it mostly virtualized QM environment?

15:52.000 --> 15:58.000
I suspect these have only ever been made by the development teams as demonstrators on FPGAs,

15:58.000 --> 16:03.000
but Code of SIP certainly intend to be able to ship stuff to their customers,

16:03.000 --> 16:10.000
and I think before too long there'll be hardware available.

16:10.000 --> 16:16.000
You have a slide about GDP.

16:16.000 --> 16:22.000
Do you have GDP support for someone who prints one of these pointers,

16:22.000 --> 16:29.000
like the semantics of the, you know, the extra-secretful bits and bits?

16:29.000 --> 16:37.000
If we take a look at, in fact, if we take a look at Lewis Walk,

16:37.000 --> 16:46.000
the capabilities are stored in address space 200, if it makes sense.

16:46.000 --> 16:54.000
So there is some kind of support, but I believe it's more axe than real thing.

16:54.000 --> 17:09.000
I'm not sure, as I said, really, I don't know much.

17:09.000 --> 17:15.000
So just to follow up, so I believe there is a reasonable support for GDP and Cherry on Cherry BSD,

17:15.000 --> 17:25.000
and it displays all the things you need within the GDP.

17:25.000 --> 17:29.000
Any more questions?

17:29.000 --> 17:36.000
If not, then let's thank our speaker again.

