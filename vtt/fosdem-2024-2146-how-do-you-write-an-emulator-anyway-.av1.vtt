WEBVTT

00:00.000 --> 00:07.000
Thank you.

00:07.000 --> 00:13.640
Well, welcome for this session and congratulations on waking up so early after yesterday evening.

00:13.640 --> 00:19.280
It's always hard on Sunday morning to watch them.

00:19.280 --> 00:23.120
And thank you for those who are watching online.

00:23.120 --> 00:24.120
So who am I?

00:24.120 --> 00:27.920
My name is Anis, as Mahmoud said.

00:27.920 --> 00:31.080
You can follow me on social media, find my blog here.

00:31.080 --> 00:35.520
I'm writing this gamegear emulator called Gears.

00:35.520 --> 00:40.160
This is not the subject of this talk, but maybe I'll tell you a bit more about the gamegear

00:40.160 --> 00:45.000
hardware so you can see how that helps writing an emulator.

00:45.000 --> 00:47.200
I'm not an emulation expert.

00:47.200 --> 00:52.760
I know there are a few here which are very well versed, but I'm hoping that helps gives

00:52.760 --> 00:54.480
another perspective.

00:54.480 --> 01:02.080
I also gave a presentation on the Z80 which was pre-recorded in the emulator dev room

01:02.080 --> 01:03.080
two years ago.

01:03.080 --> 01:04.600
You can watch the talk.

01:04.600 --> 01:10.520
And yesterday on WebAssembly, putting this emulator to the web browser in the rest dev

01:10.520 --> 01:16.520
room, we can also watch the recording when it's online.

01:16.520 --> 01:19.600
So this is a small demo, what you can see here.

01:19.600 --> 01:22.880
This is the emulator that's running in a native window.

01:22.880 --> 01:28.400
Yeah, nothing very specific.

01:28.400 --> 01:33.720
So first of all, I'll tell you why I'm giving you this presentation.

01:33.720 --> 01:40.400
But before that, has anyone here ever written an emulator before?

01:40.400 --> 01:41.400
Okay.

01:41.400 --> 01:43.440
Oh, that's quite interesting.

01:43.440 --> 01:50.120
Who here knows how to program, how to write code?

01:50.120 --> 01:52.720
Oh, nice.

01:52.720 --> 01:54.520
That's good because that's not the goal of this talk.

01:54.520 --> 01:56.560
It's not to teaching you how to code, right?

01:56.560 --> 01:57.760
You know how to program.

01:57.760 --> 02:08.800
I'm hoping with those skills you'll be able to give you a few pointers to how to start,

02:08.800 --> 02:12.560
like where to find documentation, things like that.

02:13.480 --> 02:18.360
The goal of this talk is not to be exhaustive, otherwise it will be a full university course

02:18.360 --> 02:21.680
over a semester or something.

02:21.680 --> 02:25.320
And I want to also tell you why you should write an emulator.

02:25.320 --> 02:29.320
That's something that should come from you.

02:29.320 --> 02:33.280
And yes, so the focus of this talk would be on simpler platform because it's always easier

02:33.280 --> 02:37.280
to start with something a bit simpler.

02:37.280 --> 02:39.000
Yeah.

02:39.000 --> 02:40.360
So what is an emulator first?

02:40.360 --> 02:43.720
So a few definitions.

02:43.720 --> 02:48.320
It's something I struggled a bit because they come in many shapes, but in general it's a

02:48.320 --> 02:53.440
software, I would say, a software program that is used to run software from another

02:53.440 --> 02:57.960
computer or another platform, whatever.

02:57.960 --> 03:04.440
To give a few examples, here I showed a few screenshots of existing emulators.

03:04.440 --> 03:09.080
You have Gameboy, an gameboy emulator named Semboy.

03:09.080 --> 03:13.360
You have another BGB.

03:13.360 --> 03:17.920
Some support weird devices like printer.

03:17.920 --> 03:28.840
I showed an emulator running on the Android platform for the BBC Micro.

03:28.840 --> 03:32.960
There's also an Android emulator itself.

03:32.960 --> 03:39.880
So you want to emulate the computer that runs an Android OS.

03:39.880 --> 03:44.920
And also put something in here which might be debatable, which is an analog pocket, which

03:44.920 --> 03:48.040
is an emulator using FPGA.

03:48.040 --> 03:56.240
So you write software defined hardware and use real-time thridges to run software from

03:56.240 --> 03:59.760
other platforms.

03:59.760 --> 04:08.040
An emulator can have a huge spectrum of, let's say, accuracy and emulation.

04:08.040 --> 04:10.200
What does it emulate?

04:10.200 --> 04:13.560
Accuracy is how faithful you will be to the original.

04:13.560 --> 04:19.000
When you're emulating something, will it be running like one software?

04:19.000 --> 04:21.080
If that's your goal, that's all right.

04:21.080 --> 04:28.000
You just emulate enough of the platform to run one game with burning all the available

04:28.400 --> 04:30.040
software.

04:30.040 --> 04:35.640
Or maybe you want to do even more and be able to run any software that's on the target

04:35.640 --> 04:40.440
platform identically as if it was running on real hardware.

04:40.440 --> 04:48.400
We call it clock accurate, but there are us even in this spectrum.

04:48.400 --> 04:54.840
Before we continue, I wanted to show you a crazy example I found a few weeks ago, a few

04:54.840 --> 04:57.080
months ago of an emulator.

04:57.080 --> 04:58.560
It's a Linux emulator.

04:58.560 --> 05:04.480
It's a RISC-5 emulator of running Linux written in Scratch.

05:04.480 --> 05:08.600
It's a Scratch programming language.

05:08.600 --> 05:11.120
So we can't really see anything here on the screen.

05:11.120 --> 05:12.760
So I'll describe.

05:12.760 --> 05:14.920
You have a Linux terminal on Game Console.

05:14.920 --> 05:16.440
It has already booted.

05:16.440 --> 05:17.920
I wrote some commands.

05:17.920 --> 05:23.000
And here I'm scrolling, and you can see the Scratch code of the RISC-5 core.

05:23.000 --> 05:29.720
So yeah, emulators comes in all shapes and colors.

05:29.720 --> 05:31.320
So you want to write an emulator.

05:31.320 --> 05:33.320
Let's go with the first level.

05:33.320 --> 05:34.320
What will it be?

05:34.320 --> 05:35.320
Starting.

05:35.320 --> 05:39.480
How do you start?

05:39.480 --> 05:45.320
So if you want to start, the first thing you have to do is to pick a target.

05:45.320 --> 05:50.720
And by target is the platform you're going, what I mean is the platform you want to emulate.

05:50.720 --> 05:52.840
You have to pick this target.

05:52.840 --> 05:55.840
You have to pick a host platform to start somewhere.

05:55.840 --> 05:58.960
Even if your goal is to write something that's portable and running on everything, you have

05:58.960 --> 06:00.280
to again start somewhere.

06:00.280 --> 06:04.400
So you pick a host platform and make sure you have a bit of time.

06:04.400 --> 06:13.480
If you want something that's complete, emulators are something that's hard to decide when it's

06:13.480 --> 06:14.480
complete.

06:14.480 --> 06:18.280
You can always have more features, more things.

06:18.280 --> 06:26.160
So you don't have to have a lot of time in a short period, but maybe on a longer period

06:26.160 --> 06:27.560
it works as well.

06:27.560 --> 06:32.680
For example, for my emulator, I started two years ago.

06:32.680 --> 06:40.560
I've been working on and off, so it's not something that's taking a lot of time every

06:40.560 --> 06:41.560
day.

06:41.560 --> 06:44.960
That's what I mean.

06:44.960 --> 06:45.960
Where to start?

06:45.960 --> 06:46.960
Okay.

06:46.960 --> 06:47.960
Start simple.

06:47.960 --> 06:54.480
So with the CPU, you pick one CPU instruction.

06:54.480 --> 07:01.720
You write some code that will be able to disassemble it, which means you will take the binary form

07:01.720 --> 07:03.440
of this instruction, this one instruction.

07:03.440 --> 07:08.360
It will be a few bytes, one byte, I don't know, depends on your platform.

07:08.360 --> 07:10.400
Can your code recognize this one instruction?

07:10.400 --> 07:13.520
It might seem trivial to you.

07:13.520 --> 07:16.520
Is this a few bytes?

07:16.520 --> 07:18.440
It's how it starts, basically.

07:18.440 --> 07:23.440
So you start with this, and then you start adding stuff on top of it.

07:23.440 --> 07:24.440
You have your disassembler.

07:24.440 --> 07:26.000
It's very useful to debug.

07:26.000 --> 07:29.600
Then you add something, which is execution.

07:29.600 --> 07:31.240
So you have the CPU.

07:31.240 --> 07:33.800
How do you model its state?

07:33.800 --> 07:34.800
Okay.

07:34.800 --> 07:37.720
What's inside the CPU?

07:37.720 --> 07:39.760
Go look for more information.

07:39.760 --> 07:41.800
What's the CPU?

07:41.800 --> 07:47.840
Build this state, change it, which is basically what an executing an instruction does, and

07:47.840 --> 07:50.960
verify it has the state change as you expected.

07:50.960 --> 07:57.440
So if you want to add something to a variable, you do an add operation in your language.

07:57.440 --> 08:03.880
And then as you, let's say it's a good starter, and as you go, you keep learning new CPU concepts

08:03.880 --> 08:05.480
and how a CPU works.

08:05.480 --> 08:10.280
So yeah, this is helpful for starting.

08:10.280 --> 08:12.960
So a CPU is a processor.

08:12.960 --> 08:17.160
It's a half of, usually it's considered a half of consoles.

08:17.160 --> 08:25.720
Nowadays it might be a GPU, but as I said, this is focused on 8-bit platforms.

08:25.720 --> 08:27.040
As I told you, it has states.

08:27.040 --> 08:31.360
A CPU is a processor.

08:31.360 --> 08:34.280
So this state is basically what we call registers.

08:34.280 --> 08:39.160
It has all the kind of states, but the stuff with registers.

08:39.160 --> 08:41.200
I told you about an instruction.

08:41.200 --> 08:46.800
An instruction is a minimum operation that a CPU can do.

08:46.800 --> 08:51.920
It has assembly visualization, a text.

08:51.920 --> 08:55.240
You probably have heard of assembly programming language.

08:55.240 --> 08:57.760
That's how you visualize for human instructions.

08:57.760 --> 09:00.960
And it has a binary version and encoding.

09:00.960 --> 09:06.280
And this binary is, yeah, it's bytes you have to recognize.

09:06.280 --> 09:10.560
It has other concepts that are interesting, interrupts.

09:10.560 --> 09:20.360
These CPUs usually they can do execute instructions sequentially, and they can also be interrupted.

09:20.360 --> 09:28.880
So when they have an event from the outside world, you can change the way it's executing

09:28.880 --> 09:32.200
code.

09:32.200 --> 09:34.480
Also interesting is how do you access memory?

09:34.480 --> 09:36.720
I told you about states.

09:36.720 --> 09:42.360
Usually as a programmer, when you write in code, you think about variables and things

09:42.360 --> 09:43.360
like that.

09:43.360 --> 09:49.640
And this hides that on a hardware.

09:49.640 --> 09:53.160
State can be on registers or in memory.

09:53.160 --> 09:59.480
And the way a CPU accesses memory is also quite interesting.

09:59.480 --> 10:02.600
But the goal is not to teach you those concepts.

10:02.600 --> 10:08.520
It's to give you pointers on how to learn.

10:08.520 --> 10:11.880
So we've learned about how we start.

10:11.880 --> 10:17.320
Let's talk about how do we structure an emulator?

10:17.320 --> 10:21.240
So you've been writing a bit of CPU code.

10:21.240 --> 10:22.640
How do you structure the whole emulator?

10:22.640 --> 10:27.280
Because the CPU does not make a complete thing.

10:28.240 --> 10:33.400
I'm giving you here an example of the emulator structure.

10:33.400 --> 10:44.600
It's schematic by Rodrigo Copetti, which has been doing a very nice introductory documentation

10:44.600 --> 10:48.640
on hardware platforms, various hardware platforms.

10:48.640 --> 10:54.120
And here I took the master system one.

10:54.120 --> 10:57.680
You can see here, as I told you, that the CPU has the central part.

10:57.680 --> 11:04.960
So it's the square in the middle where it's written as Xilog ZAT.

11:04.960 --> 11:07.960
Then you have other devices that are interesting.

11:07.960 --> 11:10.880
I told you about the memory.

11:10.880 --> 11:13.200
Here on this platform, you have two kinds of memory.

11:13.200 --> 11:16.800
There's ROM and there's RAM.

11:16.800 --> 11:29.280
You have IO control, which is how you plug a joystick or the time it was more controllers.

11:29.280 --> 11:34.360
So this is plugged on this platform on an IO controller, and this is connected to the

11:34.360 --> 11:36.480
CPU.

11:36.480 --> 11:38.360
You have the game cartridges.

11:38.360 --> 11:50.200
So those are specific type of memory with things like paging in order to access more

11:50.200 --> 11:56.480
memory than the CPU can access.

11:56.480 --> 12:01.080
It has also a way to generate sound.

12:01.080 --> 12:04.960
Small device, a chip called PSG.

12:05.080 --> 12:09.080
This device is from Texas Instruments.

12:09.080 --> 12:10.640
It generates a very simple sound.

12:10.640 --> 12:18.720
It has a video display processor, which would be the ancestors of today's GPUs.

12:18.720 --> 12:21.160
And other things like something to...

12:21.160 --> 12:23.400
Okay, it's a video display processor.

12:23.400 --> 12:30.040
It's a bit specific here, but it has access to its own video RAM, which is a concept that

12:30.040 --> 12:33.800
you have to think through if you want to emulate this platform.

12:33.800 --> 12:37.480
And the video encoder is used for TV output.

12:37.480 --> 12:40.240
So it depends again on the platform.

12:40.240 --> 12:43.520
This is nothing very special.

12:43.520 --> 12:47.800
Many platforms of the time had very similar architectures.

12:47.800 --> 12:58.040
This is interesting because as you want to structure your code, your emulator code, you

12:58.040 --> 12:59.440
will want to...

12:59.440 --> 13:02.600
We probably will want to follow this structure.

13:02.600 --> 13:08.200
You want to take those devices and maybe organize your code...

13:08.200 --> 13:11.480
Take them as a code boundary and organize your code in modules.

13:11.480 --> 13:19.200
I don't know whatever your language has, functions, objects, classes, namespaces, whatever is

13:19.200 --> 13:22.800
on your programming language.

13:22.800 --> 13:28.000
It's an interesting code boundary to know, okay, this device could be emulated like this.

13:28.000 --> 13:31.480
There's another device like that.

13:32.480 --> 13:40.760
Another trick I'd like to share is when you're writing an emulator, you don't have to think

13:40.760 --> 13:44.600
about optimization too much, but you're allowed to optimize a bit.

13:44.600 --> 13:48.120
Only, for example, you're writing a CPU.

13:48.120 --> 13:50.440
It's a very simple thing.

13:50.440 --> 13:52.960
You probably want it to be fast.

13:52.960 --> 13:55.200
It's something that will have to be very fast.

13:55.200 --> 14:00.680
You might want to, for example, not do allocations on the emulation path.

14:00.680 --> 14:07.560
If you know what memory allocation is, it means that you want...

14:07.560 --> 14:09.000
It's something that can be quite costly.

14:09.000 --> 14:13.520
It's very useful, but when you're emulating, it's not something you want to do every other

14:13.520 --> 14:16.560
instruction or every instruction.

14:16.560 --> 14:18.200
You might want to use drum tables.

14:18.200 --> 14:20.240
This one, on the case, is debatable.

14:20.240 --> 14:24.920
Depending on your language, it might be automatic.

14:24.920 --> 14:31.120
Quite a common advice we see when advising people to write an emulator is that you should

14:31.120 --> 14:33.760
write a vertical slice.

14:33.760 --> 14:34.760
What does that mean?

14:34.760 --> 14:37.760
That means you have all those things.

14:37.760 --> 14:43.320
You know, I told you about the CPU, there's the video display processors, the audio.

14:43.320 --> 14:52.440
If you go on to writing an emulator, you probably want to see results quickly.

14:52.440 --> 14:57.520
That means that you will write support for a few CPU instructions and then a bit of display

14:57.520 --> 15:02.720
code so that very quickly you'll be able to have feedback and see on the screen that's

15:02.720 --> 15:13.760
showing something like the Nintendo logo on Game Boy or Sega or whatever.

15:13.760 --> 15:14.760
You can do that.

15:14.760 --> 15:18.200
That's not what I did.

15:18.200 --> 15:19.320
Do what works best for you.

15:19.320 --> 15:22.920
For example, I gave you a talk two years ago on the ZAT.

15:22.920 --> 15:30.760
It was a pre-recorded talk and at the time I had nothing else but a CPU.

15:30.760 --> 15:36.280
It depends on what you want to do.

15:36.280 --> 15:38.280
Do not hesitate if you have any questions.

15:38.280 --> 15:41.360
No, maybe we'll take them at the end because they're recorded.

15:41.360 --> 15:43.360
Sorry about that.

15:43.360 --> 15:59.080
Another trick is that I told you a bit here about the disassembler before.

15:59.080 --> 16:04.920
You should disassemble and write the text versions, assembly versions of instructions.

16:04.920 --> 16:10.000
It will be very useful to have a debugger.

16:10.000 --> 16:15.400
You might want to build debugging tooling to debug what's happening inside your emulator

16:15.400 --> 16:17.920
early because you will have bugs.

16:17.920 --> 16:22.040
You will have emulation bugs.

16:22.040 --> 16:24.520
Build this tooling early.

16:24.520 --> 16:27.720
Or you can use already existing tooling.

16:27.720 --> 16:29.720
Here you have the emulation.

16:29.720 --> 16:31.600
It's a great one.

16:31.600 --> 16:35.320
It's not open source unfortunately but you should definitely check it out.

16:35.320 --> 16:38.840
It's a multi-platform emulator.

16:38.840 --> 16:43.720
I think we have the developer here in the room.

16:43.720 --> 16:45.720
Definitely use the malicious.

16:45.720 --> 16:51.880
I can't tell you how many platforms it emulates because I don't remember but it includes the

16:51.880 --> 16:57.960
Game Gear and Master System.

16:57.960 --> 17:00.320
It has great debugging toolkit.

17:00.320 --> 17:01.320
You can see assembly.

17:01.320 --> 17:02.760
You can see video devices.

17:02.760 --> 17:08.240
You can see many things.

17:08.240 --> 17:17.560
Always make sure you have debugging in whatever form works for you if it's tracing or logging.

17:17.560 --> 17:29.760
It's nice but be able to inspect the state that's happening on the target emulated machine.

17:29.760 --> 17:32.480
I told you about all of this but that's quite interesting.

17:32.480 --> 17:37.760
How does one find information on where to start?

17:38.760 --> 17:41.440
That's a very common question I've had.

17:41.440 --> 17:52.000
Where do you find documentation on emulation, on how the hardware works?

17:52.000 --> 17:55.840
Well, basically you look online.

17:55.840 --> 18:00.000
There are many different communities.

18:00.000 --> 18:05.520
If you want to emulate a Game Boy you probably want to go to GB Dev.

18:05.520 --> 18:12.280
It has information on how to write Game Boy software but also how the hardware works.

18:12.280 --> 18:17.880
In fact, I like reading documentation aimed at developers of the platform instead of emulators

18:17.880 --> 18:23.400
developers because it tells you how you're supposed to develop for this platform.

18:23.400 --> 18:28.000
It also means you'll be able to understand how to emulate it this way.

18:28.000 --> 18:31.920
There's also the Geq's complete technical reference.

18:31.920 --> 18:38.880
It's considered a definitive guide on the Game Boy.

18:38.880 --> 18:46.880
If you want to emulate a Sega platform you probably want to go to SMS Power.

18:46.880 --> 18:54.200
It's a community around the Sega Master System and other devices like the Game Gears, Sega

18:54.280 --> 19:03.280
Mark 1, Mark 3, SG-1000 and the most recently announced the Sega AI which was a computer

19:03.280 --> 19:04.280
from the 80s.

19:04.280 --> 19:08.560
I'm sorry I don't have a screenshot here but that was very interesting.

19:08.560 --> 19:12.800
It was an AI computer that Sega released in 1986.

19:12.800 --> 19:17.080
I invite you to look for it online.

19:17.080 --> 19:22.760
So here, SMS Power has documentation on how to develop software for the Sega Master System,

19:22.760 --> 19:27.120
the Game Gear, it has documentation on how the Z80 works.

19:27.120 --> 19:34.200
It has many links to other documentation on video, audio, etc.

19:34.200 --> 19:41.200
One of the guides I used when writing my newsletter, there are three main ones.

19:43.720 --> 19:48.320
The hardware reference manual for the Sega Game Gear console.

19:48.400 --> 19:55.400
Some people in the community took this developer manual that Sega wrote for game developers

19:55.400 --> 20:01.400
and they scanned it and OCRed it and made a great PDF version.

20:01.400 --> 20:08.400
I don't know who did that but it was invaluable as a preservation effort and also used that

20:08.400 --> 20:13.680
for developing my emulator.

20:13.680 --> 20:20.680
It has some things that, well, a small caveat here is when you're describing stuff for developers,

20:24.160 --> 20:28.520
you might not go into the details of how the hardware works and sometimes you'll have

20:28.520 --> 20:35.520
edge cases that won't be explained to other developers but you need to emulate properly

20:36.480 --> 20:41.200
if you want the emulation to be correct.

20:41.240 --> 20:44.840
So yeah, in general it was very useful.

20:44.840 --> 20:51.840
The CPU of the Master System as a Game Gear is fully documented by Xilog.

20:54.360 --> 20:57.680
It has very complete manuals, the company still exists.

20:57.680 --> 21:04.680
I suppose, for example, to the Game Boy where all the documentation is unofficial.

21:04.680 --> 21:11.680
The Z80 CPU is well documented and even then there are other tricks and things that are

21:12.480 --> 21:15.880
not documented in the official manual.

21:15.880 --> 21:20.040
It's kind of part of the talk I gave two years ago.

21:20.040 --> 21:27.040
You probably want to go read this undocumented Z80 documented and then afterwards watch my

21:27.200 --> 21:31.800
talk for things that are not in this document.

21:31.840 --> 21:38.840
So finding documentation on a very simple trick, you want to emulate something.

21:40.120 --> 21:42.560
When you do research, use technical terms.

21:42.560 --> 21:47.360
It might seem trivial like this but even I fell into this trap many times.

21:47.360 --> 21:52.160
You're looking for something, how to get the more accurate thing.

21:52.160 --> 21:59.160
An example is look online or what exact chip sets your target platform is using.

22:00.160 --> 22:06.160
For example, for the audio, it's a chip from Texas Instruments and instead of searching

22:08.000 --> 22:15.000
for how to do audio for X console, X computer, use more precise keywords.

22:19.480 --> 22:24.360
It gives better results and I'm showing you here, on the left here, I Google for Game

22:24.360 --> 22:31.360
Gear sound and you have audio videos, YouTube videos and things like that but nothing very

22:31.920 --> 22:36.440
specific and on the right you almost find just SMS power and that's it.

22:36.440 --> 22:43.440
So basically the link I gave you.

22:43.560 --> 22:50.560
So let's get a bit more into practically what that means.

22:51.560 --> 22:58.560
What would be, yeah, practically how does that work, how do devices work.

23:03.680 --> 23:10.680
What I'm showing you here is an extract of the ZAT manual and how to do device IO.

23:12.720 --> 23:15.040
It's very complex and you don't need to understand it.

23:15.040 --> 23:22.040
It's basically electronics but it hides the fact that back then, using devices was quite

23:25.640 --> 23:32.640
simple. It would be almost as simple as writing to a memory address and that's how you interact

23:32.640 --> 23:39.640
with the device. Now on the ZAT CPU, there were dedicated instructions to do that but

23:40.640 --> 23:47.640
it was then quite simple as opposed to modern platform where you have GPUs, memory mapping,

23:51.640 --> 23:58.640
DMA, whatever is in a modern platform, it used to be much simpler and that's something

23:59.640 --> 24:04.640
you can use when writing an emulator.

24:05.640 --> 24:12.640
So in practice you want to write an emulator for a host platform.

24:12.640 --> 24:17.640
Make sure you understand your host platform first. You want to write an emulator for windows.

24:17.640 --> 24:24.640
Make sure you understand how to display pixel buffer on windows.

24:24.640 --> 24:31.640
So you want, you know how to open a window, you know how to, I don't know, allocate a memory area

24:31.640 --> 24:38.640
where you can write pixels, what is the pixel format, can you display something, a small image,

24:39.640 --> 24:44.640
make an image, can you change it multiple times per second.

24:46.640 --> 24:53.640
So yeah, make sure you understand your host platform and yeah, it's the same for audio.

24:54.640 --> 25:01.640
Let's, you want to start emulating sound. Make sure you know how to do, play audio on your platform.

25:05.640 --> 25:12.640
You have a buffer, can you generate, I don't know, a sine wave or square wave to make a beep.

25:12.640 --> 25:20.640
Nothing about this is emulator specific but it's really something you have to do when you want to do interactive development

25:20.640 --> 25:24.640
or game development more specifically.

25:24.640 --> 25:30.640
So you want to, let's start with the graphics emulation, okay.

25:30.640 --> 25:34.640
This is something you will need hardware understanding.

25:34.640 --> 25:42.640
You will need to understand how the VDP works, for example, on the game share, how the PPU works on the Game Boy.

25:43.640 --> 25:50.640
And so you will need to read the documents I pointed earlier.

25:50.640 --> 25:58.640
I'm giving you an example here for the VDP, a few concepts that are interesting where you want to, when you want to display pixels,

25:58.640 --> 26:05.640
you need to understand how developers were interacting with the device

26:06.640 --> 26:18.640
and how they, for example, they accessed the video RAM, how did they use the registers of the VDP.

26:18.640 --> 26:23.640
So, conceptually, I told you it's very simple.

26:23.640 --> 26:33.640
You use specific instructions that are basically sending bytes one by one from the CPU to the VDP.

26:33.640 --> 26:36.640
So that's how you send commands to it.

26:36.640 --> 26:42.640
So you write your registers, you write to VRAM, so that's IO.

26:42.640 --> 26:46.640
Internally, it has a display area.

26:46.640 --> 26:56.640
Here, this is an extract of the game share documentation where the LCD display area, the small part of the screen,

26:56.640 --> 27:01.640
will be part of a bigger buffer and then it's like a viewport and it can scroll on it.

27:01.640 --> 27:04.640
It has an infinite scrolling.

27:04.640 --> 27:06.640
The top and the bottom are connected.

27:06.640 --> 27:12.640
The left and the right are connected, so it means that it's like a torus,

27:12.640 --> 27:15.640
mathematically, the donut shape.

27:18.640 --> 27:24.640
Other VDP interesting concepts, you have the sprites.

27:24.640 --> 27:26.640
I told you about the background.

27:26.640 --> 27:28.640
On the background, you display sprites.

27:28.640 --> 27:34.640
Sprites are often used for game characters.

27:34.640 --> 27:40.640
And they're very interesting because basically the VDP was like a sprite accelerator

27:40.640 --> 27:45.640
because at the time, if you wanted to display things very fast, it was not simple

27:45.640 --> 27:48.640
and the VDP helped with that.

27:48.640 --> 27:52.640
The sprite also helped to do collision detection and things like that.

27:52.640 --> 27:58.640
But you will need to understand how color encoding works, how sprite pixels are encoded

27:58.640 --> 28:04.640
because it's not really a simple square buffer or whatever.

28:04.640 --> 28:07.640
So everything has a specific encoding.

28:07.640 --> 28:08.640
It's well documented.

28:08.640 --> 28:12.640
Here, what I'm showing you is a tile map.

28:12.640 --> 28:21.640
So it's a dump of the video RAM of the Sonic 1 game share game.

28:21.640 --> 28:28.640
And this tile map has sprites on the bottom and background on the top.

28:28.640 --> 28:34.640
It's not exactly the same as the display screen, but it shows how things are represented in memory

28:34.640 --> 28:40.640
and then they can be mapped to the LCD display.

28:40.640 --> 28:47.640
I won't go into details about that, but you probably want to have a synchronization strategy

28:47.640 --> 28:50.640
between your CPU and your devices.

28:50.640 --> 28:55.640
If you want to synchronize the VDP, for example, it's something that's easier to do line by line.

28:55.640 --> 29:03.640
So you emulate a given number of instructions and then you emulate one line of the VDP.

29:03.640 --> 29:11.640
So it allows doing this emulator single threaded because it's easier to think that way.

29:11.640 --> 29:20.640
And it's an available thing strategy and one that can give accurate enough emulation.

29:20.640 --> 29:22.640
Sound emulation.

29:22.640 --> 29:24.640
Sound emulation is quite interesting.

29:24.640 --> 29:29.640
Again, it is hardware understanding, so you will need to read the documentation.

29:29.640 --> 29:32.640
I'll give you an example with the PSG.

29:32.640 --> 29:34.640
So you write registers.

29:34.640 --> 29:36.640
It has less registers.

29:36.640 --> 29:37.640
It's much simpler.

29:37.640 --> 29:41.640
It's a device that's conceptually quite simple.

29:41.640 --> 29:43.640
It has four channels.

29:43.640 --> 29:45.640
Three are tone generators.

29:45.640 --> 29:49.640
Basically, the generate beeps with a given frequency.

29:49.640 --> 29:59.640
And one is a noise generator and it generates noise, basically.

29:59.640 --> 30:05.640
So you have multiple things that are interesting.

30:05.640 --> 30:10.640
The tones are shown here on the top right.

30:10.640 --> 30:20.640
There are square waves, at least in theory, because when you interact with hardware, life is analog,

30:20.640 --> 30:29.640
and it's not perfectly square, so it might look a bit more like the wave on the bottom, just below it.

30:29.640 --> 30:34.640
And what I'm showing here is a noise generator.

30:34.640 --> 30:45.640
It's a very simple hardware device called Line Feedback Shift Register, or LFSR.

30:45.640 --> 30:54.640
And it's used to generate noise by basically shifting a set of bits,

30:54.640 --> 30:57.640
shifting them right or left.

30:57.640 --> 30:59.640
Well, it's the same, but here it's right.

30:59.640 --> 31:08.640
You start with one bit and you shift them, and then you output the bit that's on the right.

31:08.640 --> 31:12.640
But if you were to do that without feedback, it would just shift the one,

31:12.640 --> 31:15.640
and then you just put zero, and yeah, it's done.

31:15.640 --> 31:18.640
Except this here has XOR function.

31:18.640 --> 31:25.640
So we'll take two bits here, XOR them, and put them back as inputs.

31:25.640 --> 31:32.640
And with this input, you're able to generate the random-looking noise.

31:32.640 --> 31:37.640
It's not perfectly random, it's not cryptographically random, but it's good enough,

31:37.640 --> 31:42.640
and yeah, that's how it used to work.

31:42.640 --> 31:47.640
For sound emulation, again, you have to start simple.

31:47.640 --> 31:50.640
You want to generate a square wave, as I told you.

31:50.640 --> 31:54.640
It's a very good hello world for your platform, for sound.

31:54.640 --> 31:57.640
But then you will need to add more things.

31:57.640 --> 32:04.640
On the PSG, it varies on other platforms, on the master system and the megadra,

32:04.640 --> 32:07.640
as the game is here.

32:07.640 --> 32:16.640
You need to think about the tone channels having counters, and not the frequencies.

32:16.640 --> 32:19.640
You need to think in terms of period and not frequency.

32:19.640 --> 32:29.640
It's almost the same except when you're emulating, you will have edge cases that won't work well

32:29.640 --> 32:34.640
if you think in terms of frequency.

32:34.640 --> 32:43.640
A quick advice about thinking.

32:43.640 --> 32:48.640
You can have multiple ways to think audio emulations with the CPU.

32:48.640 --> 32:52.640
My advice would be to use CPU cycles.

32:52.640 --> 32:58.640
So when you're emulating instructions, you will need to count the cycles.

32:58.640 --> 33:06.640
Depending on the platform, one instruction can be a various number of cycles,

33:06.640 --> 33:11.640
from, I don't know, from four cycles to 20 on the ZAT.

33:11.640 --> 33:16.640
So you will need to count them accurately enough so that when you're playing audio,

33:16.640 --> 33:19.640
it won't be distorted.

33:19.640 --> 33:24.640
And in general, it's useful to count cycles properly even for display.

33:24.640 --> 33:29.640
I wanted to give you an example about playing samples, but very quickly.

33:29.640 --> 33:34.640
They also use a square wave, but it's quite similar.

33:34.640 --> 33:39.640
They use amplitude variations.

33:39.640 --> 33:42.640
So they play a wave that's always up.

33:42.640 --> 33:45.640
So if you were to play it, it would be silent.

33:45.640 --> 33:52.640
But they make the volume vary and they make it very, very, very fast, like 7,000 times per second.

33:52.640 --> 33:56.640
And it generates an audio signal and that's how you have samples.

33:56.640 --> 34:04.640
Samples are, when you hear, for example, Sega sound, something like you would play an audio file today.

34:04.640 --> 34:09.640
They didn't support, well, this platform did not support playing a random audio file,

34:09.640 --> 34:13.640
so developers had to get creative.

34:13.640 --> 34:20.640
Testing, how does one test an emulator?

34:20.640 --> 34:25.640
There are various strategies for that.

34:25.640 --> 34:33.640
For example, for the ZAT CPU, there are unit tests you can use from other emulators.

34:33.640 --> 34:42.640
For example, the Fuse test suite has very good unit tests that are not dependent on the Fuse emulator.

34:42.640 --> 34:45.640
You can also use integrated tests.

34:45.640 --> 34:52.640
For example, ZXOL and ZAT tests, these are programs that were written for the ZX Spectrum,

34:52.640 --> 34:55.640
which was a computer from the 80s.

34:55.640 --> 35:03.640
It has, they were generating instructions, lots of instructions, executing them,

35:03.640 --> 35:09.640
and then dumping the CPU state and making a very small checksum.

35:09.640 --> 35:20.640
And they run that on the real hardware and registered what was the checksum for each instruction set.

35:20.640 --> 35:27.640
So these are bit long, ZAT tests that can take a few seconds up to minutes.

35:27.640 --> 35:32.640
On real hardware, it was much longer, of course, and they are very useful.

35:32.640 --> 35:39.640
Go test, go test with, even if it's another platform, you can reuse the CPU tests very simply

35:39.640 --> 35:44.640
by doing a few bytes modification and it works on your platform.

35:44.640 --> 35:46.640
How to test audio?

35:46.640 --> 35:54.640
Well, this one I was not sure because I'm not so sure how to well test audio emulation.

35:54.640 --> 35:59.640
Listen to the music. Does it look like the original one?

35:59.640 --> 36:04.640
Yeah, you need a good ear for that.

36:04.640 --> 36:13.640
You can use fast Fourier transforms as well, which are mathematical operations used to analyze an audio signal.

36:13.640 --> 36:19.640
For example, you generate the square wave. Does it have the correct frequencies?

36:19.640 --> 36:22.640
If you go through the emulation path.

36:22.640 --> 36:27.640
And then can you hear the samples? I told you about the playing samples.

36:27.640 --> 36:33.640
These are, I'd say, the hardest part of the audio emulation because it plugs into many accuracy things.

36:33.640 --> 36:36.640
So yeah, can you hear them?

36:36.640 --> 36:41.640
Other examples here for the games here. This is DGTest SMS test suite.

36:41.640 --> 36:48.640
These are software developed by emulator developers for the platforms that will test various features.

36:48.640 --> 36:51.640
Here for the games here is the Sega Master System.

36:51.640 --> 36:58.640
For the Game Boy, you probably want to look at DMG AC test too, for example.

36:58.640 --> 37:02.640
The Game Boy is a platform that's very well emulated. It's a good choice to start.

37:02.640 --> 37:04.640
It has many tests.

37:04.640 --> 37:09.640
Blogs, test suite, MoonEye test suite, many accuracy tests.

37:09.640 --> 37:11.640
Yeah, you should look into it.

37:11.640 --> 37:14.640
Another testing strategy is frame generation.

37:14.640 --> 37:19.640
So you're emulating stuff. You're generating a display, pixel buffers.

37:19.640 --> 37:26.640
You can very easily dump your buffers into an image and compare this image with a good emulator.

37:26.640 --> 37:30.640
And you also can compare it with real hardware.

37:30.640 --> 37:37.640
For example, if you use flashcards and you don't have all the original games, it can be useful.

37:37.640 --> 37:45.640
In general, I would say test a lot of different software and look how it works.

37:45.640 --> 37:58.640
For example, here you can see on the left side, this is my test directory for a few games where I'm basically using that as a regression test suite.

37:58.640 --> 38:00.640
Does it always work?

38:00.640 --> 38:04.640
So some images have a story like I had bugs that I had to fix.

38:04.640 --> 38:09.640
And when it finally worked, I recorded that to make sure it kept working.

38:09.640 --> 38:13.640
On the right, what you have is the same boy auto frame generation.

38:13.640 --> 38:24.640
It's captured a very small part of a web page where they test all the Game Boy games, a Game Boy color, and other, and they make screenshots.

38:24.640 --> 38:26.640
It's very interesting.

38:26.640 --> 38:33.640
Other communities who are interesting in testing are the speedrun communities.

38:33.640 --> 38:35.640
I'll let you look into that.

38:35.640 --> 38:42.640
They also do frame testing, but they record the frames on real hardware.

38:42.640 --> 38:47.640
So summary of everything we said here.

38:47.640 --> 38:49.640
It was a bit fast. I'm sorry.

38:49.640 --> 38:54.640
Pick platforms, host platform, a target platform, something you want to emulate.

38:54.640 --> 38:59.640
First of all, always do something simple first and then make it grow.

38:59.640 --> 39:01.640
Read a lot of documents.

39:01.640 --> 39:04.640
That's probably something that's part of the emulator development.

39:04.640 --> 39:06.640
So a lot of documentation.

39:06.640 --> 39:14.640
Testing, because depending on how accurate you want to do, you probably want to test your software properly.

39:14.640 --> 39:19.640
And don't forget if you ever go and write an emulator to write blog posts about it.

39:19.640 --> 39:25.640
So people know about it and come here to first them in the emulator dev room and make a talk.

39:25.640 --> 39:27.640
Please.

39:27.640 --> 39:29.640
Thank you. Any questions?

39:29.640 --> 39:37.640
Testing, testing.

39:37.640 --> 39:39.640
Shall I do the question round?

39:39.640 --> 39:41.640
We have a bunch of questions.

39:41.640 --> 39:45.640
So I'm just going to run around and...

39:45.640 --> 39:47.640
Thanks for the talk.

39:47.640 --> 39:49.640
It was really good.

39:49.640 --> 39:51.640
Two small questions.

39:51.640 --> 39:55.640
Approximately how long did you spend on your first emulator?

39:55.640 --> 39:58.640
It was like a few weeks, a few months before you got something running.

39:58.640 --> 40:01.640
Do you have any recommendations from your experience?

40:01.640 --> 40:03.640
I know you did some stuff in Rust.

40:03.640 --> 40:06.640
Which languages did you use other languages?

40:06.640 --> 40:08.640
How was your experience with Rust?

40:08.640 --> 40:10.640
Is it good for emulators?

40:10.640 --> 40:12.640
Does it make things harder?

40:12.640 --> 40:14.640
Rust is very good.

40:14.640 --> 40:16.640
I don't use it for anything.

40:16.640 --> 40:18.640
So that's...

40:18.640 --> 40:21.640
To be honest, it's a hobby project.

40:21.640 --> 40:23.640
We have a question.

40:23.640 --> 40:30.640
It's a hobby project that you didn't measure how much time it took to develop everything.

40:30.640 --> 40:32.640
Before I had real feedback.

40:32.640 --> 40:35.640
You asked me before I had real feedback how long it took.

40:35.640 --> 40:39.640
Part of my strategy was different with what I usually recommended.

40:39.640 --> 40:41.640
I developed the CPU first.

40:41.640 --> 40:43.640
I wrote a talk about it.

40:43.640 --> 40:46.640
The feedback here was does the test fit pass?

40:46.640 --> 40:50.640
I used different tests and do they pass?

40:50.640 --> 40:57.640
That's how you get early results without having a complete emulator.

40:57.640 --> 41:00.640
About the programming language.

41:00.640 --> 41:03.640
I intentionally did not go into details here in this talk

41:03.640 --> 41:08.640
because I want people to be able to write in whatever language they feel comfortable.

41:08.640 --> 41:09.640
Rust is great.

41:09.640 --> 41:10.640
Go is great.

41:10.640 --> 41:12.640
Use whatever language you want.

41:12.640 --> 41:16.640
Especially if you're emulating an 8-bit platform.

41:16.640 --> 41:22.640
You don't really need to care too much about performance.

41:22.640 --> 41:27.640
You should be able to get very good results with whatever language you use.

41:27.640 --> 41:29.640
Unless maybe it's...

41:29.640 --> 41:31.640
I don't even have a good example.

41:31.640 --> 41:33.640
So yeah.

41:33.640 --> 41:35.640
Next question.

41:35.640 --> 41:37.640
Thanks for the talk.

41:37.640 --> 41:39.640
Regarding the audio emulation,

41:39.640 --> 41:44.640
would it be possible to just record the waveform and compare them?

41:44.640 --> 41:48.640
It can but...

41:48.640 --> 41:53.640
I didn't want to go too much into details for that.

41:53.640 --> 41:54.640
An example.

41:54.640 --> 41:59.640
On the Game Gear and Master System,

41:59.640 --> 42:04.640
the sound chip is generating audio at about 115 kHz.

42:04.640 --> 42:08.640
On modern platforms, you will run at 44 kHz, 48 kHz.

42:08.640 --> 42:13.640
You can have more on most laptops, but it's not what's usually used.

42:13.640 --> 42:17.640
So what you will need is a down-sampling strategy.

42:17.640 --> 42:24.640
So you will need to take the samples and down-sample them at your host platform sample rate.

42:24.640 --> 42:26.640
And this will generate artifacts.

42:26.640 --> 42:27.640
Yeah, okay.

42:27.640 --> 42:28.640
Good.

42:28.640 --> 42:29.640
Thanks.

42:29.640 --> 42:30.640
Yeah.

42:30.640 --> 42:33.640
Next question regarding the audio stuff.

42:33.640 --> 42:40.640
Do you know if there's any ongoing work to emulate the original sounds of the Game Boy or Game Gear

42:40.640 --> 42:44.640
because they have built-in speakers which will compress the sound and...

42:44.640 --> 42:48.640
Yeah, it will have a specific sound which you can't hear these days.

42:48.640 --> 42:50.640
Do you know if there's anything like that?

42:50.640 --> 42:55.640
Like you could record the compression and all?

42:55.640 --> 42:57.640
I think there is.

42:57.640 --> 43:03.640
I think I found a website, I don't remember, on audio emulation specifically.

43:03.640 --> 43:14.640
They were developing automatic filters to match the platforms as close as possible using machine learning

43:14.640 --> 43:18.640
and with the target of you putting back into DSPs or FPGAs.

43:18.640 --> 43:21.640
But I can't remember the name, I'm sorry.

43:21.640 --> 43:26.640
But that's something I'm very interested in, especially because audio emulation is not that simple.

43:26.640 --> 43:28.640
You need filtering.

43:28.640 --> 43:33.640
If you want to go closer to the Game Gear, for example, which has speakers,

43:33.640 --> 43:38.640
you will probably need filtering because it has a frequency response

43:38.640 --> 43:42.640
which will not be the same as your modern speakers frequency response.

43:42.640 --> 43:44.640
So yeah.

43:44.640 --> 43:45.640
I'm sorry.

43:45.640 --> 43:46.640
I'm sorry.

43:46.640 --> 43:47.640
I'm sorry.

43:47.640 --> 43:49.640
More questions?

43:49.640 --> 43:52.640
Yeah, I almost forgot about you, I'm sorry.

43:57.640 --> 44:01.640
So you mentioned tooling and debugging.

44:01.640 --> 44:02.640
What?

44:02.640 --> 44:03.640
Sorry.

44:03.640 --> 44:05.640
Tooling and debugging of the emulator.

44:05.640 --> 44:10.640
And you said there were two options like you can write your own tooling and debugging

44:10.640 --> 44:13.640
so that you can inspect the state of your emulator.

44:13.640 --> 44:17.640
But you also said you can use external existing debuggers.

44:17.640 --> 44:19.640
How do they help?

44:19.640 --> 44:22.640
How do they help for your emulator specifically?

44:22.640 --> 44:26.640
They will help you understand if you have a bug with a given game.

44:26.640 --> 44:28.640
They will help you with multiple things.

44:28.640 --> 44:31.640
They will help you understand how the game works.

44:31.640 --> 44:38.640
So you have a better view of how the game works, how the software is working.

44:38.640 --> 44:43.640
And they'll help you understand what you're doing wrong.

44:43.640 --> 44:48.640
So you're emulating the game, you have your own logging, your own debug tooling.

44:48.640 --> 44:52.640
They'll help you understand what you're doing wrong in your emulation.

44:52.640 --> 44:56.640
So it's more for a comparison type of thing.

44:58.640 --> 45:00.640
Alright, we have time for a short question.

45:00.640 --> 45:04.640
And also can you put your contacts to your first slide I think so people can find you after the talk?

45:04.640 --> 45:05.640
Oh yeah.

45:05.640 --> 45:06.640
I think that's a good idea.

45:06.640 --> 45:07.640
It was a short question, right?

45:07.640 --> 45:10.640
Or turn it into a short question.

45:10.640 --> 45:16.640
Are there any worthwhile platforms left to emulate that are also approachable?

45:16.640 --> 45:18.640
I would say yeah.

45:18.640 --> 45:22.640
I gave the example of the Game Boy, it was very specific because it has so much documentation.

45:22.640 --> 45:24.640
So yeah, it's a good platform to start.

45:24.640 --> 45:30.640
Is there anything left?

45:30.640 --> 45:33.640
It's okay if it has a lot of emulators.

45:33.640 --> 45:41.640
If you want a platform that no one has written an emulator for it will be harder because you have to discover all this information by yourself.

45:41.640 --> 45:50.640
So if you want an easy thing to start, it's not the same as exploring new stuff and reverse engineering and things like that.

45:50.640 --> 45:52.640
Well, thank you very much.

45:58.640 --> 46:00.640
Thank you, Anis.

