WEBVTT

00:00.000 --> 00:13.660
Thank youender

00:13.660 --> 00:18.660
million

00:18.660 --> 00:25.140
that is going

00:25.140 --> 00:27.140
Technical question.

00:40.140 --> 00:42.140
We can edit the video later.

00:44.140 --> 00:46.140
Let's start very lighthearted then.

00:46.140 --> 00:48.140
Maybe a shell of hands.

00:48.140 --> 00:51.140
Who here has heard of mutation testing?

00:51.140 --> 00:53.140
Amazing.

00:53.140 --> 00:55.140
I can go very quickly to some flights then.

00:55.140 --> 00:58.140
Who has never heard of mutation testing?

00:58.140 --> 01:00.140
For who is the completely new concept?

01:00.140 --> 01:02.140
I will cover it for you guys.

01:02.140 --> 01:04.140
That's nice.

01:04.140 --> 01:08.140
Of course I'm here, but I'd like to promote Striker a little bit.

01:08.140 --> 01:11.140
Who of you is actually using Striker already?

01:11.140 --> 01:13.140
Nobody. One person.

01:13.140 --> 01:16.140
Well, that's my colleague. He's also working on it.

01:16.140 --> 01:20.140
Cool. You guys are definitely going to learn some stuff today then.

01:21.140 --> 01:24.140
I can just start right?

01:24.140 --> 01:25.140
Sure.

01:25.140 --> 01:27.140
Welcome everybody to the talk,

01:27.140 --> 01:29.140
How Mutation Testing Got Practical?

01:29.140 --> 01:33.140
I'm really focusing on the Got Practical in this talk.

01:33.140 --> 01:36.140
I will be explaining mutation testing a bit,

01:36.140 --> 01:38.140
but I'm really looking deep into the internals

01:38.140 --> 01:41.140
and why is the idea really old?

01:41.140 --> 01:43.140
It's a practical use case, relatively new.

01:43.140 --> 01:45.140
So I'll get into that.

01:45.140 --> 01:47.140
But first, a little introduction.

01:47.140 --> 01:49.140
My name is Jan Dele Kester.

01:49.140 --> 01:51.140
I'm a self-engineering consultant at InfoSupport.

01:51.140 --> 01:54.140
It's a consultancy organization in the Netherlands.

01:54.140 --> 01:58.140
I'm also a trainer there, and I'm a research supervisor.

01:58.140 --> 02:00.140
And that last one is very relevant today.

02:00.140 --> 02:03.140
You'll hear why soon.

02:03.140 --> 02:05.140
If you want to contact me afterwards,

02:05.140 --> 02:07.140
you can use the link then, I guess,

02:07.140 --> 02:10.140
but you can also find me on GitHub.

02:10.140 --> 02:12.140
And as I said, I'm here on behalf of Striker.

02:12.140 --> 02:14.140
Striker is a mutation testing framework

02:14.140 --> 02:17.140
for JavaScript and TypeScripts,

02:17.140 --> 02:20.140
C-Sharp, Scala, and hopefully at some point, Kotlin.

02:20.140 --> 02:23.140
There's like a partial implementation there already.

02:23.140 --> 02:25.140
We're working hard on it.

02:25.140 --> 02:27.140
You can find us at StrikerMutator.io,

02:27.140 --> 02:30.140
and of course, I have all these nice socks for you guys.

02:30.140 --> 02:32.140
So if you're really good with asking questions

02:32.140 --> 02:36.140
and reacting to my questions, you might get some.

02:36.140 --> 02:39.140
And otherwise, you'll see us after. We'll have some more.

02:39.140 --> 02:41.140
So in this talk, in this next 25 minutes,

02:41.140 --> 02:44.140
because I am going to try to leave room for questions as well,

02:44.140 --> 02:47.140
I first want to talk about why do we actually need

02:47.140 --> 02:49.140
to understand our tests?

02:49.140 --> 02:52.140
Why is just writing a test not good enough?

02:52.140 --> 02:54.140
I also want to go into what mutation testing is

02:54.140 --> 02:57.140
for the people that don't know yet.

02:57.140 --> 02:59.140
And finally, and that's the major part,

02:59.140 --> 03:02.140
hopefully if I don't run out of time,

03:02.140 --> 03:05.140
I'm going to go deep in how we got to practical applicability,

03:05.140 --> 03:07.140
how we got into this state now

03:07.140 --> 03:11.140
where we can actually run mutation testing in our real projects.

03:11.140 --> 03:14.140
And that means talking about some state of art,

03:14.140 --> 03:17.140
state of art performance improvements.

03:20.140 --> 03:24.140
But first, we have to talk about the false sense of security.

03:24.140 --> 03:28.140
Because this is a promotional image I copied shamelessly

03:28.140 --> 03:31.140
from the Sonacube website.

03:31.140 --> 03:33.140
And they show this nice dashboard where they say,

03:33.140 --> 03:35.140
well, everything is good.

03:35.140 --> 03:38.140
There's no issues, no bugs, it's all fine.

03:38.140 --> 03:42.140
And there's even 76% test coverage.

03:42.140 --> 03:45.140
Who would be happy with that?

03:45.140 --> 03:48.140
Okay, who wants to say why?

03:48.140 --> 03:51.140
Why is 76% good according to you?

03:51.140 --> 03:53.140
Lots of green.

03:53.140 --> 03:55.140
Lots of green.

03:55.140 --> 03:57.140
Larger small socks.

03:57.140 --> 03:59.140
I don't wear small socks.

03:59.140 --> 04:01.140
You get some anyway.

04:01.140 --> 04:03.140
Sorry about that. They're hard to throw in this room.

04:03.140 --> 04:06.140
I would say I would not be happy with that.

04:06.140 --> 04:09.140
Because, I mean, our tests,

04:09.140 --> 04:11.140
apparently when we're running our tests,

04:11.140 --> 04:13.140
we reach 76% of our code.

04:13.140 --> 04:15.140
I don't think that's enough.

04:15.140 --> 04:17.140
Because there is more than 20% of our code

04:17.140 --> 04:19.140
that is not even getting executed for doing the test.

04:19.140 --> 04:21.140
That's a problem.

04:21.140 --> 04:23.140
But even 100% code coverage is actually,

04:23.140 --> 04:25.140
it doesn't say much.

04:25.140 --> 04:28.140
Because coverage only means that code is being executed.

04:28.140 --> 04:31.140
We are only testing, in a worst-case scenario,

04:31.140 --> 04:33.140
that the program does not crash.

04:33.140 --> 04:35.140
What you actually want to know

04:35.140 --> 04:37.140
is if our tests do something,

04:37.140 --> 04:39.140
and I can very easily get 100% code coverage on the program

04:39.140 --> 04:41.140
without writing any assertions,

04:41.140 --> 04:44.140
that I'm just checking that the test execution does not crash.

04:44.140 --> 04:47.140
So we need a way of testing our tests.

04:47.140 --> 04:49.140
And no, we're not going to write unit tests

04:49.140 --> 04:51.140
to test our test logic, because that would be stupid.

04:51.140 --> 04:53.140
I mean, it would never end.

04:53.140 --> 04:55.140
We need to be smart about that.

04:55.140 --> 04:57.140
And that's where mutation testing comes in.

04:57.140 --> 04:59.140
So what we're going to do is to introduce changes

04:59.140 --> 05:01.140
in production code automatically.

05:01.140 --> 05:03.140
That's a tool that's doing that.

05:03.140 --> 05:06.140
We're going to test again to see whether the tests start failing.

05:06.140 --> 05:08.140
Because when the tests start failing,

05:08.140 --> 05:10.140
at that point, you know that your tests

05:10.140 --> 05:12.140
are actually able to catch that bug

05:12.140 --> 05:14.140
that we purposefully introduced.

05:14.140 --> 05:16.140
So it's also from a white box testing,

05:16.140 --> 05:19.140
because we really have to know stuff about the internals of the code

05:19.140 --> 05:24.140
to change it, and see whether the tests are good enough to catch that.

05:24.140 --> 05:29.140
And this is really not a new idea,

05:29.140 --> 05:33.140
because there's this nice paper from 79 already,

05:33.140 --> 05:38.140
where they talk about a new way of a new type of software test.

05:38.140 --> 05:41.140
And you can actually find this on Google,

05:41.140 --> 05:43.140
and you can read it if you want.

05:43.140 --> 05:48.140
But even back then, 40 years ago, 45 years ago,

05:48.140 --> 05:51.140
they were already talking about it.

05:53.140 --> 05:57.140
But only recently, and I talk recently in a very broad sense here,

05:57.140 --> 06:00.140
because I wasn't even in high school, I think,

06:00.140 --> 06:02.140
when I'm talking about reasons.

06:02.140 --> 06:05.140
Then it got more traction, because the problem is,

06:05.140 --> 06:09.140
in the 70s, or the late 70s, it was just a good idea.

06:09.140 --> 06:13.140
We did not have the resources to actually apply it in practice.

06:13.140 --> 06:18.140
And what you see here, the dark-colored bars are publications,

06:18.140 --> 06:20.140
research publications about practical applicability,

06:20.140 --> 06:23.140
and they really spike early this millennium.

06:23.140 --> 06:25.140
And there are reasons for that.

06:25.140 --> 06:30.140
Mostly also, I think, because our computers got fast enough.

06:30.140 --> 06:33.140
And why that is important is because of how mutation testing works,

06:33.140 --> 06:35.140
what the process behind it is.

06:35.140 --> 06:37.140
Because we start with our source code,

06:37.140 --> 06:39.140
and we are feeling very happy about it, of course,

06:39.140 --> 06:42.140
because we made all this nice code, we even wrote tests for it,

06:42.140 --> 06:44.140
so we're very confident.

06:44.140 --> 06:48.140
And what the tool is then doing is going to introduce mutants in your code.

06:48.140 --> 06:50.140
And mutants are just changes.

06:50.140 --> 06:54.140
And for every change that is made, the tests are executed again.

06:55.140 --> 06:57.140
And we can have two results.

06:57.140 --> 07:00.140
Either the tests start failing, which in this case is good,

07:00.140 --> 07:04.140
because we then detected that mutant, we found the bug,

07:04.140 --> 07:07.140
so we say that mutant is killed, or the mutant survived.

07:07.140 --> 07:12.140
And that means that your test is not complete.

07:12.140 --> 07:14.140
And when you do that for everything, in the end,

07:14.140 --> 07:17.140
we get a nice report out of it, like a covers report,

07:17.140 --> 07:19.140
except a bit more detail.

07:19.140 --> 07:23.140
And how that process actually works is that there are operators for that.

07:23.140 --> 07:25.140
And an operator is basically a transformation.

07:25.140 --> 07:27.140
Given a certain thing in your code,

07:27.140 --> 07:32.140
what kind of changes can we do that might fail your tests?

07:32.140 --> 07:34.140
And some examples are here.

07:34.140 --> 07:37.140
There are way more, and also one operator on the left could result into,

07:37.140 --> 07:41.140
or one source code, original source code on the left,

07:41.140 --> 07:43.140
could result into multiple mutants.

07:43.140 --> 07:46.140
But you could do, like, just switch the operators,

07:46.140 --> 07:48.140
or throw away a whole block of code.

07:50.140 --> 07:52.140
And when we do that for every of these mutants,

07:52.140 --> 07:54.140
we measure something, right?

07:54.140 --> 07:56.140
So I already talked about killed and survived.

07:56.140 --> 07:58.140
But that's only in an ideal scenario,

07:58.140 --> 08:02.140
because in practice, there might be code that does not even reach by test.

08:02.140 --> 08:06.140
So you can say, well, we have no coverage, or we have a timeout.

08:06.140 --> 08:10.140
And timeout basically means that there are mutants caused by an infinite loop.

08:10.140 --> 08:14.140
And we should consider that, okay, well, infinite loop tests actually failed then,

08:14.140 --> 08:17.140
so that's maybe kind of killed.

08:17.140 --> 08:21.140
But you can also get runtime errors, or compile errors,

08:21.140 --> 08:24.140
because we're just introducing weird code changes

08:24.140 --> 08:27.140
without looking at what the code is actually supposed to be doing.

08:27.140 --> 08:30.140
And finally, mutants can also be ignored,

08:30.140 --> 08:32.140
because that's what a developer said, I don't want a test for this.

08:32.140 --> 08:35.140
So I don't want to see the report anymore.

08:35.140 --> 08:38.140
So it's just like suppressing warnings for your code code dejects.

08:38.140 --> 08:40.140
Who here does that very often?

08:40.140 --> 08:42.140
I do, actually, but...

08:45.140 --> 08:47.140
And then just like with the code coverage score,

08:47.140 --> 08:49.140
we want to have a nice metric.

08:49.140 --> 08:53.140
We want to know how good we are doing.

08:53.140 --> 08:55.140
And for that, we can compute the score.

08:55.140 --> 08:58.140
And we call that a striker-deorientation score.

08:58.140 --> 09:01.140
And basically what we say here is we want to express in a nice number

09:01.140 --> 09:04.140
on a scale of 0 to 100%.

09:04.140 --> 09:07.140
How many mutants did you actually manage to kill?

09:07.140 --> 09:12.140
So how many unexpected changes in your code are your tests actually catching?

09:12.140 --> 09:15.140
And that's this nice formula, but basically what you do here

09:15.140 --> 09:18.140
is everything above the line is what you consider that you killed.

09:18.140 --> 09:21.140
And everything below the line, so we divide that by everything

09:21.140 --> 09:24.140
that was actually a valid change.

09:24.140 --> 09:27.140
So we exclude the crashes, for example.

09:27.140 --> 09:30.140
And that gives you, for your whole program, for your whole code base,

09:30.140 --> 09:34.140
an indication of how good your tests actually are.

09:34.140 --> 09:37.140
But what if you don't have that many tests yet?

09:37.140 --> 09:40.140
Well, they can also compute a variant of the mutation score.

09:40.140 --> 09:44.140
We just look at the code that's actually being tested.

09:44.140 --> 09:52.140
So you see here that we do not include the mutants without coverage anymore.

09:52.140 --> 09:57.140
So one might think, just like with code coverage,

09:57.140 --> 10:00.140
we should maybe strive for a high number.

10:00.140 --> 10:04.140
We should maybe have 100% mutation coverage, 100% mutation score.

10:04.140 --> 10:06.140
That would be nice.

10:06.140 --> 10:08.140
But there we actually ran into a problem

10:08.140 --> 10:11.140
because we cannot actually kill all the mutants.

10:11.140 --> 10:15.140
It's very easy, well, relatively easy at least,

10:15.140 --> 10:19.140
to reach all your codes, to make sure all your code is getting executed.

10:19.140 --> 10:24.140
So basically to get 100% code coverage, that's relatively simple.

10:24.140 --> 10:27.140
But because you're still calling functions from the outside,

10:27.140 --> 10:31.140
you might not be able to test every single operation

10:31.140 --> 10:33.140
happening inside of these functions.

10:33.140 --> 10:40.140
And actually, some mutants are, if you split up your whole code base completely,

10:40.140 --> 10:43.140
you can never kill them.

10:43.140 --> 10:46.140
And what category of these is equivalent mutants?

10:46.140 --> 10:48.140
Which is also a problem.

10:48.140 --> 10:50.140
So given this code, we have a nice for loop,

10:50.140 --> 10:56.140
and we say, well, we want to iterate 10 times.

10:56.140 --> 11:01.140
You can also write like this, and it will still work.

11:01.140 --> 11:03.140
So this mutant, we cannot kill

11:03.140 --> 11:05.140
because even though we changed our code,

11:05.140 --> 11:10.140
semantically it's doing the same thing.

11:10.140 --> 11:16.140
So that's where you might want to ignore, basically.

11:16.140 --> 11:22.140
And mutation testing is also very challenging.

11:22.140 --> 11:27.140
That's actually where that practical application problem comes in,

11:27.140 --> 11:29.140
because you can imagine that mutation testing,

11:29.140 --> 11:32.140
basically changing your code and then running all the tests again,

11:32.140 --> 11:35.140
doesn't take a lot of time.

11:35.140 --> 11:37.140
And if you have a very large code base,

11:37.140 --> 11:41.140
that might actually not finish in a reasonable time.

11:41.140 --> 11:43.140
You also need a lot of configuration.

11:43.140 --> 11:45.140
The mutation testing tool needs to know stuff.

11:45.140 --> 11:47.140
It needs to know how it can run tests.

11:47.140 --> 11:51.140
It needs to know how it can verify that those tests did complete successfully or not.

11:51.140 --> 11:55.140
It also needs to know stuff about your programming language, for example,

11:55.140 --> 12:00.140
in order to make sure that it rewrites the code in a correct way.

12:00.140 --> 12:03.140
So that also needs to be a lot of tuning support to make it work.

12:03.140 --> 12:10.140
And for a long time, mutation testing was simply not feasible or not easy to do.

12:10.140 --> 12:12.140
But we're bracing the gap.

12:12.140 --> 12:14.140
Not specifically at Striker.

12:14.140 --> 12:16.140
A lot of stuff has already been done.

12:16.140 --> 12:18.140
Luckily for us.

12:18.140 --> 12:22.140
But when we're looking at performance, this is basically the worst-case scenario.

12:22.140 --> 12:28.140
So the time it takes to run a single mutant, to analyze a single mutant,

12:28.140 --> 12:31.140
is basically the time it takes to run on your test cases.

12:31.140 --> 12:33.140
So we can approximate it by saying,

12:33.140 --> 12:37.140
well, let's just count the number of tests that you have.

12:37.140 --> 12:43.140
And then the time it takes to mutate your whole program is just the sum of that.

12:43.140 --> 12:47.140
So it basically means that you multiply the number of test cases that you have in your code

12:47.140 --> 12:49.140
times the number of mutants that you need to check,

12:49.140 --> 12:51.140
because mutants need to be checked in isolation,

12:51.140 --> 12:54.140
because they can influence each other.

12:54.140 --> 12:57.140
So you can imagine already with a very small program,

12:57.140 --> 13:03.140
this number, the time approximation, can get really, really, really large.

13:03.140 --> 13:05.140
So we need to be smarter about that.

13:05.140 --> 13:08.140
We want to make sure that the total time is a lot less,

13:08.140 --> 13:11.140
not just a bit less, a lot less than just a multiplication.

13:11.140 --> 13:15.140
And basically there are three approaches to get there.

13:15.140 --> 13:17.140
It's either to do it faster.

13:17.140 --> 13:20.140
And doing it faster, for example, I think we're going to paralyze it.

13:20.140 --> 13:22.140
We're going to use love course.

13:22.140 --> 13:26.140
Like take a big machine, nowadays it's relatively simple to get a machine with 128 cores,

13:26.140 --> 13:30.140
so we can do 128 things at the same time.

13:30.140 --> 13:32.140
You can try to do fewer.

13:32.140 --> 13:34.140
So you can maybe try to make smart choices and say,

13:34.140 --> 13:37.140
well, certain stuff we maybe don't need to analyze,

13:37.140 --> 13:41.140
because we kind of know that it's probably fine.

13:41.140 --> 13:44.140
Or you can try to do it smarter.

13:44.140 --> 13:47.140
And the study I referenced here, they really did an analysis in there,

13:47.140 --> 13:49.140
it's like a litigator review.

13:49.140 --> 13:54.140
And most of the studies are actually focusing on fewer or smarter.

13:54.140 --> 13:57.140
And common techniques there, some of us here,

13:57.140 --> 14:00.140
I won't have time to go into detail on all of these.

14:00.140 --> 14:02.140
But you can think of like random mutation,

14:02.140 --> 14:04.140
like we're just randomly checking stuff sometimes.

14:04.140 --> 14:06.140
We're just randomly picking some mutation that we're going to do.

14:06.140 --> 14:08.140
But that's not deterministic.

14:08.140 --> 14:15.140
So that might not give you the best knowledge about what the quality of the test actually is.

14:15.140 --> 14:17.140
Parallel execution already mentioned.

14:17.140 --> 14:20.140
You can also do stuff like data flow and control flow analysis

14:20.140 --> 14:23.140
and try to reduce the set that way.

14:23.140 --> 14:32.140
Or maybe look at AI to try to pick smarter sets of stuff that you're actually going to check.

14:32.140 --> 14:36.140
But if you want to use that mutation score as a benchmark, as a comparison,

14:36.140 --> 14:40.140
for example, with the pull request, did you actually improve it or not?

14:40.140 --> 14:44.140
Or to give you a good indication of how good your tests currently actually are,

14:44.140 --> 14:46.140
you actually need to execute everything.

14:46.140 --> 14:52.140
So just the approach of we're just going to run less, that doesn't always work.

14:53.140 --> 15:00.140
And one big way how this process can be sped up is by looking at how we actually change the code.

15:00.140 --> 15:06.140
So a very new eave approach would, for example, be just changing the source code,

15:06.140 --> 15:09.140
running the compiler again, running the test again,

15:09.140 --> 15:11.140
and then making another change in the source code,

15:11.140 --> 15:14.140
and then running the compiler again, running the test again.

15:14.140 --> 15:18.140
And if you have a compiled language with a fairly slow compiler,

15:18.140 --> 15:23.140
that's quite problematic because then it gets really, really slow.

15:23.140 --> 15:26.140
A bit better might be bytecode mutation.

15:26.140 --> 15:31.140
So, for example, the JVM languages have bytecodes, they have an intermediate step,

15:31.140 --> 15:33.140
maybe you can mutate that.

15:33.140 --> 15:36.140
And they only have to compile the source code once,

15:36.140 --> 15:39.140
they just change the bytecode and then run it.

15:39.140 --> 15:44.140
And while that is a lot faster, it's also a lot more complicated,

15:44.140 --> 15:48.140
but it has one big downside, and that is that every change that is possible in the bytecode

15:48.140 --> 15:51.140
is not necessarily something you can do in your source code,

15:51.140 --> 15:54.140
especially for Java, for example.

15:54.140 --> 16:00.140
If you write Kotlin or Scala, there's a lot of, a very simple thing in Scala, for example,

16:00.140 --> 16:02.140
can result in a lot of bytecodes,

16:02.140 --> 16:06.140
and if you're trying to mutate that with the assumption that the Java compiler compiled it,

16:06.140 --> 16:08.140
it might come up with mutants that you did not kill,

16:08.140 --> 16:12.140
but you cannot actually kill them because they don't exist in your source code.

16:14.140 --> 16:19.140
So, who thinks, who has an idea, how we can, how we can do this smarter?

16:19.140 --> 16:23.140
Any ideas? Yes.

16:23.140 --> 16:25.140
Are you a step?

16:25.140 --> 16:27.140
Sorry, what did you say?

16:27.140 --> 16:34.140
You compile all the different mutants, the same as people, and you select which mutants you get from the other side.

16:34.140 --> 16:37.140
Exactly. Large or small socks?

16:37.140 --> 16:40.140
Large or small socks? You have socks with a logo on it.

16:40.140 --> 16:42.140
Large.

16:43.140 --> 16:45.140
This is the, the larger the other ones, right?

16:45.140 --> 16:48.140
Sorry about that. Thank you, Niko.

16:48.140 --> 16:50.140
For testing good device.

16:50.140 --> 16:53.140
I didn't test my own system, no.

16:53.140 --> 16:55.140
Silver written software to do this.

16:55.140 --> 16:58.140
But, yeah, basically, so the answer that was given was basically this,

16:58.140 --> 17:03.140
and we call that mutant schematic, and this just makes sure that you compile all the mutants into your code once,

17:03.140 --> 17:07.140
and then use an environment variable to just switch them on or not.

17:07.140 --> 17:11.140
So, if you do this, your compiled code is just full of if statements,

17:11.140 --> 17:13.140
that is, check a certain number.

17:13.140 --> 17:20.140
And that is complicated, but it is manageable, it's not that hard.

17:20.140 --> 17:27.140
The main problem is in keeping track of it, but if you assign every mutant a unique number, it should be fine.

17:27.140 --> 17:33.140
And this really helps with compiled languages, especially with stuff that's a bit slower, like Scala.

17:34.140 --> 17:36.140
And this is actually relatively new.

17:36.140 --> 17:39.140
In the world of mutation testing, this is relatively new.

17:39.140 --> 17:43.140
It is from 1993, though, so it's the same age as me.

17:43.140 --> 17:46.140
I wouldn't say that I am relatively new.

17:46.140 --> 17:51.140
But, as something else, Martin, that you can do is coverage analysis.

17:51.140 --> 17:55.140
That's also something that has been part of Striker for a long time already.

17:55.140 --> 18:00.140
So we actually do an initial run where we just check which tests are reaching what code.

18:00.140 --> 18:06.140
So we also know if you change one part of the code, which tests actually need to run and which don't.

18:06.140 --> 18:11.140
So you can also get that number of test cases down a lot, depending on where you mutate the code.

18:11.140 --> 18:16.140
Some codes you don't really know, so if you have something static, for example,

18:16.140 --> 18:21.140
it's not extreme defined somewhere, that, you know, you might not be able to figure out how that is used.

18:21.140 --> 18:25.140
You might still need to have to run the whole test suite, but you try not to.

18:26.140 --> 18:30.140
Something else you can do is incremental analysis.

18:30.140 --> 18:37.140
So just try to div some previously stored state and try to guess which mutants you actually need to check.

18:37.140 --> 18:45.140
This is very hard to do, fully foolproof, fully complete, but you can get there like 99%.

18:45.140 --> 18:49.140
And that means that if you make a small change, a small pull request,

18:49.140 --> 18:54.140
that checking whether your changes are tested properly is relatively simple, is relatively fast.

18:54.140 --> 18:59.140
So if, uh, Nico here in front, he gave it all yesterday in the JavaScript dev room,

18:59.140 --> 19:04.140
and he actually showed this feature, and I think that there was a difference between a couple of seconds

19:04.140 --> 19:10.140
and like 30 seconds and three seconds, something like that, on a small project.

19:14.140 --> 19:22.140
Another cool thing is mutation levels, and that's where you actually give the user a choice.

19:22.140 --> 19:26.140
Do you care about testing it fully, or do you care about performance?

19:26.140 --> 19:30.140
And the choice that the user wants to make can depend on the type of project or the domain.

19:30.140 --> 19:34.140
Do you have code where it's really important that every single thing is tested,

19:34.140 --> 19:39.140
or isn't it that important actually? Do you actually want to spend the time?

19:39.140 --> 19:44.140
Or maybe you want to do a quick and dirty but pretty good analysis for every pull request,

19:44.140 --> 19:47.140
which you do in the nightly build where you test it fully.

19:47.140 --> 19:51.140
There's different approaches here, and this is actually something that is researched

19:51.140 --> 19:55.140
by one of my colleagues at InfoSport, he did his master's thesis on it.

19:55.140 --> 19:58.140
So it's really cool.

19:58.140 --> 20:02.140
But what could be downside of this approach? Any ideas?

20:02.140 --> 20:05.140
Remember, you can get some socks.

20:09.140 --> 20:10.140
Yes?

20:10.140 --> 20:36.140
So the answer was the feedback loop is longer, basically.

20:36.140 --> 20:40.140
It might take time to find if your tests are not that great.

20:40.140 --> 20:44.140
That's the one. I have another slide, but yeah, another guest.

20:44.140 --> 20:45.140
Sorry?

20:45.140 --> 20:49.140
The problem is very useful because you run nightly and...

20:49.140 --> 20:50.140
Yeah.

20:51.140 --> 20:53.140
What kind of size socks do you have?

20:53.140 --> 20:54.140
Large.

20:54.140 --> 20:55.140
Sorry?

20:55.140 --> 20:56.140
Large.

20:56.140 --> 20:57.140
Large.

20:57.140 --> 20:59.140
It thinks too far, just come get them later.

20:59.140 --> 21:00.140
I will put them aside for you.

21:00.140 --> 21:01.140
What's your size?

21:01.140 --> 21:02.140
Small.

21:02.140 --> 21:03.140
Small.

21:06.140 --> 21:07.140
Ah, damn it.

21:07.140 --> 21:09.140
I'm not good at throwing.

21:09.140 --> 21:14.140
But yeah, so the mutation score that you compute, if you choose to run other mutants,

21:14.140 --> 21:16.140
the mutation score might not be comparable.

21:16.140 --> 21:18.140
So you really need to take care of that.

21:18.140 --> 21:21.140
And the tool that my colleague actually created,

21:21.140 --> 21:26.140
analyzes a code base so that you can do this actually for a specific project.

21:26.140 --> 21:32.140
It analyzes a code base and it analyzes the test and it's trying to find a nice balance

21:32.140 --> 21:37.140
between accuracy and the number of test executions that you need to do.

21:37.140 --> 21:41.140
So it tries to see if there are some mutants that we can exclude

21:41.140 --> 21:43.140
that will gain a lot of performance.

21:43.140 --> 21:46.140
So it speeds it up massively, but doesn't reduce a lot in accuracy.

21:46.140 --> 21:48.140
So that's really nice.

21:49.140 --> 21:53.140
And you can actually find his thesis online.

21:53.140 --> 21:59.140
So if you go to the FOSDAM page for this talk, you can have a link there as well.

21:59.140 --> 22:03.140
And I'm very hard to press actually, so there is not even documentation for that

22:03.140 --> 22:05.140
and it's not even merged.

22:05.140 --> 22:08.140
It's project Xavier and that is actually implementing that idea

22:08.140 --> 22:13.140
because it was very theoretical, actually implementing that idea in Striker for JavaScript.

22:13.140 --> 22:17.140
So if you're really interested in how that all works and what decisions they made,

22:17.140 --> 22:19.140
I honestly don't know yet myself.

22:19.140 --> 22:21.140
Go look at the request.

22:22.140 --> 22:24.140
And it's also a very cool example.

22:29.140 --> 22:32.140
Mike is dead. Oh, it's back again.

22:32.140 --> 22:37.140
We're a project group from a university, in this case the University of Twente,

22:37.140 --> 22:42.140
contributed to Striker in that way and they actually built this.

22:45.140 --> 22:48.140
Yeah, documentation as I said, still to follow.

22:49.140 --> 22:53.140
And this is also a very new thing that also a student is currently working on

22:53.140 --> 22:58.140
is to do more analysis on static analysis on the code

22:58.140 --> 23:04.140
to figure out if we can run in one run of test cases, if we can analyze multiple mutants.

23:04.140 --> 23:10.140
But in order to do that, we actually need to make sure that these mutants do not influence each other.

23:10.140 --> 23:14.140
So this only works if you know for sure that they don't cancel these order out

23:14.140 --> 23:19.140
or if you can still, given that the test fields can say with confidence which mutant it was.

23:19.140 --> 23:22.140
So this is really, really complicated.

23:22.140 --> 23:27.140
Again, I'm not entirely sure on this progress yet, but question.

23:28.140 --> 23:34.140
So this is sort of static data for more complicated.

23:35.140 --> 23:39.140
Yeah, so the question is whether modularizing your application would help.

23:39.140 --> 23:47.140
And it would help because if your modules are smaller, then the test runs are also smaller.

23:47.140 --> 23:49.140
They would take less time.

23:49.140 --> 23:54.140
But it only works if a normal boot rest for you, normal change that you want to do,

23:54.140 --> 23:56.140
if that's only contained to one module or two modules.

23:56.140 --> 24:00.140
But if you split your code up instead of changing all modules, then it doesn't help.

24:00.140 --> 24:01.140
So it might help.

24:01.140 --> 24:05.140
But that's also with, like, in general, I want to make my CI pipeline quicker,

24:05.140 --> 24:09.140
just make more repos or build less modules.

24:09.140 --> 24:11.140
So yeah, that would definitely work.

24:11.140 --> 24:14.140
Come grab a pair of socks later.

24:17.140 --> 24:21.140
And now it really is time to also start testing your tests.

24:21.140 --> 24:28.140
So if you're not using mutation testing in your products already, it's really good now.

24:28.140 --> 24:30.140
We can actually use it.

24:30.140 --> 24:33.140
There's been a lot of progress in 45 years.

24:33.140 --> 24:35.140
We have better hardware.

24:35.140 --> 24:36.140
We have process improvements.

24:36.140 --> 24:43.140
And actually, there's a lot of research going on still to make it actually faster every time.

24:43.140 --> 24:45.140
We also have production ready tooling.

24:45.140 --> 24:47.140
There are many great libraries out there.

24:47.140 --> 24:49.140
Some of them are more mature than others.

24:49.140 --> 24:51.140
Some of them are faster than others.

24:51.140 --> 24:57.140
Not everybody integrates the same process improvements, for example.

24:57.140 --> 25:01.140
But in general, for most popular programming languages, there is a tool available

25:01.140 --> 25:04.140
and you can run it in your pipeline.

25:04.140 --> 25:08.140
And most of these tools just integrate with the build tool that you expect.

25:08.140 --> 25:11.140
They use information that the test runner already gives you.

25:11.140 --> 25:13.140
So that's great.

25:13.140 --> 25:17.140
Here's an overview of some suggestions.

25:17.140 --> 25:21.140
But if you just Google your favorite programming languages plus mutation testing,

25:21.140 --> 25:24.140
I'm sure you'll probably the first result will be the right one.

25:24.140 --> 25:27.140
So in summary, when we're talking about mutation testing,

25:27.140 --> 25:30.140
we're really talking about testing your tests,

25:30.140 --> 25:34.140
making sure that your tests actually expect what you do.

25:34.140 --> 25:37.140
And something, if there's anything,

25:37.140 --> 25:39.140
only one thing that you take away from this talk,

25:39.140 --> 25:41.140
don't rely on code coverage, please,

25:41.140 --> 25:44.140
because it doesn't say anything.

25:47.140 --> 25:50.140
And a lot of research has been gone into performance improvements.

25:50.140 --> 25:53.140
There's lots of research still being done.

25:53.140 --> 25:57.140
There's still always students coming to us interested in contributing

25:57.140 --> 26:01.140
to an open source project with research.

26:01.140 --> 26:04.140
So there's plenty of open research questions.

26:04.140 --> 26:06.140
And it's also applicable now.

26:06.140 --> 26:09.140
So if you're maintaining an open source project,

26:09.140 --> 26:11.140
at least consider mutation testing,

26:11.140 --> 26:14.140
because especially in open source, where there's many contributors,

26:14.140 --> 26:18.140
there's a really good metric on to get an idea about the quality of the tests

26:18.140 --> 26:21.140
that somebody wrote for our poll request.

26:21.140 --> 26:25.140
If you want to know more of the code implementation details,

26:25.140 --> 26:28.140
as I said, my colleague gave a talk yesterday in the JavaScript Dev Room,

26:28.140 --> 26:33.140
it's probably online at some point, so you can go check that out.

26:33.140 --> 26:35.140
And that was my talk, so thank you for listening.

26:35.140 --> 26:38.140
APPLAUSE

26:42.140 --> 26:45.140
Exactly 25 minutes as well, so that went great.

26:45.140 --> 26:47.140
Any questions? Yes?

26:47.140 --> 26:51.140
I could determine which expressions do mutate.

26:51.140 --> 26:52.140
Sorry?

26:52.140 --> 26:55.140
I can determine which expressions do mutate.

26:55.140 --> 26:58.140
OK, the question is how do we determine which expressions do mutate?

26:58.140 --> 27:00.140
Basically, there's a lookup.

27:00.140 --> 27:02.140
So it does abstract syntax free analysis,

27:02.140 --> 27:04.140
and it just checks a certain node,

27:04.140 --> 27:08.140
and there's a lookup table to say, OK, if we have this kind of operation,

27:08.140 --> 27:10.140
these are the options that we can...

27:10.140 --> 27:12.140
These are the mutations that we do.

27:12.140 --> 27:14.140
So there's basically a big mapping file with all the options,

27:14.140 --> 27:18.140
and that is probably not complete for every standard library out there,

27:18.140 --> 27:21.140
but for a lot of the logic, comparisons and stuff like that,

27:21.140 --> 27:23.140
you can do it pretty complete.

27:23.140 --> 27:25.140
Yes?

27:35.140 --> 27:38.140
I couldn't hear the last part. Can you repeat that, please?

27:38.140 --> 27:40.140
What is the way to find the way to test your...

27:40.140 --> 27:44.140
OK, so the question is what is the baseline

27:44.140 --> 27:46.140
when you start with mutation testing?

27:46.140 --> 27:48.140
Right, so if you have a new code base,

27:48.140 --> 27:51.140
if you have green fields and you implement mutation testing from the start,

27:51.140 --> 27:55.140
it's actually relatively easy to get high 90% mutation score.

27:55.140 --> 27:58.140
When you have an assisting project, it's usually very hard.

27:58.140 --> 28:02.140
So actually Striker for JavaScript has a mutation score of around 80%,

28:02.140 --> 28:04.140
which is actually pretty good.

28:04.140 --> 28:06.140
It's really hard to get very high scores.

28:06.140 --> 28:08.140
So it's not very... Not like covered.

28:08.140 --> 28:12.140
If you're anywhere close to 80%, you're actually doing pretty well, I think.

28:13.140 --> 28:15.140
Yes?

28:19.140 --> 28:21.140
Yeah?

28:33.140 --> 28:37.140
Yeah, so the question is when the purpose of mutation testing

28:37.140 --> 28:40.140
is to make sure your test are good, if you're doing selective mutation,

28:40.140 --> 28:42.140
how do you know you're not missing something?

28:42.140 --> 28:44.140
Actually, you don't. You might miss stuff.

28:44.140 --> 28:49.140
That's the point is because it can take a really long time

28:49.140 --> 28:51.140
that you have at least the option like,

28:51.140 --> 28:55.140
OK, I'm OK with 80% accuracy if it's half the time,

28:55.140 --> 28:58.140
because that's for me a good balance for some use cases.

28:58.140 --> 29:00.140
But yeah, you have to accept that you're missing stuff

29:00.140 --> 29:02.140
because you're just not running all the mutants.

29:15.140 --> 29:19.140
So the combination of mutation testing and test-driven developments.

29:19.140 --> 29:21.140
Well, you have to write your test first then,

29:21.140 --> 29:23.140
but you can only mutate once the implementation is there.

29:23.140 --> 29:27.140
So once you test that green, you can check whether you actually did a good job

29:27.140 --> 29:30.140
before writing your implementation, which is kind of strange, actually.

29:44.140 --> 29:46.140
Yeah, but that's very nice, actually.

29:46.140 --> 29:48.140
If you have to change your testing of changing requirements

29:48.140 --> 29:50.140
and you re-implement part of your code,

29:50.140 --> 29:53.140
then mutation testing will check whether your test are still complete.

29:53.140 --> 29:55.140
So that's actually very good, very nice.

29:55.140 --> 29:58.140
Yeah, actually, if you really want to go into that,

29:58.140 --> 30:01.140
property-based testing, you're only going to test all possible inputs,

30:01.140 --> 30:05.140
even though for sure that is correct, but that's not feasible yet.

30:05.140 --> 30:07.140
Property-based testing is really hard, too.

30:08.140 --> 30:10.140
Do you have time for more questions?

30:12.140 --> 30:13.140
Four minutes.

30:13.140 --> 30:15.140
All the time in the world, up front.

30:15.140 --> 30:18.140
The question is, from your experience currently,

30:18.140 --> 30:21.140
if, for example, you have normal unit tests

30:21.140 --> 30:24.140
and they run, let's say, it's called one minute,

30:24.140 --> 30:28.140
how many minutes will they be around using the framework?

30:29.140 --> 30:34.140
So the question is, if I know how long my unit tests run for,

30:34.140 --> 30:37.140
how do I know how long mutation testing will take?

30:37.140 --> 30:39.140
And there's only one answer.

30:39.140 --> 30:43.140
It really depends, because it really depends why your tests take a minute,

30:43.140 --> 30:46.140
but it's going to be a lot longer.

30:46.140 --> 30:50.140
It's like, it's not going to be four minutes or five minutes.

30:50.140 --> 30:52.140
It's way more than that.

30:52.140 --> 30:55.140
The only way to find it out is to just actually run it,

30:55.140 --> 30:58.140
because the problem is it really depends on how many mutations

30:58.140 --> 31:00.140
can be generated for your specific code,

31:00.140 --> 31:02.140
because that is what makes it slow.

31:02.140 --> 31:05.140
And because of all these optimizations,

31:05.140 --> 31:08.140
you cannot really predict how long it will take.

31:11.140 --> 31:13.140
I didn't hear that one.

31:13.140 --> 31:17.140
So the question is, how do we report it?

31:17.140 --> 31:20.140
And for Striker, and you can go to the talk with my colleague,

31:20.140 --> 31:23.140
he went into that in a bit more detail.

31:23.140 --> 31:26.140
We have a standardized adjustment for that.

31:37.140 --> 31:39.140
That's good. Oh, it's a bit.

31:39.140 --> 31:41.140
So there's a nice dashboard, but go watch this talk

31:41.140 --> 31:43.140
and you will know more.

31:45.140 --> 31:47.140
Up front, yes.

31:47.140 --> 31:49.140
So you already run one mutation at a time?

31:49.140 --> 31:51.140
Yeah, you have to.

31:51.140 --> 31:55.140
If you want to do more, you have to prove first

31:55.140 --> 31:57.140
that these will not influence each other,

31:57.140 --> 31:59.140
so that you need to know that if one test fails,

31:59.140 --> 32:01.140
because of which mutant it is.

32:01.140 --> 32:04.140
With coverage, you can have reached that?

32:04.140 --> 32:08.140
No, you really have to do data flow, control flow analysis,

32:08.140 --> 32:10.140
and stuff like that.

32:10.140 --> 32:12.140
So that's very, very difficult.

32:12.140 --> 32:14.140
But yeah, there's somebody working on it right now.

32:14.140 --> 32:16.140
So maybe in half a year's time,

32:16.140 --> 32:18.140
we'll have some more to talk about.

32:18.140 --> 32:21.140
Yeah, Sci-GridNet already has an implementation for it,

32:21.140 --> 32:23.140
but it's not scientifically proven,

32:23.140 --> 32:25.140
so we do not know 100% where that's correct,

32:25.140 --> 32:27.140
but at least 95% there.

32:27.140 --> 32:32.140
So if that was the last question,

32:32.140 --> 32:34.140
if there's any more question if you want to talk some stuff,

32:34.140 --> 32:36.140
I'll be outside in the hall.

32:36.140 --> 32:38.140
And if you ask a question, feel free to come

32:38.140 --> 32:40.140
grab your socks here up front.

32:40.140 --> 32:42.140
There's plenty. Thank you.

32:42.140 --> 32:44.140
APPLAUSE

