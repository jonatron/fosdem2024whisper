WEBVTT

00:00.000 --> 00:02.060
you

00:30.000 --> 00:50.000
.

00:50.000 --> 00:51.000
.

00:51.000 --> 00:52.000
.

00:52.000 --> 00:53.000
.

00:53.000 --> 00:54.000
.

00:54.000 --> 00:55.000
.

00:55.000 --> 00:56.000
.

00:56.000 --> 00:57.000
.

00:57.000 --> 00:58.000
.

00:58.000 --> 00:59.000
.

00:59.000 --> 01:00.000
.

01:29.000 --> 01:31.000
.

01:59.000 --> 02:18.000
.

02:18.000 --> 02:19.000
.

02:19.000 --> 02:20.000
.

02:20.000 --> 02:21.000
.

02:21.000 --> 02:22.000
.

02:22.000 --> 02:23.000
.

02:23.000 --> 02:24.000
.

02:24.000 --> 02:25.000
.

02:25.000 --> 02:26.000
.

02:26.000 --> 02:27.000
.

02:27.000 --> 02:28.000
.

02:28.000 --> 02:29.000
.

02:58.000 --> 03:05.000
.

03:05.000 --> 03:06.000
.

03:06.000 --> 03:07.000
.

03:07.000 --> 03:08.000
.

03:08.000 --> 03:09.000
.

03:09.000 --> 03:10.000
.

03:10.000 --> 03:11.000
.

03:11.000 --> 03:12.000
.

03:12.000 --> 03:13.000
.

03:13.000 --> 03:14.000
.

03:14.000 --> 03:15.000
.

03:15.000 --> 03:16.000
.

03:16.000 --> 03:17.000
.

03:17.000 --> 03:18.000
.

03:18.000 --> 03:19.000
.

03:19.000 --> 03:20.000
.

03:20.000 --> 03:21.000
.

03:21.000 --> 03:22.000
.

03:22.000 --> 03:23.000
.

03:23.000 --> 03:24.000
.

03:24.000 --> 03:25.000
.

03:25.000 --> 03:26.000
.

03:26.000 --> 03:27.000
.

03:27.000 --> 03:28.000
.

03:28.000 --> 03:29.000
.

03:29.000 --> 03:30.000
.

03:30.000 --> 03:31.000
.

03:31.000 --> 03:32.000
.

03:32.000 --> 03:33.000
.

03:33.000 --> 03:34.000
.

03:34.000 --> 03:35.000
.

03:35.000 --> 03:36.000
.

03:36.000 --> 03:37.000
.

03:37.000 --> 03:38.000
.

03:38.000 --> 03:39.000
.

03:39.000 --> 03:40.000
.

03:40.000 --> 03:41.000
.

03:41.000 --> 03:43.000
.

03:43.000 --> 03:44.000
.

03:44.000 --> 03:46.000
.

03:46.000 --> 03:47.000
.

03:47.000 --> 03:48.000
.

03:48.000 --> 03:49.000
.

03:49.000 --> 03:50.000
.

03:50.000 --> 03:50.100
.

03:50.100 --> 03:51.000
.

03:51.000 --> 03:52.000
.

03:52.000 --> 03:53.000
.

03:53.000 --> 03:54.000
.

03:54.000 --> 03:55.000
.

03:55.000 --> 03:56.000
.

03:56.000 --> 04:04.000
trusted firmware and then that in hand starts up your opti and finally it goes to the main

04:04.000 --> 04:08.760
new boot image which finally loads your Linux kernel. This is a very typical boot flow.

04:08.760 --> 04:15.320
This is what you see commonly but it's talking about one core right. When you think about

04:15.320 --> 04:20.080
it you're talking about one core but that's not the case with chips today. So what if you

04:20.080 --> 04:28.160
have multi core systems. So an example would be the Texas Instruments K3 architecture of

04:28.160 --> 04:37.760
devices and here you we have two cores running. So you have your 32 bit R5 core and your 64

04:37.760 --> 04:46.120
bit A72 core. Now in this case we need two sets of SPLs right to get it going. So your

04:46.120 --> 04:53.720
as you can see I've inserted two SPLs in the boot flow and your R5 SPL will run first. Do the

04:53.720 --> 05:00.360
initial stuff and then it'll jump to ATF again to opti and then your Uboot SPL for your A72 core

05:00.360 --> 05:07.240
comes up and then finally you boot to Linux. So this is how it looks like. Now in this presentation

05:07.240 --> 05:14.320
in the interest of time I'll be talking about the A72 bootloader mainly not the R5. So yeah

05:14.440 --> 05:19.480
that's what I'll be talking about. So what do we need for the A72 bootloader? You'll need your

05:19.480 --> 05:26.920
ATF, you'll need your opti binary and you'll need DM firmware. DM is device management

05:26.920 --> 05:34.000
firmware. It's kind of like a TI version of ARM-SEP and then you'll have your SPL binary

05:34.000 --> 05:42.560
and then you'll find your device tree blob right. So let's say I want to make this position

05:42.600 --> 05:49.560
agnostic my final bootloader. So I can just append or prepend the fit header at the top so that the

05:49.560 --> 05:56.880
entire image is basically position agnostic. So that's what I've done over here and what about

05:56.880 --> 06:04.800
security? You obviously need security. So you have your X509 certificate appended to the top of

06:04.800 --> 06:10.160
each of your binary blobs. So basically it's signed all of the blobs inside are signed and this is

06:10.160 --> 06:20.600
what our final A72 bootloader binary looks like. So as you can see it's not very simple. I mean you

06:20.600 --> 06:27.240
can run it through a simple shell script and get your final output but it wouldn't be, it's not

06:27.240 --> 06:35.400
really the standard right. This is how we used to go about generating our final binary. So you can

06:35.440 --> 06:41.760
see I have U-boot. You basically give all the inputs. You give your opti or device manager firmware,

06:41.760 --> 06:49.600
your ATF and U-boot has custom scripts, a bunch of long shell scripts that used to you know tie up

06:49.600 --> 06:55.160
everything, sign everything, stitch it up into a final image. So this is what we used to go through.

06:55.160 --> 07:02.920
But in cases of higher security devices you'll need to have a core Secdev K3 which is an external

07:03.440 --> 07:13.440
TI maintained repository. And this is how we used to sign the images a few months back. Obviously

07:13.440 --> 07:18.400
there's a lot of issues with doing this. One is maintaining and scaling. It's a non-standard

07:18.400 --> 07:27.440
flow. It's for example let's say we already have more than four bootflows at present and extending

07:27.440 --> 07:31.960
it to all the bootflows you know where the binary will have to change. It gets difficult. Packaging

07:32.000 --> 07:38.520
gets difficult. And this is not the standard. It's not distro friendly. And there's no unit level

07:38.520 --> 07:44.000
testing. They're just shell scripts. You don't really, if it works it works. There's no test

07:44.000 --> 07:50.720
coverage there right. So these are the issues with the custom scripts. And this is a small snippet

07:50.720 --> 07:58.400
of the shell script that we used to use. So you can see unless I showed you the final image what

07:58.440 --> 08:06.320
it used to look like. I don't think you can gather much from this script. And you can see the

08:06.320 --> 08:11.320
highlighted ones are pointing to external scripts. So you have scripts within scripts and it's just

08:11.320 --> 08:28.080
a mess to get to know what your final image looks like. So yeah. Thank you. So just a little talk

08:28.200 --> 08:36.640
about Binman why I started writing this tool a while ago now. Packaging is actually much harder

08:36.640 --> 08:42.160
than we think. And you can see an example of that there. Some other things that go on. There are

08:42.160 --> 08:50.120
SOC specific tools that need to run. And as mentioned before there's different phases of the

08:50.120 --> 08:56.440
boot. And the image needs to contain code for all of those. It's also nice to be able to see what's

08:56.480 --> 09:02.240
actually in the image. And so this this bin man tool lets you look at an image and list it out.

09:06.240 --> 09:11.960
So the image is described as data. So rather than shell scripts or code or whatever you describe

09:11.960 --> 09:19.400
the structure of the image in a simple data format. This image has U boot and it has SPL. It has a

09:19.400 --> 09:28.680
size of one megabyte and it has some pad bytes. So that's basically how you start. Binman normally

09:28.680 --> 09:34.360
runs as part of the U boot build. So it's the final step after all the inputs have been created.

09:35.000 --> 09:44.680
You run it runs build man sorry bin man and produces a final image. But the nice thing is you can

09:44.680 --> 09:50.600
then use all those inputs and run it again separately maybe in a signing server or in some other step

09:51.160 --> 09:59.160
in production. So bin man also deals with missing blobs. It deals with tools that need to run and so

09:59.160 --> 10:04.760
on. And it can produce an image even you know even telling you that this image won't work but at least

10:04.760 --> 10:11.880
you're able to validate that you could get that far. Bin man consists of it works with a list of

10:11.960 --> 10:17.640
entries. Entries have a different type that you've seen the U boot ones and the SPL ones but there's

10:17.640 --> 10:23.960
loads of other ones as well. And they just packed one after the other. They normally can't overlap

10:23.960 --> 10:32.760
but it is possible in extreme cases if you want to do that. Bin man is written in Python. There's

10:32.760 --> 10:40.360
an entry based class. You then have an entry blob subclass of that if you like. You can see that

10:40.360 --> 10:45.560
in the middle of the screen and you can sort of extend it from there. So a blob is just basically

10:45.560 --> 10:51.560
an entry that has a blob of data in it. But you can make arbitrarily complex things that involve

10:51.560 --> 10:56.840
you know producing signatures and that sort of thing and it's fairly easy to do that. To add

10:56.840 --> 11:01.880
an entry type you basically put a new Python file in the right directory and give it a give it a

11:01.880 --> 11:08.680
class name and off you go. You can I mentioned you can run command line tools. It's actually possible

11:08.760 --> 11:16.360
to list out the tools that are available. If you don't have one you can do bin man tool minus F to

11:16.360 --> 11:22.280
fetch it and it will go and build it from source or find it in the binary or whatever it has to do

11:22.280 --> 11:27.400
to get the tools. So you don't have to go and hunt around for three days trying to find vendor

11:27.400 --> 11:35.400
tools. The code has a lot of comments. It has 100 test coverage. So it's very very strongly

11:35.480 --> 11:39.640
designed to to be reliable. That's it from me.

11:44.520 --> 11:54.520
Yeah so now you've seen how what bin man is and the rest of the presentation is going to show you

11:54.520 --> 12:01.800
how we switched rather migrated from what it used to be with shell scripts to using bin man.

12:01.800 --> 12:06.360
So this is what the final flow looked like. There's no external repository. There's no

12:06.360 --> 12:12.760
custom scripts. It's just a bin man device tree file that we've plumbed in along with the other

12:12.760 --> 12:19.960
inputs. So this is what it finally looked like. So as you can see just like the image on the right

12:19.960 --> 12:27.160
which is our target image. So you have a fit node within which each of the individual binary blobs

12:27.160 --> 12:32.840
that have to go in. So your a t f your opti or dm all of them are kind of packed in nicely.

12:32.840 --> 12:41.000
And you can see that ti secure is an entry type that we've created to mimic not mimic actually

12:41.000 --> 12:48.440
generate the x509 certificate that has to go on top. So it's being passed the contents. So the

12:48.440 --> 12:53.800
binary that it has to sign which is in this case the a t f binary and the key with which

12:54.680 --> 13:00.760
it has to sign the binary. So it's all nicely packed in and now you have a somewhat visual

13:00.760 --> 13:06.680
representation of what's going on and you can manipulate it easier easily. And yeah since I

13:06.680 --> 13:11.960
didn't get space. So this is the remaining of the two blobs that have to go in. So you can see

13:11.960 --> 13:16.600
there's a few things that you can notice from here. So one is yeah there's a custom entry type

13:16.600 --> 13:22.520
that we've defined and along with which there are standard entry types that we've used. For example

13:22.600 --> 13:29.000
opti and a t f their arm standards. So you can have the standard entry types defined as well.

13:29.000 --> 13:35.640
And it's already there in the bin man folder. And at the same time let's say you want to reuse

13:35.640 --> 13:41.720
the same device tree for building many different boards. And let's say each of the board is using

13:41.720 --> 13:47.640
a different address to load your a t f. And that's also easy to plumb into the bin man flow because

13:47.640 --> 13:55.080
it evaluates config options. So according to your build your config will change and yeah.

13:56.520 --> 14:02.600
So to kind of finish off we'll just quickly go through what the python class looks like for

14:02.600 --> 14:11.160
TI secure for the x509 certificate. So you have a special method of python in the beginning.

14:11.160 --> 14:17.480
So that's just there. And this would do the reading of the node. So you can use your FBT

14:17.480 --> 14:21.560
tools to go and grab the properties that you've mentioned in your device tree.

14:21.560 --> 14:27.560
And you can even add your own properties. That's also possible. So for example sha is the property

14:27.560 --> 14:33.880
that we are going and grabbing by default it's 512 if you haven't mentioned it. If you want to change

14:33.880 --> 14:41.480
the sha value you can give that property in the bin man node itself. And then this would be the

14:41.480 --> 14:47.640
method that you know is kind of important which is actually setting the contents of your

14:48.600 --> 14:54.120
entry. So in my case I've defined a get certificate function that actually goes and

14:54.120 --> 15:00.600
runs open SSL on the binary that you fetched and put that in the entry. So obtain contents is what

15:00.600 --> 15:08.600
is doing that. And in the case of for example you have a u boot SPL which contains the symbol to your

15:09.560 --> 15:14.760
u boot image that you want to jump to. So there's cases where you'll be writing symbols so your

15:14.760 --> 15:21.560
final image would change. So process contents runs after at the end of your build so that it'll go

15:21.560 --> 15:29.720
and update your binary essentially in your final image. And here's another last method

15:29.720 --> 15:36.760
that was used which open SSL is already a bin man tool. So it's already present there and like

15:36.760 --> 15:44.600
Simon mentioned all tools can be all CLI tools you can easily port to be run within bin man itself.

15:44.600 --> 15:49.400
So here you're just adding the open SSL tool since we'll be using it.

15:51.320 --> 15:56.600
Now we're kind of towards the end of the talk. Some of the developments that are ongoing is for

15:56.600 --> 16:04.120
example the bin man dt node is not part of the device tree specification as of now but Simon

16:04.120 --> 16:11.000
has been working on it and that's an ongoing work. Then the ability to pass custom firmware

16:11.000 --> 16:19.240
via the CLI argument. For example let's say I want to pass the dm firmware argument as an actual CLI

16:19.240 --> 16:25.240
argument instead of hard coding it in the bin man dtsi that's not supported as of now without

16:25.240 --> 16:32.600
making changes to the original u boot make file. So yeah that's also something that that is in the

16:32.600 --> 16:39.880
works and finally the x509 template that that is used to generate the final certificate that's

16:39.880 --> 16:45.480
in some ways kind of hard coded right now even though it's a very standard tool that should be

16:45.480 --> 16:53.400
generated on the fly. So that that is also something that's ongoing. Now there's a bunch of u boot

16:53.400 --> 16:59.960
boards that still use custom scripts today and they can all be ported towards using bin man which is

16:59.960 --> 17:06.840
the final aim of this presentation to get everyone to finally port and use bin man as the standard.

17:08.520 --> 17:15.320
So some of the references I've used mainly the u boot documentation Simon's talk at OSFC

17:15.960 --> 17:22.200
and my colleague Brian's bootloader presentation as well and you can also see the patch series that

17:22.200 --> 17:30.520
was used to port the entire k3 devices to using bin man. Yeah lastly I would like to credit the

17:30.520 --> 17:36.760
FOSTA organizers and Texas instruments and the u boot community that has actively been working on

17:36.760 --> 17:40.920
bin man. So yeah now we are open for questions.

17:52.520 --> 17:52.920
That's not really.

18:15.320 --> 18:21.320
So the question is how does bin man relate to make image the make image tool? The bin man calls the

18:21.320 --> 18:27.800
make image tool. Bin man can produce fit images as you probably saw you simply just write fit in

18:27.800 --> 18:37.080
there and you get one. So it's a lot more convenient. Make image has the SOC specific stuff. There's no

18:37.080 --> 18:43.320
plan to you know rip all that c code out and write in python and bin man. It's simply make images

18:43.640 --> 18:46.680
is sort of one of the tools if you like that bin man uses.

19:07.240 --> 19:13.080
It's actually already part of the r5 bootloader which is a little bit more complicated which is why

19:13.080 --> 19:20.120
we didn't cover that. The question was if you can kind of recursively sign the images so a signed

19:20.120 --> 19:25.240
image within a signed image and you can do that which is a part of the r5 bootloader.

19:26.360 --> 19:31.560
We'll be sharing the slides so you can have the r5 view as well so that it'll cover that.

19:35.320 --> 19:42.600
The images are actually hierarchical so if you want something you put it here if you want

19:42.600 --> 19:48.680
the data that comes that goes into that you put inside it and you can just keep going right. So

19:48.680 --> 19:54.280
that's one of the nice things I think it's the I can't remember what it's called Mesa or something

19:55.080 --> 19:59.960
that uses sign within signed and it's simply a case of putting it in the description.

20:12.600 --> 20:22.600
So

20:22.760 --> 20:26.200
I think you're talking about changing the key once the images.

20:30.360 --> 20:33.560
Yeah that is also possible. You want to take that?

20:33.560 --> 20:43.320
I don't know much more about that but yes you can. So the public key has to go in a prior stage but

20:43.320 --> 20:51.240
because you're producing a cohesive firmware image right where all the phases are essentially

20:51.240 --> 20:58.200
have to be there then yeah bin man can can stuff the key from one into you know that's used in the

20:58.200 --> 21:02.600
next phase into the prior stage firmware and that's obviously necessary.

21:13.720 --> 21:14.440
Yeah yeah.

21:18.040 --> 21:26.840
Yeah so if you look at the DM firmware right now that's an external blob. Oh the question is

21:28.200 --> 21:30.200
huh?

21:35.560 --> 21:41.880
So you have to mention the blobs that you so the question is whether we can include external

21:41.880 --> 21:49.640
binary blobs into the final image and whether we can use scripts to generate an image and then you

21:49.640 --> 21:57.960
know port that into the final bin man made image. So the first one is yeah you can reference

21:57.960 --> 22:05.720
external blobs like I've done here. So DM is a blob that's not in the flow so it'll go and pick that

22:05.720 --> 22:13.320
up as an external binary and in terms of scripts so UBOO does the first build and then basically

22:13.400 --> 22:19.560
you can mention the binaries that are dependent that that that have to be created before bin man

22:19.560 --> 22:25.960
can be run. So you can mention that so you can maybe run your script before that and get your

22:25.960 --> 22:33.080
binary ready and then bin man will just do the packing. So it'll only run once the input binaries

22:33.080 --> 22:39.320
are ready to go. So is this already upstream? Yeah this is already upstream. Yeah.

22:39.320 --> 22:43.320
Any other questions?

22:47.320 --> 22:49.320
Thank you very much. Thank you.

23:09.320 --> 23:09.820
you

23:39.320 --> 23:39.820
you

24:09.320 --> 24:09.820
you

24:39.320 --> 24:39.820
you

25:09.320 --> 25:10.540
you

