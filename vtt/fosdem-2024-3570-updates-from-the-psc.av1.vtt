WEBVTT

00:00.000 --> 00:07.000
All right, last session.

00:07.000 --> 00:18.000
Paul Evans, working hard behind the scenes to make sure we have a soul through 5, 6, 7.

00:18.000 --> 00:20.000
What is going to be at 3?

00:20.000 --> 00:21.000
Don't you change it?

00:21.000 --> 00:23.000
Let's call it, I don't know, 100.

00:23.000 --> 00:24.000
Who knows?

00:24.000 --> 00:25.000
All right.

00:25.000 --> 00:26.000
Man, I'll be dead by then.

00:26.000 --> 00:27.000
All right.

00:27.000 --> 00:34.000
Hello, welcome.

00:34.000 --> 00:35.000
Hello.

00:35.000 --> 00:40.000
So this is updates from the Pearl Steering Council.

00:40.000 --> 00:43.000
So a bit of history first.

00:43.000 --> 00:48.000
We've had some yearly releases of Pearl for a very long time now.

00:48.000 --> 00:52.000
532, that was out in 2020, middle of the summer.

00:52.000 --> 00:56.000
And then kind of, you know, every year or so, kind of like Clockwork.

00:56.000 --> 00:59.000
We've had new releases every year.

00:59.000 --> 01:00.000
This is a thing.

01:00.000 --> 01:05.000
People maybe don't realize this.

01:05.000 --> 01:07.000
Some recent changes we've had.

01:07.000 --> 01:10.000
So in 532, we added this Easey operator.

01:10.000 --> 01:12.000
That was kind of cool.

01:12.000 --> 01:16.000
534, we added this Try Catch syntax.

01:16.000 --> 01:19.000
These are some new things we've had.

01:19.000 --> 01:22.000
536 was a lot of new stuff.

01:22.000 --> 01:25.000
So we added loads of things here.

01:25.000 --> 01:27.000
Brief list here.

01:27.000 --> 01:30.000
First big headline thing, Stabilized Signatures.

01:30.000 --> 01:35.000
So finally, that nice little signature syntax there.

01:35.000 --> 01:37.000
That's now stable part of the language.

01:37.000 --> 01:38.000
You can just use that.

01:38.000 --> 01:41.000
You don't have to fiddle with the at underscore array anymore.

01:41.000 --> 01:43.000
It's very, very nice.

01:43.000 --> 01:46.000
We added this multi-variable for each mechanism here.

01:46.000 --> 01:48.000
Come in, come in.

01:48.000 --> 01:54.000
So if you want to iterate over multiple variables at once out of an array, for example, you can just pull multiple of them and it works.

01:54.000 --> 01:57.000
It's especially nice for iterating on hashes.

01:57.000 --> 01:59.000
So you have a hash here.

01:59.000 --> 02:02.000
You get each key and each value inside the body of the free-trilute.

02:02.000 --> 02:03.000
It's wonderful.

02:03.000 --> 02:05.000
I love it.

02:05.000 --> 02:07.000
What else have we got?

02:07.000 --> 02:08.000
We've got defer blocks.

02:08.000 --> 02:10.000
So you use feature defer.

02:10.000 --> 02:12.000
And now you've got this defer thing here.

02:12.000 --> 02:14.000
So you can put a piece of code.

02:14.000 --> 02:18.000
If you're familiar with Go, this is not like the Go ones.

02:18.000 --> 02:22.000
If you're familiar with any other language that has defer, it's exactly like that.

02:22.000 --> 02:32.000
In Go, they decided that defer blocks would always push onto a stack and then at the end of the function, it would run the block.

02:32.000 --> 02:34.000
Whereas every other language said, no, that's kind of crazy.

02:34.000 --> 02:35.000
We'll just do it lexically scoped.

02:35.000 --> 02:39.000
So you have a defer and then you get to the end of the block and it runs it.

02:39.000 --> 02:41.000
Every other language does it that way.

02:41.000 --> 02:45.000
Even C, some people are discussing adding defer to C.

02:45.000 --> 02:51.000
Because if you don't have this crazy array for the function, you can do it mostly statically in the compiler.

02:51.000 --> 02:53.000
And it's just kind of shorthand for putting it in the compiler.

02:53.000 --> 02:55.000
And every other language does it this way.

02:55.000 --> 02:57.000
Don't know why Go does it its own weird way.

02:57.000 --> 02:58.000
It's a bit weird.

02:58.000 --> 03:00.000
Anyway, so we have defer blocks.

03:00.000 --> 03:03.000
And you can put finally blocks on try catch as well.

03:03.000 --> 03:05.000
It's basically the same as a defer.

03:05.000 --> 03:09.000
But people seem to expect that if you can do try catch, you can do try catch finally.

03:09.000 --> 03:12.000
OK, we added it fine, whatever.

03:12.000 --> 03:17.000
Another thing we added in 536 is this built in namespace.

03:17.000 --> 03:25.000
So for years and years and years, if people wanted things like we can and blessed and ref adder and so on,

03:25.000 --> 03:30.000
they'd have to get them out of scale util, which is another module you'd load off the file system.

03:30.000 --> 03:31.000
It's a bit annoying.

03:31.000 --> 03:34.000
These are now built in to the language.

03:34.000 --> 03:36.000
So you don't have to use anything.

03:36.000 --> 03:38.000
It's just right there.

03:38.000 --> 03:40.000
It's already you can always use it.

03:40.000 --> 03:42.000
But if you want, you can you can import it as well.

03:42.000 --> 03:49.000
So for example, we have this nice index function that plays very nicely with the multi variable for each, for example.

03:49.000 --> 03:51.000
So this indexed, you give it a list of things.

03:51.000 --> 03:56.000
It gives you back a list that's twice as big where the first value is prefixed with zero.

03:56.000 --> 03:59.000
The second one is prefixed with one, someone and so forth.

03:59.000 --> 04:06.000
So if you're iterating a list out of an array at every element, you can see the index of that item out of the array.

04:06.000 --> 04:07.000
It's really, really nice.

04:07.000 --> 04:09.000
And it's built into the language.

04:09.000 --> 04:17.000
It's this here is really just telling the parser for this scope here.

04:17.000 --> 04:22.000
I want to have this indexed word available, but it built into the interpreters always available.

04:22.000 --> 04:25.000
And who is it?

04:25.000 --> 04:28.000
People were talking about lexical imports earlier.

04:28.000 --> 04:31.000
These built in is lexical.

04:31.000 --> 04:36.000
So basically what that means is you've just written some code here.

04:36.000 --> 04:42.000
You can just see it, but it's not putting that word indexed into your package.

04:42.000 --> 04:48.000
So if you're writing an object class that you don't get the word indexed visible as a method.

04:48.000 --> 04:50.000
It's not visible from outside.

04:50.000 --> 04:53.000
It's only visible within this scope.

04:53.000 --> 04:57.000
Really nice, really handy, excellent way of working.

04:57.000 --> 04:59.000
So these built-ins are very nice.

05:00.000 --> 05:06.000
Alongside the built-ins, we finally, finally have actual Boolean values.

05:06.000 --> 05:09.000
C originally didn't have Booleans either.

05:09.000 --> 05:13.000
And then eventually in C99 they realized whoops, we should have Booleans.

05:13.000 --> 05:17.000
It's taken us until 536 to realize we should have Booleans, but we now have them.

05:17.000 --> 05:19.000
So we've got this built-in true and false.

05:19.000 --> 05:21.000
Look at that, look at that, my T equals true.

05:21.000 --> 05:23.000
Guess what that does?

05:23.000 --> 05:24.000
There won't be a prize.

05:24.000 --> 05:26.000
It's not that subtle.

05:26.000 --> 05:30.000
But specifically we have this isBool test.

05:30.000 --> 05:35.000
So you can ask, here's a value, is it Boolean or not?

05:35.000 --> 05:42.000
So one and the string one, well they're not Booleans, but this real true, well it really is a Boolean.

05:42.000 --> 05:44.000
That's kind of handy.

05:44.000 --> 05:48.000
It's particularly handy because things like data dumper knows about it.

05:48.000 --> 05:55.000
So if we print this array here, got 2 plus 2, 2 concatenated with 2 and 2 is equal to 2.

05:55.000 --> 05:59.000
Well that gives you the fairly obviously expecting 4 and the string 22.

05:59.000 --> 06:04.000
But it also gives you this pling-pling-1.

06:04.000 --> 06:10.000
That's not very nice, but the reason for that is because everyone uses data dumper wrong.

06:10.000 --> 06:16.000
Data dumper, it's one goal is to output valid Perl code.

06:16.000 --> 06:21.000
It doesn't know that it's trying to output debugging values for humans to read.

06:21.000 --> 06:24.000
It's sole purpose is to output valid Perl code.

06:24.000 --> 06:28.000
And it doesn't know that you might not be running this on an older Perl,

06:28.000 --> 06:34.000
you might not be loading it back in to an older Perl that doesn't know what the true keyword is for example.

06:34.000 --> 06:38.000
So it's going to print pling-pling-1 because it has no other choice.

06:38.000 --> 06:42.000
This is really more a comment of please stop using data dumper for human debugging.

06:42.000 --> 06:45.000
What you want to use is something like data printer.

06:45.000 --> 06:50.000
Data printer is specifically designed for outputting pretty things to humans.

06:50.000 --> 06:54.000
And this slide doesn't show it, but that comes out in color.

06:54.000 --> 06:59.000
It colors the strings and the numbers and the keywords and the surrounding shapes all subtly different.

06:59.000 --> 07:04.000
And it looks really nice on the screen and it's lovely and data printer is so much nicer.

07:04.000 --> 07:07.000
If you're debugging stuff for humans, use data printer.

07:07.000 --> 07:11.000
So thank you to Breno for implementing.

07:11.000 --> 07:14.000
It's true, it's so good.

07:14.000 --> 07:16.000
That's not all.

07:16.000 --> 07:20.000
And the JSON-PP also knows about, yeah, there we go, JSON-PP.

07:20.000 --> 07:25.000
You encode this very same array, you get 4 string 22 and true.

07:25.000 --> 07:32.000
The JSON-XS version, Remy is still looking at it.

07:32.000 --> 07:35.000
Last time I looked it was about three, four days ago.

07:35.000 --> 07:38.000
It's not been merged yet, but he's working on it.

07:38.000 --> 07:40.000
Hopefully that'll come soon.

07:40.000 --> 07:42.000
The YAML modules is Tina around? Tina was around earlier.

07:42.000 --> 07:44.000
Yes, hello Tina, thank you.

07:44.000 --> 07:47.000
This slide is for you Tina, look at that.

07:47.000 --> 07:50.000
Four, the string 22 and true.

07:50.000 --> 07:53.000
And JSON-PP as well, they all do it.

07:53.000 --> 07:56.000
So thank you for Tina, for doing that one.

07:56.000 --> 08:00.000
So yeah, real Booleans, use them, use them, they're nice.

08:00.000 --> 08:05.000
Moving on to 538, the newest one that's currently around.

08:05.000 --> 08:09.000
Somebody wrote this class thing, I don't know if you've heard of it.

08:09.000 --> 08:12.000
Have you heard of it, Ovid? I don't know.

08:13.000 --> 08:16.000
Ovid obviously talked quite a lot about this class system earlier.

08:16.000 --> 08:18.000
So I'll just go through and brief.

08:18.000 --> 08:23.000
Here's a small example of, here's a small piece of code that you can write

08:23.000 --> 08:25.000
to implement like an object class.

08:25.000 --> 08:29.000
You can create here, we have these points, and they have some values.

08:29.000 --> 08:31.000
Yeah, they're great, you can have another point.

08:31.000 --> 08:37.000
What kind of behaves in the obvious way you'd expect from looking at the code?

08:37.000 --> 08:41.000
There's several things about this that I kind of want to point out

08:41.000 --> 08:44.000
as again, kind of covering similar stuff to Ovid earlier.

08:44.000 --> 08:48.000
There's a lot of low level stuff that this thing just does for you.

08:48.000 --> 08:51.000
So you don't have to write sub-new anymore.

08:51.000 --> 08:57.000
You don't have to write a bless, sorry, wait for that, noise outside to finish.

08:57.000 --> 09:01.000
You don't have to write a bless expression anymore.

09:01.000 --> 09:06.000
You don't have to call these accesses to get at your instance fields.

09:06.000 --> 09:11.000
They're just accessible directly as lexical variables.

09:11.000 --> 09:14.000
They're nicely there straight away and you can just use them.

09:14.000 --> 09:22.000
Specifically thinking of Java programmers, Python programmers in particular,

09:22.000 --> 09:24.000
this slide is for you.

09:24.000 --> 09:28.000
You write a class, you declare that it has some fields, x and y,

09:28.000 --> 09:30.000
here are the default values, and that's it.

09:31.000 --> 09:39.000
Nowhere did I have to unpack self.x equals x or args.x or whatever and work out

09:39.000 --> 09:42.000
did they pass a value in, take the argument otherwise take a default value.

09:42.000 --> 09:44.000
No, you don't have to do any of that.

09:44.000 --> 09:47.000
Here's a method.

09:47.000 --> 09:52.000
I've just straight away got access to the local fields and I've got the self

09:52.000 --> 09:56.000
and notice that I didn't have to put dollar self in the signature here.

09:56.000 --> 09:58.000
So I didn't have to put dollar self.

09:58.000 --> 10:03.000
No, I didn't even have to shift self in old school style.

10:03.000 --> 10:07.000
I was writing some Python class code lately and I kept forgetting to put

10:07.000 --> 10:10.000
def method open, self comma.

10:10.000 --> 10:15.000
Why would I put the self in the arguments, in the parameters to the method

10:15.000 --> 10:18.000
when I don't put the self in there when I'm calling the thing?

10:18.000 --> 10:21.000
As soon as you start getting used to using method,

10:21.000 --> 10:23.000
you forget about taking self as an argument.

10:23.000 --> 10:25.000
It goes out of your head.

10:25.000 --> 10:29.000
It's again nice and neat and lovely and it just takes things away that you

10:29.000 --> 10:31.000
don't have to think about.

10:31.000 --> 10:34.000
More things you don't have to think about anymore.

10:34.000 --> 10:39.000
So as I said signatures, we added these in 536.

10:39.000 --> 10:45.000
So here's an example of a signature subroutine and here we're taking a parameter.

10:45.000 --> 10:47.000
Are we taking this optional parameter?

10:47.000 --> 10:48.000
This one's fine.

10:48.000 --> 10:49.000
I'm shaking all over the place.

10:49.000 --> 10:52.000
This y here.

10:52.000 --> 10:56.000
If you don't pass in a value for that y, you get this default.

10:56.000 --> 11:00.000
So here we have an x is 20 and a y, well, you just take the default of 10.

11:00.000 --> 11:04.000
That's all very well, but the way these work inside,

11:04.000 --> 11:08.000
if you specifically pass in an undef, well, you've passed in a value, right?

11:08.000 --> 11:13.000
But that's probably not what the author of this code really intended.

11:13.000 --> 11:16.000
So it kind of breaks a bit if you pass in an undef.

11:16.000 --> 11:20.000
It gets a bit worse if you're just passing in variables because now,

11:20.000 --> 11:25.000
well, you'd have to check carefully is $a1 defined or not.

11:25.000 --> 11:28.000
And if it's not defined, then I'll just not pass it in.

11:28.000 --> 11:31.000
And it's messy to write some code like that.

11:31.000 --> 11:36.000
So new in 538, you can now use the defined or a sign operator

11:36.000 --> 11:40.000
to declare your signature parameter.

11:40.000 --> 11:44.000
So you don't pass, it sort of internally behaves much like this,

11:44.000 --> 11:49.000
where you look at is the value defined or not

11:49.000 --> 11:52.000
rather than just did it exist or not.

11:52.000 --> 11:56.000
So as you'd expect, you pass in one value and you just get the default.

11:56.000 --> 11:59.000
If you specifically pass in an undef, Pearl goes,

11:59.000 --> 12:02.000
ah, you've passed in an undef, that's the same as if you haven't passed it in at all,

12:02.000 --> 12:08.000
I will take the default, which means that passing in two arguments is a lot neater.

12:08.000 --> 12:14.000
I have another talk where I go into more detail about specifically what's in 538

12:14.000 --> 12:18.000
and I actually point out if you were to have, say, five parameters to your function

12:18.000 --> 12:21.000
and four of them were optional ones,

12:21.000 --> 12:24.000
you literally couldn't do it without this operator

12:24.000 --> 12:29.000
because you can't literally not pass the middle parameters and still pass the last one.

12:29.000 --> 12:32.000
Whereas you have to pass in an undef.

12:32.000 --> 12:36.000
And so suddenly with this operator, you can have those kind of middle ones missing

12:36.000 --> 12:39.000
and still put in a value at the end.

12:39.000 --> 12:42.000
So it makes that kind of thing possible that you literally couldn't do before.

12:42.000 --> 12:47.000
So pretty much any time you're using default values in a parameter,

12:47.000 --> 12:52.000
to be honest, you probably wanted this defined or because specifically passing in undef

12:52.000 --> 12:57.000
is almost never a thing you want to distinguish from just not having a thing at all.

12:57.000 --> 12:58.000
So that's quite nice.

12:58.000 --> 13:01.000
And these two things combine together quite nicely.

13:01.000 --> 13:07.000
So for example, when you have a class and you have some default values on parameters,

13:07.000 --> 13:10.000
you can of course just use the defined or operator there.

13:10.000 --> 13:12.000
So once again, it means that things like this,

13:12.000 --> 13:16.000
where you're constructing an object by just passing in whatever values you have in variables,

13:17.000 --> 13:21.000
if those happened to be undef, it wouldn't matter.

13:21.000 --> 13:24.000
It would say, okay, I'll just apply this default of zero.

13:24.000 --> 13:27.000
So that's all very nice and handy.

13:27.000 --> 13:33.000
Other new things in 538, we have these plugable infix operators.

13:33.000 --> 13:37.000
So for event and time in part, we've had plugable keywords,

13:37.000 --> 13:42.000
which is how a lot of the weirder syntax modules like syntax keyword try

13:42.000 --> 13:44.000
and future async weight and object pad,

13:44.000 --> 13:48.000
those will work with this keyword mechanism where they can tell the parser,

13:48.000 --> 13:52.000
I want to implement a whole new keyword, give me control for a bit.

13:52.000 --> 13:57.000
So new in 538, we've added more support for doing similar kind of stuff like that

13:57.000 --> 14:00.000
with infix operators.

14:00.000 --> 14:04.000
So that means that we can have even more cpan modules to experiment with

14:04.000 --> 14:08.000
things that might become new syntax in Perl at some point.

14:08.000 --> 14:10.000
And we've got a few things to play around with those.

14:10.000 --> 14:13.000
So people want like an EQ operator.

14:13.000 --> 14:17.000
People always ask for an E in operator and I've explained in great detail why

14:17.000 --> 14:20.000
that's not as easy as it sounds, but there's a few examples there.

14:20.000 --> 14:25.000
And there's things like a zip and a mesh and there's a few other modules there.

14:25.000 --> 14:29.000
But for example, this one in particular EQU is a nice behavior

14:29.000 --> 14:32.000
that at some point we might add into Corp whole.

14:32.000 --> 14:37.000
So behaves very similar to the normal string EQ operator,

14:37.000 --> 14:41.000
but it knows that undef is different from the empty string.

14:41.000 --> 14:43.000
So this is really cool.

14:43.000 --> 14:48.000
And here it's literally this new infix operator.

14:48.000 --> 14:55.000
So you use it very much like EQ in that two strings,

14:55.000 --> 14:58.000
two strings that are either the same or different, it tells you about those,

14:58.000 --> 15:01.000
but it knows that undef is equal to undef.

15:01.000 --> 15:04.000
It knows that undef is not equal to the empty string.

15:04.000 --> 15:07.000
And in none of these cases, it will print a warning.

15:07.000 --> 15:10.000
So that's quite often the sort of thing that you want.

15:10.000 --> 15:14.000
It's slightly nicer than using EQU and defined tests all the time.

15:14.000 --> 15:18.000
And this is exactly this kind of experiment that's really useful

15:18.000 --> 15:22.000
to be able to test it on CPAN first and say, hey, do we like it?

15:22.000 --> 15:26.000
We'll use it in a few places, go along, maybe decide eventually.

15:26.000 --> 15:28.000
Yes, we'll put that into the language, maybe not.

15:28.000 --> 15:31.000
Kind of depends.

15:31.000 --> 15:34.000
So one thing you might have noticed from pretty much all of these examples so far

15:34.000 --> 15:39.000
is that every single one of them starts with this use, the 536 at the top,

15:39.000 --> 15:42.000
all these other ones, or use V538.

15:42.000 --> 15:44.000
There's a reason for that.

15:44.000 --> 15:47.000
The use version mechanism.

15:47.000 --> 15:52.000
It allows you to configure effectively the language from the very first line

15:52.000 --> 15:54.000
of your source code.

15:54.000 --> 15:58.000
So rather than you just deciding this is the version of Pearl I want to use today,

15:58.000 --> 16:03.000
your file says I want to be 536 or 538 or whatever.

16:03.000 --> 16:06.000
And it's a thing we've always had in Pearl,

16:06.000 --> 16:10.000
but people haven't necessarily used it as much as they should.

16:10.000 --> 16:13.000
And I keep trying to point out how good and how useful it is

16:13.000 --> 16:15.000
and why you should do it all the time.

16:15.000 --> 16:18.000
Because, for example, it implies a feature bundle.

16:18.000 --> 16:25.000
So you say, for example, use V536, you get all of the features that were enabled in 536.

16:25.000 --> 16:28.000
So rather than having to ask for all of these things individually,

16:28.000 --> 16:31.000
if you just write use V536, you get all of this good stuff,

16:31.000 --> 16:35.000
like say and signatures and maybe some of the other ones are good as well,

16:35.000 --> 16:40.000
but those two by far are the ones that I just tend to use all the time.

16:40.000 --> 16:44.000
Everything is just say and sub-routine signatures.

16:44.000 --> 16:45.000
So those are all very nice.

16:45.000 --> 16:47.000
But it gets better.

16:47.000 --> 16:52.000
It's very similar to things like when you compile some C code,

16:52.000 --> 16:56.000
you tell the C compiler which version of C I want to be using here.

16:56.000 --> 17:00.000
So it means that just because you've installed a new version of GCC,

17:00.000 --> 17:03.000
if you don't tell GCC that I'm compiling C99 code,

17:03.000 --> 17:06.000
well, you can still compile C89 code or whatever.

17:06.000 --> 17:11.000
Just because you've updated your compiler, you can still compile old programs.

17:11.000 --> 17:15.000
It's even better than that because it's not just applying to a file,

17:15.000 --> 17:17.000
it applies anywhere.

17:17.000 --> 17:19.000
You can just put a use version inside a block.

17:19.000 --> 17:23.000
And you can say, inside this block, I want to behave as if it was 536.

17:23.000 --> 17:26.000
But I'm not going to put use V536 for the whole file just because

17:26.000 --> 17:28.000
I still happen to have some older code here.

17:28.000 --> 17:31.000
For example, this thing using prototypes.

17:31.000 --> 17:33.000
I didn't want terminal signatures here.

17:33.000 --> 17:39.000
So rather than going to fix up my entire code base all in one go to work on 536,

17:39.000 --> 17:42.000
I'll just do a small bit here today and then maybe tomorrow I'll do a bit more.

17:42.000 --> 17:48.000
And so I'm like an incrementally update to using the new stuff.

17:48.000 --> 17:52.000
It gets even better than that.

17:52.000 --> 17:56.000
So not only does it imply a feature bundle,

17:56.000 --> 17:58.000
but ever since 512, it turns on strict.

17:58.000 --> 18:02.000
So any time you write use strict at the top of your file, you always do that, right?

18:02.000 --> 18:07.000
You can instead just put use V512 and you've already got strict.

18:07.000 --> 18:09.000
Oh, and you've got all the features.

18:09.000 --> 18:13.000
Oh, but new in 536, we added warnings.

18:13.000 --> 18:17.000
So if at the top of your file you would write use strict, use warnings,

18:17.000 --> 18:18.000
by the way, you should always do that.

18:18.000 --> 18:19.000
We don't have to.

18:19.000 --> 18:20.000
You just can put use V536.

18:20.000 --> 18:24.000
And now you've got strict and warnings and all of those features.

18:24.000 --> 18:26.000
So it's really, really nice.

18:26.000 --> 18:30.000
It gives you your choice of the latest features.

18:30.000 --> 18:34.000
It means that we can maintain that compatibility of the language.

18:34.000 --> 18:36.000
We can add new stuff in Perl.

18:36.000 --> 18:42.000
So like you noticed 536 added a lot of those keywords like try and defer and so on.

18:42.000 --> 18:45.000
If you don't write use V536, you don't get those.

18:45.000 --> 18:46.000
But that's fine.

18:46.000 --> 18:49.000
It means that if in any of your code you had something called try or defer,

18:49.000 --> 18:51.000
well, we haven't broken that.

18:51.000 --> 18:54.000
We can add new stuff in Perl without breaking your code.

18:54.000 --> 18:58.000
All you have to do is put use V536 or use V540.

18:58.000 --> 19:01.000
What that means is, yeah, we can update Perl without breaking your code.

19:01.000 --> 19:07.000
That means you can update your Perl binary without breaking any code.

19:07.000 --> 19:12.000
Hands up if you've ever installed a new Perl and something has broken.

19:12.000 --> 19:13.000
Interesting.

19:13.000 --> 19:15.000
That means we failed.

19:15.000 --> 19:17.000
That means we failed.

19:17.000 --> 19:20.000
If you install a new Perl and something works.

19:20.000 --> 19:22.000
A few years ago.

19:23.000 --> 19:25.000
Yeah, yeah.

19:25.000 --> 19:28.000
Like really early ones, sometimes they didn't go so well.

19:28.000 --> 19:33.000
But more recently, I mean, you know, so for example,

19:33.000 --> 19:36.000
I think it was about last month or so,

19:36.000 --> 19:43.000
I updated a bunch of stuff on my email box and all of my email scripting stopped working.

19:43.000 --> 19:46.000
And I looked into it and I discovered actually Proc Mail has,

19:46.000 --> 19:49.000
there's a little bug in Proc Mail now, it's a bug,

19:49.000 --> 19:53.000
something in Proc Mail had changed that meant that a piece of Perl code I wrote

19:53.000 --> 19:57.000
over 15 years ago is not being invoked properly.

19:57.000 --> 20:00.000
And so all of this thing stopped working.

20:00.000 --> 20:03.000
But the script that I wrote 15 years ago for handling all my email

20:03.000 --> 20:05.000
works perfectly fine to this day.

20:05.000 --> 20:07.000
Like I haven't bothered touching it.

20:07.000 --> 20:09.000
I'd almost forgotten that I wrote it.

20:09.000 --> 20:10.000
It just works.

20:10.000 --> 20:13.000
And it's all because of this use version mechanism.

20:13.000 --> 20:16.000
And so when people say, oh, why do I have to put use version

20:16.000 --> 20:18.000
or use feature or whatever to turn on new stuff?

20:18.000 --> 20:20.000
This is exactly why.

20:20.000 --> 20:23.000
It means we can update Perl and you can update Perl

20:23.000 --> 20:25.000
and not break your stuff.

20:25.000 --> 20:28.000
But it means you have to ask for new things.

20:28.000 --> 20:32.000
Speaking of asking for new things, I've been mentioning a lot of these things

20:32.000 --> 20:35.000
are quite experimental.

20:35.000 --> 20:38.000
So some terms here.

20:38.000 --> 20:41.000
So stable stuff means it's long-term guaranteed.

20:41.000 --> 20:44.000
What that means is if we put something in the language and we say it's stable,

20:44.000 --> 20:46.000
that means in a decade's time, in two decades,

20:46.000 --> 20:50.000
like all of the stuff we're talking about now has been stable for like the last 20 years.

20:50.000 --> 20:53.000
And it's all of the stuff that if you update your Perl,

20:53.000 --> 20:57.000
you don't have to think about because it's all the stuff that's there and stable and working.

20:57.000 --> 21:02.000
Experimental simply means a lack of that guarantee.

21:02.000 --> 21:09.000
All the experimental means is we don't guarantee that this will still work in 20 years' time.

21:09.000 --> 21:14.000
But it's no worse than random stuff I downloaded anyway.

21:14.000 --> 21:18.000
Like if you install stuff off GitHub or C-Pan or other languages,

21:18.000 --> 21:20.000
things like NPM or PIPI or whatever,

21:20.000 --> 21:22.000
if you just download it and the author says,

21:22.000 --> 21:25.000
oh, actually next week I've changed my mind, it's going to work something else,

21:25.000 --> 21:28.000
that's only the same level of guarantee here.

21:28.000 --> 21:30.000
So don't be afraid of experimental.

21:30.000 --> 21:33.000
We're not saying, oh, it's crazy, it might break and blow up your code.

21:33.000 --> 21:34.000
That's not what we're saying.

21:34.000 --> 21:40.000
What we're saying is if you use it now, we don't guarantee it'll still be around next year.

21:40.000 --> 21:42.000
But maybe it will.

21:42.000 --> 21:45.000
It's not about does it work.

21:45.000 --> 21:47.000
We know it works.

21:47.000 --> 21:49.000
We have lots of tests.

21:49.000 --> 21:52.000
Things don't get merged at all unless they actually work.

21:52.000 --> 21:57.000
So things like the object system and try catch and all of this lot, it works.

21:57.000 --> 21:58.000
We know it works.

21:58.000 --> 21:59.000
People use it in production.

21:59.000 --> 22:01.000
The question is do we like it?

22:01.000 --> 22:03.000
It means you.

22:03.000 --> 22:05.000
Do you like it?

22:05.000 --> 22:08.000
If people come back and say, yes, we like this, this is great, then wonderful,

22:08.000 --> 22:10.000
we'll take the experimental tag off.

22:10.000 --> 22:13.000
Nobody comes back and says, hey, we've used this, we like this.

22:13.000 --> 22:17.000
How do we know whether we should commit on it?

22:17.000 --> 22:22.000
There's things, literally this week that we've been staring at to do with lexical subs,

22:22.000 --> 22:27.000
that if more people had been using them over the last eight or nine years

22:27.000 --> 22:31.000
since they were made non-experimental, we might have encountered sooner and said,

22:31.000 --> 22:33.000
actually, yeah, that's a bit of a design flaw.

22:33.000 --> 22:34.000
Whoops, that's a shame.

22:34.000 --> 22:36.000
But hardy knows when to be using them.

22:36.000 --> 22:37.000
So we didn't know.

22:37.000 --> 22:39.000
So now it's a little bit late to change them.

22:39.000 --> 22:40.000
So this is a request.

22:40.000 --> 22:43.000
This is the one takeaway from this talk.

22:43.000 --> 22:48.000
If you learn nothing else to learn this, please use experimental features.

22:48.000 --> 22:52.000
Not necessarily in your production, I still want this to run in a decade code.

22:52.000 --> 22:57.000
But if you're writing some small little test thing that maybe is only going to last for today

22:57.000 --> 23:01.000
or a week or whatever, or you're just grabbing some data and mangling it

23:01.000 --> 23:03.000
and fiddling around with it on your laptop,

23:03.000 --> 23:05.000
and you're going to throw away the script after lunch anyway,

23:05.000 --> 23:07.000
please play around with these experimental features.

23:07.000 --> 23:08.000
We're not saying they don't work.

23:08.000 --> 23:11.000
What we're saying is they might not exist next year.

23:11.000 --> 23:15.000
But if you're writing some code that doesn't exist next year, who cares?

23:15.000 --> 23:17.000
So please try them out.

23:17.000 --> 23:19.000
So with that said, what are the current experiments?

23:19.000 --> 23:21.000
Well, we've got try catch.

23:21.000 --> 23:29.000
That's still a bit experimental because ideally I would like when you catch an exception,

23:29.000 --> 23:34.000
you get more information out of it than just the string of what the exception was.

23:34.000 --> 23:36.000
So we might expand a bit on that.

23:36.000 --> 23:38.000
Differ is experimental.

23:38.000 --> 23:40.000
There's a few reasons for that.

23:40.000 --> 23:43.000
To do with if you throw an exception while you're deferring,

23:43.000 --> 23:45.000
while you're unwinding another exception,

23:45.000 --> 23:47.000
you've got this kind of double exception collision thing going on.

23:47.000 --> 23:48.000
It's a bit weird.

23:48.000 --> 23:50.000
Multi-variable for each, that's just because it's new.

23:50.000 --> 23:53.000
Some of the built-in functions, they're currently experimental,

23:53.000 --> 23:55.000
but they probably don't need to be.

23:55.000 --> 23:59.000
Class is obviously very experimental because we're changing a lot of stuff around.

23:59.000 --> 24:01.000
That will change and devolve over time.

24:01.000 --> 24:04.000
There's one particular experiment that I do want to draw attention to,

24:04.000 --> 24:12.000
and that's when we got rid of, when we unexperimented subroutine signatures overall,

24:12.000 --> 24:17.000
we did leave in one thing, and that's if you use the default arguments array for some reason

24:17.000 --> 24:23.000
inside a signature sub, that does currently print an experimental warning.

24:23.000 --> 24:26.000
The reason being it's kind of annoying to implement,

24:26.000 --> 24:31.000
and if people stop doing this, then we can get rid of a whole bunch of the implementation

24:31.000 --> 24:33.000
and make all of functions faster in Perl.

24:33.000 --> 24:36.000
Please stop doing this, and then we can make your Perl faster.

24:36.000 --> 24:39.000
Sonia?

24:39.000 --> 24:41.000
Any mac-in-the-feature?

24:41.000 --> 24:42.000
Any mac-in-the-feature?

24:42.000 --> 24:45.000
We could, yeah, it could become a feature.

24:45.000 --> 24:47.000
Maybe, maybe.

24:47.000 --> 24:49.000
We'll see, it's complicated.

24:49.000 --> 24:50.000
Talk to me at lunch.

24:50.000 --> 24:52.000
Anyway, so we've only got 10 minutes left.

24:52.000 --> 24:58.000
Coming up in 540, new release that we're expecting to be out sometime this summer,

24:58.000 --> 25:01.000
most built-in functions should become stable.

25:01.000 --> 25:05.000
So things like, at the moment, things like ref type, you get experimental warnings.

25:05.000 --> 25:09.000
When you do use 540, you won't get an experimental warning anymore,

25:09.000 --> 25:14.000
because hey, fairly simple, fairly stable, seems to be fine.

25:14.000 --> 25:18.000
We also are going to get built-in bundles from used versions.

25:18.000 --> 25:21.000
You know how I said, use v536 implies all of these things?

25:21.000 --> 25:25.000
Well, use v540 will add another one.

25:25.000 --> 25:30.000
So that means when you go, use v540, you get all of these built-ins for free,

25:30.000 --> 25:36.000
which means you can write, use v540, say ref type, and you just get the thing.

25:36.000 --> 25:39.000
And obviously, we're going to put that in with the capital E as well.

25:39.000 --> 25:41.000
So you can just do pearl-capital E, say ref type.

25:41.000 --> 25:43.000
Look at that, that's lovely.

25:43.000 --> 25:45.000
Everyone likes to do ref type in their one-liners.

25:45.000 --> 25:47.000
Yeah, I don't know.

25:47.000 --> 25:51.000
These ones are all bit, like, it's hard to come up with small examples,

25:51.000 --> 25:53.000
but it's nice that they're there.

25:53.000 --> 25:55.000
It's nice that you don't have to ask especially for them.

25:55.000 --> 25:56.000
You just get them.

25:56.000 --> 25:59.000
So yeah, use v540.

26:00.000 --> 26:03.000
So I want to talk a bit about the process behind some of these things.

26:03.000 --> 26:06.000
So we have this thing, the proposed pearl changes.

26:06.000 --> 26:08.000
It's, you speak a lot of C's.

26:08.000 --> 26:13.000
It's a formal process where people can request changes in the language.

26:13.000 --> 26:20.000
So already we've seen in v536 we had the enter time for, that was run by Nick Clark.

26:20.000 --> 26:26.000
We have deferred the Booleans and the name, and, well, no, that says Booleans.

26:26.000 --> 26:27.000
That should say built-ins.

26:27.000 --> 26:28.000
That's a bug.

26:28.000 --> 26:30.000
I wrote those ones.

26:30.000 --> 26:34.000
Xenu wrote the command line flag for slurping.

26:34.000 --> 26:36.000
It's just a small little bit.

26:36.000 --> 26:40.000
Rick wrote the built-in index to one.

26:40.000 --> 26:42.000
These are all the people who wrote the documents.

26:42.000 --> 26:44.000
These aren't necessarily the people who implemented the code.

26:44.000 --> 26:46.000
These are the people who wrote the documents.

26:46.000 --> 26:50.000
So part of the whole PPC process is about saying, if you have an idea for pearl,

26:50.000 --> 26:52.000
but you don't know how to implement it, well, that doesn't matter.

26:52.000 --> 26:56.000
Write us a document to explain the kind of thing you want.

26:56.000 --> 27:01.000
And if we accept it and we like it, we'll say, yes, we will work out how to get that implemented.

27:01.000 --> 27:03.000
You don't have to implement it.

27:03.000 --> 27:09.000
In v538 we got rid of the back tick for the package separators.

27:09.000 --> 27:11.000
That was the Nicholas Mendoza who wrote that one.

27:11.000 --> 27:14.000
Over here you did the module cruising.

27:14.000 --> 27:16.000
And I can't remember who implemented that.

27:16.000 --> 27:19.000
I did some of it, but someone else did.

27:19.000 --> 27:20.000
Who?

27:20.000 --> 27:21.000
Chromatic?

27:21.000 --> 27:22.000
Yeah, Chromatic wrote that one.

27:22.000 --> 27:23.000
Yeah, you just suddenly surprised us one day.

27:23.000 --> 27:25.000
I said, oh, by the way, I've implemented this.

27:25.000 --> 27:26.000
Wow, OK, fine.

27:26.000 --> 27:27.000
Yeah, so we have the module cruising.

27:27.000 --> 27:28.000
That's quite nice.

27:28.000 --> 27:30.000
And the lexical exports.

27:30.000 --> 27:31.000
Sorry about that.

27:31.000 --> 27:33.000
We're going to have to change them.

27:33.000 --> 27:36.000
Yeah, chat to me later.

27:36.000 --> 27:37.000
We're currently testing.

27:37.000 --> 27:43.000
There's only one little thing that we're PPC that we're testing at the moment for 539.

27:43.000 --> 27:45.000
That's the load module built in.

27:45.000 --> 27:46.000
It's going to be quite nice.

27:46.000 --> 27:50.000
It's just a nicer way of doing require where you have a package name in a string.

27:50.000 --> 27:53.000
It's just rather than having to do all of the horribleness of turning it into a file name.

27:53.000 --> 27:54.000
You just go load module.

27:54.000 --> 27:55.000
It's quite nice.

27:55.000 --> 27:58.000
There's a few other ones that we're in the middle of implementing.

27:58.000 --> 28:01.000
So things like English names for punctuation variables.

28:01.000 --> 28:05.000
So rather than doing dollar splat like that, you could just ask for dollar eval error.

28:05.000 --> 28:06.000
It's quite nice.

28:06.000 --> 28:07.000
Template strings.

28:07.000 --> 28:09.000
I'm almost upset you didn't.

28:09.000 --> 28:12.000
You had a sprint if in your code earlier, Rick.

28:12.000 --> 28:13.000
I mean, come on.

28:13.000 --> 28:15.000
So if you would finish the implementation.

28:15.000 --> 28:16.000
Yeah, it's hard.

28:16.000 --> 28:17.000
Sublexing is hard.

28:17.000 --> 28:22.000
So this horrible thing, especially with objects, like if you try to implement it,

28:22.000 --> 28:27.000
if you try to invoke an object accessor inside of a quoted string, you'll know you can't do that.

28:27.000 --> 28:30.000
And so you're always having to break out of the quoted string and stuff like that.

28:30.000 --> 28:34.000
So we've stolen this thing from a few other languages like quote, quote, quote, template strings.

28:34.000 --> 28:37.000
So now you can just put expressions in your code.

28:37.000 --> 28:38.000
It's lovely.

28:38.000 --> 28:39.000
It's nice.

28:39.000 --> 28:40.000
It's horrible to implement.

28:40.000 --> 28:44.000
If anyone knows how to implement it, let me know because I've had about three attempts.

28:44.000 --> 28:48.000
Anyway, other ones that we're in the middle of implementing is optional chaining.

28:48.000 --> 28:55.000
So a Python actually a couple of weeks ago said they were considering this thing.

28:55.000 --> 29:03.000
They call them the none aware operators where you have, you want to do this method call or a hash lookup or whatever it is.

29:03.000 --> 29:08.000
But the thing on the other side might be, well, in Python's case, it's none, but in Paul's case, it's undef.

29:08.000 --> 29:10.000
And you want to just return undef instead.

29:10.000 --> 29:13.000
So we have this wonderful idea of just put a question mark on the operator name.

29:13.000 --> 29:16.000
So that there, if the hash key exists, it'll call name on it.

29:16.000 --> 29:20.000
If the hash doesn't exist or if it's undef, this whole expression is just undef.

29:20.000 --> 29:23.000
And that's often a thing you want to do as well.

29:23.000 --> 29:25.000
It's nice and neat and tidy.

29:25.000 --> 29:26.000
I like it.

29:26.000 --> 29:28.000
And the metaprogramming API.

29:28.000 --> 29:35.000
So all these crazy things that you do with no strict refs and glob refs and all this other stuff that's horrible and messy.

29:35.000 --> 29:41.000
We're going to make that much, much nicer with just you get a meta package and you get the symbol out of it, you get the value in it.

29:41.000 --> 29:43.000
It's all lovely.

29:43.000 --> 29:45.000
It's all inspired by things like package stash.

29:45.000 --> 29:52.000
And there's a bunch of other things on cpan, but we want to make this an official part of core pearl so that we can tie it into things like the object system as well.

29:52.000 --> 29:55.000
It just makes that much more powerful.

29:55.000 --> 30:02.000
A few other little upcoming ideas at some point, but probably not going to be in 540, are I'd like to have named parameters and signatures.

30:02.000 --> 30:07.000
It'd be nice to be able to have these named things here.

30:07.000 --> 30:09.000
But I want to do more stuff on class.

30:09.000 --> 30:12.000
I've not really added anything extra in class for 540.

30:12.000 --> 30:14.000
So roles would be nice.

30:14.000 --> 30:16.000
The convenience accesses might be nice.

30:16.000 --> 30:22.000
It's possible by 540 I'll get around to the easy one like reader, but even something like writer is going to be a little bit awkward.

30:22.000 --> 30:25.000
But even just having readers in 540 might be nice.

30:25.000 --> 30:27.000
I'll see if I can get around to it.

30:27.000 --> 30:28.000
And I've got three minutes left.

30:28.000 --> 30:29.000
Yep.

30:29.000 --> 30:36.000
And the last thing I want to do at some point is renumber 5.whatever into 7 because I really want to be able to type use v7 and just have it work.

30:36.000 --> 30:39.000
And with that, I'm going to say there's the end.

30:39.000 --> 30:41.000
There's a link to the slides.

30:41.000 --> 30:53.000
There's also a link down here to some slides and the video of my talk that I did what's new in 538, which goes into a lot more detail about the new things we added in 538.

30:53.000 --> 31:00.000
And then I will say we will take some short questions, but our minds now the last talking here.

31:00.000 --> 31:02.000
So afterwards I'm going to go for lunch.

31:02.000 --> 31:06.000
If people want bigger chats, we can chat over lunch or in the hallway or something.

31:06.000 --> 31:09.000
So with that small questions.

31:10.000 --> 31:11.000
Yeah.

31:11.000 --> 31:12.000
Question.

31:12.000 --> 31:20.000
In the chat support for thoughts, do you expect or is it hard to plan to implement interfaces?

31:20.000 --> 31:22.000
So the question is about interfaces.

31:22.000 --> 31:24.000
Do we plan to implement interfaces?

31:24.000 --> 31:25.000
I mean, in summary, no.

31:25.000 --> 31:34.000
I mean, Java's idea of an interface is all about defining what kinds of methods you can call on a thing up front.

31:34.000 --> 31:36.000
It's all to do with static typing.

31:36.000 --> 31:38.000
That's exactly all that it is.

31:38.000 --> 31:42.000
And Pearl doesn't have static typing in that sense.

31:42.000 --> 31:49.000
Like if you have an object, you can always at compile time write the code to invoke any method you like.

31:49.000 --> 31:53.000
I mean, maybe at runtime the method may or may not exist, but it doesn't.

31:53.000 --> 32:00.000
Whereas adding the concept of static typing to a dynamic language like Pearl basically turns the entire language upside down.

32:00.000 --> 32:04.000
So the idea of a pure interface isn't really a thing that we want to add.

32:04.000 --> 32:09.000
But we definitely want to add roles because roles are statements about an interface,

32:09.000 --> 32:12.000
but they can also have implementation with them.

32:12.000 --> 32:16.000
So it's all about gluing small bits of functionality together to make a larger class.

32:16.000 --> 32:22.000
So we definitely want roles, but pure abstract interfaces are not really a thing that fits in dynamic languages.

32:22.000 --> 32:23.000
Oh, good.

32:23.000 --> 32:24.000
Comment on the question.

32:24.000 --> 32:26.000
Java allows default implementations now.

32:26.000 --> 32:27.000
Oh, does it?

32:27.000 --> 32:28.000
And residence.

32:28.000 --> 32:29.000
So basically they're roles.

32:29.000 --> 32:30.000
Yeah.

32:30.000 --> 32:31.000
Yeah.

32:31.000 --> 32:32.000
Okay.

32:32.000 --> 32:33.000
They're much nicer than they are.

32:33.000 --> 32:35.000
So we've only got one minute left.

32:35.000 --> 32:44.000
For x, y at array, if dollar y happens to be in depth, how do we know because the value is in depth or because we hit the end of the array?

32:44.000 --> 32:45.000
It doesn't matter at that point.

32:45.000 --> 32:51.000
It's just, oh, with the default argument, the signature parameters thing.

32:51.000 --> 32:54.000
No, the multi four.

32:54.000 --> 32:55.000
Oh.

32:55.000 --> 33:00.000
So I want to know that my array is even sized if I'm pulling out an even size.

33:00.000 --> 33:01.000
Yeah.

33:01.000 --> 33:02.000
Yeah.

33:02.000 --> 33:11.000
So for the, for the, for each, for each when you have multiple arguments, yeah, if, if the size of the array doesn't exactly match, it's like a, not a whole multiple.

33:11.000 --> 33:17.000
You will, you will get just undefs for those last missing positions.

33:17.000 --> 33:28.000
We did think about other bits of behavior, but I think in the end we decided that it just doesn't match because like if you just did my x, y, z equals array.

33:28.000 --> 33:37.000
Like when you get undefs in those last few values, you don't know whether that's because there were undefs in the original array or you just ran out of values.

33:37.000 --> 33:38.000
And so you've got the undefs.

33:38.000 --> 33:40.000
So it's kind of the same thing.

33:40.000 --> 33:51.000
If we did consider implementing something where you could tell the difference, then we'd start to, you'd sort of start to ask questions about, would you put it in other features as well?

33:51.000 --> 33:57.000
So like a, a, a large part of, of kind of trying to do language design is saying, well, we're not just going to do this one isolated feature.

33:57.000 --> 34:00.000
We have to consider how does it play with all these other things?

34:00.000 --> 34:05.000
And so running out of the array is a thing that happens in a lot of places.

34:05.000 --> 34:08.000
So I think that's, that's the end of, of questions now.

34:08.000 --> 34:12.000
So we'll stop there, but if people want to chat more, I'm, I'm happy to chat over lunch, but thank you very much.

34:21.000 --> 34:23.000
Thank you.

