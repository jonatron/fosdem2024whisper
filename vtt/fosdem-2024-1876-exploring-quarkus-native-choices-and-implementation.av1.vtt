WEBVTT

00:00.000 --> 00:11.480
Hello everyone, I'm Fivo Zakat and today I will talk about Quarkus native and some choices

00:11.480 --> 00:14.280
it makes and how it implements them.

00:14.280 --> 00:16.640
So how many of you are familiar with Quarkus?

00:16.640 --> 00:18.520
Know what Quarkus is?

00:18.520 --> 00:21.280
Well, less than I expected.

00:21.280 --> 00:24.200
Okay, so what it is?

00:24.200 --> 00:26.080
It's a Java framework.

00:27.080 --> 00:33.040
Well, it's an open source stack for building Java web apps, so it's a Java framework that

00:33.040 --> 00:37.800
aims to bring developer joy, it's Kubernetes native, brings the best of breed of libraries

00:37.800 --> 00:45.440
and standards and supports both imperative and reactive code.

00:45.440 --> 00:47.960
And that stopped working.

00:47.960 --> 00:54.400
So what does typically a framework do when you use it?

00:54.400 --> 00:59.160
Well, usually you write your Java application using the framework, then you package it, you

00:59.160 --> 01:02.480
save it wherever you want to deploy it and you start the application.

01:02.480 --> 01:09.800
And what it does, it will load configuration files, perform some annotations, perform some

01:09.800 --> 01:15.680
annotation processing, create some metadata graphs or whatever is needed and eventually

01:15.680 --> 01:19.520
run the application.

01:19.520 --> 01:27.400
So what Quarkus does to improve that situation is that it moves part of this configuration

01:27.400 --> 01:34.240
to build time, so you only run once the configuration and setup of your application and then when

01:34.240 --> 01:39.280
you deploy your application, it starts up faster and you don't have to repeat all this

01:39.280 --> 01:41.200
process.

01:41.200 --> 01:46.920
One benefit of this Quarkus feature is that it allows you to also go native.

01:46.920 --> 01:53.200
So instead of deploying on the JVM, you can deploy a native binary.

01:53.200 --> 01:56.480
So why would someone want to go native?

01:56.480 --> 02:04.520
We have put so much effort on making the JVM very mature, very stable, very high performance,

02:04.520 --> 02:08.760
et cetera, so why would someone want to go native?

02:08.760 --> 02:15.240
Without going in too much detail, I will list some of the pros and cons of going native.

02:15.240 --> 02:18.000
So first we will start with the pros.

02:18.000 --> 02:23.920
One of the major advantages of going native is that you get faster startup because you

02:23.920 --> 02:29.360
don't have a JVM that needs to start up, load classes, do classification, warm up, stuff

02:29.360 --> 02:32.520
like this, you get faster startup.

02:32.520 --> 02:37.720
You also get close to peak performance right from the beginning because you don't do just

02:37.720 --> 02:44.320
in time compilation, everything is ahead of time compile and that gives you close to your

02:44.320 --> 02:48.040
peak performance right from the beginning.

02:48.040 --> 02:51.800
You get a smaller standalone binary.

02:51.800 --> 02:56.480
Hint here, I'm comparing with shaping your application with the JVM.

02:56.480 --> 03:00.400
Otherwise the JAR file is smaller than the binary.

03:00.400 --> 03:04.240
And you also get smaller memory footprint when running your application because you don't

03:04.240 --> 03:10.760
have to keep all this data that the JVM keeps to track internal things.

03:10.760 --> 03:14.080
And another benefit is that if you launch the same application multiple times on the

03:14.080 --> 03:22.640
same host, they can share the heap as a copy and write memory segment.

03:22.640 --> 03:25.600
Now what are the disadvantages?

03:25.600 --> 03:28.760
First of all, you get slower development cycle.

03:28.760 --> 03:34.120
Compiling to native takes more than it takes to compiling to a JAR file.

03:34.120 --> 03:39.920
So we suggest that you develop on JVM, debug on the JVM and only when you are happy with

03:39.920 --> 03:44.680
your application then move to native because that takes some time.

03:44.680 --> 03:50.760
You also get lower peak performance because when you run binary, you don't get just in

03:50.760 --> 03:52.200
time compilation.

03:52.200 --> 03:59.560
So the compiler doesn't have the benefit to profile your code and to do better optimizations.

03:59.560 --> 04:07.040
It also can perform very aggressive optimizations relying on the deoptimizer to fall back to

04:07.040 --> 04:14.760
a slower version if something doesn't go as assumed during compilation time.

04:14.760 --> 04:18.040
Another issue is that security patches require recompilation.

04:18.040 --> 04:25.160
So even if a third-party library is vulnerable, you can just update the JAR file of that third-party

04:25.160 --> 04:28.040
library and don't recompile your code.

04:28.040 --> 04:33.080
You have to rebuild your code because parts of that third-party library might be empty

04:33.080 --> 04:34.080
in your application.

04:34.800 --> 04:37.840
So you have to recompile.

04:37.840 --> 04:40.040
Your application is also not portable.

04:40.040 --> 04:43.760
You lose the right ones run anywhere, principle.

04:43.760 --> 04:48.200
So because you are generating a binary file, it will only work on the target platform that

04:48.200 --> 04:50.880
you compile for.

04:50.880 --> 04:55.240
And last but not least, it lacks behind in terms of tooling support.

04:55.240 --> 05:01.320
So debugging is not as simple as in the JVM world.

05:01.320 --> 05:03.520
And the same goes for observability.

05:03.520 --> 05:07.000
That doesn't work.

05:07.000 --> 05:08.200
Okay.

05:08.200 --> 05:14.360
Now that we have seen that there are some benefits in using native code, let's see how

05:14.360 --> 05:16.480
it works.

05:16.480 --> 05:24.360
Quarkus uses GraVM and particularly GraVM's native image to generate the binary code from

05:24.440 --> 05:26.800
Java code.

05:26.800 --> 05:32.240
And how this works is that GraVM will take as input your Java application classes, the

05:32.240 --> 05:35.920
JDK classes, and the substrate VM classes.

05:35.920 --> 05:45.200
The substrate VM is a thin runtime layer that allows your application to run on bare metal.

05:45.200 --> 05:51.000
So it takes care of some of the system things going on.

05:51.000 --> 05:58.120
Then it performs a static analysis and this will allow it to perform dead code elimination.

05:58.120 --> 06:02.400
So it essentially doesn't compile any code that you don't need.

06:02.400 --> 06:08.200
If your application doesn't reference some part of your class path or your dependencies,

06:08.200 --> 06:10.320
it won't go in the binary.

06:10.320 --> 06:14.040
So it creates a graph like this where your Java applications reference some JDK classes

06:14.040 --> 06:19.120
and the JDK classes reference some substrate VM classes and it will eventually compile

06:19.160 --> 06:22.120
it to a native binary.

06:22.120 --> 06:28.320
However, GraVM comes with some limitations.

06:28.320 --> 06:34.160
There are things that are not supported and there are things that are supported but need

06:34.160 --> 06:38.040
manual configuration.

06:38.040 --> 06:41.440
And some of the not supported parts are currently working progress.

06:41.440 --> 06:45.880
I don't have enough time to go through this.

06:45.880 --> 06:51.120
So how does Quarkus offer, what does Quarkus offer on top of that?

06:51.120 --> 06:53.720
So GraVM takes Java and produces native code.

06:53.720 --> 06:57.600
So where does Quarkus native come into play?

06:57.600 --> 07:03.520
Because of the limitations I mentioned earlier, developing native applications for GraVM's

07:03.520 --> 07:08.200
native image might be painful and that's where Quarkus comes into play.

07:08.200 --> 07:13.960
It aims to help Java developers write their application and compile it to native without

07:14.040 --> 07:21.880
having to handle all the extra things that GraVM native image requires.

07:21.880 --> 07:27.160
First Quarkus will drive all the gathering of the metadata that the GraVM needs.

07:27.160 --> 07:35.160
So what's reflectively accessed, how many JNI interfaces are used, what are the resources

07:35.160 --> 07:39.840
we want to include our binary and stuff like this.

07:39.840 --> 07:46.520
Another benefit is that most of the ecosystem, so anything that comes with Quarkus is already

07:46.520 --> 07:50.120
supported for native image compilation.

07:50.120 --> 07:55.640
So if you want to use a library that's already supported by Quarkus, you don't have to do

07:55.640 --> 08:01.720
anything special, you just put it as a dependency to your application and it should work with

08:01.720 --> 08:03.880
native as well.

08:03.880 --> 08:08.880
It minimizes the dependencies because Quarkus already does a dependency analysis before going

08:08.880 --> 08:20.400
to native, so that allows you to pass less things to the class path and it helps the

08:20.400 --> 08:27.280
static analysis do the dead code elimination.

08:27.280 --> 08:32.360
Furthermore Quarkus through annotations, APIs and some configuration properties allow you

08:32.360 --> 08:40.640
to further find the configuration of your application for native.

08:40.640 --> 08:47.040
So some might think that that's not the only framework that does that, right?

08:47.040 --> 08:49.800
So why Quarkus?

08:49.800 --> 08:57.560
Quarkus takes an opinionated approach and it's different than the other frameworks in

08:57.560 --> 09:04.000
that it will try and build time initialize all the classes, while by default, Graph VMs

09:04.000 --> 09:09.680
native image runtime initializes the classes.

09:09.680 --> 09:14.080
And this might create some issues, so Quarkus will take care of reinitializing anything

09:14.080 --> 09:20.480
that's necessary like random seeds or some platform specific values and it will also

09:20.480 --> 09:26.240
reset fields that we don't need at runtime.

09:26.240 --> 09:30.920
It also doesn't allow incomplete class paths, so when you build everything needs to be on

09:30.920 --> 09:37.600
the class path, otherwise the build will fail and this ensures that you won't get any unexpected

09:37.600 --> 09:41.480
no class defound exceptions at runtime.

09:41.480 --> 09:47.560
And class, it uses Mandrel instead of the upstream Graph VM community addition, which

09:47.560 --> 09:54.360
is based on the Eclipse Temuring Open JDK build instead of the Laps JDK build and it's specifically

09:54.360 --> 09:59.640
tailored to Quarkus and maintained by Red Hat.

09:59.640 --> 10:05.280
So how does this really work under the covers?

10:05.280 --> 10:11.240
First of all, the Quarkus will take care of generating the Graph native image json configuration

10:11.240 --> 10:13.160
files.

10:13.160 --> 10:16.280
It will perform code substitutions wherever necessary.

10:16.280 --> 10:23.760
Code substitutions allow us to go and patch third-party libraries or even the JDK itself.

10:23.760 --> 10:28.600
So if we don't like there something or if something is not compatible with native compilation,

10:28.600 --> 10:30.760
we can adapt it.

10:30.760 --> 10:39.720
It will generate some byte code that is responsible for configuring things and it will change the

10:39.720 --> 10:49.960
defaults for Graph VM native image and it will also allow the user to pass additional parameters.

10:49.960 --> 10:56.400
So for the json configuration part, it generates these five files, one for JNI, for proxy classes,

10:56.400 --> 11:00.800
for reflective accesses, resources and serialization.

11:00.800 --> 11:06.040
These are the generation of these files is handled by the classes here.

11:06.040 --> 11:11.080
So it's native image reflective configs, let's say.

11:11.080 --> 11:16.680
And it decides what to put in these json files based on the build items that exist in your

11:16.680 --> 11:17.680
application.

11:17.920 --> 11:27.120
In Quarkus, you can define the build pipeline using these build items.

11:27.120 --> 11:29.440
And earlier I mentioned substitutions.

11:29.440 --> 11:34.240
Substitutions are heavily used in Quarkus because they assist in dead code elimination

11:34.240 --> 11:41.440
and they also make sure that things that are not supported in native code are not reachable

11:41.440 --> 11:45.160
and it will throw some appropriate exceptions for that.

11:45.160 --> 11:51.000
So Quarkus performs 303 method substitutions and 32 field recommendations in a total of

11:51.000 --> 11:54.000
208 classes.

11:54.000 --> 11:57.320
This means that you don't have to do any of these on your own.

11:57.320 --> 12:01.120
They are already handled by Quarkus and this is only on Quarkus core.

12:01.120 --> 12:06.880
If you go and use some Quarkus extension, it performs its own substitutions and stuff

12:06.880 --> 12:07.880
like this.

12:08.880 --> 12:17.080
To see an example here, here we substitute the method allocate buffer in this class and

12:17.080 --> 12:21.920
we only do that when ZSTD is absent from the class path.

12:21.920 --> 12:28.200
And what we substitute the method with is a throw of an exception that this operation

12:28.200 --> 12:29.200
is unsupported.

12:29.200 --> 12:35.840
So if you compile your code to native and it invokes this method while the ZSTD library

12:35.840 --> 12:41.560
is not available, you will get this exception.

12:41.560 --> 12:48.440
And this is how we recompute fields.

12:48.440 --> 12:55.800
So here in Bouncy Castle's easy point, we go and reset the test random field because

12:55.800 --> 13:02.000
this is a secure random class and we don't want it to be preceded and pre-initialized

13:02.000 --> 13:03.000
in the native image.

13:03.000 --> 13:10.800
But whenever we restart the application, we get different random numbers.

13:10.800 --> 13:17.960
We can similarly change the value of a field by reinitializing from an alias.

13:17.960 --> 13:23.440
That means that we can pass whatever value we want not just reset it to null.

13:23.440 --> 13:30.840
Here we change the field unavailability cause to put a Quarkus specific exception in there.

13:30.840 --> 13:37.320
And we also substitute the method is available to return false to show that OpenSSL is not

13:37.320 --> 13:43.520
supported in this specific case.

13:43.520 --> 13:48.320
Regarding features generation, this is handled by the native image features step class and

13:48.320 --> 13:51.760
it will use Quarkus Gizmo to generate bytecode.

13:51.760 --> 13:57.920
And this bytecode is used to invoke Grail VMs APIs to perform stuff that cannot be done

13:57.920 --> 14:02.560
through the json configuration.

14:02.560 --> 14:10.200
So here is a part of the native image features that we generate.

14:10.200 --> 14:16.920
And what it essentially does is that it invokes first it gets the method descriptor for the

14:16.920 --> 14:21.440
runtime class initialization.initialize at build time method.

14:21.440 --> 14:28.560
And it will invoke this method passing it a string array with the empty string.

14:28.560 --> 14:34.400
This instructs Grail VM to build time initialize everything, which is different than what it

14:34.400 --> 14:41.640
does by default.

14:41.640 --> 14:48.840
And we can also parameterize the options that are passed to the native image build.

14:48.840 --> 14:53.200
And we do that in the native image build step.

14:53.200 --> 14:56.120
And here we see part of it.

14:56.120 --> 15:01.480
And what it does is that it always enables allow fold methods, which is off by default.

15:01.480 --> 15:05.880
It makes our application headless by default.

15:05.880 --> 15:11.920
It doesn't allow the creation of fallback images because fallback images are essentially

15:11.920 --> 15:13.200
JVM lancers.

15:13.200 --> 15:16.960
So you don't get the native application that you asked for.

15:16.960 --> 15:22.240
And we also always ask it to link at build time.

15:22.240 --> 15:26.000
And that concludes the talk.

15:26.000 --> 15:32.040
I would like to acknowledge that Quarkus participates in the IROEU funded project.

15:32.040 --> 15:41.040
And I'm ready to take questions, if any.

15:41.040 --> 15:45.040
Any questions in the chat?

15:45.040 --> 16:05.040
Yeah, the custom class loader is a bit tricky because Quarkus.

16:05.040 --> 16:12.880
The question was whether Quarkus also supports the standard JDK instead of Grail VM JDK.

16:12.880 --> 16:15.280
So this is the first part of the question.

16:15.280 --> 16:17.280
And the answer to that is yes.

16:17.280 --> 16:19.480
This is Quarkus native and this is optional.

16:19.480 --> 16:21.080
This is only if you want to go native.

16:21.080 --> 16:28.040
If you want to stay on the JVM path, you can use any JDK and it will work just fine.

16:28.040 --> 16:30.960
Now to the second question about custom class loaders.

16:30.960 --> 16:35.280
Although I'm not very familiar with that, I think that this might be a bit tricky because

16:35.280 --> 16:37.680
Quarkus already uses custom class loaders.

16:37.680 --> 16:40.080
So you have to make sure that they are somehow compatible.

16:40.080 --> 16:49.520
I couldn't hear the question, so.

16:49.520 --> 16:57.480
Okay, you find out a library and you wonder whether you can use it or not.

16:57.480 --> 17:03.800
Okay, if the library is supported by Quarkus itself, you will find it listed in the Quarkus

17:03.800 --> 17:08.960
supported libraries or in a Quarkus extension that supports this library.

17:08.960 --> 17:13.640
In that case, everything should work out of the box and you don't need to do anything.

17:13.640 --> 17:19.600
In the case that your library is not supported by Quarkus Core or any of the Quarkus extensions,

17:19.600 --> 17:26.520
then you need to use some of the trickings that Quarkus does to make it work.

17:26.520 --> 17:31.240
And Quarkus gives you some APIs and annotations that may assist you.

17:31.240 --> 17:32.240
Let's see that.

17:32.240 --> 17:38.040
There is a website like supported libraries that I can go to and have a look.

17:38.040 --> 17:45.240
I think if you go to code.quarkus.io, then you can see a list of supported extensions

17:45.240 --> 17:46.240
in libraries.

17:46.240 --> 17:51.560
Do we have time to get some more questions?

17:51.560 --> 17:52.560
One more question.

17:52.560 --> 17:53.560
Sorry.

17:53.560 --> 18:01.880
I was wondering if Worker's Native works with GNI-based providers, sorry, the provider

18:01.880 --> 18:04.000
interface, not GNI.

18:04.000 --> 18:05.000
The foreign API?

18:05.000 --> 18:12.000
No, no, sorry, like classes discovery when you want to load a specific service, SPI,

18:12.000 --> 18:18.000
that's the name, sorry, the service provider interface.

18:18.000 --> 18:20.000
I think I don't know.

18:20.000 --> 18:21.000
Okay, thank you.

18:21.000 --> 18:25.480
Okay, for the rest of the questions, please feel free to approach me on the break.

18:25.480 --> 18:26.480
Thank you.

18:26.480 --> 18:27.480
Thank you.

18:27.480 --> 18:28.480
Thank you.

18:28.480 --> 18:29.480
Thank you.

18:29.480 --> 18:30.480
Thank you.

18:30.480 --> 18:31.480
Thank you.

18:31.480 --> 18:32.480
Thank you.

18:32.480 --> 18:33.480
Thank you.

18:33.480 --> 18:34.480
Thank you.

18:34.480 --> 18:35.480
Thank you.

18:35.480 --> 18:36.480
Thank you.

18:36.480 --> 18:37.480
Thank you.

18:37.480 --> 18:38.480
Thank you.

18:38.480 --> 18:39.480
Thank you.

18:39.480 --> 18:40.480
Thank you.

18:40.480 --> 18:41.480
Thank you.

18:41.480 --> 18:42.480
Thank you.

18:42.480 --> 18:43.480
Thank you.

18:43.480 --> 18:44.480
Thank you.

18:44.480 --> 18:45.480
Thank you.

18:45.480 --> 18:46.480
Thank you.

18:46.480 --> 18:47.480
Thank you.

18:47.480 --> 18:48.480
Thank you.

18:48.480 --> 18:49.480
Thank you.

18:49.480 --> 18:50.480
Thank you.

18:50.480 --> 18:51.480
Thank you.

18:51.480 --> 18:52.480
Thank you.

18:52.480 --> 18:53.480
Thank you.

18:53.480 --> 18:54.480
Thank you.

18:54.480 --> 18:55.480
Thank you.

18:55.480 --> 18:56.480
Thank you.

18:56.480 --> 18:57.480
Thank you.

18:57.480 --> 18:58.480
Thank you.

18:58.480 --> 18:59.480
Thank you.

18:59.480 --> 19:00.480
Thank you.

19:00.480 --> 19:01.480
Thank you.

19:01.480 --> 19:02.480
Thank you.

19:02.480 --> 19:03.480
Thank you.

