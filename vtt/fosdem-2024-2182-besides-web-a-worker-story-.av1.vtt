WEBVTT

00:00.000 --> 00:05.000
Okay, awesome.

00:05.000 --> 00:10.000
The mic is on, hopefully.

00:10.000 --> 00:12.000
All right, good afternoon everyone.

00:12.000 --> 00:15.000
So I'm going to talk to you about a worker story,

00:15.000 --> 00:18.000
which is something we did at work recently.

00:18.000 --> 00:22.000
And for once, it was like not using Rails.

00:22.000 --> 00:23.000
That's awesome.

00:23.000 --> 00:24.000
Not using web at all.

00:24.000 --> 00:29.000
That's what motivated me to tell you this story.

00:29.000 --> 00:33.000
So before we start, I would like to know who here is the Rails developer?

00:33.000 --> 00:34.000
Who would like?

00:34.000 --> 00:35.000
Yeah, awesome.

00:35.000 --> 00:40.000
Who would say that they are Ruby, but not Rails developer?

00:40.000 --> 00:41.000
Okay, awesome.

00:41.000 --> 00:42.000
That's great.

00:42.000 --> 00:43.000
Love it.

00:43.000 --> 00:44.000
I didn't expect that.

00:44.000 --> 00:45.000
Awesome.

00:45.000 --> 00:48.000
All right, first of all, who am I?

00:48.000 --> 00:53.000
Because if you don't know who am I, you might not rely on whatever I'm going to say.

00:53.000 --> 00:57.000
So I've been Ruby and mostly Rails developer for 10 years.

00:57.000 --> 01:02.000
I've been working with Kevin for almost that period.

01:02.000 --> 01:08.000
More recently, I have become a lead dev, then a manager, then a CTO.

01:08.000 --> 01:14.000
So I'm doing a lot of new responsibilities now, which also gives me a new perspective

01:14.000 --> 01:19.000
on a lot of programming topic, actually getting new perspective when you start making a decision

01:19.000 --> 01:22.000
about people and processes and stuff like that.

01:22.000 --> 01:26.000
And finally, I've been a teacher for more than six years.

01:26.000 --> 01:29.000
I've given a lecture at EPL and Le Wagon.

01:29.000 --> 01:31.000
Hopefully, we'll do that again.

01:31.000 --> 01:35.000
I feel like a deep-footed lover for teaching and sharing knowledge.

01:35.000 --> 01:39.000
And this is also why I'm here today.

01:39.000 --> 01:47.000
So I was saying the point of this talk is talking about Ruby, but not about Rails, not about

01:47.000 --> 01:50.000
web.

01:50.000 --> 01:52.000
And this was the first time for me.

01:52.000 --> 01:54.000
I was like a new experience.

01:54.000 --> 02:01.000
And it's strange to see how much changes when you start doing that, how much you realize

02:01.000 --> 02:06.000
Rails was giving to you once you don't have that anymore.

02:06.000 --> 02:08.000
I have some notes.

02:08.000 --> 02:11.000
By the way, all my slides are going to be minimalistic.

02:11.000 --> 02:13.000
I'm not going to show you a single line of code.

02:13.000 --> 02:19.000
I'm also going to forget a lot of stuff, which is why everything I intend to tell you is written

02:19.000 --> 02:22.000
in notes available directly in this.

02:22.000 --> 02:28.000
So hopefully, you will get everything I intend to say because I'm going to forget part of that.

02:28.000 --> 02:34.000
So the main message of this talk is like it's doable.

02:34.000 --> 02:40.000
It sounds strange that this is my message, but as most Rails developers sometimes, when we think

02:40.000 --> 02:44.000
about Ruby program, we're not even sure we can do it.

02:44.000 --> 02:47.000
We're not even sure how would we approach that.

02:47.000 --> 02:49.000
So the main message is like, yes, it's doable.

02:49.000 --> 02:50.000
There's a lot of tools.

02:50.000 --> 02:51.000
There's a lot of process.

02:51.000 --> 02:53.000
There's a lot of help along the way.

02:53.000 --> 02:59.000
And you can possibly, you can very likely, sorry, get most of your tools and knowledge

02:59.000 --> 03:04.000
used in a normal, not web Ruby application.

03:04.000 --> 03:11.000
The second news is you can also get all of your Rails knowledge useful in Ruby application

03:11.000 --> 03:14.000
if you get things right.

03:14.000 --> 03:18.000
So the story I'm going to tell is about like a worker.

03:18.000 --> 03:22.000
What is a worker in our case, in my case?

03:22.000 --> 03:23.000
It's like microservice.

03:23.000 --> 03:25.000
The specificity, why do we call it a worker?

03:25.000 --> 03:28.000
Because it's not a web microservice.

03:28.000 --> 03:33.000
It's a microservice which is consuming messages from a queue and very likely is going to process

03:33.000 --> 03:39.000
files, so it's going to get files from a bucket, process them locally, put them on another bucket.

03:40.000 --> 03:45.000
We have, we are using the word worker because we have like lots of them.

03:45.000 --> 03:46.000
That's simple definition.

03:46.000 --> 03:47.000
We have lots of them.

03:47.000 --> 03:52.000
So I'm going to talk about like one of them, but it could be any of them.

03:52.000 --> 03:55.000
So we think start with a loop.

03:55.000 --> 04:01.000
The whole story starts with a loop because when I started this, I really like I opened

04:01.000 --> 04:06.000
my editor and I saw something which I hadn't seen since school.

04:06.000 --> 04:09.000
It's an empty directory.

04:09.000 --> 04:10.000
It's very strange.

04:10.000 --> 04:16.000
Like really first as a Rails developer, I'm really used to Rails new and then you get

04:16.000 --> 04:17.000
like everything.

04:17.000 --> 04:20.000
You get folders, tree, substructure.

04:20.000 --> 04:24.000
You get the config directory, you get the app directory.

04:24.000 --> 04:30.000
You, like there's drawers everywhere about what you expect to put things.

04:30.000 --> 04:35.000
In this case, I just like create a new folder and it was empty.

04:35.000 --> 04:38.000
I'm a firm believer in emergent design.

04:38.000 --> 04:45.000
So I started immediately like new file, worker.rb, make a loop, while true, read, perform, delete

04:45.000 --> 04:46.000
message.

04:46.000 --> 04:48.000
I'm done.

04:48.000 --> 04:49.000
It was nice.

04:49.000 --> 04:55.000
Like it was, I knew it was not the end, but it was capturing whatever I was, I knew about

04:55.000 --> 04:56.000
my process.

04:56.000 --> 04:59.000
It was a single level of abstraction.

04:59.000 --> 05:03.000
So I knew it was a good start, but it wasn't.

05:03.000 --> 05:11.000
It wasn't a good start because I was already forgetting like my main tool when doing Rails

05:11.000 --> 05:15.000
apps, which was going to be my main tool when doing any app.

05:15.000 --> 05:16.000
It's tests.

05:16.000 --> 05:21.000
Anybody who knows me know that I'm a firm believer in tests.

05:21.000 --> 05:22.000
And it's a policy.

05:22.000 --> 05:24.000
It's not a religion, but it's a policy.

05:24.000 --> 05:26.000
This is how I write code.

05:26.000 --> 05:31.000
I do believe in it, but you mileage may vary.

05:31.000 --> 05:34.000
But for me, it was the beginning.

05:34.000 --> 05:39.000
And it's funny because I knew I was going to write loop, the loop of my program, but I

05:39.000 --> 05:43.000
was also starting another loop, the loop of my process.

05:43.000 --> 05:46.000
And this is what tests are for me.

05:46.000 --> 05:50.000
Test first does not mean you do test, then you do code, then you're done.

05:50.000 --> 05:53.000
Test first means your first step in the journey is test.

05:53.000 --> 05:57.000
Then code, then test, then code, then test, then code, then test, then code.

05:57.000 --> 05:59.000
That's what it means to me to do test.

05:59.000 --> 06:00.000
But I did it wrong.

06:00.000 --> 06:01.000
I started with code.

06:01.000 --> 06:03.000
So I tried again.

06:03.000 --> 06:04.000
I deleted my file.

06:04.000 --> 06:06.000
I created a spec directory.

06:06.000 --> 06:11.000
I created a spec file explaining what I knew about it.

06:11.000 --> 06:21.000
And I was happier because test is the file that depicts my best understanding of what

06:21.000 --> 06:25.000
I currently believe is the success.

06:26.000 --> 06:31.000
And I need that because I'm going to write code right after the word.

06:31.000 --> 06:35.000
And once you're deep in the code, you're super focused.

06:35.000 --> 06:37.000
You forget about landscape.

06:37.000 --> 06:40.000
You don't know what comes next.

06:40.000 --> 06:41.000
You might have a story.

06:41.000 --> 06:44.000
You might have specification requirements.

06:44.000 --> 06:46.000
You name it.

06:46.000 --> 06:52.000
But I do believe that a story or specification is like coordinates of where you're supposed

06:52.000 --> 06:54.000
to land.

06:54.000 --> 07:05.000
The whole puzzle, the whole activity of development, of programming, is like playing golf in the

07:05.000 --> 07:07.000
fog by night.

07:07.000 --> 07:09.000
You know where you are at the beginning.

07:09.000 --> 07:12.000
You sort of know when you want to land.

07:12.000 --> 07:16.000
But after your first shot, you're going to be lost.

07:16.000 --> 07:21.000
It doesn't matter even anymore what you're supposed to land because you've given your first

07:21.000 --> 07:23.000
shot and you don't even know where you are anymore.

07:23.000 --> 07:26.000
I'm using tests as torches in the night.

07:26.000 --> 07:28.000
So I read my specs.

07:28.000 --> 07:29.000
I write some tests.

07:29.000 --> 07:30.000
This is my belief.

07:30.000 --> 07:32.000
I'm going to follow that path.

07:32.000 --> 07:35.000
And then I shoot my first shot.

07:35.000 --> 07:38.000
Hopefully I'm going to reach my first torch in the night.

07:38.000 --> 07:43.000
When I have reached that one, I'm going to go to my second torch again and again.

07:43.000 --> 07:49.000
But my loop is that my test is only my best understanding of my success.

07:49.000 --> 07:50.000
So my test is going to evolve.

07:50.000 --> 07:53.000
I'm going to move my torches and I'm going to move my ball.

07:53.000 --> 07:56.000
And this is how they make sense together.

07:56.000 --> 07:57.000
Back to the story.

07:57.000 --> 08:03.000
I wrote my test, was happy with my understanding, run it, and it failed.

08:03.000 --> 08:05.000
It was a catastrophe.

08:05.000 --> 08:07.000
And why did it fail?

08:07.000 --> 08:10.000
Well, because it couldn't find our spec.

08:10.000 --> 08:12.000
Because I didn't bundle it.

08:12.000 --> 08:14.000
Because it couldn't find bundler.

08:14.000 --> 08:17.000
Like, that is how empty the whole story was.

08:17.000 --> 08:19.000
Like, I didn't even have bundler.

08:19.000 --> 08:21.000
Okay, so bundling is always easy.

08:21.000 --> 08:24.000
Bringing my dependency, starting my gem file.

08:24.000 --> 08:26.000
I need to run my spec.

08:26.000 --> 08:27.000
Run it again.

08:27.000 --> 08:28.000
Well, it still fails.

08:28.000 --> 08:29.000
But for a better reason.

08:29.000 --> 08:31.000
And that's the whole point of TG, right?

08:31.000 --> 08:35.000
You have to fail, but for a better reason than the previous failure.

08:35.000 --> 08:40.000
So now it's failing because it doesn't know about what is a queue,

08:40.000 --> 08:44.000
what is the method we see in the queue, what is a message,

08:44.000 --> 08:47.000
what is a processor, what does perform even means.

08:47.000 --> 08:49.000
Well, that makes me happy.

08:49.000 --> 08:56.000
Because now I can actually write more tests about what do I believe is a queue at this stage.

08:56.000 --> 09:01.000
Why do I believe is a processor, what do I believe should do the receive method.

09:01.000 --> 09:08.000
And this was really the starting of both my loops.

09:08.000 --> 09:12.000
I got my main loop back, but I got my working loop as well.

09:12.000 --> 09:13.000
I got a lot of tests.

09:13.000 --> 09:17.000
I knew that trying to make them go green would just generate more tests.

09:17.000 --> 09:18.000
Trying to make them go green.

09:18.000 --> 09:22.000
I got my actual work loop.

09:22.000 --> 09:24.000
Right.

09:24.000 --> 09:28.000
So, test code, test code, test code.

09:28.000 --> 09:29.000
I was in the middle of it.

09:29.000 --> 09:37.000
And every single of the code file was starting with like probably five to ten require or require relative.

09:37.000 --> 09:40.000
And I wasn't happy with that.

09:41.000 --> 09:44.000
First of all, because it is boilerplate, it's noise.

09:44.000 --> 09:45.000
I don't like noise.

09:45.000 --> 09:51.000
Also, because I want my code files to be about the responsibility they're supposed to hold.

09:51.000 --> 09:59.000
And knowing what files contains the dependency that this file depends upon,

09:59.000 --> 10:04.000
it's not the responsibility of each file to know where do I store the other responsibilities.

10:04.000 --> 10:05.000
That was wrong.

10:05.000 --> 10:07.000
And this is not something we have with Rails.

10:07.000 --> 10:15.000
I realized that we actually get something super nice from Rails is put any file in any sub directory of app folder,

10:15.000 --> 10:16.000
and you get it.

10:16.000 --> 10:17.000
It's like magic.

10:17.000 --> 10:24.000
Once you have to start all your require by hand, it felt wrong.

10:24.000 --> 10:25.000
So, I Googled.

10:25.000 --> 10:27.000
I got a few options.

10:27.000 --> 10:33.000
And the best one, which is actually the one which is currently adopted by Rails, was using SideFerq.

10:33.000 --> 10:35.000
Hopefully, I'm pronouncing it right.

10:35.000 --> 10:37.000
It's written in my speaker mode.

10:37.000 --> 10:48.000
And that stuff helped me, like, auto load the constants I was looking for by looking them up in my lib directory.

10:48.000 --> 10:49.000
Default config.

10:49.000 --> 10:52.000
I'm happy as far as I know this is what I need.

10:52.000 --> 11:00.000
But reading the rest of SideFerq, I also realized that this enables you to use short names.

11:00.000 --> 11:04.000
So, if you are in the same namespace, you can just mention a constant by a short name.

11:04.000 --> 11:05.000
Well, obviously, I want that.

11:05.000 --> 11:07.000
I'm doing that in Rails, so I want that again.

11:07.000 --> 11:12.000
It's also handling multithread code loading.

11:12.000 --> 11:16.000
I have no idea if I'm going to need that, but I certainly don't want to handle that myself.

11:16.000 --> 11:20.000
It sounds like something I really don't want to handle myself.

11:20.000 --> 11:24.000
And it also handle code reloading, which is not something I'm going to use because of TDD.

11:24.000 --> 11:26.000
But again, this is my approach.

11:26.000 --> 11:29.000
I know that most people don't do that.

11:29.000 --> 11:33.000
And code reloading is a very important part of code loading.

11:33.000 --> 11:43.000
So, SideFerq was like my first take, my first really great companion that I found along the way.

11:43.000 --> 11:46.000
The second one was dry container.

11:46.000 --> 11:51.000
Now, small disclaimer, I knew from the stuff that I was going to use dry gems because I wanted to.

11:51.000 --> 11:56.000
And as Kevin said, it's also a little bit about finding joy.

11:56.000 --> 12:02.000
So, I wanted to heavily rely on dry gems, but I wanted to wait until the use case was there.

12:02.000 --> 12:11.000
I wanted, because I did not only want to skip the requires, I wanted to not know the classes.

12:11.000 --> 12:14.000
I wanted to not call new in the middle of my code.

12:14.000 --> 12:16.000
My code is about business logic.

12:16.000 --> 12:18.000
Most of the code is about business logic.

12:18.000 --> 12:25.000
I wanted to separate, sorry, the logic about creating objects and the logic about like, I need something.

12:25.000 --> 12:29.000
And most of the time, when you're in a controller, in a Rails controller,

12:29.000 --> 12:32.000
you don't even care like where does the request object comes from.

12:32.000 --> 12:34.000
You're just like, okay, I want a request object.

12:34.000 --> 12:36.000
Just make it happen.

12:36.000 --> 12:44.000
If you're in a view, you don't care about what the view context comes from.

12:44.000 --> 12:45.000
You just have it.

12:45.000 --> 12:46.000
You just want it.

12:46.000 --> 12:52.000
And it's really comfortable to write code with just focusing on like using the stuff you need,

12:52.000 --> 12:55.000
not focusing on how you get them.

12:55.000 --> 12:58.000
So, this is what dry container brings.

12:59.000 --> 13:05.000
I've been using dry system, which is like dry container for handling all of that, and dry injector.

13:05.000 --> 13:12.000
And dry injector basically works hand in hand with dry container and allows you to call your services,

13:12.000 --> 13:15.000
call your dependencies by the small name, by the first name.

13:15.000 --> 13:20.000
You give a name to an object and then you can basically say, okay, I want this object.

13:20.000 --> 13:21.000
I don't want this class.

13:21.000 --> 13:23.000
I don't want to instantiate that class.

13:23.000 --> 13:26.000
I want specifically that object.

13:26.000 --> 13:27.000
And I'm going to use it.

13:27.000 --> 13:29.000
And I don't even care what its class is for.

13:29.000 --> 13:31.000
I want that object by name.

13:34.000 --> 13:39.000
Interestingly, this had almost no effect on the test.

13:39.000 --> 13:47.000
Even though it's a very different approach, I still had most of my tests instantiate object by themselves.

13:47.000 --> 13:48.000
Why?

13:48.000 --> 13:51.000
Because unit tests actually give a lot of fake dependencies.

13:51.000 --> 13:52.000
That's the point of unit, right?

13:52.000 --> 13:55.000
You want to test a single unit.

13:55.000 --> 13:59.000
So I was still building my subject into tests manually.

13:59.000 --> 14:07.000
And for the larger, the broader tests, I actually wanted to use the container set up correctly

14:07.000 --> 14:11.000
because I wanted to test that things were correctly wired together.

14:11.000 --> 14:17.000
So even though dry containers is like, oh, some you can stub and fake and change whatever you want.

14:17.000 --> 14:24.000
I didn't stub it because I was either using it and testing it or not using it at all in my test.

14:25.000 --> 14:28.000
And...

14:28.000 --> 14:29.000
Sorry.

14:29.000 --> 14:30.000
Yep.

14:30.000 --> 14:34.000
Yeah, I'm still in time.

14:34.000 --> 14:42.000
Dry container also brings something else, which is quite interesting.

14:42.000 --> 14:44.000
It's a settings, a settings object.

14:44.000 --> 14:50.000
And I realized very soon that the settings object was the object that I was injecting everywhere.

14:50.000 --> 14:55.000
Almost every part of my system needed to access settings.

14:55.000 --> 14:57.000
So I was injecting it everywhere.

14:57.000 --> 14:58.000
It was awesome.

14:58.000 --> 15:04.000
And dry settings provide some really interesting value.

15:04.000 --> 15:10.000
First of all, it allows any of the settings to be overridden by environment variable,

15:10.000 --> 15:12.000
which is quite important.

15:12.000 --> 15:18.000
If you know about 12 factors, it is one of the aspects you want for your config to be overridden

15:18.000 --> 15:21.000
by the environment that your program runs in.

15:21.000 --> 15:23.000
So that was the first part.

15:23.000 --> 15:32.000
And the second part is that you can coerce, you can define the type of your settings.

15:32.000 --> 15:37.000
Because if you work with environment variables, everything is a string.

15:37.000 --> 15:40.000
But when you work in your system, not everything is a string.

15:40.000 --> 15:45.000
We do have a lot of strings, but we have dates, we have integers.

15:45.000 --> 15:47.000
We have a lot of system.

15:47.000 --> 15:50.000
And usually what we do is we just parse them.

15:50.000 --> 15:55.000
Dry types allows you to create all types, name them for starters.

15:55.000 --> 16:00.000
Also naming things is probably the most important stuff we do in our work, I believe.

16:00.000 --> 16:07.000
You can name your type and get them correctly and get your settings in the proper types,

16:07.000 --> 16:14.000
which brings me to my next slide about dry types.

16:14.000 --> 16:16.000
So dry type creates a contract.

16:16.000 --> 16:22.000
It says, okay, this value, this settings, it has to be a phone number.

16:22.000 --> 16:25.000
And I'm going to explain exactly what is a phone number.

16:25.000 --> 16:31.000
And I'm also going to coerce like a string into a phone number, which means at the end of the day,

16:31.000 --> 16:37.000
I either have an error or I do have a phone number, which is exactly the object I want.

16:37.000 --> 16:40.000
And it makes a big difference.

16:40.000 --> 16:50.000
I don't know if any of you have ever created a class like phone number, like age, like bucket name.

16:50.000 --> 16:57.000
If you read correctly the literature about object-oriented design, we are supposed to do that.

16:57.000 --> 17:04.000
We are sort of supposed to do that, like subclass string when we want to make a first name.

17:04.000 --> 17:08.000
To be honest with you, I've never done that in my life.

17:08.000 --> 17:11.000
I've always used string and it's not a first name.

17:11.000 --> 17:12.000
It's a string.

17:12.000 --> 17:13.000
I know it's a first name.

17:13.000 --> 17:20.000
I know I'm not going to use all the methods of string, but the variable is name, first name, that's enough.

17:20.000 --> 17:25.000
Using types allows us to actually have proper types, more meaningful types,

17:25.000 --> 17:30.000
without creating full-blown classes for everything.

17:30.000 --> 17:34.000
Well, settings is one thing.

17:34.000 --> 17:37.000
But this contract, it can really be used for something else.

17:37.000 --> 17:40.000
It can be used for app input.

17:40.000 --> 17:44.000
When you are working in a web application, app input is a request.

17:44.000 --> 17:47.000
This is where most of our payload comes from.

17:47.000 --> 17:52.000
In our case, the app input was messaged from a queue, but the concept was very similar.

17:52.000 --> 18:02.000
As soon as we got one message, we treated it in a very similar fashion as we would have treated a request.

18:02.000 --> 18:09.000
When working with app input as a web, there's a very known pattern for handling that input,

18:09.000 --> 18:13.000
for validating that input, for correcting that input to everything that you wanted.

18:13.000 --> 18:16.000
These are form objects.

18:16.000 --> 18:21.000
We basically reused the same.

18:21.000 --> 18:28.000
I realized that I'm doing my slide in the wrong order, but you don't care because you don't have the order.

18:28.000 --> 18:30.000
But that's okay.

18:30.000 --> 18:36.000
We used kind of form object in the form of a dry contract.

18:36.000 --> 18:41.000
It comes from dry validation, that is the gem we have been using.

18:41.000 --> 18:46.000
Dry validation is really about two pillars.

18:46.000 --> 18:48.000
The first one is about typing.

18:48.000 --> 18:51.000
Eventually, it leverages dry types.

18:51.000 --> 18:57.000
It ensures that you get the keys of your payload that you expect, that you get the values that you expect,

18:57.000 --> 19:04.000
that basically your data is of the type you expect, that's the schema, that's the structure.

19:04.000 --> 19:10.000
Once you have the proper types, you still have business logic to handle.

19:10.000 --> 19:15.000
This is the second pillar of dry validation.

19:15.000 --> 19:20.000
A typical example would be if you have to handle a deadline.

19:20.000 --> 19:23.000
Imagine that somewhere in your payload there's a deadline.

19:23.000 --> 19:28.000
The first pillar would ensure that the deadline is actually a date because you get a string.

19:28.000 --> 19:33.000
Hopefully it's an ISO 8601 string, but it could be anything else.

19:33.000 --> 19:36.000
You want to coerce that in a string, you want to ensure that you have a string.

19:36.000 --> 19:39.000
If it's not coerceable into a string, you want the first error.

19:39.000 --> 19:45.000
But now that you have a string, you also need to validate that this actual date is in the future.

19:45.000 --> 19:47.000
This is what the second pillar is.

19:47.000 --> 19:50.000
You can create rules, business rules.

19:50.000 --> 19:55.000
That means that once your payload goes through the dry validation mechanism,

19:55.000 --> 20:01.000
you actually get a very valid, very reliable payload from a typing perspective,

20:01.000 --> 20:05.000
but also from a business perspective.

20:05.000 --> 20:10.000
Once we have that payload, what do we want to do with that?

20:10.000 --> 20:15.000
We actually want to process it.

20:15.000 --> 20:19.000
For that, we are using a pattern which is named Interactor.

20:19.000 --> 20:22.000
At least we used to use a gem which is named Interactor.

20:22.000 --> 20:26.000
You can think of an Interactor a little bit like an operation in Trailblazer.

20:26.000 --> 20:30.000
I don't know if anybody has used Trailblazer previously.

20:30.000 --> 20:32.000
No? Okay.

20:32.000 --> 20:34.000
All right. I'm going to go back.

20:34.000 --> 20:39.000
The idea of an Interactor is that this is the entry point to your business layer.

20:39.000 --> 20:44.000
Because the entry point to your application to most of the web application are the controllers.

20:44.000 --> 20:48.000
This is how... I'm not talking about the rules.

20:48.000 --> 20:51.000
Let's consider that the entry point is the controller.

20:51.000 --> 20:55.000
But that's not true because sometimes your entry point is your test.

20:55.000 --> 20:57.000
Sometimes your entry point is a rate task.

20:57.000 --> 20:59.000
Sometimes your entry point is an active job.

20:59.000 --> 21:02.000
Sometimes your entry point is a channel.

21:02.000 --> 21:07.000
So you actually get a lot of entry points into your app.

21:07.000 --> 21:12.000
But at the business level, you don't really care if you want to delete a user

21:12.000 --> 21:17.000
because of a GraphQL request, of a REST request, of an active job.

21:17.000 --> 21:21.000
You want to delete a user. It's the same business unit.

21:21.000 --> 21:27.000
And this is how we encapsulate things we are using in Interactor.

21:27.000 --> 21:31.000
One Interactor is responsible for one business unit.

21:31.000 --> 21:36.000
And well, very fortunately, DRI has a solution for us.

21:37.000 --> 21:40.000
It's a name DRI Transaction.

21:40.000 --> 21:42.000
So their name for it is a transaction.

21:42.000 --> 21:46.000
It allows you to create a series of steps.

21:46.000 --> 21:51.000
It relies on DRI Modad because each step can give you a result.

21:51.000 --> 21:57.000
And if the result is a success, then the next step is going to happen.

21:57.000 --> 22:00.000
If the result is a failure, then the next step is not going to be done.

22:00.000 --> 22:02.000
You're going to keep your failure.

22:02.000 --> 22:05.000
This is known as the railway oriented programming.

22:05.000 --> 22:07.000
Nothing related to rails.

22:07.000 --> 22:12.000
It's just because you either stay on your success track, like train track,

22:12.000 --> 22:16.000
or at each step you have a junction to your failure track.

22:16.000 --> 22:20.000
Well, the thing is we didn't use DRI Transaction.

22:20.000 --> 22:23.000
So I wanted to let you know because I would really recommend that you use it.

22:23.000 --> 22:28.000
I wanted to use it, but also we have a team of several developers

22:28.000 --> 22:30.000
who are used to our Interactors.

22:30.000 --> 22:34.000
And it sounded like a better idea to use what everybody knew

22:34.000 --> 22:36.000
than trying to reinvent the wheel.

22:36.000 --> 22:38.000
We had something, it's working well, everybody knows it well.

22:38.000 --> 22:42.000
So this is like my manager voice talking.

22:42.000 --> 22:45.000
If it's end broken, broken, don't fix it.

22:45.000 --> 22:50.000
But if you're doing it from the start, give a chance to DRI Transaction and DRI Modad.

22:50.000 --> 22:57.000
At this point in the talk, I hoped to try my own definition of DRI Modad,

22:57.000 --> 23:02.000
of Monad, what is a Monad, which is probably going to take the next two hours.

23:02.000 --> 23:04.000
So let's keep it.

23:06.000 --> 23:14.000
So the end of this slide is about why do we want to do all that validation early?

23:14.000 --> 23:17.000
And this was also something a bit new.

23:17.000 --> 23:19.000
First of all, like failing early is a good idea.

23:19.000 --> 23:26.000
But it was not enough because doing the business validation at each step would have made more sense.

23:26.000 --> 23:30.000
It's just easier to keep the business steps together.

23:30.000 --> 23:38.000
It makes more sense if you want to check some permission, then delete a record, then send an email.

23:38.000 --> 23:43.000
It makes sense that you do everything related to sending the email at the sending email step.

23:43.000 --> 23:48.000
It doesn't really make sense to already check stuff from the start.

23:49.000 --> 23:57.000
But the thing is, in Rails, we are very much used to a highly rollback-able environment

23:57.000 --> 24:01.000
because most of what we do, well, sending email doesn't count,

24:01.000 --> 24:04.000
but most of what we do is manipulate the database.

24:04.000 --> 24:11.000
And this is a huge comfort being able to say, my record.transaction do blah, blah, blah, blah, blah, blah, blah, blah, blah, blah.

24:11.000 --> 24:15.000
If anything goes wrong, just roll back and done, nothing has happened.

24:15.000 --> 24:20.000
When you're doing a microservice, at least what we are doing, nothing is rollback-able.

24:20.000 --> 24:28.000
Everything you do, if you send an API request to something, if you delete a file, download a file, create a file, there's no rollback to that.

24:28.000 --> 24:35.000
And this is why it was so important to check as much as we could right from the start.

24:36.000 --> 24:39.000
All right, next step.

24:40.000 --> 24:42.000
Next step, next challenge.

24:43.000 --> 24:52.000
The next challenge was an interesting one, as every challenge, because it was about design and design opinion.

24:52.000 --> 24:58.000
And there's no truth, there's no strong truth in design opinion.

24:58.000 --> 25:00.000
So what was the challenge exactly?

25:00.000 --> 25:08.000
The challenge was that we realized we were not using dry containers properly.

25:08.000 --> 25:12.000
It felt like we were supposed to use it in a new way.

25:12.000 --> 25:14.000
Why was that?

25:16.000 --> 25:22.000
The reason was that we are very used to object-oriented design, object-oriented programming,

25:22.000 --> 25:30.000
which means we are putting together state and behavior in small objects, and they are responsible for doing that stuff.

25:31.000 --> 25:37.000
And the dry system, the dry container, was pushing us to use stateless objects,

25:37.000 --> 25:42.000
because that's what you could enjoy if you want to inject something everywhere.

25:42.000 --> 25:44.000
It better be stateless.

25:44.000 --> 25:49.000
But the code we wanted to write, because we have a lot of experience with that, was stateful.

25:49.000 --> 25:54.000
We don't want a command wrapper.

25:55.000 --> 26:01.000
We want a command execution specifically about this option.

26:01.000 --> 26:04.000
We want to ask a specific invocation.

26:04.000 --> 26:06.000
We don't want the full program.

26:06.000 --> 26:11.000
So it was very important to be able to write the code that we wanted to write,

26:11.000 --> 26:15.000
but it was also important to use the tools properly.

26:16.000 --> 26:21.000
And initially what we did is we had that big interactor, or big entry point,

26:21.000 --> 26:26.000
get injected with a ton of stuff from the container.

26:26.000 --> 26:29.000
It was getting all the services that it would eventually use,

26:29.000 --> 26:34.000
and that interactor was instantiating all the small objects,

26:34.000 --> 26:37.000
the small life cycle objects that it was going to use,

26:37.000 --> 26:41.000
and it was instantiating those objects, giving them their state,

26:41.000 --> 26:45.000
so maybe the current date, the current user, the current payload,

26:45.000 --> 26:48.000
and all the dependencies that the objects needed.

26:48.000 --> 26:51.000
So maybe there's a command service, maybe there's an API client,

26:51.000 --> 26:54.000
so the interactor was instantiating all of that,

26:54.000 --> 26:59.000
which means the interactor knew about almost everything.

26:59.000 --> 27:01.000
There's a name for that.

27:01.000 --> 27:02.000
GodObject.

27:02.000 --> 27:04.000
And it's a bad name.

27:04.000 --> 27:07.000
So we knew we were doing something wrong.

27:07.000 --> 27:12.000
We had a small discussion, and we realized that actually the literature

27:12.000 --> 27:14.000
again had a solution made for that.

27:14.000 --> 27:16.000
There's a pattern made for that.

27:16.000 --> 27:18.000
The pattern is factory.

27:18.000 --> 27:23.000
So what we eventually did is that we created new services, factories,

27:23.000 --> 27:25.000
very shallow services.

27:25.000 --> 27:30.000
Each factory was injected with the services that it needed,

27:30.000 --> 27:34.000
and the interactor was simply injected with the factories,

27:34.000 --> 27:36.000
and the interactor was just asking the factory,

27:36.000 --> 27:42.000
well, give me a command invocation specifically about this file,

27:42.000 --> 27:47.000
about this API, about this payload.

27:47.000 --> 27:53.000
And it's not a fun because it was so difficult to realize at first that we needed that,

27:53.000 --> 27:58.000
but at the same time it was so obvious what was the solution.

27:58.000 --> 28:04.000
It also raised an interesting comparison with a former colleague of mine

28:04.000 --> 28:06.000
who told me he was like a functional programmer.

28:06.000 --> 28:12.000
He, I'm not going to say despised, but he despised object-oriented programming.

28:12.000 --> 28:13.000
Well, I said it.

28:13.000 --> 28:18.000
And he told me, you know, an object is just a set of partially applied function.

28:18.000 --> 28:22.000
He was very like this day in for like, oh, it's just a set of partially applied function.

28:22.000 --> 28:24.000
We have like, we have object at home.

28:24.000 --> 28:26.000
Well, it's not the same.

28:27.000 --> 28:31.000
But to be honest, like, introducing those factories gave me that feeling

28:31.000 --> 28:34.000
because we had like those functions.

28:34.000 --> 28:38.000
We were partially applying all the dependencies.

28:38.000 --> 28:40.000
That's like first partial application,

28:40.000 --> 28:43.000
and then we were partially applying the state.

28:43.000 --> 28:48.000
It also opened our mind about what is stateless, what is stateful.

28:48.000 --> 28:52.000
Usually state is like all your instance variables.

28:52.000 --> 28:54.000
It's not really true.

28:54.000 --> 28:56.000
You don't see things like this anymore.

28:56.000 --> 29:02.000
Like your dependencies might still make you stateless.

29:02.000 --> 29:08.000
And your state is really what makes an object throwable.

29:08.000 --> 29:12.000
So if it's a reusable object, it's stateless.

29:12.000 --> 29:15.000
If it's like a one-use object, it's stateful.

29:15.000 --> 29:17.000
That's sort of our new definition of that.

29:17.000 --> 29:20.000
And factories helps us creating one-use object

29:20.000 --> 29:24.000
because factories are all stateless object.

29:24.000 --> 29:28.000
Well, I felt bad creating the slide without mentioning a single dry gem.

29:30.000 --> 29:36.000
So I also want to bring one here, is the dry initializer gem.

29:36.000 --> 29:39.000
And to be honest, this is my favorite, and it's so small.

29:39.000 --> 29:42.000
The thing is this is so small that it's crazy that this is my favorite gem.

29:42.000 --> 29:44.000
It creates contractors.

29:44.000 --> 29:46.000
It just creates an initialized method.

29:46.000 --> 29:48.000
But why does it matter?

29:48.000 --> 29:51.000
Because if you are very strict about it,

29:51.000 --> 29:55.000
all your initializer very probably look the same.

29:55.000 --> 29:57.000
It's like you pass them arguments,

29:57.000 --> 30:00.000
and then you store them into instance variable.

30:00.000 --> 30:04.000
Nothing more because doing business in initializer is a bad idea.

30:04.000 --> 30:07.000
So you always get the same initializer times and again,

30:07.000 --> 30:09.000
and it makes no sense, and it creates noise.

30:09.000 --> 30:12.000
And if you're used to more style guides,

30:12.000 --> 30:14.000
it has to be at the top of the file,

30:14.000 --> 30:17.000
and it also takes a very important part, focus,

30:17.000 --> 30:19.000
because top of the file is very important.

30:19.000 --> 30:21.000
So dry initializer, just do that.

30:21.000 --> 30:28.000
It says you can create one line for each dependency or state that you want.

30:28.000 --> 30:30.000
You can give it a type. You don't have to,

30:30.000 --> 30:32.000
but if you have a drive type, you might want to.

30:32.000 --> 30:34.000
You can give it a default value,

30:34.000 --> 30:37.000
and you automatically get an initializer that accepts them,

30:37.000 --> 30:42.000
and you automatically create an ATTR reader for each of the dependencies.

30:42.000 --> 30:45.000
You don't want the reader. You don't have to, but by default, you get that.

30:45.000 --> 30:48.000
And that's it, and you just transform something very long and noisy

30:48.000 --> 30:50.000
into a series of lines.

30:53.000 --> 30:56.000
We used to have ATTR reader anyways.

30:56.000 --> 31:01.000
That's most of our classes have ATTR, one line for ATTR reader anyways.

31:01.000 --> 31:03.000
So it changed nothing in terms of noise.

31:03.000 --> 31:06.000
It changed everything in terms of clarity, intention,

31:06.000 --> 31:12.000
and anyone reading a file now gets something directly by reading those lines.

31:12.000 --> 31:15.000
And yeah, I'm still on time.

31:15.000 --> 31:20.000
Well, we were done with the code application.

31:20.000 --> 31:23.000
Of course, we had additional challenges,

31:23.000 --> 31:26.000
but eventually using those tools and approaches,

31:26.000 --> 31:30.000
we reached up the end of the application, and we were done, right?

31:30.000 --> 31:32.000
Well, no, we still had to package it.

31:32.000 --> 31:35.000
We still had to deploy it, because as long as we were actually solving problems,

31:35.000 --> 31:37.000
we had nothing.

31:37.000 --> 31:42.000
This is again a time when we realized how rich is the Rails ecosystem,

31:42.000 --> 31:48.000
because for deployment, you either get services like Heroku or similar services,

31:48.000 --> 31:53.000
or using Capistrano, which does everything for you.

31:53.000 --> 31:56.000
You write one CAP file and everything is magic.

31:56.000 --> 32:01.000
When we had to deploy, we were like, yeah, we have files with code,

32:01.000 --> 32:04.000
but we still have no application.

32:04.000 --> 32:08.000
So we get some help from partners about that.

32:08.000 --> 32:11.000
We use Docker Compose locally for creating containers.

32:11.000 --> 32:14.000
We use Kubernetes remotely for deploying them.

32:14.000 --> 32:17.000
We use Helm for actually doing the deployment.

32:17.000 --> 32:20.000
And this led us to realize that we still had problems,

32:20.000 --> 32:23.000
because we had no observability.

32:23.000 --> 32:27.000
We had very difficult access to the log files,

32:27.000 --> 32:33.000
so there was still a lot of stuff we didn't have.

32:33.000 --> 32:37.000
So what we did is we introduced Yabbaida from Evil Martian.

32:37.000 --> 32:40.000
I don't know if anybody is from Evil Martian here,

32:40.000 --> 32:46.000
but if you are and if you watch us, like, thank you, you're awesome Evil Martian.

32:46.000 --> 32:50.000
So we used Yabbaida, which is an observability framework.

32:50.000 --> 32:55.000
It allows you to mention what you want to observe, create metrics,

32:55.000 --> 32:58.000
without having to care like where you intend to put those metrics,

32:58.000 --> 33:00.000
what we intend to do with those metrics.

33:00.000 --> 33:03.000
And then another part of Yabbaida, you can mention, like,

33:03.000 --> 33:04.000
actually what you want to do.

33:04.000 --> 33:05.000
You can separate the two.

33:05.000 --> 33:11.000
So your business logic is not riddled with, like, technical details about monitoring.

33:11.000 --> 33:16.000
So this observability allows us to expose some metrics,

33:16.000 --> 33:20.000
which in turn enabled us to create autoscaling to measure health.

33:20.000 --> 33:23.000
So these are typically stuff that you get for free in Rails

33:23.000 --> 33:26.000
if you're using your relic or data.

33:26.000 --> 33:31.000
But we had to do it by hand.

33:31.000 --> 33:35.000
And we finally reached our latest challenge,

33:35.000 --> 33:39.000
because we are not experts in Helm or Kubernetes.

33:39.000 --> 33:42.000
We are actually very noob in that.

33:42.000 --> 33:44.000
So we had partners helping us.

33:44.000 --> 33:49.000
But those partners are also responsible for, like, running and ensuring that

33:49.000 --> 33:51.000
our app is working properly.

33:51.000 --> 33:57.000
So the way the agreement we had with them is they handled their own repo

33:57.000 --> 33:59.000
with everything they do about us.

33:59.000 --> 34:03.000
And we have our own repo with our code base.

34:03.000 --> 34:06.000
And the problem we realized, and we still haven't solved,

34:06.000 --> 34:10.000
is that part of the application is actually in the infrastructure.

34:10.000 --> 34:13.000
And this is something we are not used to do in Rails.

34:13.000 --> 34:18.000
But typically the queue we use have a dead-letter queue.

34:18.000 --> 34:22.000
If you try to read something and it fails, so you release,

34:22.000 --> 34:24.000
you retry to receive, it fails.

34:24.000 --> 34:27.000
After sometimes that message, you put it into a dead-letter

34:27.000 --> 34:32.000
because you don't want to lose waste more time trying to handle that.

34:32.000 --> 34:35.000
Another aspect is buckets have life cycle.

34:35.000 --> 34:39.000
If a file is forgotten there after 24 hours, you want to delete that file.

34:39.000 --> 34:42.000
You don't want to pay fees for that file for the rest of your life.

34:42.000 --> 34:44.000
And this is application logic.

34:44.000 --> 34:48.000
Even though it fits in infrastructure, like it is application logic.

34:48.000 --> 34:54.000
And this bothers me because application logic, anyone who clones a repo

34:54.000 --> 34:57.000
should be able to see everything, to know everything.

34:57.000 --> 34:59.000
They don't have to be master at everything.

34:59.000 --> 35:01.000
They don't have to change everything.

35:01.000 --> 35:06.000
But cloning a single repo should explain everything there is to know about this app.

35:06.000 --> 35:08.000
So at the moment we still have those two repo.

35:08.000 --> 35:10.000
One is like focusing on the infrastructure.

35:10.000 --> 35:13.000
One is focusing on the code base.

35:13.000 --> 35:17.000
Hopefully we will solve that very soon.

35:17.000 --> 35:22.000
But with that done, we actually had the app deployed,

35:22.000 --> 35:25.000
monitors scaled, we learned quite a lot.

35:25.000 --> 35:27.000
We actually made a blueprint out of that,

35:27.000 --> 35:31.000
so we are creating several other workers right out of that.

35:31.000 --> 35:36.000
And we feel much more confident actually using Ruby for something else

35:36.000 --> 35:39.000
than web application.

35:39.000 --> 35:41.000
So thank you, everyone, for your time.

35:41.000 --> 35:43.000
Thank you.

35:49.000 --> 35:52.000
Any questions? We have two minutes of questions, hopefully.

35:54.000 --> 35:56.000
You've talked a lot about...

35:56.000 --> 35:59.000
I mean, first you never talked about Rails,

35:59.000 --> 36:02.000
but you actually miss it a lot.

36:02.000 --> 36:06.000
It's pretty funny that it was not about Rails, but actually...

36:06.000 --> 36:08.000
Anyway, you talked a lot about types.

36:08.000 --> 36:11.000
Is that something more to bring to the rest of the ecosystem?

36:11.000 --> 36:13.000
Yeah, that's a very good question.

36:13.000 --> 36:16.000
So the question is, I talked a lot about types.

36:16.000 --> 36:19.000
Do I want to bring that into Rails?

36:19.000 --> 36:22.000
Actually, the interactor is something we do in Rails already,

36:22.000 --> 36:24.000
which means we are using dry validation already,

36:24.000 --> 36:27.000
which means we are using dry types already.

36:27.000 --> 36:30.000
To be fully honest, we don't use it enough.

36:30.000 --> 36:33.000
We sort of use it when we realize that we should have used it before.

36:33.000 --> 36:36.000
So it's like not good enough,

36:36.000 --> 36:38.000
but it is something we are using,

36:38.000 --> 36:41.000
and types have been very helpful in the past already.

36:41.000 --> 36:45.000
And there's a lot of other tools that we have discovered here,

36:45.000 --> 36:49.000
because we had to, and I very much hope that we are going to use them.

36:49.000 --> 36:54.000
But also, my first slide means that I'm no CTO, I'm no manager,

36:54.000 --> 36:57.000
which means I don't get to make those calls anymore.

36:57.000 --> 37:01.000
And it's very important to me that the one who writes the app

37:01.000 --> 37:04.000
are responsible for writing it, maintaining it, running it,

37:04.000 --> 37:07.000
so I can influence, I can give my opinion,

37:07.000 --> 37:10.000
but I don't make those calls anymore.

37:12.000 --> 37:14.000
Yes?

37:14.000 --> 37:17.000
You said that you use dry monot.

37:17.000 --> 37:21.000
What has been, can you tell me more about your experience,

37:21.000 --> 37:24.000
because I used it quite extensively in the past

37:24.000 --> 37:27.000
before they introduced these two notations.

37:27.000 --> 37:31.000
And it was very sticky to the code as in,

37:32.000 --> 37:37.000
it made Ruby not look like Ruby, like something else.

37:37.000 --> 37:41.000
So, if there is something changed there, how's your experience?

37:41.000 --> 37:44.000
All right, so the question is, do I use dry monot?

37:44.000 --> 37:46.000
What do I think of the do notation,

37:46.000 --> 37:49.000
and how Ruby-esque does it feel?

37:49.000 --> 37:50.000
Is that right?

37:50.000 --> 37:51.000
Yes.

37:51.000 --> 37:52.000
Okay.

37:52.000 --> 37:56.000
So I am not using dry monot, except for like toy projects.

37:56.000 --> 37:58.000
So we are not using dry monot in this,

37:58.000 --> 38:01.000
so our own take is using our own interactors.

38:01.000 --> 38:06.000
So whatever I'm going to say is out of my experience on toy projects.

38:06.000 --> 38:09.000
I've learned initially about monads in Haskell.

38:09.000 --> 38:13.000
This is still very painful to me 10 years later.

38:13.000 --> 38:17.000
So my take on monads is like, most of the time,

38:17.000 --> 38:20.000
it's like not the right tool.

38:20.000 --> 38:23.000
And it's something that people,

38:23.000 --> 38:26.000
the learning curve for understanding what is a monad

38:26.000 --> 38:30.000
is so high that once you've earned the right to understand what it is,

38:30.000 --> 38:32.000
you want to put it everywhere.

38:32.000 --> 38:35.000
A little bit like meta-programming.

38:35.000 --> 38:37.000
So this is my take on monads.

38:37.000 --> 38:42.000
I wouldn't force them into anyone who is not very comfortable using them.

38:42.000 --> 38:46.000
I do believe that it is a very elegant solution,

38:46.000 --> 38:51.000
but I also do believe that sometimes a bunch of if-else

38:51.000 --> 38:58.000
makes the team happier than using the best tool for the occasion.

38:58.000 --> 39:02.000
And I don't have any opinion about the do notation and how Ruby-esque it feels.

39:05.000 --> 39:07.000
All right, thank you.

