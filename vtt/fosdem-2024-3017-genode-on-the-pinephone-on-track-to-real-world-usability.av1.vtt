WEBVTT

00:00.000 --> 00:06.840
All right.

00:06.840 --> 00:12.200
Next up we have G-Note on the platform on the track to real-world usability.

00:12.200 --> 00:14.440
Have a big round of applause for Norman.

00:14.440 --> 00:25.000
Thank you very much for the chance to be the second time at this developer room.

00:25.000 --> 00:29.200
I was here one year ago introducing G-Note based phone,

00:29.200 --> 00:32.600
and now I will give you an update what happened in the meanwhile.

00:32.600 --> 00:35.400
So I had very little preparation here,

00:35.400 --> 00:37.240
but I wanted to show some demo source.

00:37.240 --> 00:39.680
If something breaks, please feel with me.

00:39.680 --> 00:42.000
I hope it will run smoothly.

00:42.000 --> 00:45.400
So first, to give you some background.

00:46.900 --> 00:49.480
Microphone is a bit.

00:55.500 --> 00:58.200
I will try.

00:58.200 --> 01:03.680
So the background of what we are doing to just recap.

01:03.680 --> 01:07.320
Like in 2003, my best friend Christian and me,

01:07.320 --> 01:11.720
we had a dream about a truly trustworthy operating system.

01:11.720 --> 01:14.680
We are somehow new from academia,

01:14.680 --> 01:17.640
certain puzzle pieces that should lead us there,

01:17.640 --> 01:19.400
but those puzzle pieces,

01:19.400 --> 01:22.240
each of those seem to belong to a different puzzle each.

01:22.360 --> 01:26.320
So that was quite difficult to align them.

01:26.320 --> 01:27.240
Can you hear me still?

01:27.240 --> 01:32.960
Okay. So it took us a few years to bring them into

01:32.960 --> 01:37.080
alignment to build the first prototype back then.

01:37.080 --> 01:40.600
Once we saw how all this could work,

01:40.600 --> 01:46.360
we were quite motivated to bring it to the real world and

01:46.360 --> 01:51.600
bootstrapped a company in Dresden by ourselves doing contract work.

01:51.600 --> 01:54.760
And with the idea to do our licenses technology.

01:54.760 --> 02:00.560
Fast forward ten years, we kept on working on this.

02:00.560 --> 02:06.440
And during this time, we had grown a small team of ten people.

02:06.440 --> 02:11.600
And at this time, we were able to move our work towards our genoed on our laptops.

02:11.600 --> 02:13.800
This was a bit milestone.

02:13.800 --> 02:16.240
And now a few years later,

02:16.240 --> 02:19.840
we did the first baby steps to also bring it on a mobile phone.

02:19.840 --> 02:21.960
So on the PC, it looks like this.

02:21.960 --> 02:24.200
So this is this good OS.

02:24.200 --> 02:27.880
That's an operating system built on top of the genoed system.

02:27.880 --> 02:30.640
And this is actually also running on this machine right now here.

02:30.640 --> 02:36.800
So that's basically used day to day on our developed machines.

02:36.800 --> 02:39.960
On the phone, what I presented one year ago,

02:39.960 --> 02:42.480
is this system running on the pine phone.

02:44.200 --> 02:49.520
The basic idea is that there is a part of the phone that has

02:49.640 --> 02:53.360
kind of fixed functionality like a feature phone you can think,

02:53.360 --> 02:57.200
or like a boot loader, something that is really fixed.

02:57.200 --> 02:59.400
And then there is a user defined part of the phone

02:59.400 --> 03:04.160
where the user can install software into and switch it in and out.

03:04.160 --> 03:11.240
And I will just give you a quick tour through the user interface.

03:11.240 --> 03:16.920
Let me just log into ARM.

03:17.040 --> 03:20.640
This type into my Linux VM over here.

03:23.720 --> 03:27.080
And let's see if you can get some kind of video running.

03:31.960 --> 03:32.640
Yeah, this one.

03:34.760 --> 03:37.200
So basically, here you see the phone UI.

03:37.200 --> 03:41.200
And the basic UI divides the phone into five categories over here.

03:42.600 --> 03:44.080
Is it doing something or why?

03:44.080 --> 03:45.000
Yeah.

03:45.000 --> 03:49.960
And the device category basically gives you control over physical things,

03:49.960 --> 03:53.000
physical aspects like the brightness or volume,

03:53.000 --> 03:56.440
or control over the microphone like a kill switch for the microphone,

03:56.440 --> 04:00.880
or some power settings like how you want to operate the phone.

04:00.880 --> 04:04.520
And you can see here when I modify the brightness, it has immediate effect.

04:06.680 --> 04:11.960
Then there is a second section that is all related to telephony.

04:11.960 --> 04:15.720
And you see here also the user has complete control over even lower level

04:15.720 --> 04:17.600
aspects like the powering of the phone.

04:17.600 --> 04:23.960
So here the power lines to this phone is really controlled by the user.

04:23.960 --> 04:28.760
So now, for example, when you switch it on, the modem is booted.

04:28.760 --> 04:34.520
And now we interact with the SIM card and the user can type in some PIN to get

04:34.520 --> 04:35.240
access to the network.

04:36.240 --> 04:41.560
And now we can receive calls or initiate calls.

04:41.560 --> 04:45.680
And we can also initiate a mobile data connection,

04:45.680 --> 04:48.640
which I'm going to do now.

04:50.080 --> 04:55.040
So basically, switching on the option to use your mobile data.

04:55.040 --> 04:58.760
So you can see that's also the option to use Wi-Fi.

04:58.760 --> 05:01.200
And now you see the three dots over here.

05:01.200 --> 05:05.280
They are basically telling that there is a currently setting up the connection.

05:05.280 --> 05:09.160
And once this is done, we see an IP address appearing here.

05:10.320 --> 05:12.160
And this means we have a data connectivity.

05:13.320 --> 05:17.880
And with this data connectivity, we can actually now do interesting things like

05:17.880 --> 05:20.480
install photo software.

05:20.480 --> 05:26.720
And the image when you just install it comes with a few example systems,

05:26.720 --> 05:27.520
I would say.

05:27.520 --> 05:32.920
So these are basically systems for the other side of the device.

05:32.920 --> 05:37.000
You can switch these two sides using this gesture here on the left side.

05:37.000 --> 05:40.600
And this is, for example, a very minimalistic example of an interactive

05:40.600 --> 05:46.240
application as a subsystem running on this user defined side of the device.

05:46.240 --> 05:48.440
And there are a few other examples, like, for example,

05:48.440 --> 05:52.840
this small oscilloscope that just shows microphone data.

05:52.840 --> 05:57.400
And you can see, basically, when switching to the other side,

05:57.760 --> 06:00.480
nothing is really visible there.

06:00.480 --> 06:04.360
That's because the microphone is still not enabled.

06:04.360 --> 06:07.040
So the user must enable the microphone first.

06:08.680 --> 06:13.000
And then you can see that the application, the user defined side,

06:13.000 --> 06:16.680
can observe the audio data from the mic.

06:19.000 --> 06:22.600
There are a bunch of other examples.

06:22.600 --> 06:28.320
I think the most interesting one is a web browser that we ported to the system.

06:28.320 --> 06:33.560
So this is based on the Chromium Engine and the Morph browser specifically.

06:33.560 --> 06:39.400
So in order to bring this to our OS, we also had to port, for example,

06:39.400 --> 06:44.000
the Uwuntu Touch UI toolkit, or nowadays called Lumiri UI toolkit,

06:44.000 --> 06:46.520
also enable the GPU and things like that.

06:46.520 --> 06:48.960
And you see here that the browser is running.

06:48.960 --> 06:51.680
It's not super smooth, but you have to keep in mind,

06:51.680 --> 06:53.800
it's a time phone that we are running on.

06:53.800 --> 06:58.800
But it's actually usable, and you can browse those websites and

06:58.800 --> 07:04.240
use these kind of modern JavaScript-based sites also.

07:04.240 --> 07:07.880
I think visiting GitHub also is possible.

07:11.400 --> 07:15.040
Yeah, this was basically what I could show you last year.

07:15.040 --> 07:17.800
So just to get to the set of

07:22.440 --> 07:27.600
this point, and now, okay, you see here,

07:27.600 --> 07:31.600
the number of controls that you may know from the Uwuntu Touch UI project.

07:33.640 --> 07:38.000
Okay, so what do I want to cover this time?

07:38.000 --> 07:41.520
So shortly after my talk here at FOSSTEM,

07:41.520 --> 07:47.760
we published a first image for the community to try out and to get user feedback.

07:47.760 --> 07:49.080
And then once you get user feedback,

07:49.560 --> 07:52.040
of course the problem you have to incorporate a somehow,

07:52.040 --> 07:53.560
you have to do something with this.

07:53.560 --> 07:56.920
And then you want to give the user some new version, the user needs to install it.

07:56.920 --> 08:01.800
And so how can this interplay work to be enjoyable for both sides?

08:01.800 --> 08:06.520
Then I want to also talk a bit about our first wishes by the users,

08:06.520 --> 08:11.760
and then going forward to speak about how to bring software on the device.

08:11.760 --> 08:14.720
So first when speaking about user feedback,

08:14.720 --> 08:17.720
you have this loop where the developer installs it.

08:17.720 --> 08:21.520
The system originally on the SD card following the instructions from the website

08:21.520 --> 08:27.160
gives feedback to the developer, improves the image, publishes it,

08:27.160 --> 08:29.720
and then the user installs into a new version and gives feedback.

08:29.720 --> 08:30.880
And you have this loop.

08:30.880 --> 08:35.880
And now the question is how fast can this loop happen and how frictionless can this be?

08:37.080 --> 08:39.680
Friction comes in at these two places.

08:39.680 --> 08:42.480
So for example, when the user wants to install a new version,

08:42.480 --> 08:44.520
the question is can the user trust the new version?

08:44.520 --> 08:46.200
It downloading something from the internet.

08:46.200 --> 08:48.360
How much work is it to install a new version?

08:48.360 --> 08:53.240
So if this is like a real big operating system that you have to upgrade,

08:53.240 --> 08:56.840
it's really a lot of effort and also a risk.

08:56.840 --> 09:02.520
What happens when you have a regression and you want to roll back to the previous version, for example?

09:02.520 --> 09:06.160
And on the developer side, it comes down to basically labor.

09:06.160 --> 09:11.360
So the developer has to put thoughts and work into improving the images

09:11.360 --> 09:17.200
and then also building it, publishing it, hosting the images for the users.

09:17.200 --> 09:21.800
So these are the costs at the developer side.

09:21.800 --> 09:24.440
That's just how it disturbs you somehow.

09:24.440 --> 09:29.680
This kind of rigging is okay.

09:29.680 --> 09:34.800
So we tried to look at this cycle in a kind of holistic way.

09:34.800 --> 09:40.760
So you see here that the developer cycle can come down to about five to 20 seconds.

09:40.800 --> 09:43.480
So for the image that I will show you in a minute,

09:43.480 --> 09:48.760
the cycle for iterating over this UI to things was about five seconds to 20 seconds,

09:48.760 --> 09:56.480
depending on whether I could start this whole thing on my Linux system or on the Python via fastboot.

09:56.480 --> 09:59.960
And then the publishing of the new version takes about three minutes or

09:59.960 --> 10:02.400
I do a full release, 30 minutes.

10:02.400 --> 10:07.040
So this is all done from my laptop, so I don't need any special hardware for that.

10:07.080 --> 10:14.160
Out of this complete process comes a really small image on that source, about 16 megabytes.

10:14.160 --> 10:16.360
And the user can basically install this.

10:16.360 --> 10:22.560
It's signed by the developers, so there is some kind of integrity protection there.

10:22.560 --> 10:26.760
And the nicest thing is that the installation is very simple and very transparent.

10:26.760 --> 10:29.760
It's basically replacing just one file in the boot directory.

10:29.760 --> 10:33.640
And the user can instantly roll back to another version if some regression occurs.

10:34.640 --> 10:38.800
So let's now try to give this as a demo.

10:38.800 --> 10:42.960
So to do that, I first have to, let me see.

10:48.560 --> 10:53.040
I first have to start a USB webcam over here.

10:53.040 --> 10:55.760
Let me see if this works.

10:55.760 --> 10:56.760
Okay.

10:58.840 --> 11:01.640
Okay, here's the webcam.

11:01.640 --> 11:03.360
Okay, can you see this?

11:03.360 --> 11:05.360
Okay, okay.

11:05.360 --> 11:07.840
So I will switch down.

11:07.840 --> 11:12.560
So now there are a few risks involved because the update will run over the air.

11:12.560 --> 11:16.520
So I hope that I get some kind of connectivity over here.

11:16.520 --> 11:20.280
So now you have seen the boot of the image from SD card.

11:20.280 --> 11:24.520
So it's quite quick to come up, but it's also a small image.

11:24.520 --> 11:27.000
So let's try to connect to the Wi-Fi.

11:32.640 --> 11:35.640
Okay, I think I tested this first and do a stack.

11:35.640 --> 11:37.640
Let me see if I get an IP address.

11:37.640 --> 11:38.640
Ah, I got an IP.

11:38.640 --> 11:39.640
Okay.

11:39.640 --> 11:42.640
So now you can basically go to the software dialogue over here.

11:42.640 --> 11:45.640
There's this tab over there, update.

11:45.640 --> 11:50.640
And one concept is that we can basically select different software sources,

11:50.640 --> 11:52.640
which are basically URLs.

11:52.640 --> 11:55.640
So this is, for example, the software source of my company, JunoLabs.

11:55.640 --> 11:59.640
But I can also select other sources like my colleagues or this guy here,

11:59.640 --> 12:01.640
and Feske, that's me.

12:01.640 --> 12:06.640
And I can basically check what Nfeske has to offer.

12:06.640 --> 12:10.640
So now there are some metadata is downloaded.

12:10.640 --> 12:15.640
And I see, okay, there are different images offered by Nfeske myself.

12:15.640 --> 12:18.640
And I can basically get some information about these different images.

12:18.640 --> 12:23.640
This was the last real release, and there's a new image that's the FOSTA edition.

12:23.640 --> 12:26.640
So let's try to download this one.

12:27.640 --> 12:33.640
And, yeah, I have luck that the wireless connection works well.

12:33.640 --> 12:36.640
So you can see now the progress of downloading.

12:36.640 --> 12:38.640
I can actually see it.

12:42.640 --> 12:47.640
And you can see with these buttons, you can also download the other versions.

12:47.640 --> 12:53.640
So you can have any number of versions downloaded and also from different software sources

12:53.640 --> 12:55.640
and keep them on your system as well.

12:55.640 --> 12:58.640
So we are almost there.

13:04.640 --> 13:10.640
Okay, so now the integrity is checked using openPGB signatures.

13:10.640 --> 13:12.640
So everything went smooth.

13:12.640 --> 13:20.640
And now I can install this image to my system, which is basically copying one file to the boot directory.

13:20.640 --> 13:22.640
And it says, okay, reboot to activate.

13:22.640 --> 13:24.640
So let's do this.

13:24.640 --> 13:28.640
So I go to the device section and I say, okay, reboot.

13:28.640 --> 13:30.640
And I have to confirm it.

13:30.640 --> 13:37.640
And now I'm doing a hardware reset and pressing fingers, crossing fingers.

13:37.640 --> 13:42.640
Sometimes the boot load, ah, now it's actually working.

13:42.640 --> 13:48.640
And now for anyone of you who also grew up in the 80s using Atari 800 computers,

13:48.640 --> 13:51.640
you may recognize the fonts and the color scheme.

13:51.640 --> 13:54.640
So these are inspired by my childhood.

13:54.640 --> 13:57.640
But what you see here is really a custom image.

13:57.640 --> 13:59.640
So I hacked this together in the last week.

13:59.640 --> 14:02.640
We had a lot of fun with these kind of graphics.

14:02.640 --> 14:06.640
It's basically the same functionality as the regular script image.

14:06.640 --> 14:12.640
But you can now see that the appearance has changed completely.

14:12.640 --> 14:15.640
So it's a completely different image.

14:15.640 --> 14:20.640
And using the update feature, I could now also go to another place

14:20.640 --> 14:27.640
and switch, for example, install another version and switch back to the earlier version.

14:27.640 --> 14:29.640
Okay.

14:29.640 --> 14:33.640
Let's continue.

14:38.640 --> 14:40.640
Okay.

14:40.640 --> 14:46.640
So the first response we got from the community of users was a question about the power.

14:46.640 --> 14:53.640
So the pine phone is quite well known for not being very long lasting when it comes to the battery.

14:53.640 --> 14:58.640
So people found it quite unacceptable that we left the screen on all the time.

14:58.640 --> 15:03.640
So they asked, how about implementing some kind of a screen saver to save the energy.

15:03.640 --> 15:06.640
So that was the first thing that we considered.

15:06.640 --> 15:10.640
And I will just give you a brief tour of how this normally works.

15:10.640 --> 15:13.640
So when you speak about power management on the pine phone,

15:13.640 --> 15:16.640
you have on the bottom of this this power management chip,

15:16.640 --> 15:22.640
which is in control over the actually voltages, power ramps, battery, the power button is attached there.

15:22.640 --> 15:28.640
So these are the lowest level kind of electric concerns.

15:28.640 --> 15:31.640
And once the pine phone switches, it's switched on,

15:31.640 --> 15:36.640
and the communication processor starts up together with a kind of companionship,

15:36.640 --> 15:38.640
which is the system control processor.

15:38.640 --> 15:40.640
And these are completely separate.

15:40.640 --> 15:42.640
So this is an ARM processor.

15:42.640 --> 15:44.640
This is a small microcontroller.

15:44.640 --> 15:49.640
It's based on RISC 1000 CPU core over here.

15:49.640 --> 15:55.640
And the first thing that happens at boot is that the ARM trusted firmware is started,

15:55.640 --> 15:59.640
and this loads the firmware into the system control processor.

15:59.640 --> 16:02.640
So this is also an open source of the nowadays, which is pretty cool.

16:02.640 --> 16:07.640
And this firmware is basically meant to interact with this power management chip over here.

16:07.640 --> 16:14.640
And this can also run when the application processor gets switched off if you want to save power.

16:14.640 --> 16:18.640
And then the Linux kernel is started, and you have these bunch of drivers.

16:18.640 --> 16:25.640
One driver talks over these kind of devices, mailbox device and chat memory through the device to the firmware.

16:25.640 --> 16:30.640
You can give commands, for example, for suspend or resume.

16:30.640 --> 16:36.640
And then you have drivers for the display, for the touch input and so on, all as kernel drivers.

16:36.640 --> 16:40.640
And then on top of that, you have the user space that uses these kernel services,

16:40.640 --> 16:47.640
like the input driver services, like kernel mode settings, things like that.

16:47.640 --> 16:50.640
And on top of that, you have the applications.

16:50.640 --> 16:54.640
That's the traditional architecture that you may know.

16:54.640 --> 16:59.640
And with G-Node, we can do a bit more flexible, so the picture looks like this.

16:59.640 --> 17:05.640
What's the same is that we have the startup, we have this ARM trusted firmware,

17:05.640 --> 17:10.640
but this time it loads a custom firmware, which is basically a small force interpreter.

17:10.640 --> 17:15.640
You have to know that the execution environment over here is just about 16K, so it's really small.

17:15.640 --> 17:20.640
So we put a small force interpreter here, but left it basically like a hull.

17:20.640 --> 17:25.640
It has no predefined functionality, it's just an open-ended force interpreter.

17:25.640 --> 17:32.640
And then the system be woods a small microkernel, and on top of that, now things get upside down.

17:32.640 --> 17:39.640
Because here we have the GUI server directly running on top of the microkernel with no dependencies underneath.

17:39.640 --> 17:42.640
So it can run without any driver running.

17:42.640 --> 17:47.640
And the drivers, they come in later, they connect to the GUI server as a client.

17:47.640 --> 17:51.640
So now we have put this upside down.

17:51.640 --> 17:55.640
And so you have the applications that talk to the GUI server using the SCUI interface over here.

17:55.640 --> 18:02.640
You have a display server that talks to the CAPTCHA service, which is the same service as you would use for screen shots and things like that.

18:02.640 --> 18:09.640
And the input driver, the touch screen driver, talks to the event service for injecting input events.

18:09.640 --> 18:16.640
Then there is this platform driver over here, and this guy has the job to arbitrate the access to the physical device resources,

18:16.640 --> 18:19.640
like interrupts, memory mapped I.O. and things like that.

18:19.640 --> 18:24.640
And so then, for example, this display driver comes up to the platform driver, asking for a platform session.

18:24.640 --> 18:32.640
The platform driver turns on the right power, watches and the right clocks, and the driver can do its work.

18:32.640 --> 18:34.640
And then you have this power driver here.

18:34.640 --> 18:44.640
This uses this interface over here and can send force commands to the force interpreter and can basically extend from there at runtime, which is quite flexible.

18:44.640 --> 18:52.640
So when we started this system, initially it grew about two and a half watts, which is quite a lot.

18:52.640 --> 18:58.640
And now, when it's going to sleep, five minutes, oh, okay, I have to hurry up.

18:58.640 --> 18:59.640
This is basically different.

18:59.640 --> 19:00.640
You see this difference?

19:00.640 --> 19:03.640
We just removed two components and that's it.

19:03.640 --> 19:10.640
And the power draw goes up down to just one watt, thereby also tweaking some voltages.

19:10.640 --> 19:11.640
Okay, live sleeping demo.

19:11.640 --> 19:21.640
I don't know if this I should really show because of the time constraints, but let's do this one quickly.

19:21.640 --> 19:23.640
So now it's sleeping, you see.

19:23.640 --> 19:29.640
So I will also have to connect the console here, the Pico.com.

19:29.640 --> 19:31.640
Oh, no.

19:39.640 --> 19:44.640
Okay, I will skip this small demo.

19:44.640 --> 19:51.640
I wanted to show you how the drivers come up, but it's probably, even time constraints, I will just skip this.

19:51.640 --> 19:53.640
It's a bit sad, but yeah.

20:00.640 --> 20:03.640
Okay, here we were.

20:08.640 --> 20:15.640
Okay, the last point I wanted to talk about is the question of extending the system.

20:15.640 --> 20:24.640
So we identified this whole bunch of work items that the developer typically has in front of him.

20:24.640 --> 20:32.640
And we also touched this at some parts of the previous talks, like the flat out talk was quite interesting in this respect.

20:32.640 --> 20:39.640
You have a bunch of different toolings and different build systems and so on to consider and all these different steps.

20:39.640 --> 20:41.640
And this is quite complicated.

20:41.640 --> 20:45.640
So and when targeting a system, the developer is confronted with all of this.

20:45.640 --> 20:49.640
And so we came up with a tool that's called Goa.

20:49.640 --> 20:53.640
It's called Goa because it's gold, but reached a little bit sooner.

20:53.640 --> 20:56.640
To basically assist the developer with these steps.

20:56.640 --> 21:03.640
And I will just show you an example how this Goa tool can be used.

21:03.640 --> 21:13.640
Using my Linux VM over here, I go to my Goa playground directory where I'm just playing around.

21:13.640 --> 21:20.640
And so I wanted to, for example, port the Atari 800 emulator to this phone.

21:20.640 --> 21:27.640
So I can do a Goa run and this basically runs this emulator here now on Linux.

21:27.640 --> 21:37.640
And I can basically see when I do a PS that these genot components that you see in the background with this Atari basic running here.

21:37.640 --> 21:39.640
They are actually Linux processes over here.

21:39.640 --> 21:45.640
So this is basically the Linux version of genot running on inside the VM here.

21:45.640 --> 21:50.640
And there is a nice demo I wanted to show you for the Atari 8 bit.

21:50.640 --> 21:55.640
So I can basically make a modification here in this runtime file.

21:55.640 --> 22:03.640
So I will, for example, at this argument here to the emulator, do a Goa run again.

22:03.640 --> 22:10.640
And you see here that this is now running a small graphics demo here for that's quite famous on the Atari 8 bit.

22:10.640 --> 22:14.640
And you see now the cycle is really fast.

22:14.640 --> 22:16.640
Okay, correct.

22:16.640 --> 22:27.640
Then when I want to try out this on a real machine, I can say I want to target this script system over here.

22:27.640 --> 22:32.640
So my host system, I start the test environment over here.

22:32.640 --> 22:48.640
And I can say I want to target script and I want to give the information where this script server, where this should be run.

22:48.640 --> 22:54.640
Okay, thank you.

22:54.640 --> 22:56.640
Still not going.

22:56.640 --> 22:58.640
Time's up.

22:58.640 --> 23:14.640
Time's up. Okay, so I will stop over here and invite you to catch up with my colleague Johannes who will give a talk at the microcunnel death room later at 6.30.

23:14.640 --> 23:16.640
And I will be there as well.

23:16.640 --> 23:20.640
So if you want to get in touch and see where we should go.

23:20.640 --> 23:29.640
Thank you.

