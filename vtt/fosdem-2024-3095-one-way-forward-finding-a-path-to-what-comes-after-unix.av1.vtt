WEBVTT

00:00.000 --> 00:15.320
Hi, so while we are figuring out how to fix the image, we will start with a lecture,

00:15.320 --> 00:21.400
One Way Forward, Finding a Path to What Comes After Unix by Liam Proven.

00:21.400 --> 00:36.760
Hi, thank you. So this is my fourth FOSDEM talk, remarkably enough. Thank you for coming back

00:36.760 --> 00:46.560
to listen to me again. I have presented three previous talks which were all on the theme of

00:46.560 --> 00:55.200
the progression of the software industry and some misunderstandings. The first one was called

00:55.200 --> 01:00.720
The Circuit Less Travelled and I talked a bit about alternate operating systems, people have

01:00.720 --> 01:06.640
probably never heard of or met. Then in 2020 I did one called Generation Gaps which talked about

01:06.640 --> 01:15.200
how the perceived threat of switching generations of tech and losing backwards compatibility is a

01:15.280 --> 01:24.280
boom, not a cost. Then the last one I did in 2021 was called Starting Over and I talked about a

01:24.280 --> 01:33.680
proposal for a next generation of operating system discarding 50 years of legacy baggage using a

01:33.680 --> 01:39.400
memory technology called Optane from Intel which has since been cancelled, shows my an airing

01:39.480 --> 01:49.320
finger on the pulse. Now I kind of want to go in a slightly different direction with this one. So

01:49.320 --> 01:57.640
since I proposed this talk, something very sad happened, something inevitable but nonetheless

01:57.640 --> 02:07.080
regrettable, a giant of 20th century software design, Niklas Theot died. So because of that and

02:08.040 --> 02:18.280
in a small tribute I tried to slightly rework the introduction of the talk. Now Theot was famous

02:19.000 --> 02:25.720
probably for what I feel was kind of only a relatively minor aspect of his career. For example

02:27.400 --> 02:35.400
Theot studied and later taught in California for quite a while as a young man where he had a nickname

02:35.960 --> 02:42.040
of Bucky and I rather like the idea of this dignified computer scientist was Bucky Theot.

02:43.240 --> 02:51.000
In the days when he was teaching and studying the Unix system was being developed and people use

02:51.000 --> 02:58.920
teletypes and teletypes are very roughly a printer with a typewriter plugged in and typewriters don't

02:59.000 --> 03:07.960
have things like control and alt and shift and so on. And Theot proposed a mechanism for how

03:07.960 --> 03:12.600
controller keys would work, modifier keys would work and the mechanism is still used, it's called

03:12.600 --> 03:22.200
Bucky bits in his honor. He is of course famous for Pascal but one thing that I found is not

03:22.280 --> 03:29.480
fully understood sometimes is how and why Pascal came about. Theot and the British computer scientist

03:29.480 --> 03:36.760
Tony Hall were working with the Algol programming language committee to design the next version

03:36.760 --> 03:44.680
of Algol and Theot proposed a relatively simple change to the language. The Algol committee rejected

03:44.680 --> 03:51.000
it and went with a counter proposal which was rather more complicated and that became Algol 68

03:51.000 --> 03:57.160
and killed the language forever. As a result lots of other programming languages got their chance

03:57.160 --> 04:03.960
to grow in the sunshine when this giant fell and one of those was BCPL, BCPL gave rise to B, B gave

04:03.960 --> 04:13.960
rise to C and Unix grew in part because Bucky Theot pulled out of the Algol committee. A lot

04:13.960 --> 04:23.080
of what we work in and use today came from this. He didn't just do Pascal but Pascal had ramifications

04:23.080 --> 04:29.400
people might not know today. The original operating system for the Apple Lisa was largely implemented

04:29.400 --> 04:38.360
in Pascal. A version of Pascal or a derivative of Pascal called Concurrent Euclid was used to build

04:38.360 --> 04:44.360
an operating system called Tunis which was a Unix. There was a Unix built in Pascal.

04:45.880 --> 04:51.240
So now with lots of people getting interested in more typesafe languages to descend from C like

04:51.240 --> 04:58.280
Rust and Go and D and whatnot. People were building Unix compatible operating systems in a Pascal

04:58.280 --> 05:08.040
derivative in the 70s. Pascal of course became a huge hit partly due to Bolland's turbo Pascal and

05:08.760 --> 05:16.040
that gave rise to Bolland Delphi and set much of the course of Microsoft Windows 3.

05:17.880 --> 05:24.760
The more of all that, he didn't care and Theot instead went on and wrote a successor language

05:24.760 --> 05:30.280
with more and better modularity called Modular but he immediately discarded that and he moved on to

05:31.320 --> 05:38.200
a modular version of Pascal with more concurrency called Modular 2. That for a while was

05:39.880 --> 05:46.680
the fastest compiler on the PC platform and was briefly very successful. He ignored that as well.

05:47.240 --> 05:57.000
Late in Viet's career, only a few years before he retired, he wrote a wonderful short article

05:57.000 --> 06:03.720
called A Plea for Lean Software. I have a screen grab of it which you can't see which is a slightly

06:03.720 --> 06:10.920
skew if PDF from Viet's own homepage. It's only a few pages long. It's very readable. I really

06:11.000 --> 06:20.280
recommend if you haven't seen it, Google it. But as a proof of the validity of the concept of

06:20.280 --> 06:27.000
extremely lean, tiny, simple software, he moved on from Modular 2 and he came up with what is

06:27.000 --> 06:36.280
arguably the masterpiece of his career, a system called Oberon. Oberon is a tiny Pascal-like language.

06:36.280 --> 06:45.400
It has built-in concurrency primitives and the language also comes with a compiler and an editor

06:45.400 --> 06:53.640
and an IDE which are all implemented in Oberon itself. Now, I wrote an obituary for Nicklaus

06:53.640 --> 07:00.120
Theod for the register in early January and I couldn't come up with a clear source for how

07:00.120 --> 07:05.640
many lines of code there were in Oberon. So I went to the project Oberon website. I downloaded the

07:05.640 --> 07:12.440
zips of the core operating system. I unpacked them and I ran WC-L against them and it came out to

07:12.440 --> 07:22.680
only just over 4,000 lines of code. 4,623 lines of code in 262 kilobytes of text files. That's an

07:22.680 --> 07:28.120
operating system and a tiling windowing interface and an editor and a compiler.

07:30.760 --> 07:35.080
When people talk about Lean Software and talk about how much smaller software could be,

07:35.080 --> 07:40.040
I don't think people fully understand the scale of the issues we are facing these days.

07:41.560 --> 07:49.000
So, when I talked about Oberon as an interesting candidate for maybe a successor to Unix for

07:49.000 --> 07:57.320
a new technological generation, well, you know what, I think trying to propose a Pascal-related

07:57.320 --> 08:02.200
language to an audience of Linux and Unix folks was probably the wrong audience.

08:05.320 --> 08:08.680
The talk seemed to go down well but I've not heard of any results or anybody

08:08.680 --> 08:13.000
particularly investigating although development in Oberon is still quite active. So,

08:14.280 --> 08:19.000
I've come up with something else that might be a bit more familiar and close to home territory here.

08:21.400 --> 08:26.840
FOSDEM is a FOS conference. It's all about FOS and unfortunately, or for better or for worse,

08:26.840 --> 08:32.840
maybe I should say FOS these days is about Unix and Unix-related operating systems. Now,

08:33.800 --> 08:35.960
a lot of people misunderstand that, I think.

08:39.240 --> 08:45.800
So, Unix today is increasingly about Linux. I can see an open BSD developer in the audience down

08:45.800 --> 08:54.120
there but increasingly Unix means Linux. But what is Unix? Now, the definition of what is

08:54.120 --> 09:01.000
Unix changed in 1993. I just want to ask you guys, stick your hands up if you can remember the year

09:01.000 --> 09:10.120
1993. We got quite a few grumpy old gits. Well done. Congratulations. Thank you. But about half

09:10.120 --> 09:25.560
the crowd probably can't clearly remember 1993. In 1993, I can go to the 60s sadly for me. In 1993,

09:25.560 --> 09:31.560
what Unix is changed. And a lot of people still haven't heard the news. Because in 1993,

09:31.560 --> 09:39.320
Novell bought Unix system laboratories from AT&T and they donated the trademark of Unix to the

09:39.320 --> 09:48.120
open group, famous for Motif and CDE and a few other things. They kept the Thrust Code and much

09:48.120 --> 09:58.920
good it did them because there is a successor company to Novell which spone off Caldera and Caldera

09:58.920 --> 10:03.720
bought Skow and changed its name to Skow and went crazy and sued its own customers. A derivative

10:04.840 --> 10:08.920
sort of subsidiary company called Cinewoth are still trading. They're still selling operating

10:08.920 --> 10:15.160
systems based on the original AT&T code base. Unix doesn't mean based on AT&T code and it hasn't

10:15.160 --> 10:23.720
for 31 years. Unix now means passes open group compliance tests and those used to be called

10:23.720 --> 10:32.680
POSIX. Effectively what used to be called POSIX now means Unix. If it passes compliance tests,

10:32.680 --> 10:40.040
it's Unix. We have to pay for the trademark, right? So there are a few operating systems that

10:40.120 --> 10:45.960
have paid. HP UX doesn't have a future because it only runs on Atenium and there's no more Atenium

10:45.960 --> 10:53.160
kit. IBM AIX, I don't know if anybody heard but last year IBM shut down the AIX development team

10:53.160 --> 11:02.440
in Boko Vatan and passed maintenance over to a team in India. Mac OS both on Intel and X6.

11:03.080 --> 11:09.720
Both on Intel and ARM is certified but at least two or three Linux distributions have passed the

11:09.720 --> 11:15.880
testing. They were all Chinese CentOS Linux derivatives but the point is they passed the

11:15.880 --> 11:24.600
test and for a while the company's paid. Unix is Linux. Linux is a Unix. It's not Unix like

11:25.320 --> 11:31.400
it is Unix and that upsets some Linux folks who like to think they're rebels.

11:31.400 --> 11:46.120
Now, I had a family tree of Unix from Wikipedia here but you can't see it. It shows the original

11:46.120 --> 11:53.000
development series at AT&T, Unix 3rd edition, 4th edition, System 5, lots of derivatives branching

11:53.000 --> 11:59.400
off at various dates and of course off on its side with no direct connection Linux.

12:00.120 --> 12:08.280
But I would argue if you take a step back, BSD did descend from originally the AT&T code base.

12:08.280 --> 12:22.920
Cisco and AIX and Solaris and SunOS before it and HP UX and all of them still have roots in that

12:22.920 --> 12:32.600
code base. You can consider all of the monolithic proprietary Unix as one branch. They've all got

12:32.600 --> 12:39.720
shared ancestry. On the side of that there's all the branch which is Linux which is a separate

12:39.720 --> 12:50.760
code base but taken by the same design. I would say Unix arguably is just all those as one. You

12:50.760 --> 12:56.440
know what the implementation differences now are relatively minor. You know, I'm presenting,

12:56.440 --> 13:01.000
he says. I'm using LibreOffice. I'm using a version that was released about two days ago.

13:01.480 --> 13:08.120
I don't think that's why you can't see it. But LibreOffice, Firefox, bunch of other stuff,

13:08.120 --> 13:12.280
you know, Chrome, Chromium, blah blah blah. They run on Mac OS, they run on Linux, they run on all

13:12.280 --> 13:24.040
the BSDs. It's all close enough. But there is another branch of this family. Several systems

13:24.040 --> 13:28.840
passed the testing and are called Unix that aren't because it's just a compatibility layer.

13:28.840 --> 13:33.720
IBM's EOS still carries the branding. But it's a weird mainframe operating system which doesn't

13:33.720 --> 13:39.960
even use things like ASCII. It's, it can act like, no, Unix but it's not a Unix. But there is

13:39.960 --> 13:45.720
another branch of the family. The microconnors. There's a bunch of microconnel operating systems

13:45.720 --> 13:51.000
out there which are Unix-like enough to pass the test. There's Mac OS, which is what I'm running

13:51.000 --> 13:57.480
on here. There's QNICS, which not enough people have heard of. I think QNICS is very cool. It's a

13:57.560 --> 14:06.360
Canadian system. It's tiny and it's mainly used in embedded systems. It runs lots of traffic lights

14:06.360 --> 14:11.000
and engine management units. But if you ever owned a BlackBerry 10 device, that was QNICS.

14:12.600 --> 14:19.080
And there's a couple of open source ones that have not set the world on fire like the GNU Heard

14:19.080 --> 14:27.480
and Minix 3. Minix 3 is a true microconnel. But sadly, Dr. Andy Tannenbaum has retired.

14:27.480 --> 14:31.160
Minix 3 is looking stagnant. I don't think there's been any commits in several years.

14:31.160 --> 14:38.040
It'd be a great project for somebody to pick up. Minix has tens of millions, maybe hundreds of

14:38.040 --> 14:44.040
millions of users. And probably half this room run Minix and you might not know it. Because Minix

14:44.040 --> 14:50.920
runs on the embedded management chip inside all modern Intel processors from the Core i3,

14:50.920 --> 14:56.200
i5, i7 onwards. They've all got Minix in there somewhere. But Intel didn't contribute much

14:56.200 --> 15:00.840
code back and didn't contribute any money back. And so it didn't help Minix 3 at all.

15:02.360 --> 15:10.040
So we've got two families, the big monolithic Unixers and the microconnel Unixers.

15:11.000 --> 15:16.120
But they may not share the code base. But we all know what a Unix looks like, right?

15:16.120 --> 15:22.440
It's probably written in C or something very much like C. It's probably got one big file

15:22.440 --> 15:29.000
system that's rooted at a folder called slash. It's probably got a shell which uses the familiar

15:29.000 --> 15:35.960
little cryptic short commands. It's probably got case sensitivity. But there are exceptions,

15:36.040 --> 15:42.600
macOS 10, sorry, macOS. It's not case sensitive. It's case preserving. Still a Unix. It's still

15:42.600 --> 15:49.080
compatible. It's passed the test. But you know what? All these charts, all of these sort of

15:49.080 --> 15:56.360
generation diagrams and so on, show the AT&T Unix line going on and things branching off it at

15:56.360 --> 16:02.760
third edition, fourth edition, fifth, sixth, seventh. And then they stop. But it didn't stop there.

16:03.320 --> 16:09.080
And I think that's quite important. And my computer won't go to the next slide.

16:09.080 --> 16:17.160
Have notes. Great. Thanks. So there is another line of descent. And I have a wonderful spinal

16:17.160 --> 16:23.480
tap gag that you can't see. Research Unix continued in AT&T after the industry took what,

16:23.480 --> 16:30.520
worked and ran with it and made it huge. But Dennis Ritchie and Ken Thompson and some others

16:31.320 --> 16:35.720
did what Niklas the Up did. They ignored what the industry were doing with their earlier product

16:35.720 --> 16:42.840
and they kept on. And there was research Unix eighth and then ninth and then tenth edition.

16:43.640 --> 16:49.480
Very little trace of them seems to remain. I've tried to write about them. And when I've said

16:49.480 --> 16:55.880
stuff that Wikipedia has links pointing to sources, mostly I get people angrily telling me I'm wrong,

16:55.880 --> 17:01.880
but they can't actually provide an alternate story. What came back, what happened next,

17:02.920 --> 17:07.480
I think, was interesting and significant. And a lot of this industry have neglected it.

17:09.080 --> 17:16.920
By 1992, Unix was a massively important commercial system and the roots of what became

17:16.920 --> 17:26.840
free BST and net BST were happening. But let's look at somewhat like the, what defines something

17:26.840 --> 17:35.160
as being a Unix or Unix-like system. It's not about a GUI because Mac OS X passes the test,

17:35.160 --> 17:40.840
but there's no X or anything like X in here. There's an optional X package, but it's not

17:40.840 --> 17:47.240
defined by the GUI. It's not defined by case sensitivity. It's not defined by the kernel.

17:47.240 --> 17:50.760
It's just, does it look like a Unix? Does it feel like a Unix? Well,

17:53.640 --> 18:01.320
in the end, at the end of the 1980s, a change happened which brought the Unix industry of

18:01.320 --> 18:07.560
proprietary workstations into conflict with the PC industry and cheap X86 kit. Because suddenly

18:07.560 --> 18:14.440
it was affordable to buy, a reasonably capable 32-bit computer with a reasonably fast expansion

18:14.440 --> 18:20.600
bus so you could have fast networking, cheap. And suddenly this created the conditions for

18:21.400 --> 18:29.000
open source Unixes to take root and flourish and thrive. They grew in the soil of Windows.

18:29.000 --> 18:36.040
I know a lot of people like to hate Windows, but Windows created a marketplace of cheap

18:36.040 --> 18:44.040
32-bit hardware that was ideal for Linux to grow. Windows was not a particularly useful

18:44.040 --> 18:49.000
platform on 286s and 286s were not particularly useful for most Unix-like systems.

18:55.160 --> 19:03.160
What the Open Source Unixes that took root in the late 80s, early 90s, did not account for how

19:03.160 --> 19:10.440
the hardware they were running on had changed. Traditional Unix was a mini-computer operating

19:10.440 --> 19:15.320
system. It ran on a big shared box with no display of its own, no keyboard of its own,

19:15.320 --> 19:21.960
just dumb terminals. And a lot of what and how Unix is and how it works is because of that.

19:22.520 --> 19:27.320
It's focused on text files, it's focused on piping, it's focused on text editors.

19:28.280 --> 19:34.680
It's because of the mini-computers that it evolved on. But by the 90s, computers won't like that

19:34.680 --> 19:40.360
anymore. By the 90s, computers were standalone boxes with a graphical screen and a network card.

19:40.920 --> 19:46.040
And Unix doesn't account for that well. I mean, Unix does networking, sure, you know,

19:46.040 --> 19:51.400
there's things like NFS, but it's a bolt-on. You have to run external commands and mount

19:51.480 --> 19:58.680
external file systems in particular places. Graphics are bolted on. There's very little

19:58.680 --> 20:05.240
conception of them in the traditional Unix kernel. So, you know, everybody likes to hate on X11

20:05.240 --> 20:10.120
these days, it works for me. But Wayland, they like to talk about how they're modernizing the

20:10.120 --> 20:16.200
Linux and Unix graphics stack because Wayland works on FreeBSD. Well, Unix is about files,

20:16.440 --> 20:20.600
everything in Unix is a file, right? So, go on, then, Wayland enthusiasts, tell me,

20:20.600 --> 20:25.240
where in the file system can I find a window on the display of a Wayland box?

20:26.920 --> 20:30.840
Go on, then, point me at the file that has the dimensions of the window.

20:30.840 --> 20:36.520
Point me at a file that says where it is in the Z-order. Can't you show this is a

20:36.520 --> 20:39.240
Unix display system? Because it doesn't sound like one to me.

20:41.480 --> 20:45.640
But you know what? The research Unix team, well, thinking about stuff like that, and they

20:45.640 --> 20:51.320
started to put stuff like that into Research Unix 10, and that finally became a product that was

20:51.320 --> 21:00.280
announced in 1990. It's called Plan 9 from Bell Labs. It is effectively Research Unix 11, but

21:01.320 --> 21:06.680
they didn't call it Unix, and they didn't call it Unix for a good reason. It looks a lot like

21:06.680 --> 21:13.960
Unix because it's built in C and it's case sensitive and it has a fairly familiar shell,

21:14.760 --> 21:22.520
but it's got networking right in the heart of the design where it should be. So, you can have

21:22.520 --> 21:28.200
access to the file systems of other Plan 9 machines on your network, and they can have access to

21:28.200 --> 21:34.040
your subject to permissions and so on. It has a built-in graphical windowing system, which went

21:34.040 --> 21:40.280
through several iterations, but the one that it has now is called Rio, and in Rio, a window is also

21:41.240 --> 21:47.080
a folder. It's a directory, and in that directory there are text files. You want to write to a window,

21:47.080 --> 21:51.720
you put text in a file in a folder. That's what Unix is meant to be about, not

21:52.680 --> 22:00.280
wretched gamer hacks like variable refresh rate and so on. I don't know, I don't. I'm frankly

22:00.280 --> 22:04.200
indifferent to Wayland because there's not a single desktop I like to use that runs on the Wayland yet.

22:04.760 --> 22:12.440
So, Plan 9 takes the idea of everything as a file and really means it, whereas it was just a marketing

22:12.440 --> 22:18.920
slogan for traditional Unix, and that includes Linux and OpenBSD and FreeBSD and NetBSD and DragonflyBSD.

22:20.120 --> 22:26.600
Everything really is a file. You don't need a network-aware windowing system to put windows on

22:26.600 --> 22:30.040
another box on the network in Plan 9 because you can get it at their file system and you can just

22:30.040 --> 22:37.240
write files into the file system and windows just happen. It makes X11 look very over complicated,

22:37.240 --> 22:42.360
which the Wayland people would agree with, but it makes Wayland look like it was something

22:42.360 --> 22:53.240
invented by Microsoft. And in a way, Plan 9 also invalidated all that 80s work that went into

22:53.240 --> 23:00.280
micro kernels because a lot of the problems of micro kernel implementation just kind of go away

23:00.280 --> 23:04.200
in Plan 9. It's not that it's better, it just kind of makes some of it irrelevant. One of the big

23:04.200 --> 23:08.440
problems of micro kernels is you put all of the bits of your operating system that would be in the

23:08.440 --> 23:13.240
kernel in separate little blobs, servers that run in user space, but they have to communicate with

23:13.240 --> 23:17.640
each other to get the job done and that communication is slow and it becomes a bottleneck. Plan 9 just

23:17.720 --> 23:25.080
has put it in the file system, which is the Unix way. So the original Plan 9, when they showed it

23:25.080 --> 23:32.520
in the year 1990, at that point they had a code comparison and Plan 9 was actually just about

23:32.520 --> 23:38.840
the same size as the new Mach micro kernel that Carnegie Mellon University was showing off then.

23:39.560 --> 23:44.520
And I don't know if you know what happened with Mach. Mach had a whole load of operating systems

23:44.520 --> 23:52.280
based on it. It was very cool in the late 80s. Deck OSF 1, which later became True 64, was based on

23:52.280 --> 23:59.560
Mach. The PowerPC version of OS 2 is based on Mach. Only one of them is still around and really gets

23:59.560 --> 24:05.400
much attention and it's Mach OS 10. And the way that they got it to work is they took a big chunk

24:05.400 --> 24:13.000
of code from originally, I think it was 4.4 BSD, but now it's from free BSD, and they had that as

24:13.000 --> 24:17.960
the Unix server, which provided all that nice Unix file compatibility stuff, but it was a bit too

24:17.960 --> 24:26.840
slow, so they stuck it into the kernel. That's the XMU kernel behind Mac OS. It's Mach and a lot of

24:26.840 --> 24:34.120
the stuff in free BSD that provides all those handy APIs. But all in kernel space. It's not really

24:34.200 --> 24:44.360
a very micro kernel design anymore. So, as an aside, in case all of this sounds a little bit too

24:44.360 --> 24:50.360
theoretical, one of the problems, if you put everything in the file system, of course, is where?

24:50.360 --> 24:56.520
Where is it going to go? What's the layout of the file system? Back in 2011 on the register, I

24:56.600 --> 25:04.280
predicted that the next big thing in Linux virtualization would be containers. It was the same

25:04.280 --> 25:11.160
year that Docker launched. It's one of the couple of times in my life I really called it. Containers

25:11.160 --> 25:17.000
are sort of CH routes on steroids, of course. All the file paths for a given process get a new

25:17.000 --> 25:23.240
route directory, and since everything is relative to route, that means they're isolated. But the

25:23.240 --> 25:30.920
problem is that on Unix there isn't a good clear separation between different types of namespace.

25:30.920 --> 25:36.520
Unix doesn't just have the file system namespace. It's got user IDs, and it's got group IDs, and

25:36.520 --> 25:43.480
it's got process IDs, and they're not in the file system as such. So, if you just have a different

25:43.480 --> 25:48.760
file system, your process can still see other processes. It can talk to them. There is a feature

25:48.760 --> 25:57.000
in the kernel now called C groups, which splits up those namespaces as well, and so it provides a

25:57.000 --> 26:06.440
kind of isolation by sub namespacing multiple different traditional Unix namespaces.

26:09.000 --> 26:18.120
But Plan 9 did that in 1990. It first shipped in 1992. Every process has its own namespace. Every

26:18.120 --> 26:23.400
process has its own view of the file system. Every process is in a container.

26:25.240 --> 26:33.240
That was announced a full decade before the first pre-BST would jail. This was a project put together

26:33.240 --> 26:39.240
by two geniuses who really had a pretty good idea of where the industry was going to go,

26:39.240 --> 26:44.920
and the industry ignored it. But, of course, there's always a bad side to go with a good side,

26:45.240 --> 26:50.200
if Plan 9 is so clever, why aren't we all using it? Well, some of the reasons are easy.

26:53.880 --> 26:58.360
Like Unix itself in its early days, it was a research operating system. It wasn't intended as

26:58.360 --> 27:05.960
a product for commercial use. It wasn't sold, and it wasn't open source. But in 2000, Plan 9

27:05.960 --> 27:12.360
3rd Edition did become open source under its own license, but they fixed that in 2014 when it was

27:12.360 --> 27:22.200
re-licensed under the GPL. It's very, very minimal, and the conceptual design, especially the

27:23.240 --> 27:31.400
namespaces, have penalties. So, because there isn't a real view of the real file system underneath,

27:32.360 --> 27:39.240
there's a bunch of stuff we take for granted on Unix, which you can't do. There's no way to move

27:39.320 --> 27:42.840
a file from one place to another, except by copying it and then deleting the copy.

27:44.840 --> 27:50.040
There's no way to move a whole directory tree. The recommended way to do it is tar it and un-tar it

27:50.040 --> 27:56.120
where you want it to be. There's no links. There's no hard links or soft links, because that would

27:56.120 --> 28:02.840
break the clarity of there being no one mass underlying hierarchy, so no links. I know that

28:02.840 --> 28:08.280
sounds a massive limitation, but you know what? As I said, I'm old. When I started in this industry,

28:08.280 --> 28:17.240
I put in large commercial systems based on DOS, both the 4, even Windows 3, and DOS until DOS 5

28:17.240 --> 28:21.880
didn't have a move command. You couldn't do it. The best you could do was copy it and then delete

28:21.880 --> 28:26.680
the original. And you know what? I ran large file servers supporting hundreds of users.

28:30.120 --> 28:34.360
Plan 9 is weird. It's unforgiving. It's strange, but you know what? It's...

28:35.320 --> 28:42.280
They had an idea. They had a set of solutions to industry problems 30 years ago, and the industry

28:42.280 --> 28:46.920
ignored them. So it's kind of understandable that they're a bit sore about that. There are many

28:46.920 --> 28:53.000
talks of Plan 9, and I wrote about one of them a year or so ago called Nine Front. It has a famously

28:53.000 --> 28:59.960
cryptic website, which is full of weird little in-jokes and things. I think it's fair. It's

29:00.520 --> 29:05.000
legit. The whole industry has ignored that they've got better solutions to the stuff we've

29:05.000 --> 29:11.720
implemented with massive stacks like Kubernetes. I'm somewhat neutral on the whole flat pack and

29:11.720 --> 29:19.000
snap controversy in Linux these days, but you know what? The snap model is easy. You copy a

29:19.000 --> 29:25.720
big compressed file. That's your app. The flat pack model is OS Tree. OS Tree is Git, but for binaries.

29:25.960 --> 29:31.000
Anybody here who thinks they really understand how Git works and how it distributes those changes,

29:32.840 --> 29:37.480
there's not. If you can't explain it and you don't understand it, it's not a good model.

29:41.640 --> 29:47.160
The OS Tree people had a slogan in the early days. They said it was a better DOS than DOS and a

29:47.160 --> 29:54.200
better Windows than Windows. Well, Plan 9 was a better Unix than Unix, but it wasn't better enough.

29:54.200 --> 29:56.840
They didn't call it Unix because it breaks so much compatibility.

30:00.760 --> 30:08.680
Plan 9 is kind of Unix 2.0. There was more work after that. There is also a successor to Plan 9

30:08.680 --> 30:17.080
called Inferno. It solves other interesting problems, but I haven't got time. I deleted a whole page

30:17.080 --> 30:25.480
and slide about that. The late great Bucky Viet made a plea for Lean software. When I wrote this

30:25.480 --> 30:33.880
yesterday, I couldn't find a word, a line count for the successor to Oberon. Oberon is a tiny

30:33.880 --> 30:39.960
single processor operating system. There is a successor, one of several called A2, which understands

30:39.960 --> 30:45.240
multiple processors. It has a network stack. It has a web browser. It's a very basic one,

30:45.240 --> 30:51.160
but the point is it's got a more conventional GUI. I estimated yesterday that it's maybe,

30:51.160 --> 30:56.200
let's say, about 5 to 10 times bigger. There's a team in Russia actively working on A2,

30:56.200 --> 31:00.280
and I asked on their Telegram channel last night, and they got back to me today. I said,

31:00.280 --> 31:07.160
maybe it's 5 times bigger than the 5,000-odd lines of Oberon or 10 times bigger. Yeah, I was wrong.

31:07.880 --> 31:15.480
It's 8,000-odd lines. That's a preemptively multitasking, multi-threaded

31:16.120 --> 31:20.200
SMP operating system with a GUI and an IP stack in 8,000 lines.

31:21.640 --> 31:35.000
Debian 12, for comparison, contains 1,341,564,204 lines of code. Source the Debian 12 release

31:35.000 --> 31:44.440
announcement. One and a third billion lines of code, one and a third thousand million lines of code.

31:45.880 --> 31:51.240
Nobody can read that. You won't live long enough to read that. For comparison, Google Chrome,

31:51.240 --> 31:57.400
the Chromium code base, is approximately 40 million lines of code. If somebody tells you

31:57.400 --> 32:00.920
they've gone through the Google Chromium code base and cleaned it up and removed all the Google

32:01.240 --> 32:10.200
algorithms, they're lying to you. There are a lot of big lies in this industry, and one of them is the

32:10.200 --> 32:15.480
scale of the problem that we have, of billions and billions of lines of code that nobody can

32:15.480 --> 32:21.640
understand. Now, computers, another big lie is that computers stopped getting a lot quicker a few

32:21.640 --> 32:28.600
years ago. About the time that Intel released the Pentium 4, that space heater that some of you

32:28.600 --> 32:34.040
might remember, Intel released it in 2000. They promised that by 2005 they'd have a 10 gigahertz

32:34.040 --> 32:40.280
one. It didn't happen. Instead, we got the Pentium M, and that evolved into the Core series.

32:40.280 --> 32:45.640
They're smaller and they're cooler. More's law doesn't hold anymore. What we get now is Kumi's

32:45.640 --> 32:52.200
law. Kumi's law says that over time, chips get smaller and use less power, not twice as fast.

32:52.680 --> 32:59.080
What we get now is width, not speed. We get more cores, more co-processors. Brothers and

32:59.080 --> 33:07.640
Level law. Amdahl's law. Look that one up. It's quite fun. Amdahl's law says when you parallelize

33:07.640 --> 33:13.880
a piece of code, the scales you get from more threads of execution top out quite rapidly.

33:14.440 --> 33:22.760
If you have an infinite number of cores available and you can take 95% of your code base and make

33:22.760 --> 33:30.200
it parallel, you'll get a maximum 20 times speed up. That often actually requires in the region

33:30.200 --> 33:38.200
of 1,000 to 2,000 cores to support that. After that, it stops working. Nobody can automate making

33:38.200 --> 33:43.880
code parallel. It's not possible. As far as we can tell, this never will be possible. A human has

33:43.880 --> 33:49.800
to read the code and make it parallel. That is never going to happen with the size of Linux and

33:49.800 --> 33:55.400
so on today. It's not possible. We can nibble around the edge with our many eyes making all those

33:55.400 --> 34:00.120
buds shallow. We can tweak little bits. We can refine subsystems. We can't rewrite the whole thing.

34:00.840 --> 34:05.960
It's no longer manageable. This has built a multi-trillion dollar industry around the world,

34:06.760 --> 34:12.760
but it's very, very hard to make big improvements anymore. The hardware isn't helping anymore.

34:14.680 --> 34:20.520
Software is vast and vastly complicated and nobody understands it anymore.

34:21.960 --> 34:28.760
Let's compare this with Plan 9. I got a few letters and emails and a phone call when I last

34:28.760 --> 34:38.840
wrote about Plan 9. One chap said, oh, yeah, yeah, about the size. The kernel is 5,191,091 bytes.

34:38.840 --> 34:44.840
It's 5 meg. The entire distribution is all sources, documents, the local Git repository,

34:44.840 --> 34:52.680
and binaries is about 530 meg in the AMD64 version. That is not just an operating system. That is

34:53.240 --> 34:58.360
a clustering system, a cluster-aware file system. It's a container management system

34:58.360 --> 35:09.400
and a networked GUI in half a gig. Plan 9 has 38 system calls. I have been trying to find a list

35:09.400 --> 35:16.200
of how many system calls there are in Linux. In 2016, I found an estimate that kernel 4.7 had

35:16.200 --> 35:27.960
335 syscalls. In 2017, that was up to 341. I found a chart for 6.8 and fed it into Libre

35:28.200 --> 35:33.560
Office and looked at the number of rows because it's weird and it's formatted. I think there are 520

35:33.560 --> 35:39.880
syscalls across all the architectures. That's the bare kernel. Plan 9, 38.

35:42.600 --> 35:47.480
There is another problem with Plan 9. It's not Unix and you can't run Unix apps on it.

35:47.480 --> 35:50.040
You can't port Unix apps to it. It's too different.

35:52.120 --> 35:57.800
They have some solutions. There's a thing called Ape which is a wine or wine lib. You can recompile

35:57.800 --> 36:03.320
POSIX code for 8 and get it to work, maybe, if you're lucky. They also have a Linux emulator

36:03.320 --> 36:08.680
called Linux Emu, which is a bit like the FreeBSD one. It's 32-bit only. It's old. It's largely

36:08.680 --> 36:16.680
unmaintained. Now, the open Solaris Linux Emulator was unmaintained until Joian modernized it for

36:16.680 --> 36:21.080
SmartOS and they got it up to parity with kernel 5 and 64-bit, but it was a lot of work.

36:22.040 --> 36:28.920
It also has a hypervisor called VMX. It's limited. It only can give a VM one core. I think it might

36:28.920 --> 36:34.680
be only a 32-bit VM and the documentation says VMX can and will crash your kernel.

36:35.320 --> 36:40.040
But it is there. But look, there's all the technology that's come along. We all have 64-bit

36:40.040 --> 36:45.560
computers now. We all have loads of memory. There's 64-bit Plan 9 in the form of 9-front.

36:45.880 --> 36:52.840
Over in Linux world, there are these things called micro-VMs. Amazon have got Firecracker for AWS.

36:52.840 --> 36:59.240
There was also a project called Intel Clear Containers, which merged with another one to become

36:59.240 --> 37:05.640
Catech Containers. Tiny virtual machines designed to boot an operating system in milliseconds,

37:05.640 --> 37:10.120
run one program and then quit. They're trying to make VMs as small and quick as containers.

37:10.600 --> 37:22.600
There is already a hypervisor for 9-front. Maybe we can make a Linux micro-VM for 9-front.

37:23.160 --> 37:30.200
So you run Firefox and it starts up a kernel and it loads Firefox and it's running in a window on

37:30.200 --> 37:34.760
your desktop and when you close Firefox, the VM goes away. It doesn't mean adding loads of bloat

37:34.760 --> 37:41.480
to Plan 9. It doesn't mean it has to have a huge emulation. Just run the real kernel. We can do

37:41.480 --> 37:48.840
that these days. There is stuff we can do. There's a thing called KubeOS that some people may have

37:48.840 --> 37:53.960
seen. It runs every internet-facing program in a separate VM for enhanced security. But

37:55.640 --> 38:01.400
we can do some stuff on the Linux side of this. When I predicted containers, I went back to IBM

38:01.400 --> 38:07.960
inventing virtualization in the 60s. IBM couldn't make mainframes in the 60s interactive. So what

38:07.960 --> 38:12.680
they did is they put a hypervisor on the mainframe and they ran a dedicated interactive operating

38:12.680 --> 38:20.520
system, one per user, in a VM. How about we make a Linux that's designed and can only run in a VM?

38:21.320 --> 38:27.080
How about we have a Linux that has no hardware support? It can only talk to VertiO devices.

38:27.800 --> 38:33.480
It boots with Pixi or something like this off a file system. There's already a 9p server and

38:33.480 --> 38:39.560
client in the Linux kernel. It boots off a directory. It has no hardware support, no file

38:39.560 --> 38:44.680
systems, no disk drives, no serial port emulation. All that goes out the window. It can only run in

38:44.680 --> 38:53.000
a VM. We make it boot really quickly. We can do it today on Hyper-V and KVM and Xen and

38:53.720 --> 38:56.680
VMware and all these things. We can get this working now.

38:58.920 --> 39:04.520
And then we can make a plan line that could run Linux programs and was Linux compatible,

39:04.520 --> 39:10.520
which means it is Unix compatible. And so I had this idea a while ago and I took it to a couple

39:10.520 --> 39:17.080
of plan line communities like on Reddit. And I expected people to shout and call me an idiot

39:17.080 --> 39:22.120
and tell me it was a stupid idea. Well, okay, some of them did. But what surprised me is people

39:22.120 --> 39:26.600
said, why would you want to do that? You can run plan 9 in a VM if you want that plan 9 stuff.

39:26.600 --> 39:32.280
Just run it on Linux and then you can run your web browser on the host. Well, I'm interested in

39:32.280 --> 39:39.720
trying to go the other way. Can we provide a plan 9, this Unix 2, that can run our old programs

39:39.720 --> 39:45.800
while we find ways to bring this stuff across? Can we make the whole Waylon versus X argument

39:45.960 --> 39:55.240
go away? There's an X server for plan 9. It's called X. Spanish for X, I think.

39:56.840 --> 39:59.960
Probably going to crash a lot, but the point is you could have graphical apps in your tiny

39:59.960 --> 40:04.440
container rendered on the desktop. Linux is really mature. The VSDs are really mature. Each

40:04.440 --> 40:09.880
successive release doesn't change much anymore because the code base is so big, so complicated,

40:10.040 --> 40:16.360
so hairy, we can't change it much anymore. But there is another path here. Now, I proposed a

40:16.360 --> 40:22.680
path involving Smalltalk and Lisp and Dylan and Oberon and why I was fosdome the wrong crowd for

40:22.680 --> 40:30.200
that, I think. But here's a very unixy way forward. Here's a way to build a next generation

40:31.480 --> 40:38.520
better system that brings in containers and a windowing server and networking right into the

40:39.000 --> 40:45.960
operating system. Does it with 10% of the syscalls of a modern Linux system, maybe more like 5%

40:45.960 --> 40:51.560
these days? None of the plan 9 people said to me, you can't do that, that's ridiculous.

40:51.560 --> 40:56.920
They're like, could if you wanted. Well, I can't. I can barely program my way out of a paper bag.

40:56.920 --> 41:02.760
I write about this stuff. I explain it. That's my job. But I'm just throwing this idea out there.

41:02.760 --> 41:06.840
There is a possible path forward. It's all open source. It all already exists.

41:07.480 --> 41:14.520
We could start working on this now and actually possibly have a plan for a next generation

41:15.240 --> 41:20.920
of unix-like system. There isn't billions of lines of code that nobody can ever fix.

41:22.520 --> 41:26.200
I'm throwing the idea out. Have fun with it. That's the end.

41:27.080 --> 41:38.360
So we have time for a few questions.

41:43.640 --> 41:51.240
Will you publish the slides on the FOSTA and webpads? Absolutely. And the script as well if you'd like it.

41:51.960 --> 41:59.640
May I just tell you want to restart everything from scratch, which is good because I really think

42:00.440 --> 42:07.480
more lines of codes, it's not good. And kids now they don't know what means to make it less.

42:08.120 --> 42:16.920
Less RAM, less CPU. So they need to learn that part of the schooling. I completely agree.

42:21.960 --> 42:31.640
Hi. Thank you for your very interesting talk. My question is you compared the size of plan 9

42:31.640 --> 42:38.760
and let's say a successor 9 front with a Debian. So what the point is that the communities that

42:38.760 --> 42:46.920
are creating new Linux distributions are much larger while let's say 9 front is the work on

42:46.920 --> 42:53.880
that stopped in the 90s and there is the plan 9 stopped in the 90s and there's this 9 front

42:53.880 --> 43:03.240
community which are only very few people. So I would assume that when more people would work

43:03.240 --> 43:09.320
on 9 front it would also just grow to the same size as unix or VSD systems today and then we

43:09.640 --> 43:14.040
have the same problems again. It might well be, yes. I mean that's kind of human nature, isn't it?

43:18.040 --> 43:25.000
But I think that there are core hard problems which we do not have any way to tackle

43:25.720 --> 43:31.960
with the vast code bases of things like Linux. The problem may recur but that's the problem

43:31.960 --> 43:36.680
for our kids if they're not living in caves in the Arctic thanks to climate change.

43:37.400 --> 43:48.200
I wanted to maybe disperse your bubble but I have tried that sort of thing when you try to

43:49.160 --> 43:59.800
take a simple system and bring it up to some bigger project. It doesn't work because you end up

43:59.800 --> 44:09.080
for performance reasons re-implementing all the complexity on bigger systems. You may get something

44:09.080 --> 44:15.160
slimy because you started from scratch, you know the problems but you end up adding a lot of the

44:15.160 --> 44:20.840
complexity and particularly when it comes to things like plan 9 it's all these things you

44:20.840 --> 44:28.600
mentioned like the fact you cannot move files or the fact that you need some ways to

44:29.480 --> 44:36.440
share the view between processes or the fact of simple hardware support and heavy-dip performance

44:36.440 --> 44:45.400
that bring back all that complexity. It could be, it could be. I looked up the hard link,

44:45.400 --> 44:56.360
sim link and move issue. Oh brilliant. Don't get too excited that's no mine.

