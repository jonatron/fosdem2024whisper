WEBVTT

00:00.000 --> 00:14.500
Hi, I'm Emily. I work for Mozilla. Yeah, so this is a talk I literally don't think I've

00:14.500 --> 00:21.920
got. I could give any wealth except an audience like the translations of ROOM at Vosdom. So

00:21.920 --> 00:30.800
I thought I did. I would. In my work at Mozilla on localization systems and tools and standards,

00:30.800 --> 00:37.720
recently I've ended up spending quite a bit of time participating in the Unicode Consortium's

00:37.720 --> 00:47.080
project to define message format 2, an evolution of the ICU message format standard and a bunch

00:47.200 --> 00:54.920
of other things. And I'm here not talking about that like specifically, but more like a side

00:54.920 --> 01:01.440
product of what we've ended up doing through that work, which is defining a data model for

01:01.440 --> 01:09.280
messages. In particular, messages that are not just a single segmented phrase that you've extracted

01:09.280 --> 01:16.600
and you might be able to send it to translation, but more dynamic content as well as everything else.

01:16.600 --> 01:25.120
And one of the interesting things about what we've ended up effectively not discovering,

01:25.120 --> 01:32.160
but kind of stating the obvious, is that there's an upper bound to this sort of what makes up a

01:32.160 --> 01:41.000
localizable segmented phrase or message really. That this is limited by the fact that the keyword

01:41.000 --> 01:45.880
localizable there because it's dealing with humans. Humans who need to understand it,

01:45.880 --> 01:53.280
but also translators who, well still, are mostly humans who need to be able to take in the

01:53.280 --> 01:59.480
the source message and be able to produce an output from that that is understandable in their

01:59.480 --> 02:11.760
locale. And this ends up depending on a limited number of different dimensions in which messages

02:12.040 --> 02:18.800
kind of vary. Variants have kind of hidden it there as the first one and there of course spoiled

02:18.800 --> 02:27.680
everything by saying so. It's the way that messages, message content can vary depending on

02:27.680 --> 02:34.640
inputs like numbers and their pluralization categories. You have no apples, you have one apple,

02:35.200 --> 02:45.720
you have 15 apples and gender-based determinants, grammatical gender, personal gender, all sorts of

02:45.720 --> 02:52.320
various things in different locales languages. But this is one dimension. If you can express that,

02:52.320 --> 02:58.040
hey, we've got this variance happening, this message depends on these input values. This is a

02:58.080 --> 03:07.480
dimension that we can express. Then of course, once we have a single pattern, a single sequence,

03:07.480 --> 03:17.040
it might include placeholders. It might include the number n for how many apples you have or it

03:17.040 --> 03:22.680
might be something entirely different. But then finally, we've ended up at least through the message

03:22.720 --> 03:30.760
format to work, determining that markup should be kind of kept as a separate thing from placeholders.

03:30.760 --> 03:37.120
So markup here means something like HTML. It doesn't need to be HTML. It can be any sort of

03:37.120 --> 03:44.440
syntax or any sort of indicator that is saying that the content in this part of the message has

03:44.520 --> 03:57.000
these attributes or these something about it. Then within a placeholder, we can have values

03:57.000 --> 04:04.280
like numbers that we need to deal with. They can be just strings that are coming from an external

04:04.280 --> 04:10.400
source. We can also have annotations on them. We can say that this number here, yeah, it's coming in

04:10.440 --> 04:16.400
as a number, but I want it to be formatted. So it has at least two fraction digits, for instance.

04:16.400 --> 04:26.840
This needs to be accounted for in the whole message, how it ends up being formatted. Then as I

04:26.840 --> 04:32.240
mentioned, we need to be able to deal with variables because we are ultimately here talking about

04:32.320 --> 04:42.480
the scope of dynamic messages. So we need to be able to say that explicitly that this message might

04:42.480 --> 04:47.880
be getting a number from the outside. It might be getting some string content. It might be getting

04:47.880 --> 04:56.000
anything as input, and it needs to deal with those. But sometimes we need to, within a message,

04:56.320 --> 05:01.920
want to also do a little bit further processing on a variable value. We may want to

05:05.920 --> 05:11.680
select a certain part of it, capitalize it if we're talking about a string, do other sorts of

05:11.680 --> 05:16.640
transformations, or express the same sort of value in multiple different ways within a message.

05:16.640 --> 05:24.800
So we need a little bit of a tooling to deal with variables. And that's it. That's like

05:25.600 --> 05:30.640
through the working message format two, for the past like four years, we've not come up with

05:30.640 --> 05:37.600
effectively anything else that really is core, driving the qualities of a formatable message.

05:38.400 --> 05:44.400
And that's ended up meaning that one of the things we've produced out of this whole project is this

05:44.400 --> 05:49.520
data model for what does a message look like. When you don't consider the syntax of it, when you

05:49.520 --> 05:59.040
consider it as a data structure, I'm not going to go through like all of this. But roughly speaking,

05:59.760 --> 06:04.320
we can say that a message has two different forms that it can take. It could be either just a single

06:04.320 --> 06:10.720
pattern, single sequence that we're dealing with, or it can have some variance. That's the select

06:10.720 --> 06:17.280
message over there, which then has some selectors from that when formatting guide us towards

06:17.280 --> 06:25.680
selecting one of the variants of the message. The declarations help us declare these are some

06:25.680 --> 06:33.040
of the input and local to this message sort of variables that exist. And then the variants of

06:33.040 --> 06:39.600
the catch-all key end up defining how exactly do the, when we have multiple message variants,

06:39.600 --> 06:44.480
how does that work really? And then when you get to within a single pattern,

06:46.480 --> 06:53.520
again, as I alluded to, it can really just, obviously, contain literal content,

06:54.640 --> 07:00.960
a string, or it can have expressions, placeholders that is, or it can have markup

07:01.520 --> 07:06.960
that can be starting or opening. We also included standalone there, so you can have an element,

07:07.200 --> 07:14.000
for example, an inline image be expressed within a message. Then we can have literals,

07:16.880 --> 07:22.800
variable references, and the annotations that I mentioned. That's it. That's like these two

07:22.800 --> 07:28.080
slides are defining the whole data model that we've ended up dealing with. Okay, I left some

07:28.080 --> 07:34.240
like tiny little details out, like for example, the annotations, sorry, the expression, it needs

07:34.240 --> 07:39.440
to have at least one of an argument or an annotation in order to be valid and stuff like this, and

07:41.200 --> 07:48.640
minor details. But that's it. This is, we think, a universal data model for representing messages.

07:49.680 --> 07:55.760
And I'm here basically saying, hey, I think this is kind of cool. And this is not necessarily

07:57.040 --> 08:03.120
relevant for just the work specifically to do with message format to the syntax.

08:03.760 --> 08:09.040
But more that this is effectively a data model that

08:11.120 --> 08:18.800
can allow us to separate the concerns around the syntax of whether your messages are stored in

08:21.040 --> 08:32.720
get text files, ICU message format, fluent, any, literally any format. You can take that syntax

08:33.360 --> 08:41.040
and you can parse it into this data model structure representing a message. And this is, I think,

08:41.040 --> 08:49.760
leading us to a world where we can consider more of a UNIX philosophy for, okay, what do we do now?

08:50.880 --> 09:00.640
And I've, sort of, separation of concerns here. And I have, yes, cherry picked explicitly

09:01.600 --> 09:05.200
the part of the UNIX philosophy where it says to do one thing and do it well.

09:05.760 --> 09:09.760
And not included, for instance, the part about, you know, make sure that you're just

09:09.760 --> 09:15.280
dealing, you're communicating as strings the values from one process to another because

09:16.320 --> 09:22.400
that's kind of not necessarily working so well. Because we need those parsers. And if we need to

09:22.400 --> 09:31.280
understand all of the structure in a message every time when we do it, we end up, for the most part,

09:31.280 --> 09:37.600
mixing up the syntax concerns with everything else we're doing with messages. So as some of the

09:38.480 --> 09:44.880
things you can do with this data model as ideas is that if you can read and write from a syntax to

09:44.880 --> 09:50.960
this data model, and you can do this with multiple syntaxes, this is effectively an interface from

09:50.960 --> 09:55.040
which you can take messages from one syntax, turn them into this data model representation,

09:55.040 --> 09:59.920
and from there to any other syntax with caveats, but roughly.

10:02.320 --> 10:08.160
Another thing is we can build tooling on top of this. So you can build a linter or a validator

10:09.120 --> 10:14.400
on top of the data model representation of messages, rather than any syntax representation.

10:14.400 --> 10:20.720
And this means that you can use the same validation for all messages independently of what syntax

10:20.720 --> 10:30.480
they might be coming from. And if you have these capabilities, it means that when you have an

10:30.480 --> 10:36.960
established many localization systems right now are very much monolithic. They have expectations

10:36.960 --> 10:43.680
about this is the exact syntax in these sorts of files that are used for messages or resources.

10:43.680 --> 10:48.560
This is exactly how you deal with them. And this is what you get included in your output or your

10:48.560 --> 10:54.080
program, and this is exactly how it works. But as we're defining here a data model that can read

10:54.080 --> 10:59.520
any of these syntaxes, it means that you can build a different sort of formatting or a runtime

10:59.520 --> 11:06.880
on the same syntax. So you can start from the way you are now and maybe consider if you want to

11:06.880 --> 11:12.880
change how you're doing localization. You don't need to change necessarily everything all at once,

11:12.880 --> 11:18.080
but you can take just the formatting runtime change that to work with the same messages you've got,

11:18.080 --> 11:25.360
and move on from there. Or vice versa, actually. You could change the message

11:26.000 --> 11:31.760
structure, how do you store your messages and still use the same runtime because this is bringing

11:31.760 --> 11:39.360
in an ability to very effectively transform your messages from one syntax to another. And you can,

11:40.160 --> 11:44.160
when you're dealing with localization, you of course need to deal with translation.

11:44.880 --> 11:49.760
And this means that you need to somehow present to your translators the messages that they're

11:49.760 --> 11:58.640
working with. And if a translation tool or a framework is going through the message format

11:58.640 --> 12:04.320
to data model, it means that you can build an interface for localizers. With the localizers,

12:04.320 --> 12:11.040
don't need to know what is the syntax underneath for the placeholders, the variables, the markup,

12:11.040 --> 12:18.400
anything else, but they can be presented the same thing for all syntaxes, which might make things

12:18.400 --> 12:26.880
a little bit easier for everyone. So those are the ideas I came up with here for what could be

12:26.880 --> 12:32.800
the next steps from here, but I'm here saying, hey, this is a cool thing. You guys should play around

12:32.800 --> 12:43.600
with it. For us, the current and ongoing work is to extend this sort of a definition to also

12:43.600 --> 12:50.160
include method resources and also include the sort of comments and metadata that is quite essential

12:50.160 --> 12:56.080
for communicating the context of a message to translation, which as I'm kind of hoping some

12:56.080 --> 13:02.080
of you noticed was completely left out of the earlier. But that's intentionally so that we

13:02.080 --> 13:09.760
can separate these considerations from each other. But that's it for me. Thank you very much

13:09.760 --> 13:14.320
for listening. I'd be very happy to have any questions, comments.

13:17.520 --> 13:22.080
In another talk, I heard about message format 2 and function invocations.

13:22.080 --> 13:26.320
How do function invocations, how does the data model work, or how do they relate?

13:27.040 --> 13:37.040
The question is for how do function invocations relate to all of this? And this, yes, they are

13:37.040 --> 13:48.960
represented here in the function annotations here. So something like, for example, plural selection

13:49.600 --> 13:58.240
could use a function with a name of plural, for instance, for being this element existing

13:58.880 --> 14:06.800
in a select message, selector expression, which is there.

14:19.440 --> 14:24.000
Question was whether there are a set of built-in functions that are supported. And message

14:24.000 --> 14:32.960
format 2 does come with a relatively small set of built-in functions. The data model itself does

14:32.960 --> 14:41.760
not presume this set absolutely. But the set of functions can be extended. For message format 2

14:41.760 --> 14:48.000
in particular, we are looking at a very minimum of effectively number, which also does plural and

14:48.000 --> 14:56.160
ordinal selection, but also acts as a formatter. And then string, which is a sort of default

14:56.160 --> 15:01.920
for string formatting, but also does the same sort of selection as ICU message format select does.

15:03.760 --> 15:10.160
And we are still discussing for message format 2 what other things to include here. Now, of course,

15:10.720 --> 15:17.440
when representing messages coming from some completely other syntax, it is entirely conceivable

15:17.440 --> 15:23.600
that it is not directly possible to express these messages using the functions that message

15:23.600 --> 15:31.840
format 2 defines out of the box. But the data model does allow for you to define that a function

15:31.840 --> 15:38.080
like this must be used here, and you can otherwise define how that function works,

15:38.880 --> 15:42.960
if that makes sense. And it's possible to make translations between these

15:43.040 --> 15:49.200
function meanings. Anything more?

16:02.000 --> 16:12.400
The reason to separate context from the minimum required effectively, and here I'm jumping

16:12.400 --> 16:17.760
into the answer here, the minimum required for formatting a message is that the context is

16:17.760 --> 16:24.800
absolutely required for the translation work. But the context is not absolutely required for

16:24.800 --> 16:34.080
the message formatting. So we need to be able to represent it, but we do not absolutely need to have

16:34.080 --> 16:40.800
it be a part of the message itself when it is being formatted. And this is why we are dealing

16:40.880 --> 16:48.000
with it slightly separately. They are very much related concerns, but we've tried to find with

16:49.120 --> 16:56.880
the data model the minimum required for representing a message. And when you trim down the minimum,

16:56.880 --> 17:02.560
the context kind of ends up as a thing we can define externally, so we've chosen to be doing that.

17:03.120 --> 17:06.080
And I mean if you're interested in that, in particular

17:08.480 --> 17:14.720
the specifics of what should we include in the sort of base set of

17:16.160 --> 17:22.960
metadata and context fields, here's an issue link where we're discussing this right now

17:23.760 --> 17:26.400
that I would be very happy to have your input on.

17:32.640 --> 17:33.200
Anything more?

17:35.440 --> 17:43.600
Regarding the edit the translator tools, so now most translator tools

17:44.640 --> 17:51.200
present a string and expect that the translator will write in a string. Do you imagine that this

17:51.200 --> 17:59.520
will change and that the translator will see the elements of the data model in a more graphical way

18:00.480 --> 18:08.800
and choose translations through Google boxes, or something like that? Or do you think it will

18:09.440 --> 18:13.360
stay as a string representation for the translators in the future?

18:13.920 --> 18:21.360
I have no idea and anything is possible and that's kind of cool. So predicting the future of what

18:21.360 --> 18:27.360
the translator experience is going to be here is shall we say a hard question.

18:29.280 --> 18:36.080
One thing I do think is that this sort of a data model makes it easier to build tools that

18:39.120 --> 18:45.760
can present to a translator more the options and opportunities that they might have in modifying

18:45.760 --> 18:52.960
a message and content like placeholders and markup which might just show up a syntax when

18:52.960 --> 18:59.680
presented a string and be a challenge to even realize that I could change how this bit of it is

19:00.240 --> 19:06.800
styled. But if we can present interfaces that can read the data model and understand from this

19:06.800 --> 19:13.760
that hey hang on this could be tweaked this way, interfaces that are richer could be built. However

19:13.760 --> 19:21.600
of course we do need to keep in mind that such a vast majority of cases are just it's best represented

19:21.600 --> 19:28.320
as a pure string. So a majority of work is not going to change but the corner case is where it

19:28.320 --> 19:34.320
gets interesting and challenging for those there might be opportunities to present messages in a

19:34.320 --> 19:42.960
more translator friendly way. And one part of this I kind of skimmed over it was mentioned in the

19:44.480 --> 19:50.880
Ujjwelts presentation yesterday on message format too is that here the selection for variants is

19:50.880 --> 19:58.400
not an inline component as it is for example in ICU message format or fluent but the variants

19:58.400 --> 20:05.680
all of the variants need to be complete messages presented at the sort of top level of the whole

20:05.680 --> 20:14.400
message which is entirely intended to guide towards structures that are easier for translators to

20:14.400 --> 20:19.360
deal with rather than needing to to figure out you have and then a selector of apples.

20:21.680 --> 20:27.840
Instead of that you have a selector which has you have one apple you have three apples and

20:27.840 --> 20:38.400
this sort of an interface. But yeah anymore? If not I would like to thank you very much for your time

20:39.360 --> 20:48.080
and yeah that's it for me.

