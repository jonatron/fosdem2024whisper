WEBVTT

00:00.000 --> 00:06.000
So good morning.

00:06.000 --> 00:13.360
I am Flor ArlÃ© and I am here with my colleague Jean Monnier to present you a way to announce

00:13.360 --> 00:23.620
the video call experience by using the flexible forward error correction.

00:23.620 --> 00:27.400
We work in the Bell Dawn Communication Company.

00:27.400 --> 00:39.560
This company has developed the LIN phone product that is a soft phone open source to make some

00:39.560 --> 00:43.400
video and audio calls.

00:43.400 --> 00:48.720
And it works on several platforms.

00:48.720 --> 00:55.360
So today I will explain to you how we implement the forward error correction for our video

00:55.360 --> 00:56.360
calls.

00:56.360 --> 01:04.320
The first way we choose to use the flexible FEC scheme, I will explain to you how it is

01:04.320 --> 01:14.600
described in the RFC 8627, how it has been developed in our products and I will show

01:14.600 --> 01:18.760
you some results.

01:18.760 --> 01:23.560
So at first let's talk about the forward error correction.

01:23.560 --> 01:34.000
If you see this real schematic way to represent a video call, you have at first two people

01:34.000 --> 01:36.800
who share a video call.

01:36.800 --> 01:42.920
On the center side you have a device that captures the video.

01:42.920 --> 01:51.800
The signal is encoded here by a video encoder that transforms the signal into frames.

01:51.800 --> 01:59.680
And those frames are split into packets that will be sent to the receiver through video

01:59.680 --> 02:02.880
stream on the network.

02:02.880 --> 02:09.880
On the receiver side the packets are collected and decoded and the frames are recovered back

02:09.880 --> 02:16.200
and the signal is displayed and the receiver can see the video.

02:16.200 --> 02:21.480
In the case of the video call we are in a real time context.

02:21.480 --> 02:32.600
So we work on the RTP retight transport protocol that describes how you can send video or audio

02:32.600 --> 02:35.240
with the internet.

02:35.240 --> 02:42.840
This protocol describes the format of the RTP packets and it is more regalable than

02:42.840 --> 02:48.760
the UDP because for example you don't have latency problem that is adapted for real time

02:48.760 --> 02:51.360
communication.

02:51.360 --> 02:57.640
Unfortunately in the real world you have problems, you can experiment problems with your network

02:57.640 --> 03:04.200
so the traffic may be high, you can have a low bandwidth and sometimes you lose packets

03:04.200 --> 03:05.840
during the transmission.

03:05.840 --> 03:12.800
So the receiver doesn't collect all the packets, the signal is not complete and you see that

03:12.800 --> 03:18.000
your video can freeze and it is really annoying for everyone.

03:18.000 --> 03:25.520
To overcome that you can use a strategy to recover your lost packets.

03:25.520 --> 03:31.720
For the forward error correction you will recover the lost packets by using the next

03:31.720 --> 03:38.560
packet and also a run-down-see information that is sent at the same time than the video

03:38.560 --> 03:40.280
stream.

03:40.280 --> 03:48.680
With this way you can recover your full video and have a nice video call.

03:48.680 --> 03:54.200
We choose to use the flexible scheme for our project.

03:54.200 --> 04:00.280
So when you detect loss in your receiver, the receiver side, you have several strategies

04:00.280 --> 04:01.720
that you can apply.

04:01.720 --> 04:07.920
You can ask to send the packet again but you will have to wait to get the packet.

04:07.920 --> 04:14.400
You can primitively decide to send twice the video stream but it is really costly.

04:14.400 --> 04:20.000
Or you can try to recover the packets with what you have at the time.

04:20.000 --> 04:25.560
The forward error corrections allow you to recover the lost packets by using the run-down-see

04:25.560 --> 04:28.920
information and the other packets.

04:28.920 --> 04:36.440
There are several algorithms, for example the low density parity check codes and there

04:36.440 --> 04:40.040
is the flexible forward error correction.

04:40.040 --> 04:43.480
That is the method that we choose because it is really simple.

04:43.480 --> 04:51.880
It is based on the combination of the packets with an exclusive XOR operation and it is

04:51.880 --> 04:52.880
free.

04:52.880 --> 04:53.880
There is no patterns.

04:53.880 --> 04:56.160
It is a recent standard.

04:56.160 --> 05:00.400
It has been for example developed in the web RTC.

05:00.400 --> 05:06.000
So we can be interoperable with it.

05:06.560 --> 05:11.120
The standard is described in the RFC 8627.

05:11.120 --> 05:17.000
It describes, this document describes fully how an FTP stream can be protected with flexible

05:17.000 --> 05:19.000
FEC.

05:19.000 --> 05:24.720
It gives the format for the repair packet that will be sent to carry the run-down-see

05:24.720 --> 05:34.240
information and it proposes the codes to generate those packets and to decode to reconstruct

05:34.240 --> 05:36.520
the lost packets.

05:36.520 --> 05:44.360
This RFC is applicable to all media, not only video but also video, text and application.

05:44.360 --> 05:52.000
So now we will explain you how it works as described in this RFC document.

05:52.000 --> 06:00.760
So at first when you have a video stream you send the packets within an FTP session with

06:00.760 --> 06:03.320
a source RTP stream.

06:03.320 --> 06:07.680
Your packets are here represented by the squares.

06:07.680 --> 06:12.680
They have a unique sequence number that increase with time.

06:12.680 --> 06:20.400
And when you want to make a flexible FEC you add another run-down-see RTP stream and you

06:20.400 --> 06:22.360
don't change the source stream.

06:22.360 --> 06:26.400
So it is backward compatible.

06:26.400 --> 06:33.360
The principle is simply to take a set of source packets, combine them with your XO with a

06:33.360 --> 06:38.800
priority FEC encoder and generate a repair packet here.

06:38.800 --> 06:43.400
So for example this one is called R5, R4.

06:43.400 --> 06:46.720
Why using XO operation?

06:46.720 --> 06:56.360
It is because of a nice property of this operation that makes you able to recover one of the

06:56.360 --> 07:00.480
packets if you have all the other.

07:00.480 --> 07:05.960
So you can encode a packet and decode a missing packet.

07:05.960 --> 07:15.200
At the receiver side when you detect a loss, for example here the packet S4 has been lost,

07:15.200 --> 07:25.480
you can get it back by applying your exclusive OR over S6, S5 and the repair packet R4.

07:25.480 --> 07:35.480
And then this new packet can be sent to the stream here.

07:35.480 --> 07:40.040
To operate your flexible FEC you can choose several parameters.

07:40.040 --> 07:44.160
You have to decide what is the length of your repair window.

07:44.160 --> 07:51.960
It is a duration interval that allows you to buffer your source packets to be sure that

07:51.960 --> 07:55.880
you have enough source packets to make the recovery.

07:55.880 --> 08:02.600
And you have to decide which packet you will combine with which one within a protection

08:02.600 --> 08:04.520
pattern.

08:04.520 --> 08:08.280
So now we present you several protection patterns.

08:08.280 --> 08:19.200
If you represent your source packets like a block here from S1 to SdL with L columns

08:19.200 --> 08:26.800
and D lines you can make a first way to protect that is a row protection, a one-dimensional

08:26.800 --> 08:32.160
non-interleave protection where the XOR is applied on the rows.

08:32.160 --> 08:39.920
So here you generate D repair packets that protects a set of source packets of length

08:39.920 --> 08:45.560
L. Another way is to combine them by columns.

08:45.560 --> 08:54.280
So here you have L repair packets that protects the source packets with depth D.

08:54.280 --> 09:01.560
So now I will show you how you can recover the source packets with this combination.

09:01.560 --> 09:08.840
So here you have an example with row protection and here with column protection.

09:08.840 --> 09:17.160
Because you have random losses in your transmission you can apply the XOR to recover the lost

09:17.160 --> 09:23.160
packets here with the row application of the XOR and here with the columns.

09:23.160 --> 09:27.960
But in some cases it will be more difficult because if you have burst in your transmission

09:27.960 --> 09:32.120
it means that you will lose a consecutive source packet.

09:32.120 --> 09:40.200
You won't be able to recover because you can't have both packets here and here you

09:40.200 --> 09:45.760
will recover the columns that have only one loss but not the columns that have more than

09:45.760 --> 09:46.760
one loss.

09:46.760 --> 09:52.720
To overcome this problem you can make a two-dimensional protection.

09:52.720 --> 09:59.560
Here you have simply the combination of row protection and column protection and it generates

10:00.360 --> 10:04.040
L plus D repair packets.

10:04.040 --> 10:12.200
In this case you have in the RFC an iterative algorithm to recover the lost packets.

10:12.200 --> 10:21.120
So here I show you two examples with long burst here and here with random loss.

10:21.120 --> 10:23.760
The algorithm starts like this.

10:23.760 --> 10:28.680
You repair at first all the rows that can be repaired.

10:28.800 --> 10:37.400
Then you apply the XOR on the columns and you repeat so the rows, the columns until you

10:37.400 --> 10:42.200
can't repair any more any packets.

10:42.200 --> 10:46.840
Here you can see that the burst has been fully resolved.

10:46.840 --> 10:53.960
All the packets have been recovered but sometimes you don't have chains and you can't recover

10:53.960 --> 11:00.400
some patterns that are connected like a cycle here.

11:00.400 --> 11:05.080
So in this case you can do much more with the flexible efficiency.

11:05.080 --> 11:11.320
But this two-dimensional protection is really efficient for bursts.

11:11.320 --> 11:16.520
But sadly it has a cost because you have to send a lot of repair packets.

11:16.520 --> 11:23.960
You can measure the impact on the width that you will need with this term the overhead.

11:23.960 --> 11:29.240
It is a ratio between the number of bytes of the repair packets that you sent over the

11:29.240 --> 11:32.760
number of bytes of the protected source packets.

11:32.760 --> 11:38.360
Usually the repair packets are bigger than the source packets but if you suppose that

11:38.360 --> 11:45.320
all the source packets are approximately the same size, the overhead will be 1 over L

11:45.320 --> 11:52.680
for the row protection, 1 over D for the column protection and 1 over L plus 1 over D for

11:52.680 --> 11:55.960
the two-dimensional protection.

11:55.960 --> 12:04.240
For example here are the values of the overhead with increasing values of L and D on increasing

12:04.240 --> 12:05.680
protection level.

12:05.680 --> 12:11.240
You see that the overhead increases very fast.

12:11.240 --> 12:16.600
The RFC describes also what are the formats of the packets.

12:16.600 --> 12:24.520
So first you have your source packets with the LTP convention with an LTP header and

12:24.520 --> 12:26.800
a LTP payload.

12:26.800 --> 12:33.080
And you will generate your repair packets that are also LTP packets with a header and

12:33.080 --> 12:34.080
a payload.

12:34.080 --> 12:38.960
But within this payload you will carry two kinds of information.

12:38.960 --> 12:41.800
The first one is written in the FERC header.

12:41.800 --> 12:47.920
It's information about how to identify which source packets are protected.

12:47.920 --> 12:55.000
And in the repair payload you will have the result of the XOR operation between the payloads

12:55.000 --> 12:57.080
of the source packets.

12:57.080 --> 13:03.400
When you apply the XOR between the payload here you have to be sure that your source

13:03.400 --> 13:04.800
packets have the same length.

13:04.800 --> 13:12.400
So sometimes you will need to add zeros at the end of your payload in order to have the

13:12.400 --> 13:16.400
same length for all packets.

13:16.400 --> 13:23.440
A single repair packet will carry all the information needed to recover the source packets.

13:23.440 --> 13:29.920
It says the size of the source packet protected and which is the configuration of the protection.

13:29.920 --> 13:37.560
For example, here when you have R1 and you see that in the FEC header you read L is positive

13:37.560 --> 13:39.320
and D is zero.

13:39.320 --> 13:46.200
You know that you have a raw protection and the sequence number of the source packets

13:46.200 --> 13:54.800
that are protected comes from S1 to SN plus L minus 1 with the consecutive values.

13:54.800 --> 14:01.240
If L is positive but D is equal to 1 you also have a raw protection but you are inside

14:01.240 --> 14:03.120
a two-dimensional pattern.

14:03.120 --> 14:09.160
So you know that you will collect several repair packets that protect rows and then

14:09.160 --> 14:13.840
you will have a set of repair packets that protect the columns.

14:13.840 --> 14:21.080
And when L is positive and D is more than 1 you have the column FEC protection and the

14:21.080 --> 14:24.960
repair packets that are protected are interleaved.

14:24.960 --> 14:35.320
So from SN to SN plus D minus 1 times L and it can be the column of the two-dimensional

14:35.320 --> 14:46.160
FEC block protection but it also can be a single column protection in one dimension.

14:46.160 --> 14:52.600
This method has been implemented in our project NINFON.

14:52.600 --> 14:59.200
We decided to use four sets of L and D parameters.

14:59.200 --> 15:06.480
It comes from one-dimensional very low protection to high protection with three and three.

15:06.480 --> 15:14.160
Ideally we want to have two-dimensional parity protection but it has a cost because you have

15:14.160 --> 15:17.680
to send a lot of data.

15:17.680 --> 15:24.680
So we decided to adapt our protection to the loss rate that is measured in the transmission

15:24.680 --> 15:28.160
and also to the network capabilities.

15:28.160 --> 15:33.360
The repair window is 200 milliseconds.

15:33.360 --> 15:40.400
It is long enough to collect all the repair packets for any values of L and D and it doesn't

15:40.400 --> 15:44.440
cause any delay in the video.

15:44.440 --> 15:50.840
The RFC has been implemented in C and C++ in our LINFON SDK.

15:50.840 --> 15:58.320
All the elements of the FEC stream are written in the library ORTP and in our streaming engine

15:58.320 --> 16:09.840
for video and audio we added a way to manage the video quality with the flexible FEC.

16:10.280 --> 16:15.320
For many months about our strategy for the video quality, our rule is to make the best

16:15.320 --> 16:20.680
possible use to use the bandwidth but sometimes you don't know the bandwidth at the beginning

16:20.680 --> 16:21.680
of the call.

16:21.680 --> 16:26.640
It can change during the call and you have all events to manage.

16:26.640 --> 16:33.240
We want an optimal video setting so the best definition betrayed and firm rates but most

16:33.240 --> 16:35.880
important we don't want freeze in the video.

16:35.880 --> 16:44.720
So we decided to prioritize the packet protection before having high encoding setting.

16:44.720 --> 16:52.400
To have an adaptability to the network events we make periodic control of several values

16:52.400 --> 17:00.320
so we measure regularly the available bandwidth, the loss rate and the bandwidth that is dedicated

17:00.320 --> 17:03.240
to FEC.

17:03.240 --> 17:12.400
For example in this graph you can see that we propose to have low FEC protection when

17:12.400 --> 17:20.040
you have low bandwidth and to enable high level of FEC only when the loss rate is very

17:20.040 --> 17:29.880
high but if you have a lot of bandwidth you can have full FEC protection it is not a problem.

17:29.880 --> 17:35.640
And finally when you have congestions it means that you have too much packets and the transmission

17:35.640 --> 17:37.920
stops.

17:37.920 --> 17:44.840
You disable immediately the FEC because it is not your tool and it will make the things

17:44.840 --> 17:48.400
worse.

17:48.400 --> 17:56.240
So now we will show you some video with flexible FEC activated.

17:56.240 --> 18:03.200
So here you have a video, so we simulate a video call with a moving pattern.

18:03.200 --> 18:10.960
In the first window here there is 6% of packet losses and we do no protection so you can

18:10.960 --> 18:13.760
see that the video is really bad.

18:13.760 --> 18:21.400
It is a very very bad case, 6% is really a lot of losses.

18:21.400 --> 18:28.320
In this window we have enabled the FEC with a one dimensional row protection with L is

18:28.320 --> 18:29.800
equal to 5.

18:29.800 --> 18:35.440
You see that the video moves a little more but they are still freezing.

18:35.440 --> 18:42.680
In the last window it is a two dimensional FEC protection with a high level, 3 L is equal

18:42.680 --> 18:45.280
to 3 and D is equal to 3.

18:45.280 --> 18:51.240
And you can see that here the video is perfectly fluent so we have recovered all the lost information

18:51.240 --> 18:54.080
here.

18:54.080 --> 19:04.160
We have measured the recovery rate here with several values of FEC protection and you see

19:04.160 --> 19:06.400
that it increases very fast.

19:06.400 --> 19:12.240
So the flexible FEC is really interesting to recover the lost packets and the effects

19:12.240 --> 19:15.840
are really obvious.

19:15.840 --> 19:23.000
Another example here, this time we have simulated a transmission with loss and burst so we

19:23.000 --> 19:29.760
lose consecutive packets so it is a very bad situation.

19:29.760 --> 19:35.400
This time you can see that the performance of the FEC reconstruction decreases a little

19:35.400 --> 19:37.720
but they are still interesting.

19:37.720 --> 19:45.920
In the two dimensional parity protection you can see now some phrases but it is still

19:45.920 --> 19:52.520
much more fluent than the initial video.

19:52.520 --> 19:57.600
So we can make some conclusions about flexible FEC.

19:57.600 --> 20:04.400
It is a simple and resilient way to improve the resiliency to the packet loss in video

20:04.400 --> 20:07.400
transmission.

20:07.400 --> 20:15.200
It is based on the fact that you send redundant information on a dedicated stream.

20:15.200 --> 20:22.440
It is adaptable to the level and the event of your network and it works with a short

20:22.440 --> 20:29.840
delay because you don't have to wait that the sender sends you back the missing information.

20:29.840 --> 20:37.600
And the exclusive operation is really efficient and rapid.

20:37.600 --> 20:43.080
But you have to keep in mind that you will need a significant bandwidth so in some cases

20:43.080 --> 20:46.480
it is not indicated.

20:46.480 --> 20:54.760
The RFC 8627 gives a complete description of the flexible FEC scheme and it is clever

20:54.760 --> 21:01.560
because it is also backward compatible with the RTP protocol.

21:01.560 --> 21:07.240
And we show that it gives a real improvement in the video quality.

21:07.240 --> 21:13.760
So we decided to release it this year in the video calls of the Linfuan project and we

21:13.760 --> 21:22.880
want to in future work add it to the video conference and the audio stream.

21:22.880 --> 21:29.880
So thank you for your attention and we will be happy to answer any questions.

21:29.880 --> 21:51.880
Thank you.

21:51.880 --> 21:54.800
The question is about the size of the source packet.

21:54.800 --> 21:59.960
And in fact you are right, it is an issue that we have to deal with.

21:59.960 --> 22:03.880
The source packets doesn't have the same size.

22:03.880 --> 22:10.520
And for the encoding you have to pad the payload to make the XOR operation.

22:10.520 --> 22:17.360
And the thing is that when you combine them to build your repair packet you will have

22:17.360 --> 22:23.160
very high, very big repair packets and your overheads will be increasing a lot because

22:23.160 --> 22:25.040
of few big source packets.

22:25.040 --> 22:29.560
So that is a problem that you have to deal with.

22:29.560 --> 22:38.760
So you can change the size of the source packet if possible to make the more equal sizes.

22:38.760 --> 22:44.600
But you have to adapt the overheads to decide to have, you have to measure your overheads

22:44.600 --> 22:52.360
to check that the repair packets are not too big compared to the source packets and to

22:52.360 --> 23:02.040
decide to reduce the FEC protection in order to keep an overhead reasonable.

23:02.040 --> 23:08.480
But yes you have to take care of the real size of your source packets.

23:08.480 --> 23:11.240
I don't know if it answers your question.

23:11.240 --> 23:12.240
Thank you.

23:12.240 --> 23:13.240
Yes?

23:13.240 --> 23:24.600
Then you always have this fixed delay of 200 milliseconds, right?

23:24.600 --> 23:25.600
On the repair window?

23:25.600 --> 23:26.600
Yes.

23:26.600 --> 23:27.600
So we have a fixed value here.

23:27.600 --> 23:34.120
The question is do we have a fixed duration for the repair window of 200 milliseconds?

23:34.120 --> 23:35.120
Or it can be changed?

23:35.120 --> 23:36.120
The fixed delay.

23:36.120 --> 23:37.120
The question is the video output is put on the screen 200 milliseconds after the respective

23:37.120 --> 23:44.120
video break has arrived, right?

23:44.120 --> 23:52.080
Yes, the 200 milliseconds is a delay that you had before displaying your video.

23:52.080 --> 23:53.080
Yes?

23:53.080 --> 23:54.080
I'm sorry.

23:54.080 --> 23:55.080
Okay.

23:55.080 --> 23:57.080
Yes, that's the, in fact yes.

23:57.080 --> 23:58.080
Yes?

23:58.080 --> 24:06.080
So when you assemble in the stream and rows and columns, I know the second one is reversed.

24:06.080 --> 24:07.080
Is that right?

24:07.080 --> 24:08.080
No, it's not reversed.

24:08.080 --> 24:19.280
In fact, sorry, it was maybe not clear in the representation.

24:19.280 --> 24:25.280
You have, okay.

24:25.280 --> 24:26.280
This one?

24:26.280 --> 24:27.280
Yes.

24:27.280 --> 24:30.400
The draw comes back to here.

24:30.400 --> 24:34.280
So you read those one, then those one, and then those one.

24:34.280 --> 24:41.280
The second question, do you have any examples of an STP line describing how this is expected?

24:41.280 --> 24:42.280
Those ones.

24:42.280 --> 24:51.280
You have an example of an STP packet that contains a line that describes how this is established.

24:51.280 --> 24:56.280
The question is, is it mandatory to signal?

24:56.280 --> 25:03.280
So when the stream is a setup on the signaling layer, you have no flyer, I'm guessing, you

25:03.280 --> 25:08.280
still use STP and this would exist as a line in the STP to describe how it's established.

25:08.280 --> 25:09.280
Yes.

25:09.280 --> 25:18.280
The question is to know if during the call exchange, we signal the use of this protocol

25:18.280 --> 25:21.280
into the STP right.

25:21.280 --> 25:23.280
I'm not sure.

25:23.280 --> 25:24.280
There is a.

25:24.280 --> 25:25.280
Yes, okay.

25:25.280 --> 25:26.280
Signaling.

25:26.280 --> 25:27.280
That's the answer.

25:27.280 --> 25:28.280
Okay.

25:28.280 --> 25:29.280
Yes.

25:29.280 --> 25:43.280
So what you described seems very similar to RAID 5 with disk drives.

25:43.280 --> 25:50.280
So when you join drives in RAID, you have an eight blocks and then you have one drive

25:50.280 --> 25:57.280
block which contains a pad bit for each of the blocks.

25:57.280 --> 26:04.280
But there's also RAID 6 which has not one but two pad blocks.

26:04.280 --> 26:08.280
Could that be applicable to your skin here?

26:08.280 --> 26:16.280
So you have a line of five packets and then you have not one but two redundancy packets

26:16.280 --> 26:23.280
which could help you recover the line between two packets of lost.

26:23.280 --> 26:24.280
Okay.

26:24.280 --> 26:31.280
So the question is about what happens if we lose repair packets for example or if we.

26:31.280 --> 26:37.280
Could that skin be improved with having two pallet packets but one?

26:37.280 --> 26:39.280
Not one packet but two.

26:39.280 --> 26:45.280
Yes, it may be it's always a trade-off between what you what bond with you have and what

26:45.280 --> 26:49.280
you decide to send to improve the protection.

26:49.280 --> 26:55.280
There is a other way to other protection pattern described in the RFC.

26:55.280 --> 27:02.280
For example, you can decide to protect small very specific source packets by using for

27:02.280 --> 27:05.280
example a flexible mask.

27:05.280 --> 27:12.280
So you can have maybe here in this example decide to protect some packets twice and some

27:12.280 --> 27:15.280
other once or not at all.

27:15.280 --> 27:24.280
Yes, it can be an improvement to prioritize the most important packets in your stream.

27:24.280 --> 27:26.280
And there is other schemes.

27:26.280 --> 27:28.280
One pair is one pair two block one.

27:28.280 --> 27:33.280
Yes, there is other parity codes.

27:33.280 --> 27:40.280
Honestly, I have to try to tell you which one can be better.

27:40.280 --> 27:45.280
I don't know.

27:45.280 --> 27:50.280
Probably one of the problems if you apply too much protection is that you're also going

27:50.280 --> 27:51.280
to a lot of overhead.

27:51.280 --> 27:56.280
So at one point if you're in a lossy network, you send more data to try to recover from

27:56.280 --> 28:01.280
more loss, you end up in this spinning spiral that doesn't make things better.

28:01.280 --> 28:08.280
So finding the balances is where the black magic is usually.

28:08.280 --> 28:09.280
Well, thanks Flo.

28:09.280 --> 28:10.280
Well, no, it's okay.

28:10.280 --> 28:11.280
Oh, there's one more question.

28:11.280 --> 28:12.280
Please go ahead, we have some time.

28:12.280 --> 28:17.280
Maybe regarding exactly what you said, how do you know that you don't make it worse?

28:17.280 --> 28:20.280
Yes, in fact, we had the problem.

28:20.280 --> 28:27.280
So at some point we sent more information in the written on stream than simply sending

28:27.280 --> 28:29.280
the video stream twice.

28:29.280 --> 28:36.280
In that case, we control the overhead periodically.

28:36.280 --> 28:43.280
And when it goes above, for example, 1.9, you reduce the FEC protection.

28:43.280 --> 28:45.280
It's not always indicated.

28:45.280 --> 28:49.280
So it's a decision that you have to make.

28:49.280 --> 28:54.280
We have established empirical rules to manage that.

28:54.280 --> 28:55.280
Yes?

28:55.280 --> 29:00.280
I want to ask you about the masking of your gold right now.

29:00.280 --> 29:01.280
Yes?

29:01.280 --> 29:04.280
The slide is right now there.

29:04.280 --> 29:08.280
You have said that you can protect the specific package.

29:08.280 --> 29:10.280
Yes, like you protect a group of packets.

29:10.280 --> 29:11.280
Yes?

29:11.280 --> 29:14.280
That's for example in video conversations for you.

29:14.280 --> 29:23.280
For example, the push and the step or that X2, 6, 4, and you protect, for example, the

29:23.280 --> 29:29.280
key frames do be interpolated instead of, isn't it?

29:29.280 --> 29:35.280
Yes, so the question is if you can protect, for example, the key frames of the video conference.

29:35.280 --> 29:38.280
Yes, it's a way to choose which packet you want to protect.

29:38.280 --> 29:45.280
If you don't want to protect everything, but mainly the key frame, it's a good approach.

29:45.280 --> 29:52.280
Or you can make the one-dimensional, two-dimensional only protection, only when you have the packets

29:52.280 --> 29:54.280
of the key frame.

29:54.280 --> 29:55.280
Okay.

29:55.280 --> 29:56.280
So the receiver size.

29:56.280 --> 30:00.280
Is it right like all your key frames are on one column and you just protect them?

30:00.280 --> 30:07.280
Yes, but you, so the key frames are not necessarily in the same rows or the same columns, but you

30:07.280 --> 30:11.280
can change the values of D and L whenever you want.

30:11.280 --> 30:18.280
On the receiver side, the receiver just read what it has in the FEC header.

30:18.280 --> 30:26.280
You see the value of D, the value of L, and it adapts the configuration to recover the lost packets.

30:26.280 --> 30:30.280
Okay, so you can modify that value dynamically during the...

30:30.280 --> 30:36.280
Yes, you can dynamically modify the protection configuration.

30:36.280 --> 30:41.280
And it's very powerful.

30:41.280 --> 30:42.280
Yes.

30:42.280 --> 30:47.280
How do you measure the network's bandwidth, for example?

30:47.280 --> 30:51.280
Because without provoking the network with high load, right?

30:51.280 --> 30:54.280
Yes, how do we measure the available bandwidth?

30:54.280 --> 31:05.280
We have estimator in our program that tries to measure the...

31:05.280 --> 31:15.280
If I remember, the time delay between the reception of packets and try to establish the bit rate.

31:15.280 --> 31:20.280
And we see if there is congestion, if there is congestion occurs or not.

31:20.280 --> 31:23.280
But it's based on estimation.

31:23.280 --> 31:26.280
We have to deal with that.

31:26.280 --> 31:33.280
Yes, the idea of the algorithm that we use is to measure the regularity of the packet at the receiver side.

31:33.280 --> 31:38.280
And when it changes, we can deduce that the bandwidth is more...

31:38.280 --> 31:40.280
is close to be saturated.

31:40.280 --> 31:44.280
This is more or less the way that we use.

31:44.280 --> 31:47.280
So do you use RTCP for this configuration?

31:47.280 --> 31:52.280
Yes, and we also use RTCP feedback as well in order to measure...

31:52.280 --> 31:56.280
packet losses from the receiver side.

31:56.280 --> 32:00.280
But it's a bit different than just bandwidth.

32:00.280 --> 32:06.280
For the bandwidth, it's really the regularity of the receiver side, which is a measure.

32:15.280 --> 32:16.280
Thanks, Bois.

32:16.280 --> 32:17.280
Thank you.

32:22.280 --> 32:23.280
Thank you.

