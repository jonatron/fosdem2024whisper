WEBVTT

00:00.000 --> 00:07.000
I'll scare me like that.

00:07.000 --> 00:17.000
Alright, without further ado, I want to introduce you to Paris.

00:17.000 --> 00:23.000
Paris is here. He was supposed to give the talk together with George, but George could not make it.

00:23.000 --> 00:28.000
Paris is going to tell us about the 3DS, but I know that he also has knowledge of the Nintendo 64,

00:28.000 --> 00:31.000
so make sure to ask him any questions about that as well.

00:31.000 --> 00:33.000
Did I forget anything, Paris?

00:33.000 --> 00:40.000
No, that's all I think. Alright, then please take it away.

00:40.000 --> 00:44.000
Alright, hello everyone. Welcome to our talk on the Panda 3DS.

00:44.000 --> 00:49.000
We'll cover a variety of topics, but first I'll introduce the three names on this list.

00:49.000 --> 00:54.000
First is George. He is the creator of Panda 3DS and this presentation.

00:54.000 --> 01:03.000
Next, me, Paris, I'm a contributor in Panda 3DS, and we also have David, who helped a lot with making the presentation really pretty.

01:03.000 --> 01:05.000
You don't want to see the original version.

01:05.000 --> 01:10.000
For questions, you can ask either after the talk or on the Panda 3DS Discord server.

01:10.000 --> 01:17.000
And lastly, you can send an email to these two to punish them for not showing up here.

01:17.000 --> 01:20.000
So, what is Panda 3DS?

01:20.000 --> 01:25.000
Panda 3DS is a Nintendo 3DS emulator for Windows, Mac OS, Linux and Android.

01:25.000 --> 01:29.000
Just like all emulator projects, we have several goals and aspirations,

01:29.000 --> 01:34.000
such as providing users with a pleasant experience, creating a portable code base,

01:34.000 --> 01:39.000
exploring new possibilities, researching the 3DS, expanding the RedPandicold,

01:39.000 --> 01:45.000
aiding homebrew developers in their 3DS software, and fun, usually.

01:45.000 --> 01:54.000
Here's a peek at Panda 3DS. We have three frontends, the SDL one, the QT one, and we also have an Android version.

01:54.000 --> 01:57.000
Let's take a look at what we're going to be discussing today.

01:57.000 --> 02:02.000
So, three topics. First, we're going to go over the hardware architecture of the 3DS.

02:02.000 --> 02:08.000
Next, we're going to talk about the 3DS software stack, that means the Horizon operating system and the user land.

02:08.000 --> 02:11.000
Finally, we're going to go over emulating the 3DS.

02:11.000 --> 02:18.000
We're going to talk about the levels of emulation, points of interest for new developers of the 3DS, etc.

02:18.000 --> 02:22.000
So, this is the first glance at the 3DS hardware.

02:22.000 --> 02:30.000
Most of the action happens in this big chip named the CTR, which is where Citrus name comes from.

02:30.000 --> 02:38.000
It has three CPUs. So, one is this ARM 11 right here, and this is what runs all 3DS code.

02:38.000 --> 02:45.000
It also has this ARM 9, which is the same model that was used in the DS and the DSi.

02:45.000 --> 02:52.000
And next is this ARM 7 CPU, which is the same in the DS and DSi, and also in the Game Boy Advance.

02:52.000 --> 02:55.000
We're going to see why it has three CPUs in a second.

02:55.000 --> 03:04.000
But first, there's also the DSP, the digital signal processor for audio, and then there is the Pica 200 GPU, which uploads to two displays right there.

03:04.000 --> 03:08.000
One notable thing about the top display is that, as you can see, there's two frames here,

03:08.000 --> 03:15.000
and that is because it would generate two frames, one for each eye, to sort of create this fake 3D effect.

03:15.000 --> 03:18.000
It has some other miscellaneous hardware.

03:18.000 --> 03:25.000
It has 128 megabytes of RAM in the original version, and the new one has 256, and some other miscellaneous stuff.

03:25.000 --> 03:27.000
We're going to go over all of that.

03:27.000 --> 03:35.000
But first, the reason that it had three CPUs is because, actually, the 3DS can run DS and GBA games natively.

03:35.000 --> 03:41.000
And a fun fact about this is that many people didn't know that the 3DS can run GBA games natively,

03:41.000 --> 03:45.000
because only those who were part of the Nintendo's ambassador program could use this feature officially.

03:45.000 --> 03:55.000
And that program is something that Nintendo launched for people that bought the 3DS at the original price of $250 before it dropped to $170.

03:55.000 --> 04:00.000
Nowadays, there's an open source interface for running GBA games called OpenAGBFirm.

04:00.000 --> 04:05.000
Alright, so inside the system on chip first, there is the ARM 11,

04:05.000 --> 04:10.000
and in the original 3DS, it is composed of two cores running at 268 MHz.

04:10.000 --> 04:13.000
That first core is not supposed to look like that, but let's ignore it.

04:13.000 --> 04:18.000
In the new 3DS, there is four cores running at 804 MHz.

04:18.000 --> 04:23.000
And we're going to see exactly what each core does, but first let's look inside one of these cores.

04:24.000 --> 04:29.000
Okay, of course, my clicking doesn't work, so I'm going to manually go to a different slide.

04:29.000 --> 04:32.000
This was supposed to be a cool transition, but it didn't work.

04:32.000 --> 04:39.000
Alright, inside the ARM 11 core, there is the ARM V6 architecture, and it is composed of three instruction sets.

04:39.000 --> 04:44.000
There is the ARM, the 32-bit main instruction set, that is what most game code is.

04:44.000 --> 04:52.000
There is the thumb, this is a reduced 16-bit version of the ARM instruction set for improved code density.

04:52.000 --> 05:03.000
Some operating system code uses thumb, and then there is Giselle, which is a Java byte code runner in hardware, essentially.

05:03.000 --> 05:07.000
Games don't use this, some homebrew uses this.

05:07.000 --> 05:09.000
There is also a vector floating point unit.

05:09.000 --> 05:14.000
There is media instructions for video and audio decoding, say your cut scenes, stuff like that.

05:14.000 --> 05:19.000
There is an MMU for running multi-tasking operating systems, and I guess more stuff.

05:20.000 --> 05:22.000
And there is a branch predictor out of order completion.

05:22.000 --> 05:26.000
Alright, now I will transition back to my normal slide.

05:26.000 --> 05:29.000
Alright, let's pretend everything worked.

05:29.000 --> 05:37.000
There is the ARM 9, which is the same as we said that was in the DS, and it has the ARM V5 architecture.

05:37.000 --> 05:46.000
In 3DS mode, it's actually used, however, to manage storage and cryptography hardware, so it's not completely unusable in the 3DS.

05:46.000 --> 05:49.000
It runs part of the operating system, we're going to look into that.

05:49.000 --> 05:57.000
And then there is the ARM 7, which is for DS and GBA backwards compatibility, and it is completely disabled in 3DS mode.

05:57.000 --> 06:00.000
How do the cores communicate with each other?

06:00.000 --> 06:07.000
Well, in the ARM 11, they use shared memory and interrupts to communicate with each other, and a bus.

06:07.000 --> 06:13.000
The ARM 11 with the ARM 9 communicates with this thing called the PXI-FIFO.

06:13.000 --> 06:17.000
PXI stands for a processor exchange interface.

06:17.000 --> 06:20.000
I mean, there's the bait. Some people say processor interconnect.

06:20.000 --> 06:23.000
Some people say pixie, as in furry, I don't know.

06:23.000 --> 06:27.000
Then the ARM 9 communicates with the ARM 7 using the IPC-FIFO.

06:27.000 --> 06:29.000
That was what it was called in the DS.

06:29.000 --> 06:32.000
So, it's the same there.

06:32.000 --> 06:40.000
And now we're quickly talking about the Pica 200, which is Nintendo's first off-the-shelf GPU in a handheld, and what was used in 3DS.

06:40.000 --> 06:50.000
It implements OpenGL ES 1.1, although most games didn't use OpenGL, and it has some extensions, and some of those include per fragment lighting,

06:50.000 --> 07:00.000
which means it can calculate lighting per fragment instead of per vertex, hardware saddle mapping, polygon subdivision through the use of geometry shaders,

07:00.000 --> 07:08.000
subsurface scattering, which is the scattering of light as it penetrates a translucent object, and more, many, many more.

07:08.000 --> 07:16.000
And games communicate with the GPU using a piece of shared memory, which is used to store GPU commands and some other interrupt info.

07:16.000 --> 07:25.000
If a game wants to render, it first needs to write to the Pica's external registers, which can figure the frame buffer and some other secondary things,

07:25.000 --> 07:30.000
and then they need to initialize the rendering context, which is done by configuring the internal registers,

07:30.000 --> 07:37.000
and this is done through the use of GPU commands, as before it was done through the use of writing to a memory address.

07:37.000 --> 07:46.000
Pica command lists are nothing more than a list of values, describing patterns and data for writing to the GPU internal registers.

07:46.000 --> 07:48.000
So that's all there is to it.

07:48.000 --> 07:51.000
This is a white square.

07:51.000 --> 08:01.000
This is Mikage, a demo by DMP for Pica 200 that was presented at SIGGref 2006, so they could show off their new GPU.

08:01.000 --> 08:09.000
It shows the impressive shadows, like you can see here, and fragment lighting functionality, like, for example, in the Samurai's helmet.

08:09.000 --> 08:20.000
And also, there is, you can't see it there, but the floor, the wood grain, was procedurally generated because the Pica 200 could procedurally generate textures.

08:20.000 --> 08:27.000
The name Mikage, that's where the Mikage 3DS emulator got its name from.

08:27.000 --> 08:34.000
And you may be wondering that, you know, Citro got its name from the CTR, Mikage got it from this, where did Panda get its name from?

08:34.000 --> 08:39.000
That is a really good question, so if you find the answer, do let me know.

08:39.000 --> 08:44.000
Alright, my computer is lagging.

08:44.000 --> 08:53.000
Well, that's the joy of running it in a VM, so you could use a PowerPoint.

08:53.000 --> 09:03.000
It would be quite nice if it would run live right now.

09:03.000 --> 09:10.000
Oh, this is awkward.

09:10.000 --> 09:18.000
Yeah.

09:18.000 --> 09:23.000
Is that a thing? It's like frozen. Oh, it's back.

09:23.000 --> 09:30.000
Alright, I'll restart the virtual machine just to be safe. Or maybe I won't. Let's see.

09:30.000 --> 09:33.000
Aha!

09:33.000 --> 09:35.000
No, no, no.

09:35.000 --> 09:37.000
You're good on time still.

09:37.000 --> 09:41.000
Okay, good. How do I send this?

09:41.000 --> 09:44.000
Aha! Alright, sorry about that.

09:44.000 --> 09:47.000
Oh, now my first window is buggy. Okay, great.

09:47.000 --> 09:51.000
So, this is a Vertex shader in the Pica 200.

09:51.000 --> 09:56.000
The Pica 200 didn't use a high level shading language like GLSL.

09:56.000 --> 10:00.000
Instead, shaders were usually written in assembly.

10:00.000 --> 10:04.000
So, let me actually try to fix my thing.

10:04.000 --> 10:06.000
Okay, I guess I can.

10:06.000 --> 10:12.000
There is uniforms at the top, just like in a GLSL shader, which is a read-only piece of data.

10:12.000 --> 10:14.000
In this case, it's our projection matrix.

10:14.000 --> 10:18.000
There's constants, output attributes and input attributes.

10:18.000 --> 10:21.000
So, our position are in color, we want to output.

10:21.000 --> 10:24.000
And moving down to the main function here,

10:24.000 --> 10:30.000
it calculates for dot products to combine the projection metrics with our input coordinates

10:30.000 --> 10:35.000
and moves the output color. It doesn't do any modifications there.

10:35.000 --> 10:38.000
So, we're quickly talking about the pixel pipeline.

10:38.000 --> 10:43.000
So, in modern GPUs, fragment shaders are used,

10:43.000 --> 10:48.000
which is a small program essentially to run the fragment pipeline.

10:48.000 --> 10:51.000
But in the Pica 200, there is no fragment shaders.

10:51.000 --> 10:56.000
Instead, it has a six-stage color combiner to do so.

10:56.000 --> 10:58.000
So, essentially what would happen is,

10:58.000 --> 11:03.000
Vertex data would come from programmable shader units into the rasterizer.

11:03.000 --> 11:07.000
The rasterizer would generate a position.

11:07.000 --> 11:12.000
And then, four textures would be sampled using these texture units.

11:12.000 --> 11:15.000
All of them could do 2D textures.

11:15.000 --> 11:19.000
The first one could also do cube maps, 3D textures.

11:19.000 --> 11:23.000
And the last one could also do procedural textures.

11:23.000 --> 11:28.000
And then, this texture data and the Vertex data would be passed to the color combiners,

11:28.000 --> 11:30.000
along with lighting data.

11:30.000 --> 11:34.000
And color combiner is essentially what the name suggests, color combiner.

11:34.000 --> 11:39.000
It takes in two inputs and a way to operate between these two inputs

11:39.000 --> 11:41.000
and sort of produces a new color.

11:41.000 --> 11:45.000
So, for example, you could have two textures that you want to combine,

11:45.000 --> 11:49.000
or you could have a texture and lighting source that you want to combine.

11:49.000 --> 11:53.000
And after that, after passing through all the six stages,

11:53.000 --> 11:56.000
you get a color which is then post-processed,

11:56.000 --> 11:58.000
and voila, you get the Kirby,

11:58.000 --> 12:03.000
which, for example here, the beanstalk is mixed.

12:03.000 --> 12:06.000
The beanstalk texture with the lighting from light source.

12:06.000 --> 12:08.000
This is why it has, like, a scene here.

12:08.000 --> 12:11.000
And then on the leaf Kirby standing on, there's a gradient from left to right.

12:11.000 --> 12:14.000
That's not probably how the texture was of the leaf.

12:14.000 --> 12:19.000
Instead, it was using a color combiner combining with horizontal position,

12:19.000 --> 12:23.000
so it gets darker as it goes to the right.

12:23.000 --> 12:26.000
Some sewing off of the pica, some games.

12:26.000 --> 12:30.000
So, Captain Toad Treasure Tracker is known for being good and clever

12:30.000 --> 12:33.000
with lighting and shadow effects.

12:33.000 --> 12:35.000
The Legend of Zelda Ocarina of Time,

12:35.000 --> 12:39.000
which uses the fog rendering hardware that pica has,

12:39.000 --> 12:43.000
and also ADC-1, which is a format you probably never heard of,

12:43.000 --> 12:46.000
which is a compressed texture format.

12:46.000 --> 12:51.000
Mario and Luigi Paper Jam, it generates the seawater via procedurally generated textures.

12:51.000 --> 12:54.000
And Super Mario 3D Land, the sole source of things,

12:54.000 --> 12:56.000
like stencil testing, logic operations,

12:56.000 --> 13:00.000
command lists that invoke other command lists and more.

13:00.000 --> 13:04.000
And now we're talking about the digital signal processor.

13:04.000 --> 13:09.000
It is the same one that was used in the DSi, but in the 3D S2s, far more.

13:09.000 --> 13:13.000
And most games would ship with a common firmware,

13:13.000 --> 13:18.000
which includes support for 24 audio channels, ASC audio decoder,

13:18.000 --> 13:21.000
for games like Pokemon X and Y and Fire Emblem,

13:21.000 --> 13:25.000
multiple audio encodings, effects such as reverb, delay,

13:25.000 --> 13:28.000
both mono and stereo input, but only stereo output.

13:28.000 --> 13:34.000
And the architecture for this digital signal processor

13:34.000 --> 13:36.000
might seem a little bit weird,

13:36.000 --> 13:42.000
but it's not really because, well, for example, it has 16-bit bytes instead of typical 8-bits.

13:42.000 --> 13:45.000
And that is because it is a digital signal processor

13:45.000 --> 13:50.000
and needs to process samples, which usually are 16-bits, but not always.

13:50.000 --> 13:54.000
It has some weird instructions that you may not find in a typical CPU,

13:54.000 --> 13:56.000
such as multiply ad.

13:56.000 --> 14:01.000
It has support for type loops, which is necessary for such work,

14:01.000 --> 14:04.000
and 500 kilobytes of memory.

14:04.000 --> 14:08.000
And this is a rendering of the DSP doing math, I guess,

14:08.000 --> 14:10.000
Georgia at this time.

14:10.000 --> 14:13.000
And then there is some other miscellaneous hardware that we saw earlier.

14:13.000 --> 14:15.000
So the RAM, we went through that.

14:15.000 --> 14:18.000
There is also 6 and 10 megabytes of VRAM,

14:18.000 --> 14:23.000
one-time programmable memory for storage uniques, console uniques, sorry,

14:23.000 --> 14:25.000
controller, DMA engine, cryptography engine.

14:25.000 --> 14:27.000
You're probably not interested in all of that.

14:27.000 --> 14:33.000
There's two back cameras and a front camera and an EIR front LED,

14:33.000 --> 14:36.000
which is used in the new 3DS for face tracking,

14:36.000 --> 14:41.000
because actually the fake 3D effect would be quite straining.

14:41.000 --> 14:44.000
They would need this.

14:44.000 --> 14:47.000
All right, and we've reached the point to talk about the software stack,

14:47.000 --> 14:51.000
and we're going to start by talking about the Horizon OS.

14:51.000 --> 14:54.000
So the Horizon OS was the operating system of the 3DS,

14:54.000 --> 14:57.000
and it was split between the RM11 CIS score,

14:57.000 --> 15:01.000
which I actually skipped because my transition didn't work.

15:01.000 --> 15:03.000
So let me find the slide.

15:03.000 --> 15:06.000
I'm sorry about this.

15:06.000 --> 15:10.000
Oh, okay, I guess everything is broken now, huh?

15:10.000 --> 15:12.000
Okay, let's see here.

15:12.000 --> 15:14.000
Close this.

15:14.000 --> 15:17.000
Aha!

15:17.000 --> 15:18.000
Okay, quick interjection.

15:18.000 --> 15:20.000
Sorry about that.

15:20.000 --> 15:23.000
What's the problem about the cores because of that broken effect before?

15:23.000 --> 15:26.000
In the original 3DS, there is two cores.

15:26.000 --> 15:28.000
One is the up core, one is the CIS score.

15:28.000 --> 15:31.000
The up core runs usual in apps, including games and system apps.

15:31.000 --> 15:34.000
The CIS score runs the operating system and services.

15:34.000 --> 15:36.000
We're going to see what those are in just a second.

15:36.000 --> 15:38.000
And the new 3DS has two more cores.

15:38.000 --> 15:40.000
One is for the head tracking service,

15:40.000 --> 15:42.000
which is for the straining effect that we talked about,

15:42.000 --> 15:45.000
and the other is just available as another app core.

15:45.000 --> 15:46.000
So they would have two cores.

15:46.000 --> 15:48.000
All right, after this quick interjection,

15:48.000 --> 15:52.000
I'm going to go back to the operating system, if I may.

15:52.000 --> 15:54.000
All right.

15:54.000 --> 16:01.000
So yeah, the R9 is for security and IO as we just saw earlier.

16:01.000 --> 16:05.000
So you need to get a firm grasp of firms.

16:05.000 --> 16:07.000
There is four in the 3DS.

16:07.000 --> 16:09.000
The one we're going to be talking about is the native firm,

16:09.000 --> 16:11.000
which runs 3DS games natively.

16:11.000 --> 16:13.000
This is the 3DS mode.

16:13.000 --> 16:16.000
In the R11 part of the operating system,

16:16.000 --> 16:18.000
the R11 runs the usual length and the majority of the

16:18.000 --> 16:21.000
operating system code while the R9 is dedicated to

16:21.000 --> 16:23.000
cryptography and cartridge.

16:23.000 --> 16:26.000
There is the AGB firm for GBA games natively.

16:26.000 --> 16:29.000
And the R7 is the start of the solo runs all the game code.

16:29.000 --> 16:33.000
There is the Twilight firm for the S, pretty much the same.

16:33.000 --> 16:35.000
And then there is the Safe firm,

16:35.000 --> 16:38.000
which is a bare bones version of native firm for recovery.

16:38.000 --> 16:40.000
And you also can use it for updating.

16:40.000 --> 16:43.000
But later on, from now on, actually,

16:43.000 --> 16:46.000
we're going to look at only the native firm here for when we

16:46.000 --> 16:48.000
talk about stuff.

16:48.000 --> 16:52.000
And the kernel inside the R11 is called kernel 11.

16:52.000 --> 16:55.000
I'm going to go through a brief introduction of what is a kernel.

16:55.000 --> 16:57.000
Every operating system has a kernel,

16:57.000 --> 16:59.000
which is considered the core of the operating system and

16:59.000 --> 17:02.000
handles various critical functionality.

17:02.000 --> 17:05.000
So in the 3DS R11, there is this kernel 11 and it is what we

17:05.000 --> 17:07.000
call a microkernel.

17:07.000 --> 17:11.000
A microkernel essentially tries to be as small as possible.

17:11.000 --> 17:14.000
It runs its services in user space, things that it needs to do,

17:14.000 --> 17:17.000
such as file systems and networking.

17:17.000 --> 17:20.000
It is less code, which means less vectors of attack.

17:20.000 --> 17:23.000
And it's generally considered to be more reliable.

17:23.000 --> 17:26.000
So if something crashes, not the whole thing crashes,

17:26.000 --> 17:29.000
like if your network crashes, the kernel doesn't.

17:29.000 --> 17:32.000
Examples are this kernel 11 and also Minix, for example.

17:32.000 --> 17:34.000
And then there is a monolithic kernel.

17:34.000 --> 17:37.000
There's more types of kernels, but these are the major ones.

17:37.000 --> 17:40.000
In the monolithic kernel, all or most services run inside

17:40.000 --> 17:42.000
the kernel proper.

17:42.000 --> 17:45.000
And there is supposed to be fewer context switches,

17:45.000 --> 17:48.000
so everything is supposed to be faster inside the kernel.

17:48.000 --> 17:51.000
One example of a monolithic kernel is Linux.

17:51.000 --> 17:54.000
Kernel calls happen via the supervisor call,

17:54.000 --> 17:57.000
SVC, which is this.

17:57.000 --> 18:01.000
Here is an example of the assembly function called SVC.

18:01.000 --> 18:04.000
And like most operating system, kernel level is not a pure

18:04.000 --> 18:08.000
microkernel, but it is still a microkernel and handles memory

18:08.000 --> 18:11.000
management, processing thread management,

18:11.000 --> 18:16.000
and service and process intercommunication.

18:16.000 --> 18:18.000
Let's see what a service is.

18:18.000 --> 18:20.000
So services, as we said, usually end processes.

18:20.000 --> 18:23.000
And inside the 3DS, they're managed by another service

18:23.000 --> 18:26.000
called the service manager.

18:26.000 --> 18:29.000
In order to interact with a service, say you're a game

18:29.000 --> 18:32.000
and you need to interact with them, first you need to get

18:32.000 --> 18:35.000
a handle to the service manager itself, which is a public service,

18:35.000 --> 18:37.000
unlike all others.

18:37.000 --> 18:40.000
And you do so using a supervisor call.

18:40.000 --> 18:42.000
And once you have a handle to the service manager,

18:42.000 --> 18:45.000
you can ask it for the handle to the service you actually want

18:45.000 --> 18:47.000
to use, say the file system service.

18:47.000 --> 18:50.000
And you do so using the sent sync request.

18:50.000 --> 18:53.000
So you request the handle from the service manager

18:53.000 --> 18:55.000
through the sent request.

18:55.000 --> 18:57.000
Then you need to set up a parameter buffer with the function

18:57.000 --> 19:00.000
you want to call to that service in the file system,

19:00.000 --> 19:02.000
say the file system service you want to call the read file

19:02.000 --> 19:04.000
function, which might not exist.

19:04.000 --> 19:06.000
And you pass the function you're being called,

19:06.000 --> 19:08.000
and the necessary parameters.

19:08.000 --> 19:10.000
And then you need to send a request to the service,

19:10.000 --> 19:12.000
again using sent sync request.

19:12.000 --> 19:15.000
And you receive an output buffer.

19:15.000 --> 19:18.000
The majority of communication with services is implemented

19:18.000 --> 19:20.000
with requests like this.

19:20.000 --> 19:23.000
Sometimes shared memory is used to reduce latency

19:23.000 --> 19:26.000
for some crucial services, such as the GPU service.

19:26.000 --> 19:29.000
And requests and responses are really thread-locked with storage.

19:29.000 --> 19:33.000
And as the name suggests, sent sync request, that is,

19:33.000 --> 19:37.000
they are synchronous, which means they're not a sync.

19:37.000 --> 19:40.000
The response is written after the function returns.

19:40.000 --> 19:43.000
But some services can't use something to happen later.

19:43.000 --> 19:46.000
So for example, there is this Y2R service, which is

19:46.000 --> 19:51.000
YUV2RGB color, is typically used for decoding videos

19:51.000 --> 19:53.000
and FMVs and cut scenes.

19:53.000 --> 19:56.000
It doesn't stall until it's finished, which might take a while.

19:56.000 --> 20:00.000
Instead, it notifies you when it's done using a kernel event.

20:00.000 --> 20:03.000
These are some important services.

20:03.000 --> 20:07.000
So there's the file system, the DSP, the GSP for GPU,

20:07.000 --> 20:10.000
communication, app for applets,

20:10.000 --> 20:12.000
HID for input, et cetera.

20:12.000 --> 20:14.000
There's many, many.

20:14.000 --> 20:17.000
This is a function that asks the HID to HID service

20:17.000 --> 20:19.000
to enable the gyroscope.

20:19.000 --> 20:21.000
It gets a thread command buffer.

20:21.000 --> 20:25.000
It makes a header to send in, and it sends a sync request.

20:25.000 --> 20:29.000
It checks if there is an error, and otherwise gets the result.

20:31.000 --> 20:33.000
So there is then Process9.

20:33.000 --> 20:36.000
And Process9 is what runs inside the ARM9,

20:36.000 --> 20:40.000
and it is unlike the kernel 11,

20:40.000 --> 20:43.000
it is a monolithic single process kernel.

20:43.000 --> 20:46.000
And all it handles, like we said, is cryptography

20:46.000 --> 20:50.000
and device IO talking to the cartridge, to the SD card, et cetera.

20:50.000 --> 20:53.000
It has over-complicated C++ that reverse engineers hate,

20:53.000 --> 20:55.000
and it's really, really big.

20:55.000 --> 20:59.000
And here's a funny quote by PSI, creator of Corgi3DS,

20:59.000 --> 21:02.000
goes, if you ever feel useless, just know that Process9

21:02.000 --> 21:04.000
calculates a ha ha on the CPU,

21:04.000 --> 21:07.000
despite having access to a full hardware shanjin.

21:07.000 --> 21:10.000
All right, so this is live demos,

21:10.000 --> 21:13.000
but my system just broke, so I'm not going to do the live demos.

21:13.000 --> 21:15.000
I'm actually going to show you a video of the live demos.

21:15.000 --> 21:17.000
So here's a static frame.

21:17.000 --> 21:23.000
Here's a video of Pand3DS running on a Discord button.

21:23.000 --> 21:25.000
This is done through HTTP streaming.

21:25.000 --> 21:29.000
There is a server, and it sends the frames,

21:29.000 --> 21:32.000
and it becomes a GIF, and you can use the buttons to play

21:32.000 --> 21:34.000
at two frames per second.

21:34.000 --> 21:36.000
We've actually finished some games using this,

21:36.000 --> 21:38.000
so it's not as bad as it looks.

21:38.000 --> 21:41.000
This failed too, all right.

21:41.000 --> 21:44.000
Here is Lua scripting in Pand3DS,

21:44.000 --> 21:48.000
so you can use Lua scripts to create MGUI windows like this,

21:48.000 --> 21:51.000
and you can create a lag.

21:51.000 --> 21:53.000
Okay, there we go.

21:53.000 --> 21:56.000
You can create cheats and stuff.

21:56.000 --> 22:00.000
So you can...Pand3DS exposes these, like, functions,

22:00.000 --> 22:03.000
such as write16, so you can write to address and stuff,

22:03.000 --> 22:06.000
and it also exposes events, so you can do a function of a frame.

22:06.000 --> 22:09.000
So here I'm going to change, for example, the slider,

22:09.000 --> 22:11.000
if the video...

22:11.000 --> 22:13.000
Okay, let's skip the video.

22:13.000 --> 22:16.000
Oh, no, actually, here you can increment the RUPIC count,

22:16.000 --> 22:18.000
and there is also a button below that says...

22:18.000 --> 22:20.000
you can't see it, but it says murder link,

22:20.000 --> 22:23.000
and pretend I pressed it and link died.

22:23.000 --> 22:25.000
Oh, there you go. All right.

22:25.000 --> 22:27.000
Let's get away from the videos.

22:27.000 --> 22:30.000
All right, so there is a hidden emulation talk

22:30.000 --> 22:33.000
inside this 3DS architecture talk.

22:33.000 --> 22:35.000
So first, before we get into it,

22:35.000 --> 22:38.000
I need to introduce you to HLE and OLE.

22:38.000 --> 22:41.000
So HLE stands for high-level emulation,

22:41.000 --> 22:43.000
and in high-level emulation,

22:43.000 --> 22:46.000
you essentially reimplement parts of the emulator system software

22:46.000 --> 22:49.000
in your own code to avoid emulating the hardware

22:49.000 --> 22:51.000
that is needed to run said software.

22:51.000 --> 22:54.000
So, for example, I told you that the DSP

22:54.000 --> 22:57.000
has a common firmware that most games use.

22:57.000 --> 23:00.000
Well, instead of emulating the over-complicated DSP,

23:00.000 --> 23:03.000
you can emulate this common firmware.

23:03.000 --> 23:06.000
The calls that would happen,

23:06.000 --> 23:09.000
you do so by re-implementing it in C++.

23:09.000 --> 23:11.000
The opposite of that is HLE,

23:11.000 --> 23:14.000
where you would emulate the entire DSP,

23:14.000 --> 23:18.000
which is, you know, much harder, or actually may not be.

23:18.000 --> 23:20.000
And then you run the actual software,

23:20.000 --> 23:23.000
the DSP firmware, on that hardware.

23:23.000 --> 23:25.000
There is benefits to each side.

23:25.000 --> 23:28.000
So, for example, LLE is slow

23:28.000 --> 23:30.000
because you emulate the entire hardware,

23:30.000 --> 23:32.000
but HLE is not easy.

23:32.000 --> 23:34.000
You need to reverse engineer the software.

23:34.000 --> 23:36.000
You want to run, et cetera.

23:36.000 --> 23:38.000
We're going to look a bit more into that.

23:38.000 --> 23:40.000
So for the 3DS specifically,

23:40.000 --> 23:42.000
you can HLE the operating system.

23:42.000 --> 23:44.000
So kernels, services, process nine,

23:44.000 --> 23:47.000
there's more things you can add HLE.

23:47.000 --> 23:50.000
And this is an example of something being HLE.

23:50.000 --> 23:52.000
So there is the file system service,

23:52.000 --> 23:56.000
and this is an HLE implementation of the file system service

23:56.000 --> 23:58.000
that returns if an SD card is inserted.

23:58.000 --> 24:00.000
And if you were to LLE this,

24:00.000 --> 24:05.000
you would need to emulate the complex SD hardware interface.

24:05.000 --> 24:09.000
So, you know, there are some benefits to HLE, of course.

24:09.000 --> 24:11.000
So just a quick summary.

24:11.000 --> 24:15.000
LLE is tedious because there's much, much harder to implement,

24:15.000 --> 24:16.000
especially in the 3DS,

24:16.000 --> 24:18.000
and it's also slower.

24:18.000 --> 24:21.000
But, beneficially, you can run any 3DS software,

24:21.000 --> 24:24.000
including bare metal firmware such as Linux for 3DS

24:24.000 --> 24:25.000
or GodMode 9.

24:25.000 --> 24:27.000
HLE is again tedious

24:27.000 --> 24:29.000
because there's so many services to implement.

24:29.000 --> 24:32.000
But it is performant, but still are prone,

24:32.000 --> 24:34.000
and there's many things to reverse engineer.

24:34.000 --> 24:36.000
There is also a hybrid approach you can do.

24:36.000 --> 24:39.000
So you can HLE the kernels,

24:39.000 --> 24:41.000
but you could LLE most operating system services.

24:41.000 --> 24:43.000
And what does LLE services mean?

24:43.000 --> 24:45.000
Well, services, as we said, are usual and apps.

24:45.000 --> 24:49.000
So you can literally just take the binary and just run it.

24:49.000 --> 24:52.000
That would be LLE-ing it in your emulated hardware.

24:52.000 --> 24:53.000
You run it.

24:53.000 --> 24:55.000
This is a nice bit of balance.

24:55.000 --> 24:58.000
It minimizes work, improves performance, and accuracy.

24:58.000 --> 25:00.000
Maintains accuracy.

25:00.000 --> 25:01.000
So as a 3DS MUDAP,

25:01.000 --> 25:05.000
you need to consider how you're going to approach the CPU.

25:05.000 --> 25:07.000
And there is many ways to do so.

25:07.000 --> 25:10.000
First, let's take a look at interpreters.

25:10.000 --> 25:13.000
An interpreter, you essentially interpret

25:13.000 --> 25:15.000
all the opcodes that you need to run,

25:15.000 --> 25:18.000
which is to say you switch through them, you decode them.

25:18.000 --> 25:22.000
This is slow, but it's also very portable.

25:22.000 --> 25:25.000
As long as your code compiles to the target platform,

25:25.000 --> 25:28.000
you're pretty much good to go, usually.

25:28.000 --> 25:30.000
And this might be your choice

25:30.000 --> 25:34.000
because a GIT might be very hard or impossible

25:34.000 --> 25:38.000
on whatever you're targeting, say an iPhone, I don't know,

25:38.000 --> 25:40.000
or WASM.

25:40.000 --> 25:45.000
GIT recompilation is converting the ARM code to host CPU code.

25:45.000 --> 25:47.000
So if you're running on an X64,

25:47.000 --> 25:50.000
you would convert the ARM32 code to X64.

25:50.000 --> 25:52.000
This is the most common solution.

25:52.000 --> 25:57.000
It's also easier if you use dynamic, like Citroen Panda Do,

25:57.000 --> 26:01.000
which can perform ARM32 to X86 or ARM64.

26:01.000 --> 26:05.000
So you can run most devices that most people might care about,

26:05.000 --> 26:09.000
such as computers and phones and stuff like that.

26:09.000 --> 26:12.000
Then you could also consider virtualization.

26:12.000 --> 26:15.000
As far as I know, this hasn't been tried yet in the 3DS,

26:15.000 --> 26:18.000
but there is an ongoing request to try to do this.

26:18.000 --> 26:23.000
So virtualization is the way apps like VMware and VirtualBox work.

26:23.000 --> 26:28.000
And on some ARM32 and some ARM64 devices,

26:28.000 --> 26:32.000
there is the possibility to execute 3DS code natively

26:32.000 --> 26:34.000
through the use of virtualization.

26:34.000 --> 26:36.000
It's not possible on all ARM64 devices

26:36.000 --> 26:38.000
because they're removing this functionality, unfortunately.

26:38.000 --> 26:40.000
But on some Raspberry Pi, for example,

26:40.000 --> 26:42.000
and some rooted Android phones,

26:42.000 --> 26:45.000
you can run 3DS code natively implementing this.

26:45.000 --> 26:49.000
We don't yet know if it's faster than GIT, but yeah.

26:49.000 --> 26:51.000
And then you could also consider

26:51.000 --> 26:54.000
ahead-of-time recompilation potentially.

26:54.000 --> 26:59.000
So that would mean recompiling the ARM code from the code section

26:59.000 --> 27:01.000
to your host operating system.

27:01.000 --> 27:03.000
This has a benefit compared to the GIT,

27:03.000 --> 27:06.000
which is that if you ahead-of-time compile,

27:06.000 --> 27:08.000
you don't need to compile fast,

27:08.000 --> 27:10.000
which means that you can perform optimizations.

27:10.000 --> 27:13.000
So for example, you could use something like LLVM

27:13.000 --> 27:16.000
to produce optimal code.

27:16.000 --> 27:20.000
So yeah, this is another potential way you could run your games.

27:20.000 --> 27:23.000
Then you need to consider how you're going to approach the GPU.

27:23.000 --> 27:26.000
Again, there is two ways to go about it.

27:26.000 --> 27:30.000
So you could do software rendering, which is simpler,

27:30.000 --> 27:32.000
but again, portable and slower.

27:32.000 --> 27:34.000
That's the downside.

27:34.000 --> 27:36.000
You could also do a hardware renderer,

27:36.000 --> 27:39.000
which draws on the GPU using something like OpenGL,

27:39.000 --> 27:42.000
Vulkan, Metal, et cetera, DirectX.

27:42.000 --> 27:45.000
This is much faster and obviously ideal for playing games,

27:45.000 --> 27:49.000
but less portable.

27:49.000 --> 27:52.000
So for software renderers, how do you make them faster?

27:52.000 --> 27:54.000
That's what you've got to consider.

27:54.000 --> 27:56.000
Well, there's many ways to make them faster.

27:56.000 --> 27:58.000
For example, there is multi-threading.

27:58.000 --> 28:01.000
You can draw on concurrently on several threads.

28:01.000 --> 28:04.000
And then you could also use a recompiler for a software renderer.

28:04.000 --> 28:08.000
So you would take the pika state, the current render state.

28:08.000 --> 28:10.000
You would make a small binary for it,

28:10.000 --> 28:13.000
and you would run it for set state for every pixel.

28:13.000 --> 28:18.000
So this would avoid like running a branch for everything.

28:18.000 --> 28:21.000
For example, if the depth buffer is disabled

28:21.000 --> 28:24.000
and you don't want to check for every pixel.

28:24.000 --> 28:27.000
This is optimal, optimized.

28:27.000 --> 28:29.000
And you can also reuse this compiled binary

28:29.000 --> 28:32.000
if the same rendering state arises again.

28:32.000 --> 28:34.000
This is something that, for example,

28:34.000 --> 28:37.000
PCSX2 does for its software renderer.

28:37.000 --> 28:40.000
And then for hardware rendering, well, it's challenging.

28:40.000 --> 28:44.000
You have to make sure you choose the ideal API,

28:44.000 --> 28:48.000
manage surfaces correctly, such as textures, color buffers, et cetera.

28:48.000 --> 28:50.000
There's many, many other problems to solve.

28:50.000 --> 28:54.000
For example, dealing with the parts that are on really OpenGL compliant

28:54.000 --> 28:57.000
or games that use depth buffers, color buffers,

28:57.000 --> 28:59.000
and write to them directly.

28:59.000 --> 29:01.000
Or, yeah, there's many, for example,

29:01.000 --> 29:03.000
tracking when a texture has changed,

29:03.000 --> 29:05.000
and it's no longer valid.

29:05.000 --> 29:07.000
There's many issues to solve in a hardware renderer,

29:07.000 --> 29:10.000
which makes it a bit harder.

29:10.000 --> 29:12.000
Then you're going to consider how you're going to approach

29:12.000 --> 29:13.000
the pika state.

29:13.000 --> 29:15.000
So again, you can do it in Turbo.

29:15.000 --> 29:18.000
That's simple and also too slow.

29:18.000 --> 29:20.000
You could do a GIT on the CPU.

29:20.000 --> 29:22.000
So this is the vertex state that we saw before,

29:22.000 --> 29:26.000
and it is converted to some scary looking X64 assembly.

29:26.000 --> 29:29.000
A little more 64 assembly, scary looking.

29:29.000 --> 29:31.000
And then another approach.

29:31.000 --> 29:34.000
This is decent performance, but it could be better.

29:34.000 --> 29:39.000
Is to recompile these satyrs from this state to your own GPU.

29:39.000 --> 29:42.000
So something like GLSL or Spurvee, for example.

29:42.000 --> 29:44.000
This would give even better performance,

29:44.000 --> 29:49.000
but it might not be possible for some select pika satyrs.

29:49.000 --> 29:53.000
So, yeah, let's move on.

29:53.000 --> 29:57.000
Then you need to consider how you're going to emulate

29:57.000 --> 29:58.000
the pika pixel pipeline.

29:58.000 --> 30:00.000
There's a lot of things to emulate in the 3DS.

30:00.000 --> 30:03.000
So one approach to specialized satyrs.

30:03.000 --> 30:05.000
I think this is what Citra does.

30:05.000 --> 30:07.000
So essentially you compile a specialized satyr

30:07.000 --> 30:10.000
for each pika pixel pipeline configuration.

30:10.000 --> 30:12.000
That's how you will emulate the pika pixel pipeline

30:12.000 --> 30:14.000
and run it on your GPU.

30:14.000 --> 30:16.000
This has low GPU usage because those specialized satyrs

30:16.000 --> 30:19.000
are specialized and small,

30:19.000 --> 30:22.000
but lots of time spent compiling satyrs

30:22.000 --> 30:25.000
which causes stutters on some games.

30:25.000 --> 30:27.000
This is the most common approach.

30:27.000 --> 30:29.000
Panda3DS currently doesn't have this,

30:29.000 --> 30:34.000
but it has uber satyrs, which is a term coined by Dolphin

30:34.000 --> 30:38.000
which aims to solve that issue of specialized satyrs

30:38.000 --> 30:41.000
of causing stutters.

30:41.000 --> 30:43.000
You essentially take an entire emulator

30:43.000 --> 30:46.000
for the pika pixel pipeline and run it inside a GPU fragment

30:46.000 --> 30:47.000
satyr.

30:47.000 --> 30:49.000
So you don't need to compile many times.

30:49.000 --> 30:51.000
You just compile once and you run it forever.

30:51.000 --> 30:53.000
This, however, has higher GPU usage

30:53.000 --> 30:55.000
because it's very, very big,

30:55.000 --> 30:57.000
but no compilation stutter.

30:57.000 --> 30:59.000
And it works well on more PC GPUs,

30:59.000 --> 31:01.000
but struggles on mobile GPUs, for example,

31:01.000 --> 31:04.000
or lower end ones maybe, because it's very big.

31:04.000 --> 31:06.000
And this is what Panda3DS does,

31:06.000 --> 31:08.000
but, however, an even better solution would be

31:08.000 --> 31:10.000
to do hybrid emulation.

31:10.000 --> 31:13.000
So you will compile the specialized satyrs

31:13.000 --> 31:15.000
as synchronously in the background,

31:15.000 --> 31:17.000
which you couldn't do before because you need them to render.

31:17.000 --> 31:20.000
And while they're compiling on a different thread,

31:20.000 --> 31:22.000
you use the uber satyr right here,

31:22.000 --> 31:24.000
which is, this is used for every call

31:24.000 --> 31:26.000
until the relevant satyr is ready.

31:26.000 --> 31:29.000
And this gives, I think, better performance

31:29.000 --> 31:32.000
than either method and works well on all GPUs.

31:32.000 --> 31:35.000
And this is what Panda3DS wishes to achieve

31:35.000 --> 31:39.000
after we've, after we're done with specialized satyrs.

31:39.000 --> 31:43.000
And finally, there is the audio DSP.

31:43.000 --> 31:46.000
There is two approaches, as we saw earlier.

31:46.000 --> 31:48.000
There is the LLE approach.

31:48.000 --> 31:51.000
In the LLE, you need to consider how do you optimize it?

31:51.000 --> 31:55.000
Do you recompile the firmware to your own architecture?

31:55.000 --> 31:57.000
Do you do it ahead of time?

31:57.000 --> 32:00.000
Teacro comes to mind, which is an emulator,

32:00.000 --> 32:03.000
assembler, disassembler for the TIC DSP,

32:03.000 --> 32:05.000
and it's used in Citra and Mount DS.

32:05.000 --> 32:08.000
And you could also, instead, HLE DSP,

32:08.000 --> 32:12.000
which should be faster, and things you need to do with that

32:12.000 --> 32:15.000
is improving the current DSP reverse engineering efforts.

32:15.000 --> 32:17.000
It hasn't been fully reverse engineered.

32:17.000 --> 32:20.000
You need to make test runs and tooling.

32:20.000 --> 32:22.000
And then you would need to optimize it.

32:22.000 --> 32:26.000
You could do so using SIMB or SIMD,

32:26.000 --> 32:29.000
and multi-threading and end-end.

32:29.000 --> 32:31.000
That is all for emulation.

32:31.000 --> 32:35.000
And now I'll show you again some ways

32:35.000 --> 32:38.000
we are exploring new territory in the 3DS emulation

32:38.000 --> 32:41.000
to sort of wrap up this talk.

32:41.000 --> 32:43.000
So Panda3DS comes with fluid scripting,

32:43.000 --> 32:46.000
including a text editor, so developers can make scripts

32:46.000 --> 32:49.000
and mods and tests and stuff like that.

32:49.000 --> 32:51.000
And we also have MGUI support.

32:51.000 --> 32:53.000
You can have your little windows.

32:53.000 --> 32:56.000
And I think it's pretty cool.

32:56.000 --> 32:59.000
Also Panda3DS here is running CTR aging,

32:59.000 --> 33:05.000
a factory test program some other emulators may struggle with.

33:05.000 --> 33:07.000
And Panda3DS running on the Wii,

33:07.000 --> 33:11.000
via the same HTTP streaming, not natively on the Wii.

33:11.000 --> 33:13.000
Yeah, yeah, unfortunately.

33:13.000 --> 33:15.000
Not natively on the Wii, just using HTTP streaming.

33:15.000 --> 33:18.000
We thought to show it off because we have an HTTP server.

33:18.000 --> 33:20.000
Just throw it on the Wii, whatever.

33:20.000 --> 33:24.000
And the physics book there, the monitor rest,

33:24.000 --> 33:26.000
I failed that class.

33:26.000 --> 33:28.000
All right.

33:28.000 --> 33:30.000
We have a revolutionary UI.

33:30.000 --> 33:32.000
It has Panda icons.

33:32.000 --> 33:36.000
You can play on Discord with all your friends.

33:36.000 --> 33:39.000
That is it for me.

33:39.000 --> 33:41.000
Thank you very much.

33:41.000 --> 33:50.000
APPLAUSE

33:50.000 --> 33:53.000
Hello, hello. Test? Does it work?

33:53.000 --> 33:54.000
Yeah.

33:54.000 --> 33:56.000
OK. Thanks for nice talk.

33:56.000 --> 33:58.000
Anybody has any questions?

33:58.000 --> 34:00.000
We have quite some time.

34:00.000 --> 34:01.000
I'll start here.

34:01.000 --> 34:02.000
Hello.

34:02.000 --> 34:03.000
Hello.

34:03.000 --> 34:08.000
Great talk. How much time did it take to build all that stuff?

34:09.000 --> 34:12.000
Well, I think we've been working on it

34:12.000 --> 34:15.000
since the FOSTA applications opened,

34:15.000 --> 34:17.000
since we got accepted, actually.

34:17.000 --> 34:20.000
So I would say, like, about three months now,

34:20.000 --> 34:22.000
something like that.

34:22.000 --> 34:25.000
The original version was not nice,

34:25.000 --> 34:28.000
but we fixed it.

34:28.000 --> 34:29.000
So yeah.

34:29.000 --> 34:31.000
Maybe you can give us a presentation of the...

34:31.000 --> 34:33.000
Oh, I'm sorry.

34:33.000 --> 34:35.000
LAUGHTER

34:35.000 --> 34:37.000
Silly me.

34:37.000 --> 34:38.000
Three months.

34:38.000 --> 34:39.000
Three months.

34:39.000 --> 34:41.000
Yeah, we built all this and the presentation.

34:41.000 --> 34:43.000
LAUGHTER

34:43.000 --> 34:45.000
All right.

34:45.000 --> 34:49.000
No, it has been in development since September 2022.

34:49.000 --> 34:51.000
Yeah, so more than three months.

34:51.000 --> 34:54.000
One and a half years now.

34:54.000 --> 34:56.000
Sorry. Hello.

35:00.000 --> 35:03.000
I have a question regarding GPU emulation.

35:03.000 --> 35:04.000
Yes.

35:04.000 --> 35:07.000
Have you considered using parts of Mesa, for example,

35:07.000 --> 35:10.000
which has a lot of GPU stacks, open-jade implementations,

35:10.000 --> 35:13.000
and can do compilation to native GPUs?

35:13.000 --> 35:15.000
I wonder if it has been explored,

35:15.000 --> 35:18.000
not necessarily in Pandat 3DS, but any emulator?

35:18.000 --> 35:20.000
That is a good question.

35:20.000 --> 35:22.000
No, I haven't considered it.

35:22.000 --> 35:24.000
I don't know if George has.

35:24.000 --> 35:27.000
He's the main developer on the Pandat 3DS.

35:27.000 --> 35:29.000
You can ask him directly if he has,

35:29.000 --> 35:33.000
but as far as I know, no.

35:35.000 --> 35:39.000
Hey, thanks for the presentation.

35:39.000 --> 35:40.000
Hello.

35:40.000 --> 35:41.000
I was curious.

35:41.000 --> 35:44.000
Do you know how you mentioned that in the 3DS,

35:44.000 --> 35:47.000
different generations of the hardware have more hardware?

35:47.000 --> 35:51.000
How do games and other software handle that?

35:51.000 --> 35:55.000
The different generations of the 3DS have more hardware?

35:55.000 --> 35:57.000
Yeah, and the different CPU speeds and whatever.

35:57.000 --> 36:02.000
Do the games do more if they are on different versions of the 3DS?

36:03.000 --> 36:06.000
Are you talking about the DS or GBA backwards compatibility,

36:06.000 --> 36:08.000
or are you talking about 3DS games?

36:08.000 --> 36:13.000
Because the 3DS in all generations has the same CPUs,

36:13.000 --> 36:16.000
but the RM11 has more cores.

36:16.000 --> 36:19.000
Yeah, but what do they do with the more cores?

36:19.000 --> 36:23.000
Oh, I think I mentioned it, but I'll show you again here.

36:25.000 --> 36:27.000
Yeah, so one is used for running games,

36:27.000 --> 36:29.000
one is used for the operating system,

36:29.000 --> 36:31.000
this is used for head tracking,

36:31.000 --> 36:35.000
so your eyes don't get dizzy from the 3D effect on the new 3DS.

36:35.000 --> 36:37.000
These two are on the new 3DS,

36:37.000 --> 36:40.000
and then the new one, this one is available as another app core.

36:40.000 --> 36:43.000
I think for backwards compatibility,

36:43.000 --> 36:46.000
if you try to run an older game on the new 3DS,

36:46.000 --> 36:52.000
it tries to downclock the speeds and not use the extra app core,

36:52.000 --> 36:54.000
and if you run a new 3DS game,

36:54.000 --> 36:57.000
it uses both of these to run the game.

36:57.000 --> 36:58.000
Okay, thank you.

36:58.000 --> 37:02.000
What happens if you run the new game on older generation 3DS?

37:02.000 --> 37:05.000
Does it fall back here and turns off parts of the game

37:05.000 --> 37:08.000
and not to crash on the new 3DS?

37:08.000 --> 37:09.000
I'm not...

37:09.000 --> 37:13.000
Yes, they asked,

37:13.000 --> 37:17.000
what happens if you run a new 3DS game on all 3DS?

37:17.000 --> 37:21.000
And I'm not sure, but my guess would be

37:21.000 --> 37:25.000
that it would display some sort of message

37:25.000 --> 37:28.000
that you can't run it on this console.

37:28.000 --> 37:30.000
This is what happens, for example,

37:30.000 --> 37:32.000
when trying to run a Game Boy Color game on a Game Boy

37:32.000 --> 37:34.000
if there was no such support.

37:34.000 --> 37:37.000
So I would assume that's what would happen, but I'm not sure.

37:44.000 --> 37:48.000
I'm wondering about the ARM 7 core.

37:48.000 --> 37:51.000
You mentioned it was disabled on the 3DS mode,

37:51.000 --> 37:53.000
but can it be used in certain situations

37:53.000 --> 37:57.000
like running virtual console, GBA games?

37:57.000 --> 38:02.000
Can it be used to run natively, or is it still emulation?

38:02.000 --> 38:07.000
Did you ask if it's used to run natively Game Boy Advance games?

38:07.000 --> 38:08.000
Yes.

38:08.000 --> 38:12.000
Yeah, that is its only purpose, and also to run DS games,

38:12.000 --> 38:14.000
because the DS also had an ARM 7 core.

38:14.000 --> 38:17.000
The ARM 7 only exists in the 3DS to run

38:17.000 --> 38:22.000
Nintendo DS and DSi games and Game Boy Advance games natively.

38:24.000 --> 38:30.000
For the GPU emulation, did you consider using

38:30.000 --> 38:34.000
compute shaders on modern GPUs as well, like speed up

38:34.000 --> 38:37.000
parts of the rendering pipeline that are hard to do

38:37.000 --> 38:39.000
with normal fragment and vertex shaders?

38:39.000 --> 38:42.000
Yeah, that is a question for George,

38:42.000 --> 38:45.000
but I think he definitely would have considered

38:45.000 --> 38:47.000
to use compute shaders, yes.

38:49.000 --> 38:51.000
Does anybody else have a question?

38:53.000 --> 39:08.000
Yeah, my question was, you said that currently

39:08.000 --> 39:14.000
on the 3DS supports Windows Linux, Mac OS and Android,

39:14.000 --> 39:18.000
and do you expect to support more platforms in the future

39:18.000 --> 39:21.000
like Wasm or iOS?

39:22.000 --> 39:27.000
I personally wanted to try at least to port it to Wasm.

39:27.000 --> 39:30.000
It's not that easy.

39:30.000 --> 39:33.000
There's no recompiler from ARM32 to Wasm.

39:33.000 --> 39:35.000
You would need to use an interpreter.

39:35.000 --> 39:37.000
Currently, Panda 3DS doesn't have one,

39:37.000 --> 39:39.000
but we're hoping to add one eventually.

39:39.000 --> 39:44.000
And then there is WebGL, which is not great,

39:44.000 --> 39:46.000
but you can use it.

39:46.000 --> 39:49.000
Theoretically, it should be possible for Wasm,

39:49.000 --> 39:53.000
but it's in the future plans.

39:53.000 --> 39:56.000
What was your other system question?

39:56.000 --> 39:57.000
iOS.

39:57.000 --> 40:01.000
I think iOS also has some problems with running a recompiler.

40:01.000 --> 40:03.000
It needs special privileges.

40:03.000 --> 40:06.000
And also there's the fact that you can't really post an emulator

40:06.000 --> 40:08.000
on the App Store, which is unfortunate.

40:08.000 --> 40:13.000
But we definitely want to at some point, yes.

40:13.000 --> 40:14.000
That might change in the future.

40:14.000 --> 40:15.000
I may be able to.

40:15.000 --> 40:17.000
Yeah, hopefully.

40:19.000 --> 40:27.000
I have a question.

40:27.000 --> 40:29.000
I'm allowed to ask questions.

40:29.000 --> 40:31.000
So this is not really a question,

40:31.000 --> 40:34.000
but George is in the chat and he's answering some questions.

40:34.000 --> 40:36.000
I'm not sure if you have access to the chat.

40:36.000 --> 40:37.000
You can read the answers.

40:37.000 --> 40:39.000
The FOSTA chat?

40:39.000 --> 40:41.000
Yeah, it's on Matrix.

40:41.000 --> 40:44.000
No, this computer is not connected to the Internet.

40:44.000 --> 40:46.000
It's secure, ultra secure.

40:46.000 --> 40:49.000
But the answers are too long to read for now,

40:49.000 --> 40:51.000
so just check Matrix for now.

40:51.000 --> 40:54.000
So my question is, it's actually related to Anise's talk

40:54.000 --> 40:56.000
because he mentioned vertical slicing.

40:56.000 --> 40:58.000
I'm very curious, how would you do vertical slicing

40:58.000 --> 41:03.000
for complex systems such as this or Nintendo 64, for example?

41:03.000 --> 41:06.000
Could you provide a definition for vertical slicing?

41:06.000 --> 41:08.000
Like very...

41:08.000 --> 41:10.000
Anise, could you...

41:10.000 --> 41:12.000
A definition for vertical slicing.

41:12.000 --> 41:14.000
I don't think it's a good question.

41:14.000 --> 41:16.000
I have a question.

41:16.000 --> 41:22.000
Like you emulate just the necessary path to emulate,

41:22.000 --> 41:26.000
this is the start of a game, and then go on from that.

41:26.000 --> 41:29.000
Yeah, by the world, or just maybe, I don't know,

41:29.000 --> 41:34.000
a test run and then test game, and then more stuff as you go.

41:34.000 --> 41:37.000
So sort of test-driven development?

41:37.000 --> 41:40.000
More like emulating as little as possible,

41:40.000 --> 41:45.000
but just having feedback, visual feedback from the...

41:45.000 --> 41:49.000
I don't know if that's possible, emulating as little as possible.

41:49.000 --> 41:53.000
Even the simplest ROMs use quite a bit of the operating system.

41:53.000 --> 41:56.000
Even like a simple triangle uses quite a bit.

41:56.000 --> 41:58.000
So yeah, I don't know if it's possible

41:58.000 --> 42:00.000
if I understand the definition correctly.

42:00.000 --> 42:02.000
Thank you.

42:11.000 --> 42:14.000
So first question.

42:14.000 --> 42:18.000
How do you feel knowing that every second spent on emulation

42:18.000 --> 42:21.000
is making a Nintendo business executive cry?

42:21.000 --> 42:23.000
And...

42:23.000 --> 42:28.000
Secondly, do you think ahead of time compilation

42:28.000 --> 42:30.000
could seriously improve performance,

42:30.000 --> 42:32.000
especially in lower-end hardware,

42:32.000 --> 42:36.000
or do you think the actualize more on the GPU on the rendering side?

42:36.000 --> 42:38.000
Yeah, it definitely could.

42:38.000 --> 42:40.000
I don't know if it has been tried yet,

42:40.000 --> 42:43.000
but we do want to explore that possibility.

42:43.000 --> 42:46.000
The big thing about ahead of time is...

42:46.000 --> 42:50.000
Well, the thing about the 3DS is that it doesn't really

42:50.000 --> 42:54.000
do a lot of any dynamic code execution,

42:54.000 --> 42:57.000
so it should be theoretically possible.

42:57.000 --> 42:59.000
There is CROs in 3DS,

42:59.000 --> 43:04.000
which is the alternative of DLLs in 3DS,

43:04.000 --> 43:09.000
but George has told me that they can be handled.

43:09.000 --> 43:11.000
And yeah, the big thing about AOT...

43:11.000 --> 43:13.000
Yeah, that's all he told me, didn't elaborate.

43:13.000 --> 43:17.000
But the big thing about AOT is that you can optimize the code,

43:17.000 --> 43:21.000
so I would think that it would run quite faster.

43:21.000 --> 43:24.000
But we don't know.

43:25.000 --> 43:29.000
Okay, I think this is the last one.

43:29.000 --> 43:34.000
How do you deal with the system applets that the 3DS has?

43:34.000 --> 43:37.000
Do any games even interact with those in any way?

43:37.000 --> 43:39.000
When you say the system applets,

43:39.000 --> 43:41.000
do you mean like the home menu, stuff like that?

43:41.000 --> 43:43.000
Yeah, like when you go to the home menu,

43:43.000 --> 43:45.000
there's little apps at the top, for instance.

43:45.000 --> 43:47.000
How do games interact with that?

43:47.000 --> 43:51.000
Can they launch other games, that kind of stuff?

43:51.000 --> 43:54.000
Games in the 3DS only interact with services.

43:54.000 --> 43:57.000
They don't interact with the system apps.

43:59.000 --> 44:01.000
Okay, final one.

44:04.000 --> 44:08.000
Yeah, you talked a bit about the new 3DS infrastructure

44:08.000 --> 44:11.000
and the additional CPUs.

44:11.000 --> 44:15.000
And I was wondering, when you run older games

44:15.000 --> 44:18.000
that weren't using the additional CPU,

44:18.000 --> 44:23.000
does the new 3DS automatically use the additional CPUs,

44:23.000 --> 44:27.000
or are they just completely ignored and just unused?

44:27.000 --> 44:31.000
No, as far as I know, it just uses the original LabCore,

44:31.000 --> 44:35.000
the one it has, and it also down clocks it to the original speeds.

44:35.000 --> 44:37.000
Oh, well, thank you.

44:38.000 --> 44:41.000
Okay, great. Let's thank our speaker again.

44:41.000 --> 44:43.000
Thank you.

44:57.000 --> 44:59.000
Thank you.

