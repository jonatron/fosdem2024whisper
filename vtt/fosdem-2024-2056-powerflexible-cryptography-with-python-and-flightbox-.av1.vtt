WEBVTT

00:00.000 --> 00:12.000
All right, so now we have the next talk in the Python Dev Room.

00:12.000 --> 00:16.000
We're going to welcome Pascal Chambon, who's going to talk about PyFlexible

00:16.000 --> 00:20.000
PyGraph 3 with Python and FlightBox. And it's going to be interesting to see

00:20.000 --> 00:24.000
what FlightBox actually is. It says here that it's about

00:24.000 --> 00:29.000
encryption-based access control. So very warm welcome to Pascal.

00:29.000 --> 00:34.000
And this is going to be a longer talk, so he's going to have some things to show

00:34.000 --> 00:36.000
there, so it's going to be nice. Thank you.

00:36.000 --> 00:38.000
Thank you.

00:38.000 --> 00:49.000
Hello, everyone. I'm happy. I'm excited to be here to talk with you

00:49.000 --> 00:55.000
about these little things. So we are going to discuss powerful and flexible

00:55.000 --> 01:00.000
cryptography with Python, of course, on something we call FlightBox.

01:00.000 --> 01:05.000
You probably don't know because it's all you and not famous yet.

01:05.000 --> 01:12.000
So I'm Pascal Chambon. I'm from France. And I am here not as just a freelancer,

01:12.000 --> 01:16.000
but as part as a dev of the Witness Angel project.

01:16.000 --> 01:22.000
I will talk a bit later about this project, which has led me to cryptography.

01:22.000 --> 01:27.000
Whereas I was just another web developer before, and it was all new for me,

01:27.000 --> 01:33.000
and I hope you will like it too. So what's the battle we are dealing with here

01:33.000 --> 01:40.000
is that some data on many kinds of data need to be strongly protected,

01:40.000 --> 01:48.000
really strongly. The problem is that control, access control to this data

01:48.000 --> 01:54.000
can have lots of holes in it, lots and lots. So of course, there is a zero-day exploit.

01:54.000 --> 01:59.000
You're unlucky. They found a bug in the Linux kernel. You can't do anything.

01:59.000 --> 02:05.000
But lots of time is just that you forget to update your packages or there's a failure

02:05.000 --> 02:10.000
in the update system. Only in a few months, your nice server is full of little holes,

02:10.000 --> 02:18.000
vulnerabilities, even in the big and the major packages like Django and stuff like that.

02:18.000 --> 02:25.000
There are also, of course, your bugs in your code, a problem with a previous escalation

02:25.000 --> 02:30.000
and protected endpoints because there were deadlines and so something went wrong.

02:30.000 --> 02:36.000
But it's not all. You can, if you do backups of your data, because you do backups,

02:36.000 --> 02:43.000
of course, of your data, these backups can have a big source of trouble if they fall in the wrong hands.

02:43.000 --> 02:51.000
So they must also be protected. These are also pirates, your credentials to learn

02:51.000 --> 02:56.000
because they are on a post-it on the screen. It happens in lots of societies.

02:56.000 --> 03:03.000
And of course, human malevolence and human errors everywhere, phishing, stuff like that.

03:03.000 --> 03:11.000
So there are lots of attack vectors to your precious medical, personal data.

03:11.000 --> 03:22.000
So we need something better than that. We don't want each update of our server to be a cause of potential drama.

03:22.000 --> 03:27.000
For the anecdote, I have a cheap web host for my own little blobs.

03:27.000 --> 03:35.000
Like two or three times in my life, I arrived to my website and the root of the web server was exposed,

03:35.000 --> 03:44.000
the whole file system, so my data, and the data of thousands of other Django users because of a little mistake

03:44.000 --> 03:50.000
in an NGNX configuration. Now we have containers, so it's a bit better, but still, at the moment,

03:50.000 --> 03:56.000
I was a bit upset even though I have nothing important on my personal blobs.

03:56.000 --> 04:03.000
So that's why I spoil the result. We need cryptography.

04:03.000 --> 04:08.000
So let's go a little tour of the basics of cryptography.

04:08.000 --> 04:15.000
Encryption, of course. So we use what we call a cipher, cryptographic algorithm,

04:15.000 --> 04:21.000
to transform a plain text content. It's not always text. It's often not text.

04:21.000 --> 04:26.000
It can be video, image, documents, whatever you want.

04:26.000 --> 04:32.000
Encryption turns this into what we call a cipher text for the vocabulary,

04:32.000 --> 04:36.000
and the cipher text is not text at all. Don't try to read it.

04:36.000 --> 04:43.000
If it's readable, there's a problem somewhere. It's just zero and one in random order.

04:43.000 --> 04:49.000
Not random, but incompressible. Then there's hashing.

04:49.000 --> 04:54.000
Of course, most of you know, it's just taking a fingerprint, a little representation

04:54.000 --> 05:02.000
of a potentially very big content. And then there's signing, which is a way to authenticate

05:02.000 --> 05:07.000
to check the integrity of a content on most of the time to timestamp it

05:07.000 --> 05:15.000
to know where, when it was created or updated. So that's the basics of the vocabulary.

05:15.000 --> 05:21.000
Now let's talk about the first cipher type. It's the symmetric cipher.

05:21.000 --> 05:28.000
So what is it? It's a box, but a box with a keyhole.

05:28.000 --> 05:36.000
So you have a big key to go with it. So you use the key to close it.

05:36.000 --> 05:41.000
You use the same key to open it. That's why we call it symmetric cipher.

05:41.000 --> 05:48.000
This key is supposed to be 100% random in symmetric cryptography.

05:48.000 --> 05:53.000
And the problem you have, if I give you this box, you can't open it.

05:53.000 --> 05:58.000
I have to give you the key. So you have this awkward exchange of passwords

05:58.000 --> 06:02.000
over SMS or email. You know, here is the password of the zip I gave you.

06:02.000 --> 06:07.000
That's because of symmetric cryptography. Most of the time we use two channels.

06:07.000 --> 06:11.000
We should, that's the minimum we can do, use two different channels

06:11.000 --> 06:17.000
because if I send you the chest and the key, that's very interesting.

06:17.000 --> 06:23.000
And we have another metaphor, which is a cryptex, a little chest

06:23.000 --> 06:26.000
with the password written on it with little rings.

06:26.000 --> 06:30.000
And when you put the right rings, you can open it and close it.

06:30.000 --> 06:34.000
So that's the same thing. It's symmetric too, but it's not a key.

06:34.000 --> 06:40.000
It's a password, so cryptex is closer to digital world.

06:40.000 --> 06:43.000
No time for details. The slides are online.

06:43.000 --> 06:46.000
You just have to remember these two things.

06:46.000 --> 06:51.000
The winner currently this year is AES. It is everywhere.

06:51.000 --> 06:57.000
So if you need symmetric cryptography and you don't have time to think a lot

06:57.000 --> 07:00.000
on no precise needs, you take AES. Why?

07:00.000 --> 07:07.000
Because it's very famous, very tested, very secure, and its performance is

07:07.000 --> 07:11.000
especially great. Symmetric ciphers are very good at performance,

07:11.000 --> 07:15.000
but they are hardware accelerated when you, when they, you can.

07:15.000 --> 07:21.000
And AES has extensions to be accelerated on desktop platforms, servers,

07:21.000 --> 07:25.000
and also little chips like ESP32, stuff like that.

07:25.000 --> 07:29.000
They have extensions to do encryption very quickly.

07:29.000 --> 07:35.000
So no problem to encrypt your whole hardware with AES or another symmetric

07:35.000 --> 07:41.000
cipher. It just works. And it's quick and it's very hard to see the difference

07:41.000 --> 07:47.000
with not encrypting, at least in my tests, or little chips.

07:47.000 --> 07:50.000
Then there's the other one. If you have symmetric, of course,

07:50.000 --> 07:54.000
you have asymmetric. What is asymmetric cipher?

07:54.000 --> 08:02.000
It is another test so far. Same thing, but this marvelous invention

08:02.000 --> 08:08.000
that I'm showing you, showing you the most expert-noddy things, it's a padlock.

08:08.000 --> 08:14.000
It's marvelous. Why? Because I can give this open padlock to anybody.

08:15.000 --> 08:19.000
And they will take this, I can distribute thousands of them.

08:19.000 --> 08:24.000
They can put something, I don't know, here is some data, for example.

08:24.000 --> 08:30.000
Most people will never, will not use any more what it is in a few years.

08:30.000 --> 08:37.000
But we put it in the box, we close the box, we lock with the padlock,

08:37.000 --> 08:41.000
and I have this key, I keep it, it is a private key.

08:41.000 --> 08:46.000
It's not a secret key. Secret key is secret, but it's a secret you can share.

08:46.000 --> 08:50.000
Private key is private, it's my privacy, it's intimate.

08:50.000 --> 08:54.000
I must not give it to anybody. So I keep it.

08:54.000 --> 08:59.000
And we have asymmetric encryption because anybody can lock,

08:59.000 --> 09:05.000
anybody can trap data in a chest. Only I, the rightful owner of this key,

09:05.000 --> 09:10.000
can open the chest. So the use case is a bit different

09:10.000 --> 09:13.000
and very interesting, of course, in lots of cases,

09:13.000 --> 09:16.000
because you don't have to transmit your private key.

09:16.000 --> 09:20.000
You just transmit what we call public keys in the digital world

09:20.000 --> 09:23.000
that are actually, we should have named them padlocks.

09:23.000 --> 09:28.000
But it's a bit too late. We can do a petition, I don't know.

09:28.000 --> 09:34.000
No time for details. Just remember when we talk about asymmetric cipher,

09:34.000 --> 09:37.000
we talk about RSA most of the time,

09:37.000 --> 09:41.000
even though it's not the best from a purely mathematical point of view,

09:41.000 --> 09:46.000
it is here to stay. And the problem of asymmetric ciphers

09:46.000 --> 09:50.000
is that they exploit mathematical operations that are heavy,

09:50.000 --> 09:55.000
so the performance is bad. Do not encrypt your hardware with RSA.

09:55.000 --> 10:01.000
Or unless you have very much time in your hands, it's not made for that.

10:01.000 --> 10:04.000
So far, so good?

10:04.000 --> 10:07.000
OK.

10:07.000 --> 10:12.000
Then we have a little talk about digital signature.

10:12.000 --> 10:17.000
So it's the good old stamp. I hope you all have a stamp because it's so classy.

10:17.000 --> 10:22.000
And you have a fingerprint because it's a heavy operation,

10:22.000 --> 10:26.000
like asymmetric, it's kind of like asymmetric ciphering.

10:26.000 --> 10:29.000
So you apply this fingerprint on a content,

10:29.000 --> 10:32.000
and you have a magnificent seal,

10:32.000 --> 10:35.000
and you have a verifier, which is your eye in reality,

10:35.000 --> 10:39.000
or a public key in the digital world.

10:39.000 --> 10:43.000
And once you have stamped something, you have a proof of integrity,

10:43.000 --> 10:50.000
of authenticity, and also of anteriority if you put a stamp.

10:50.000 --> 10:55.000
But it's very hard to have a posteriority proof, almost impossible actually.

10:55.000 --> 11:00.000
That's bad because we would have loved to have that for the Whitney Central project.

11:00.000 --> 11:02.000
It's just impossible.

11:02.000 --> 11:04.000
But anteriority is already very good.

11:04.000 --> 11:08.000
You can show that this document existed before this day.

11:08.000 --> 11:13.000
So an example are PIS, DSS, they are not very well known.

11:13.000 --> 11:16.000
Most of the time, we don't care so much.

11:16.000 --> 11:21.000
We use a trusted signer to do that.

11:21.000 --> 11:24.000
So that's signature.

11:24.000 --> 11:28.000
And here's my preferred primitive, what we call a primitive, a little operation.

11:28.000 --> 11:31.000
It's a shared secret of Shamir.

11:31.000 --> 11:34.000
So I don't know if Shamir was the only one involved,

11:34.000 --> 11:37.000
but he managed to stick his name on this achievement

11:37.000 --> 11:41.000
because I love this algorithm, lots of people love it.

11:41.000 --> 11:44.000
It's something we don't do much in real life.

11:44.000 --> 11:48.000
We have some data once more,

11:48.000 --> 11:52.000
and we want to share it into what we call shards.

11:52.000 --> 11:57.000
But we distribute these shards to N people,

11:57.000 --> 12:01.000
and only N of them, a smaller number,

12:01.000 --> 12:03.000
are enough to reconstitute the secret.

12:03.000 --> 12:06.000
So it's not like when you cut a cake, it's more than that.

12:06.000 --> 12:10.000
So here is an example of shared secret for a barrier.

12:10.000 --> 12:14.000
I don't know for leading cause to pastures and stuff like that.

12:14.000 --> 12:17.000
Each people has one key.

12:17.000 --> 12:20.000
Each co-owner of the barrier has one key.

12:20.000 --> 12:26.000
And each time you open a padlock, you can remove a little part of the lock.

12:26.000 --> 12:29.000
And when enough of them have opened the lock,

12:29.000 --> 12:32.000
you can pull the bar and you can open the barrier.

12:32.000 --> 12:36.000
So I think most of the time here M equals 1.

12:36.000 --> 12:39.000
So one person is enough to open the barrier,

12:39.000 --> 12:43.000
but you can do fancy stuff like at least three people must come

12:43.000 --> 12:47.000
until we can open, unless we can't open the barrier.

12:47.000 --> 12:51.000
That's the secret of Shamir, and here is another example, and I love it.

12:51.000 --> 12:57.000
You see you have some weird lock on the door barrier once more.

12:57.000 --> 13:04.000
Any person that has one of these locks can open his or her lock

13:04.000 --> 13:09.000
and then slide the bars in all the senses, and it opens the whole lock.

13:09.000 --> 13:12.000
So it's unusual, but it exists,

13:12.000 --> 13:16.000
and it avoids the problem we all have in our buildings.

13:16.000 --> 13:23.000
You know everybody has the same key for the common parts like the trash room and stuff like that.

13:23.000 --> 13:29.000
And when someone does dirty stuff or gives a key to somebody else,

13:29.000 --> 13:33.000
we have trouble, we are forced to all change our key.

13:33.000 --> 13:39.000
So the secret of Shamir helps with that in the digital world.

13:39.000 --> 13:44.000
You can give parts of your secret to some people.

13:44.000 --> 13:46.000
If some of them disappear, it's not a problem.

13:46.000 --> 13:50.000
You get back your data.

13:50.000 --> 13:53.000
And what happens in real life?

13:53.000 --> 13:57.000
We use hybrid encryption scheme, as we call it.

13:57.000 --> 14:01.000
So we use the performance of symmetric cipher.

14:01.000 --> 14:06.000
It gives you a big key, a random big key.

14:06.000 --> 14:10.000
We put it in the little box,

14:10.000 --> 14:17.000
and then the person who has access to this data keeps the private key.

14:17.000 --> 14:24.000
And then we stamp whatever we want, the data, the cipher data, cipher text, plain text.

14:24.000 --> 14:28.000
There are lots of different cases.

14:28.000 --> 14:34.000
Okay, so that's already much for primitives,

14:34.000 --> 14:42.000
but we can already do much with these four primitives, these four concepts.

14:42.000 --> 14:46.000
What did we learn when we studied cryptography?

14:46.000 --> 14:50.000
Once more, we came from a web developer background where cryptography was not our problem.

14:50.000 --> 14:57.000
It was dealt for us by frameworks, by web servers and stuff.

14:57.000 --> 15:01.000
The first thing is that cryptography is dangerous.

15:01.000 --> 15:06.000
It can be harmful.

15:06.000 --> 15:08.000
Main lessons.

15:08.000 --> 15:11.000
So that's maybe the most important part.

15:11.000 --> 15:15.000
If you want to do cryptography, do not try to implement them yourself.

15:15.000 --> 15:17.000
You will get hurt.

15:17.000 --> 15:19.000
Other people too.

15:19.000 --> 15:25.000
Just trust the big experts, the big libraries, pycrypto dom, the main 10 wide, of course.

15:25.000 --> 15:29.000
Libsodium, OpenSSL and stuff.

15:29.000 --> 15:35.000
They are not perfect, but they do much better than you will do yourself.

15:35.000 --> 15:40.000
Second point to know, the order of operations is very important.

15:40.000 --> 15:48.000
So even when the primitives are strong, if you mix them up, you can have useless results or bad results.

15:48.000 --> 15:55.000
In this case, all I found was reading and reading and reading blog posts on the article on Stack Overflow posts

15:55.000 --> 16:01.000
to understand if I had to sign before or after I encrypted.

16:01.000 --> 16:04.000
Very important.

16:04.000 --> 16:08.000
Do not use the same key for different purposes.

16:08.000 --> 16:16.000
For example, my RSA key, if I use it to encrypt and to sign,

16:16.000 --> 16:19.000
I have just given my key to my enemies.

16:19.000 --> 16:23.000
So that's a very bad situation.

16:23.000 --> 16:32.000
Same thing for what we call initialization vector, non-seize, that are values that are supposed to be used once and only once.

16:32.000 --> 16:35.000
Most of the time, even if it's not mandatory, do it.

16:35.000 --> 16:38.000
It's so cheap that why not?

16:38.000 --> 16:40.000
Why not do it?

16:40.000 --> 16:47.000
Of course, when we talk about randomness in cryptography, it must be really random.

16:47.000 --> 16:51.000
So don't use a random source, if I can see that.

16:51.000 --> 16:55.000
Use a cryptographically proven source.

16:55.000 --> 16:57.000
On our desktop, it's not a problem.

16:57.000 --> 17:04.000
Really, our operating systems do a good job finding randomness with the hard drive, on the CPU lag,

17:04.000 --> 17:09.000
on the audio, the microphone, there are randomness everywhere,

17:09.000 --> 17:12.000
what we call entropy everywhere.

17:12.000 --> 17:17.000
But if you're on a little chip, on an embedded device, it becomes a real pain.

17:17.000 --> 17:24.000
And there are devices for that, devices that just create entropy, randomness.

17:24.000 --> 17:31.000
And sometimes that's the only thing you can do, because an embedded world is hard.

17:31.000 --> 17:38.000
And also, sometimes you have to let it go, like for electric curve cryptography,

17:38.000 --> 17:44.000
I was searching for the best curve, the word curve, to use for my cryptography,

17:44.000 --> 17:46.000
and there were endless debates.

17:46.000 --> 17:51.000
So in the end, just pick one which is about good, and don't try to be perfect,

17:51.000 --> 17:55.000
because there's always someone who will discuss and say,

17:55.000 --> 18:02.000
what was provided by the NSA, so we don't know what they did with it, things like that.

18:02.000 --> 18:05.000
OK.

18:05.000 --> 18:11.000
Now, some good news, because we don't want to get hurt, we did something for a reason.

18:11.000 --> 18:15.000
Cryptography is strong, and when I mean strong, it's really strong.

18:15.000 --> 18:18.000
It's not our usual strong.

18:18.000 --> 18:24.000
For example, if you want to break that chest, symmetric cipher,

18:24.000 --> 18:28.000
there's not enough energy in this room to break it.

18:28.000 --> 18:35.000
OK. Not enough energy on Earth, not enough energy in the solar system, so far so good.

18:35.000 --> 18:41.000
But there's not enough energy in the galaxy nor the entire known universe.

18:41.000 --> 18:48.000
So, good for seeing this chest, even if you are put very, very interesting things in it, like cookies,

18:48.000 --> 18:50.000
it's not worth it.

18:50.000 --> 18:55.000
We don't have enough universes to break most of the chest.

18:55.000 --> 18:59.000
So that's what we call strong in a cryptographic sense.

18:59.000 --> 19:03.000
And that's good for us, because we have data which is sensitive.

19:03.000 --> 19:09.000
If we want to break the little padlock, it's easier in some way.

19:09.000 --> 19:11.000
You just have to be a mathematical genius.

19:11.000 --> 19:20.000
You have to break discrete logarithm or factorization of integers or elliptic curve cycles, something like that.

19:20.000 --> 19:26.000
If you manage that, not only do you break the entire payment system on the Internet, so you will have trouble,

19:26.000 --> 19:32.000
but you also get a field of the middle, like the Nobel Prize for Mathematicians.

19:32.000 --> 19:36.000
So try it, but we are kind of safe, and we will know it.

19:36.000 --> 19:40.000
When someone will have broken this padlock, everybody will soon know it,

19:40.000 --> 19:45.000
and we will have to change everything very quickly.

19:45.000 --> 19:49.000
So it's not easy, still not easy.

19:49.000 --> 19:53.000
OK, so far so good?

19:53.000 --> 19:57.000
No question?

19:57.000 --> 20:04.000
It's time to innovate, because everything I've just said is common knowledge in the cryptographic world.

20:04.000 --> 20:09.000
It was only new for me and my fellows.

20:09.000 --> 20:14.000
So what is the witness-essential project that I've been dealing with?

20:14.000 --> 20:16.000
It's a black box for humans.

20:16.000 --> 20:20.000
When a plane crashes, we want to know what happens.

20:20.000 --> 20:27.000
When a human gets robbed, raped or worse, we want to know too what happens

20:27.000 --> 20:33.000
to put the right people in the jail or not the wrong people in the jail, things like that.

20:33.000 --> 20:38.000
So we want to get rid of judicial errors, we want to get rid of all these cases

20:38.000 --> 20:42.000
where people cannot get justice because they have just no proof,

20:42.000 --> 20:46.000
because in most of the time when people aggress you,

20:46.000 --> 20:51.000
they try to not do that in a public place like today, like here.

20:51.000 --> 20:56.000
But if we put spy cams everywhere, we have another problem, we have no more privacy.

20:56.000 --> 21:00.000
Our Libertbertese can very quickly go downhill.

21:00.000 --> 21:05.000
So our secondary goal, which is as important as the first one in Witness Angel,

21:05.000 --> 21:09.000
is that we want to preserve privacy and get proof.

21:09.000 --> 21:13.000
So it's a tough challenge. We need innovation.

21:13.000 --> 21:17.000
So we invented Witness Angel recorders.

21:17.000 --> 21:21.000
What's the concept is that you record stuff, okay,

21:21.000 --> 21:26.000
but nobody can read what has been recorded and encrypted.

21:26.000 --> 21:29.000
So it's a write only device.

21:29.000 --> 21:35.000
You know the read only logs, read only files on your system.

21:35.000 --> 21:40.000
That's the contrary. Anybody can write to this file, but nobody can read.

21:40.000 --> 21:42.000
Almost, of course, nobody.

21:42.000 --> 21:46.000
So it's a bit like, you know, the good old magician bags.

21:46.000 --> 21:48.000
That's something, I love it.

21:48.000 --> 21:52.000
You have some data, you put in it, okay, so far so good.

21:52.000 --> 21:54.000
But you cannot have it.

21:54.000 --> 21:56.000
That's the fun part.

21:56.000 --> 21:59.000
So my data, what do I do?

21:59.000 --> 22:03.000
So we have both security and privacy, okay?

22:03.000 --> 22:07.000
We have what we call a revelation.

22:07.000 --> 22:12.000
So I will have some of my key guardians, my trusted third parties, my mentors,

22:12.000 --> 22:18.000
here to grant me authorization because I have been robbed, by example, on the way home.

22:18.000 --> 22:24.000
So I need proof of who to bring to the judge that someone robbed me.

22:24.000 --> 22:28.000
So I, of course, must grant authorization because I am the victim

22:28.000 --> 22:32.000
and I am the owner of the data in here.

22:32.000 --> 22:38.000
The key guardians, at least three of them, among five must grant authorization.

22:38.000 --> 22:41.000
We need redundancy because some of them are in vacations.

22:41.000 --> 22:44.000
Some of them have lost their key, their password.

22:44.000 --> 22:48.000
It occurred a lot of times to me and my key guardians.

22:48.000 --> 22:50.000
And we have a special case.

22:50.000 --> 22:54.000
If I get murdered, I hope not, but we never know.

22:54.000 --> 23:02.000
We have a special assembly of wise people and six of them, among the six of them,

23:02.000 --> 23:05.000
four of them must say, okay, he has really been murdered.

23:05.000 --> 23:10.000
So we have this special right to access his private data.

23:10.000 --> 23:14.000
So when we do that, we recover the data.

23:14.000 --> 23:19.000
Only in this case, only that data, not the other CDs that are here,

23:19.000 --> 23:25.000
only the data of one hour before I was murdered, something like that.

23:25.000 --> 23:31.000
And here I present to you, Meet Shidi, the little mascot,

23:31.000 --> 23:33.000
little symbol of our project.

23:33.000 --> 23:35.000
It's so cute because it's harmless.

23:35.000 --> 23:36.000
It can help you.

23:36.000 --> 23:38.000
It cannot betray you.

23:38.000 --> 23:43.000
It cannot leak your new files, things like that.

23:43.000 --> 23:50.000
So it's a big technical quest, of course, because we want a high-security level,

23:50.000 --> 23:56.000
lots of different ciphers, because if someone breaks RSA, we want to be safe anyway.

23:56.000 --> 24:00.000
We want multiple key guardians, what we call.

24:00.000 --> 24:03.000
So some of them must be mandatory.

24:03.000 --> 24:07.000
They must give their authorization like myself.

24:07.000 --> 24:09.000
And some of them are optional.

24:09.000 --> 24:14.000
A certain number of them must say okay, but not all of them.

24:14.000 --> 24:21.000
So we are thinking about creating eBAC, which is encryption-based access control.

24:21.000 --> 24:26.000
We know role-based access control or relationship-based access control.

24:26.000 --> 24:29.000
There are lots of conferences on that.

24:29.000 --> 24:33.000
But here we want permission to be based on something very strong.

24:33.000 --> 24:36.000
So it's not very flexible in a sense.

24:36.000 --> 24:40.000
In a sense that once it's in place, it's hard to change it.

24:40.000 --> 24:45.000
But at least your data is very secure.

24:45.000 --> 24:48.000
So we have begun the reflection.

24:48.000 --> 24:54.000
Let's begin by chaining symmetric on the symmetric cipher.

24:54.000 --> 25:00.000
So what we call chaining is just I have a chest with a cd-knit or USB key.

25:00.000 --> 25:03.000
I put it in another chest.

25:03.000 --> 25:05.000
And I close.

25:05.000 --> 25:09.000
And I lock with my big key or my padlock.

25:09.000 --> 25:16.000
And it's a logical hand, because you need both keys to access your data.

25:16.000 --> 25:19.000
And it's like the Matryoshka doll, the nested dolls.

25:19.000 --> 25:25.000
You can put as many chests as you want in the computer world at least.

25:25.000 --> 25:29.000
And it's an easy way to chain our key guardians.

25:29.000 --> 25:31.000
So that was the easy step.

25:31.000 --> 25:33.000
And we were a big stuck.

25:33.000 --> 25:36.000
How to do a logical or?

25:36.000 --> 25:38.000
I have already spoiled the result.

25:38.000 --> 25:41.000
We go back to that dear Shamir.

25:41.000 --> 25:44.000
And we use the shared secret algorithm.

25:44.000 --> 25:50.000
We showed a threshold, like m, and n, a count n of key guardians.

25:50.000 --> 25:57.000
And we split our key into as many parts, and we give them a round.

25:57.000 --> 26:00.000
And then we have different cases.

26:00.000 --> 26:05.000
If m equals 1, if any key guardian is enough to open the chest,

26:05.000 --> 26:08.000
then we have the logical or we wanted.

26:08.000 --> 26:14.000
If m equals n, it means that all key guardians must give their shard

26:14.000 --> 26:16.000
so that we can open the chest.

26:16.000 --> 26:18.000
We have another kind of or.

26:18.000 --> 26:21.000
So we don't even need the nested chest.

26:21.000 --> 26:23.000
Shamir can do that too.

26:23.000 --> 26:28.000
And if m is strictly between 1 and n, it's the shared secret.

26:28.000 --> 26:32.000
So something unusual, but very, very important for us,

26:32.000 --> 26:37.000
because it's securing the data and still having a workaround

26:37.000 --> 26:43.000
in case of disappearance of one of the key guardians.

26:43.000 --> 26:45.000
Let's wrap it up.

26:45.000 --> 26:47.000
Let's put it all together.

26:47.000 --> 26:50.000
So our data, where is it?

26:50.000 --> 26:52.000
It's here.

26:52.000 --> 26:55.000
It will go through several symmetric ciphers,

26:55.000 --> 26:59.000
because data can be very big, can be petabytes of data.

26:59.000 --> 27:03.000
We can put it in here.

27:03.000 --> 27:07.000
Then we take the key on the part of key, the shard.

27:07.000 --> 27:12.000
On each of them, we will recursively make them go through

27:12.000 --> 27:16.000
symmetric ciphers, asymmetric ciphers, shared secrets,

27:16.000 --> 27:18.000
etc., etc.

27:18.000 --> 27:23.000
And at every step, when we want, we can timestamp stuff,

27:23.000 --> 27:25.000
authenticate stuff.

27:25.000 --> 27:28.000
That's a separate operation.

27:29.000 --> 27:32.000
That's what it gives.

27:32.000 --> 27:35.000
It can be a little scary at first.

27:35.000 --> 27:37.000
We have a cipher tree.

27:37.000 --> 27:43.000
So our key text here goes through AES on chat.20,

27:43.000 --> 27:47.000
which are two symmetric algorithms, and becomes a cipher text.

27:47.000 --> 27:50.000
That's the easy part of the pipeline.

27:50.000 --> 27:54.000
It can be very quickly done with little chips.

27:54.000 --> 28:00.000
They can pass the data, unencrypted, and put it on SD card on disk.

28:00.000 --> 28:04.000
And here is the funny part of the algorithm.

28:04.000 --> 28:10.000
It is, for example, the first AES key that was created.

28:10.000 --> 28:16.000
I have protected it myself, me, with my RSA identity.

28:16.000 --> 28:21.000
I didn't trust myself enough, so I asked for mom to,

28:21.000 --> 28:24.000
for her identity to protect.

28:24.000 --> 28:30.000
Also, we have two nested chests on my mom to protect the first

28:30.000 --> 28:32.000
symmetric key.

28:32.000 --> 28:33.000
So that's done.

28:33.000 --> 28:37.000
We have one layer of security, which is already quite strong.

28:37.000 --> 28:39.000
But that's not enough.

28:39.000 --> 28:45.000
Chat.20, which is a byte stream and crypto, has given another key.

28:45.000 --> 28:50.000
And this time, we want to rely on three-street third parties,

28:50.000 --> 28:51.000
key guardian.

28:51.000 --> 28:57.000
So we encrypt that key through AES in mode EAX.

28:57.000 --> 29:02.000
And it gives a shared, we split the resulting blue key between

29:02.000 --> 29:03.000
John and Jane.

29:03.000 --> 29:08.000
Then we use AES in mode CBC, and it gives a key that we encrypt

29:08.000 --> 29:09.000
with Jess.

29:09.000 --> 29:14.000
And then the initial key, we make it protected by Jill.

29:14.000 --> 29:19.000
So it's a bit complicated, but in the end, we have six key

29:19.000 --> 29:25.000
guardians, me, my mom, and the four other people, that we are all

29:25.000 --> 29:29.000
protecting in different ways the same secret.

29:29.000 --> 29:34.000
Now, there's a little thing a bit weird.

29:34.000 --> 29:35.000
Why?

29:35.000 --> 29:43.000
Me and my mom, we just tacked our chest, one in the other, one in

29:43.000 --> 29:44.000
the other.

29:44.000 --> 29:47.000
Why didn't we just do that for John, Jane, Jess, and Jill?

29:47.000 --> 29:52.000
Why did we complicate ourselves with other symmetric ciphers?

29:52.000 --> 29:55.000
Here and here.

29:55.000 --> 29:57.000
That's a bit weird.

29:57.000 --> 29:59.000
There's a reason for that.

29:59.000 --> 30:03.000
It's a bit just a trick, it's just for ergonomics when we

30:03.000 --> 30:04.000
decrypt.

30:04.000 --> 30:08.000
Because me and my mom, we have a problem.

30:08.000 --> 30:11.000
We have nested our chest.

30:11.000 --> 30:15.000
So when we want to decrypt, my mom, if she's in vacation, I

30:15.000 --> 30:19.000
must wait for her to come back and open her chest, and then I

30:19.000 --> 30:26.000
can access my chest and open my little padlock, which is it.

30:26.000 --> 30:29.000
And so it creates a dependency link.

30:29.000 --> 30:35.000
That's why we use symmetric ciphers here and there to create

30:35.000 --> 30:40.000
new random keys, symmetric keys, the blue one, the red one,

30:40.000 --> 30:42.000
and the initial green one.

30:42.000 --> 30:46.000
And that way, each key guardian can have his or her shard to

30:46.000 --> 30:47.000
protect.

30:47.000 --> 30:50.000
It's just a way to remove dependencies between them.

30:50.000 --> 30:52.000
They are all leaves in that big tree.

30:52.000 --> 30:57.000
They are all on the external path, not stacked, and so it makes

30:57.000 --> 30:59.000
an encryption easier.

30:59.000 --> 31:04.000
But on a purely security point of view, it changes nothing

31:04.000 --> 31:09.000
because E-A-E-S, A-E-S, sorry, is very strong anyway, doesn't

31:09.000 --> 31:10.000
change much.

31:10.000 --> 31:13.000
You can add it, you can remove it.

31:13.000 --> 31:15.000
OK.

31:15.000 --> 31:21.000
All that travel, all that road, let us do something that we wrap

31:21.000 --> 31:26.000
in a little package and we call Fightbox, and we even have a

31:26.000 --> 31:28.000
nice little logo.

31:28.000 --> 31:29.000
That's about it.

31:29.000 --> 31:34.000
Fightbox is how to protect one piece of data with multiple key

31:34.000 --> 31:40.000
guardians with different access rights.

31:40.000 --> 31:43.000
So, of course, we need something more concrete than just

31:43.000 --> 31:47.000
these wild ideas, so we have a little workflow.

31:47.000 --> 31:51.000
A key guardian is someone who will generate a key pair, actually

31:51.000 --> 31:56.000
a set of key pairs, a digital identity, and like usual, like

31:56.000 --> 32:03.000
in PCP, we'll publish the public part, the padlock to a registry,

32:03.000 --> 32:08.000
and keep the private key to himself or herself.

32:08.000 --> 32:12.000
Then we have a crypto conf, crypto configuration.

32:12.000 --> 32:16.000
We have chosen the extended JSON format because it's so funny.

32:16.000 --> 32:21.000
It's a way to store what anything you want about in a JSON.

32:21.000 --> 32:23.000
It's used by PyMongo.

32:23.000 --> 32:29.000
And this will describe, this tree will be described in JSON

32:29.000 --> 32:30.000
format.

32:30.000 --> 32:36.000
Then we have recorder devices, which will encrypt the content

32:36.000 --> 32:41.000
using all these identities that are available on USB keys or

32:41.000 --> 32:44.000
Web registries or stuff like that.

32:44.000 --> 32:48.000
That's the first part of the workflow, and it gives us what we

32:48.000 --> 32:51.000
call with much originality, cryptainers.

32:51.000 --> 32:57.000
There are containers that contain both the encrypted data,

32:57.000 --> 32:59.000
the ciphertext, and the metadata.

32:59.000 --> 33:01.000
So it's self-describing.

33:01.000 --> 33:05.000
The tree of key guardians is stored in there with the random

33:05.000 --> 33:10.000
UIDs, with signatures, integrity tags, and stuff like that.

33:10.000 --> 33:15.000
This cryptainer is like a little box, very, very safe.

33:15.000 --> 33:17.000
You can store it anywhere you want.

33:17.000 --> 33:20.000
You can store it by mail.

33:20.000 --> 33:21.000
It's very secure.

33:21.000 --> 33:26.000
You can even over encrypt it, put it in another, of course,

33:26.000 --> 33:32.000
cryptainer if some day the security ciphers have evolved,

33:32.000 --> 33:35.000
which will be, of course, the case.

33:35.000 --> 33:39.000
And when you want to decrypt, then the key guardians,

33:39.000 --> 33:45.000
they each receive their little box with their padlock on it.

33:45.000 --> 33:51.000
They will open it if they want, of course, and return the content

33:51.000 --> 33:55.000
via a secure channel, something a bit like PGP,

33:55.000 --> 34:00.000
but we're using, of course, our already existing system.

34:00.000 --> 34:05.000
This way we can retrieve all the little bits of keys and get

34:05.000 --> 34:08.000
access to the data.

34:08.000 --> 34:09.000
So far so good?

34:09.000 --> 34:11.000
Okay.

34:11.000 --> 34:16.000
Now let's go down to real business, because so far it can be just

34:16.000 --> 34:22.000
vapaware and things like that, but we can already use this in

34:22.000 --> 34:23.000
practice.

34:23.000 --> 34:26.000
So how do we do that?

34:26.000 --> 34:29.000
We have a reference implementation in Python,

34:29.000 --> 34:35.000
WA CryptoLib, which we have worked on it for years now,

34:35.000 --> 34:36.000
maybe three years.

34:36.000 --> 34:40.000
We have changed our workflow.

34:40.000 --> 34:46.000
We discovered the Shamir after one year, so we had changes to do.

34:46.000 --> 34:49.000
And it has been recently audited, so I'm very, very happy,

34:49.000 --> 34:54.000
because some young crypto analyst, Raccoon, has looked at the code

34:54.000 --> 34:57.000
and said, okay, you are not screwing it up.

34:57.000 --> 34:58.000
It works.

34:58.000 --> 35:02.000
You could do better with this and this number of iterations of PKBF.

35:02.000 --> 35:03.000
I don't know what.

35:03.000 --> 35:08.000
So he gave us a list of little preconizations, but we have not broken

35:08.000 --> 35:12.000
ourselves like you can easily do when you don't, you're not sure of what

35:12.000 --> 35:13.000
you're doing.

35:13.000 --> 35:17.000
And we were a bit scared at the beginning, but it told us it's okay.

35:17.000 --> 35:18.000
It works.

35:18.000 --> 35:25.000
The CryptoLib has grown up to be quite big in some aspects.

35:25.000 --> 35:26.000
So we have utilities.

35:26.000 --> 35:33.000
It's over by Cryptodome, the very well-known cryptography package in

35:33.000 --> 35:34.000
Python.

35:34.000 --> 35:39.000
You can, of course, generate unsalized keys in the PM format that you

35:39.000 --> 35:43.000
already use on Apache and Genix and stuff like that.

35:43.000 --> 35:48.000
We have some utilities to manage identities of key guardians, to group

35:48.000 --> 35:50.000
them, to query them.

35:50.000 --> 35:56.000
We have the support for USB devices because it can still be considered a

35:56.000 --> 36:00.000
safe way to transfer stuff when you really don't want anything to be

36:00.000 --> 36:01.000
online.

36:01.000 --> 36:07.000
We have a little GZNRPC client with a custom exception translator that I'm

36:07.000 --> 36:09.000
very proud of.

36:09.000 --> 36:14.000
It allows us to communicate with our server and see the errors very, the

36:14.000 --> 36:16.000
errors very easily.

36:16.000 --> 36:19.000
And we have lots of sensor tooling.

36:19.000 --> 36:24.000
So it's, it's more, it's more complicated than I thought.

36:24.000 --> 36:30.000
When you have to push or pull data from camera, make microphone, GPS, it's

36:30.000 --> 36:31.000
always different.

36:31.000 --> 36:34.000
No, no, no sensor works the same.

36:34.000 --> 36:40.000
So we had to make a pipeline to extract data aggregated for the

36:40.000 --> 36:45.000
Polytar format and then push it to the encryption pipeline.

36:45.000 --> 36:50.000
And, of course, we have the cryptanal encryption, which is the root of the

36:50.000 --> 36:56.000
system, and ways to store and decrypt these cryptanals.

36:56.000 --> 37:05.000
So here is the hard way using the Python API of WA CryptoLib.

37:05.000 --> 37:07.000
What do we do?

37:07.000 --> 37:12.000
We have some very sensitive data here, ABCD.

37:12.000 --> 37:19.000
So first we are going to load our CryptoConf, which is in that file, on this.

37:19.000 --> 37:24.000
And we have utilities that deal with encoding stuff like that.

37:24.000 --> 37:27.000
Then we create a cryptanal storage.

37:27.000 --> 37:34.000
It's a high-level structure to, to put lots of cryptanal together in a

37:34.000 --> 37:35.000
directory.

37:35.000 --> 37:41.000
And we give it what we call a crypt keystore pool, which is a set of

37:41.000 --> 37:43.000
key guardians, actually.

37:43.000 --> 37:49.000
And then we tell the system, go encrypt my data into a file called

37:49.000 --> 37:53.000
rake with this configuration.

37:53.000 --> 37:58.000
And if it succeeds, and it should succeed unless some key guardians are

37:58.000 --> 38:04.000
missing, then you have your cryptanal.

38:04.000 --> 38:07.000
So, of course, you must import your key guardians first.

38:07.000 --> 38:12.000
We have lots of other levels of difficulty to manage more precisely

38:12.000 --> 38:15.000
what you encrypt and maybe not store it on disk.

38:15.000 --> 38:19.000
Maybe you want to stream it directly to a server.

38:19.000 --> 38:22.000
On encryption, basically it was one shot.

38:22.000 --> 38:28.000
So you had your mp4 file, your video file on your encrypted it.

38:28.000 --> 38:36.000
But when we did some tests, of course, on Raspberry Pi, it was not

38:36.000 --> 38:39.000
happy with gigabytes of file for some reason.

38:39.000 --> 38:44.000
So to preserve the memory of it, we have been first to

38:45.000 --> 38:51.000
introduce the proper way of doing it, which is streamed encryption.

38:51.000 --> 38:53.000
So you have packets of data which arrive.

38:53.000 --> 38:55.000
You encrypt them.

38:55.000 --> 38:57.000
You dump them onto the disk.

38:57.000 --> 39:05.000
And like that, the memory usage stays very slow.

39:05.000 --> 39:11.000
But API is only for pitoniers and pitoniers that want to dig this

39:11.000 --> 39:12.000
deep.

39:12.000 --> 39:16.000
So we have a command line interface since last year.

39:16.000 --> 39:23.000
And with a click, for those who know, a marvelous little library.

39:23.000 --> 39:27.000
So here is how to do it with a command line interface, which you can

39:27.000 --> 39:33.000
download for different, you have binaries for different operating systems.

39:33.000 --> 39:39.000
First, you begin by importing your foreign key stores that are the digital

39:39.000 --> 39:41.000
identities of your key guardians.

39:41.000 --> 39:47.000
Here, I just showed, imagine, that I have plugged a USB key with the identity

39:47.000 --> 39:49.000
on it.

39:49.000 --> 39:52.000
And then we list the foreign key stores on UC.

39:52.000 --> 39:55.000
We have two different ones.

39:55.000 --> 40:00.000
We have AAA, which is, of course, a test key, and John Doe, which could be

40:00.000 --> 40:02.000
a real key guardian.

40:02.000 --> 40:06.000
They have seven on three public keys respectively.

40:06.000 --> 40:10.000
And we have no private keys, and it's good.

40:10.000 --> 40:15.000
Unless we are testing stuff, we don't want any private keys in our local

40:15.000 --> 40:19.000
repositories, because in this case, they are not private anymore.

40:19.000 --> 40:25.000
Now that we have key guardians imported, we generate a crypto conf.

40:25.000 --> 40:29.000
So a crypto conf, you can, of course, write JSON by hand.

40:29.000 --> 40:30.000
It works very well.

40:30.000 --> 40:35.000
But if you have a simple use case, you can just use our generate simple

40:35.000 --> 40:37.000
command.

40:37.000 --> 40:42.000
You add key guardians one by one, you specify share secret, and it makes a

40:42.000 --> 40:44.000
simple tree.

40:44.000 --> 40:46.000
And here, we summarize this tree.

40:46.000 --> 40:48.000
What did we do?

40:48.000 --> 40:55.000
We added one EAS layer of symmetric encryption, one chat at 20 layer.

40:55.000 --> 41:00.000
And inside the first layer, only the local device is holding the key, so it's

41:00.000 --> 41:01.000
very insecure.

41:01.000 --> 41:05.000
It means the keys are directly on the PC.

41:05.000 --> 41:12.000
On the second layer, we have used two what we call automticators, which are

41:12.000 --> 41:17.000
remote identities, really secure remote identities.

41:17.000 --> 41:23.000
So this layer is really the one protecting our data, because as long as you

41:23.000 --> 41:27.000
use local keys, you are not protected at all.

41:27.000 --> 41:32.000
Yes, a little bit, but not much.

41:32.000 --> 41:34.000
And then, it's time to encrypt.

41:34.000 --> 41:38.000
So I encrypted my readme because why not?

41:38.000 --> 41:41.000
With this crypto conf, I had just created.

41:41.000 --> 41:47.000
And then when I list my cryptator, ta-da, readme.rst.crypt.

41:47.000 --> 41:51.000
Maybe we will find a better extension later.

41:51.000 --> 41:56.000
It has a size a bit bigger, of course, than just the plain text.

41:56.000 --> 41:58.000
It is offloaded.

41:58.000 --> 42:00.000
What does it mean offloaded?

42:00.000 --> 42:07.000
Offloaded just means that the metadata and the ciphertext are split into files.

42:07.000 --> 42:10.000
And it's a follow-readme, we don't care, really.

42:10.000 --> 42:16.000
But when it's a gigabyte of video, you're happy to not put it into a json.

42:16.000 --> 42:22.000
Because when you open a one gigabyte json, even your PC will not be happy.

42:22.000 --> 42:25.000
That's why we offload most of the time.

42:25.000 --> 42:32.000
The cryptator is created very quickly, and then the data is streamed directly to disk

42:32.000 --> 42:36.000
by the encryption pipeline.

42:36.000 --> 42:39.000
And then we have lots of other commands, of course.

42:39.000 --> 42:42.000
We can purge cryptators, for example, in France.

42:42.000 --> 42:52.000
We cannot keep more than one month the video protection data from the mailbox hole, for example.

42:52.000 --> 42:54.000
So we purge them.

42:54.000 --> 42:56.000
We can validate cryptators.

42:56.000 --> 42:58.000
We can decrypt data.

42:58.000 --> 43:02.000
And here, will it work if I call decrypt?

43:02.000 --> 43:07.000
If all my keys are local, just for testing, it will work.

43:07.000 --> 43:10.000
But in real life, no, I have no permission.

43:10.000 --> 43:17.000
I don't have the private keys, so it will put some log and explain to me, a long log to explain to me,

43:17.000 --> 43:21.000
I tried to decrypt with disk gigarian, he was not there, this one is there.

43:21.000 --> 43:23.000
I need two, I have zero.

43:23.000 --> 43:25.000
Your data is unavailable.

43:25.000 --> 43:26.000
And that's what we want.

43:26.000 --> 43:31.000
We're happy when we don't manage to decrypt.

43:31.000 --> 43:37.000
On the third kind of use of Flightbox for now, it is a standalone program.

43:37.000 --> 43:41.000
So we have it, we have binaries for desktop environment to play with it.

43:41.000 --> 43:47.000
So it's with Kivi, a nice little framework, very cute and cross-platform.

43:47.000 --> 43:53.000
So with this tool, you can record and you can also put it on Raspberry Pi.

43:53.000 --> 43:59.000
It's compatible to have a little, for example, a camera station dash cam, things like that.

43:59.000 --> 44:06.000
And we have little interfaces to import gigarian from the web or from USB to manage the cryptators,

44:06.000 --> 44:10.000
to launch the recording on specify which IP camera to use,

44:10.000 --> 44:16.000
and also a little workflow to aggregate permissions until you can decrypt.

44:16.000 --> 44:21.000
So that you can play with it in the recorder software.

44:21.000 --> 44:23.000
That's key guardians.

44:23.000 --> 44:26.000
We have not talked a lot about key guardians.

44:26.000 --> 44:34.000
There can be anybody in my building, we have five key guardians, Mr. and Mrs. anybody.

44:34.000 --> 44:42.000
So that's why we have thought about them and we created mobile applications with Kivi again.

44:42.000 --> 44:45.000
Well, I tell you it's great.

44:45.000 --> 44:51.000
So this is Python working on Android and it also works on iOS.

44:51.000 --> 44:53.000
So it's unusual.

44:53.000 --> 44:59.000
We had a very hard time doing it, but it was fun and it works for now.

44:59.000 --> 45:04.000
So no policy change occurs on Android or iOS.

45:04.000 --> 45:11.000
So you have your little program which allows you to create your digital identity, publish it, check it,

45:11.000 --> 45:16.000
check that your password, your password phrase, as we say, is still working.

45:16.000 --> 45:23.000
And most importantly, you can manage the permission, the request that you get and say,

45:23.000 --> 45:25.000
I authorize you or not.

45:25.000 --> 45:35.000
So I have been installing parcels in my mailbox and two times the neighbors have given me permission to see that it was a deliverer

45:35.000 --> 45:43.000
that stole my precious parcels and so the filters for Roomba, you know, they stole,

45:43.000 --> 45:46.000
but at least I knew what happened.

45:46.000 --> 45:50.000
Thanks to this authenticator.

45:50.000 --> 45:57.000
So here is the dash cam, for example, Raspberry Pi Zero with a little screen.

45:57.000 --> 45:58.000
It works.

45:58.000 --> 46:01.000
It's just not very simple.

46:01.000 --> 46:03.000
It's a bit clunky.

46:03.000 --> 46:08.000
And for example, I can film anything I want with this one because I lost the key years ago.

46:08.000 --> 46:11.000
So I can dance naked in front of it.

46:11.000 --> 46:13.000
I have no risk at all.

46:13.000 --> 46:19.000
Nobody will ever be able to decrypt that unless some aliens invade Earth.

46:19.000 --> 46:21.000
But that's another trouble.

46:21.000 --> 46:29.000
So we have some prototypes to put in a handbag, some prototypes to put in, to replace dash cams of cars,

46:29.000 --> 46:38.000
and also to replace video surveillance, video surveillance in, yes, everywhere actually.

46:38.000 --> 46:46.000
All the cameras we have in the streets that are deeply insecure to me can be replaced by witness angels

46:46.000 --> 46:50.000
on this way when there is someone burning your car.

46:50.000 --> 46:55.000
You ask the neighbors, but they're key guardians, can I see who burned my car?

46:55.000 --> 46:57.000
And they say yes or no.

46:57.000 --> 47:01.000
If they say no, maybe you have a problem with your neighbors.

47:01.000 --> 47:05.000
But you see the principle, privacy first.

47:05.000 --> 47:07.000
And you can't do it secretly.

47:07.000 --> 47:13.000
You have to ask publicly, hey, girls, I have a problem.

47:13.000 --> 47:18.000
So we have a flight box in Python, and we could make it work in micro-Python,

47:18.000 --> 47:21.000
but micro-Python is still huge for tiny chips.

47:21.000 --> 47:27.000
So we are currently re-implementing the best part of it, the encryptor in C.

47:27.000 --> 47:31.000
That way we can put it about everywhere actually.

47:31.000 --> 47:39.000
And we have a huge challenge because we want to do a portable shivy, a little familiar, a little pet.

47:39.000 --> 47:44.000
You have in your pocket, you have on your J-wall, especially if you're a girl,

47:44.000 --> 47:51.000
you go anywhere with it, and if you have some trouble, because you can have some trouble even in France,

47:51.000 --> 47:59.000
then you can go to the judge and show your J-wall, and there will be an angel in it telling the judge what happened

47:59.000 --> 48:04.000
with proof, with lots of proof, timestamp and stuff like that.

48:04.000 --> 48:11.000
It's a big challenge, so it's a little moment where I ask some of you if you have some contacts

48:11.000 --> 48:17.000
or some free time in hardware development in open source, cheap creation,

48:17.000 --> 48:21.000
we are starting this project and we know it won't be easy, but it's necessary.

48:21.000 --> 48:30.000
We have to last one day on a tiny battery, some Chinese product do it, or they pretend they do it.

48:30.000 --> 48:40.000
We know it's possible, but it's a huge challenge because we have to optimize everything from the sensor to the SD card.

48:40.000 --> 48:46.000
So we use Flightbox for justice, but there are lots of other cases.

48:46.000 --> 48:49.000
You can use it for protecting your credentials.

48:49.000 --> 48:52.000
That's a hashicorp, does it with the vault.

48:52.000 --> 49:00.000
They have a vault when you have to output several passwords from several persons of the enterprise to access the server credentials.

49:00.000 --> 49:04.000
Same thing for your couple or family photos.

49:04.000 --> 49:13.000
You can decide that me and my wife, we both have to input our passwords from very sensitive documents

49:13.000 --> 49:17.000
that I could give if I had a gun on the head, but she would not be there.

49:17.000 --> 49:20.000
She would not have the gun on the head too, possibly.

49:20.000 --> 49:22.000
You see, double security.

49:22.000 --> 49:28.000
And also we can replace file transfer systems with Flightbox, a little Flightbox,

49:28.000 --> 49:30.000
no need for thousands of Kigadian.

49:30.000 --> 49:34.000
And there are lots of businesses probably to do about it.

49:34.000 --> 49:35.000
We just don't know them.

49:35.000 --> 49:42.000
So if you have ID, go take it, it's open source, and make money with it.

49:42.000 --> 49:44.000
That's the part.

49:44.000 --> 49:48.000
Thank you for listening to me.

49:48.000 --> 49:50.000
Thank you.

49:50.000 --> 49:52.000
Thank you.

49:52.000 --> 49:54.000
Thank you.

49:54.000 --> 49:56.000
Thank you.

49:56.000 --> 50:00.000
Thank you very much for the really interesting talk.

50:00.000 --> 50:02.000
So now we all know what Flightbox is.

50:02.000 --> 50:04.000
Are there any questions?

50:04.000 --> 50:12.000
Do you have any hardness proofs?

50:12.000 --> 50:20.000
Currently, you said you had a recent audit, but proper proof of your library.

50:20.000 --> 50:22.000
You mean certification?

50:22.000 --> 50:28.000
Not exactly, but cryptographic hardness proof, like some publication that people can analyze.

50:28.000 --> 50:31.000
Yes, the code is all online.

50:31.000 --> 50:37.000
But we have not had a big name certificate, just a hacker from internet.

50:37.000 --> 50:40.000
But yes, we try to certify as soon as we can.

50:40.000 --> 50:44.000
But no, we don't have a big enterprise saying, okay, it's safe.

50:44.000 --> 50:46.000
Okay.

50:46.000 --> 50:48.000
Yet.

50:48.000 --> 50:52.000
There was one more question.

50:52.000 --> 51:01.000
I'm interested if this is used only for files that are already saved, backups,

51:01.000 --> 51:08.000
or you can use it in the, for example, a relationship database for the data inside.

51:08.000 --> 51:14.000
While it's created and read it.

51:14.000 --> 51:18.000
So the question is, can it be used in a database that's it?

51:18.000 --> 51:23.000
Yes, but in real, in live database.

51:23.000 --> 51:30.000
The Flightbox, the core concept is that that data can be written very easily, but it's hard to read.

51:30.000 --> 51:32.000
It's even very long.

51:32.000 --> 51:37.000
So in most cases, it will not work for a live database that you use.

51:37.000 --> 51:44.000
But I am currently brain storming myself because I would love to have a special database system,

51:44.000 --> 51:48.000
like SQLite, that you encrypt with Flightbox.

51:48.000 --> 51:51.000
And when you have enough authorization, it goes live.

51:51.000 --> 51:54.000
It comes in memory, like in memory SQLite.

51:54.000 --> 51:57.000
And you can access this until it shut down.

51:57.000 --> 52:02.000
But it means you will be granted access temporarily to a live instance of your database

52:02.000 --> 52:10.000
when your neighbors, your boss, have said, okay, you have one hour to do stuff with the database and then it's gone.

52:10.000 --> 52:12.000
But it's a very specific use case.

52:12.000 --> 52:17.000
Yes, we cannot use it on your live HDD or live database.

52:17.000 --> 52:19.000
Thank you for your presentation.

52:19.000 --> 52:20.000
It was awesome.

52:20.000 --> 52:25.000
Nice examples from real life like logs, chess, pads.

52:25.000 --> 52:27.000
It was very awesome.

52:27.000 --> 52:31.000
My question is half psychological, half technical.

52:31.000 --> 52:38.000
Because we live in a very dynamic life, I mean the relationships.

52:38.000 --> 52:46.000
And I would like to ask how it looks like the process of management of the accesses.

52:46.000 --> 52:50.000
How to add new angel, how to remove angel.

52:50.000 --> 52:56.000
So yes, about the management of these permissions, actually.

52:56.000 --> 52:58.000
That's the hardest part.

52:58.000 --> 53:04.000
That's the hard part with flight box because it is meant to be once that is encrypted.

53:04.000 --> 53:09.000
My neighbor was unhappy because he wanted to reset his passphrase.

53:09.000 --> 53:17.000
I had to explain to him that there's no reset because nobody can recover the data when he has forgotten the password.

53:17.000 --> 53:22.000
So we can easily add over encrypt and add key guardians.

53:22.000 --> 53:31.000
If we want to remove or switch, we have to decrypt everything or at least this layer, you know, up to the layer on re-encrypt.

53:31.000 --> 53:34.000
And there are homomorphic encryptions.

53:34.000 --> 53:41.000
There are things that look very promising to modify, but I really don't know them well.

53:41.000 --> 53:44.000
I know there are some researches and things like that.

53:44.000 --> 53:52.000
But for now, maybe for a long time, the only option will be to decrypt and re-encrypt.

53:52.000 --> 53:55.000
More questions?

53:59.000 --> 54:02.000
Hello, thank you for your talk.

54:02.000 --> 54:09.000
Looking at your hardware devices like safety camera and protected with angel,

54:09.000 --> 54:19.000
my question is if you do something to protect the channel from the camera before it gets encrypted

54:19.000 --> 54:27.000
because a nasty actor that have physical access to the camera can niche on the bus.

54:27.000 --> 54:34.000
Yes, so there are lots of aspects we are thinking about concerning the hacking of the device.

54:34.000 --> 54:42.000
So there are lots of ways to hack into the device, but it's much easier to buy a spy cam on the internet and wear it.

54:42.000 --> 54:44.000
So the spy cams are already there.

54:44.000 --> 54:48.000
You can already use them on an event you could fake that it's a witness angel.

54:48.000 --> 54:50.000
That's a problem we are thinking about.

54:50.000 --> 54:52.000
That's why we want full integration.

54:52.000 --> 54:56.000
That's why we want a witness angel chip that contains the camera sensor.

54:56.000 --> 55:01.000
And even that signs with a trusted platform model that signs the frames as they go by.

55:01.000 --> 55:09.000
Because now that we have the era of fake news, anybody can indeed create a video of you saying or doing whatever he wants.

55:09.000 --> 55:19.000
And we would like witness angel to be a countermeasure to that by having devices that have their own signatures

55:19.000 --> 55:25.000
and that show that they are well taken by a witness angel.

55:25.000 --> 55:33.000
Of course, there are always a simple solution to film a screen showing a video of fake data.

55:33.000 --> 55:39.000
So it's a problem that for now nobody has resolved, but we can go as far as we can.

55:39.000 --> 55:44.000
And the farthest we will go is having our own device with all integrated.

55:44.000 --> 55:47.000
And if you try to open it, it explodes.

55:47.000 --> 55:49.000
That will be the goal.

