WEBVTT

00:00.000 --> 00:07.880
We're going to have your attention.

00:07.880 --> 00:10.880
We'd like to begin with the next talk.

00:10.880 --> 00:11.880
We have Guillaume.

00:11.880 --> 00:15.560
He's going to explain to us how to write your own Rust Linter, as you can see on the lovely

00:15.560 --> 00:16.560
slides.

00:16.560 --> 00:21.840
And if you talk, Luca, have we got the audio as unmuted and everything?

00:21.840 --> 00:22.840
Perfect.

00:22.840 --> 00:23.840
Wonderful.

00:23.840 --> 00:24.840
Okay.

00:24.840 --> 00:25.840
Take it away.

00:25.840 --> 00:32.520
Hi, everyone.

00:32.520 --> 00:35.640
I will try to speak loud so everyone can hear.

00:35.640 --> 00:42.200
So like he mentioned today, I will explain to you how to write your own Rust Linter.

00:42.200 --> 00:44.440
So first little presentation.

00:44.440 --> 00:45.640
I'm Guillaume Goumez.

00:45.640 --> 00:50.280
If you come every year, I give a talk, so now you should more or less remember me, I

00:50.280 --> 00:51.280
think.

00:51.280 --> 00:58.320
I'm a member of a few teams of Rust projects and I'm an engineer at Huawei.

00:58.320 --> 01:03.040
So first, let's explain what a Linter is in case some people don't know yet what it

01:03.040 --> 01:04.040
is.

01:04.040 --> 01:11.400
A Linter is a tool that generally is an addition to a compiler of a language.

01:11.400 --> 01:15.160
And here in Rust, I suppose everyone heard about Clippy.

01:15.160 --> 01:17.560
At least I hope so.

01:17.560 --> 01:26.840
The goal is to detect some very basic logic errors to suggest improvements for any method

01:26.840 --> 01:30.720
you might use, anything you could use better.

01:30.720 --> 01:35.960
The goal is to make your code better in short.

01:35.960 --> 01:38.960
So now how is a Rust Linter actually working?

01:38.960 --> 01:42.080
We are directly entering into the subject.

01:42.080 --> 01:47.680
So let's say it's an extension of the Rust compiler.

01:47.680 --> 01:51.600
The Rust compiler has an API, very unstable.

01:51.600 --> 02:00.840
So very frequently we have to update the Linter to be able to still work with the Rust compiler.

02:00.840 --> 02:02.680
And that's exactly how Clippy works.

02:02.680 --> 02:08.880
So when Clippy is running, it's actually running a lot of parts of the compiler to get parts

02:08.880 --> 02:17.320
like AST for people who don't know what AST is, it's a token representing your code.

02:17.320 --> 02:22.880
So if you have the struct keyword, it's a keyword and it's a struct.

02:22.880 --> 02:26.660
So that allows you to have information higher than.

02:26.660 --> 02:30.800
But it's not only that because if you only had the AST information, you could only make

02:30.800 --> 02:36.560
suggestions like, yeah, you use this generics but not in a good way so you can do it like

02:36.560 --> 02:38.480
that, et cetera.

02:38.480 --> 02:43.280
So the goal is to go beyond that and to get access to more information like a borrower

02:43.280 --> 02:44.800
checker and everything.

02:44.800 --> 02:50.320
So if you have a trait you're using but you could use another trait which does the same

02:50.320 --> 02:55.320
thing but shorter, we can now suggest it because we have this information from the compiler.

02:55.320 --> 03:01.160
But because of that, we have to update the Linter often or never update which version

03:01.160 --> 03:05.160
of the compiler we are using.

03:05.160 --> 03:09.320
So why does it need to be a rest compiler extension?

03:09.320 --> 03:11.040
It's quite simple to explain.

03:11.040 --> 03:17.400
So unless you want to reimplement all the parsing, the borrower checking and pretty much everything,

03:17.400 --> 03:24.760
well, better use what is already existing and ask them likely to make their API public

03:24.760 --> 03:26.800
so you can use them.

03:26.800 --> 03:34.080
And that's exactly how things went with Clippy and that's exactly how I went as well.

03:34.080 --> 03:36.680
So I mentioned a few limitations already.

03:36.680 --> 03:42.120
So it can only work on crates compiled with the same Rusty version.

03:42.120 --> 03:46.320
You don't see it with Clippy because it's tied with your compiler.

03:46.320 --> 03:49.800
When you un-style a Clippy, it's tied with your current compiler version.

03:49.800 --> 03:55.200
So it just works but it's something to keep in mind you will see later.

03:55.200 --> 04:00.920
Like I mentioned, the Rusty API is not stable so very often you have to update your Linter

04:00.920 --> 04:05.000
code to be able to keep up.

04:05.000 --> 04:09.480
It's tied to a specific Rusty version and I'm not talking about a stable release but

04:09.480 --> 04:14.720
literally to commit version which is a bit annoying.

04:14.720 --> 04:20.120
And also because of everything, it's annoying to wrap in a cargo command because you need

04:20.120 --> 04:22.280
to use a very specific Rusty version.

04:22.280 --> 04:26.560
Again, we'll come back to that later.

04:26.560 --> 04:31.520
So I will voluntarily don't mention all lint passes.

04:31.520 --> 04:36.680
I will only speak of the two main ones, the early and the late passes.

04:36.680 --> 04:39.680
The early passes give you access to AST.

04:39.680 --> 04:44.760
So you are able to see the syntax and the work a bit on it but you don't have type information

04:44.760 --> 04:45.760
or everything.

04:45.760 --> 04:50.080
You can only just know that this is a struct and its name is and it has generics but you

04:50.080 --> 04:52.400
don't know what traits it implements or anything.

04:52.400 --> 04:58.880
You just have very basic information and you have the late pass which in this case goes

04:58.880 --> 05:00.380
a lot further.

05:00.380 --> 05:02.920
You have access to Borrowchecker information.

05:02.920 --> 05:05.160
You have access to everything.

05:05.160 --> 05:08.320
What does this type is implementing?

05:08.320 --> 05:09.640
Does it implement this trait?

05:09.640 --> 05:12.080
What is its layout?

05:12.080 --> 05:15.600
Everything.

05:15.600 --> 05:22.040
So in this case, we will talk about how to write a linter but with Rusty tools.

05:22.040 --> 05:28.800
The goal of this trait is to wrap the Rusty API into something easier to set up because

05:28.800 --> 05:32.320
there is a lot of things to set up.

05:32.320 --> 05:35.440
And to add it, it's just that.

05:35.440 --> 05:38.080
Like you would add any other trait.

05:38.080 --> 05:44.400
For now, the version 0.3 later on it will be updated.

05:44.400 --> 05:47.120
And now we start to enter into the fun.

05:47.120 --> 05:54.880
So actually to make it work, you need to add this little line in your Kaggle file to tell

05:54.880 --> 05:58.240
okay it's a trait but not any trait.

05:58.240 --> 05:59.680
It's a Rusty trait.

05:59.680 --> 06:03.360
So you need to do some very funny things.

06:03.360 --> 06:11.120
And we'll come back to this one but it's some things that you thought were something that

06:11.120 --> 06:16.960
we had for years like having to write an extant trait to import a trait.

06:16.960 --> 06:21.920
As back you actually need to import a trait from the compiler with extant trait.

06:21.920 --> 06:23.240
Otherwise it doesn't work.

06:23.240 --> 06:25.200
It's not provided by default.

06:25.200 --> 06:29.720
The other thing is we need to create a Rust toolchain file.

06:29.720 --> 06:31.680
It's literally its name.

06:31.680 --> 06:38.440
If you never use it, if you have a Rust toolchain file in your folder, cargo will only use the

06:38.440 --> 06:42.360
version provided inside this file.

06:42.360 --> 06:46.080
So in this case, the version of the compiler we're using.

06:46.080 --> 06:49.160
This is all in the documentation of Rusty tools.

06:49.160 --> 06:54.400
Basically you just need to copy and paste the file into your local file.

06:54.400 --> 06:59.840
So in here we say that as components we want the Rusty div which means the traits from

06:59.840 --> 07:01.040
the compiler.

07:01.040 --> 07:03.480
We want Rust FMT because we are not savages.

07:03.480 --> 07:06.320
We want to actually format our code.

07:06.320 --> 07:10.000
And the LLVM tool, the preview is to be able to actually compile.

07:10.000 --> 07:15.920
Otherwise you don't have a backend which is also problematic.

07:15.920 --> 07:18.880
And now let's get into the code.

07:18.880 --> 07:23.880
To declare a lint it's mostly macro.

07:23.880 --> 07:27.560
As you can see on top we use internal Rusty traits.

07:27.560 --> 07:29.480
So lint and session.

07:29.480 --> 07:34.480
Lint provides some types linked to handling lints.

07:34.480 --> 07:39.320
And session allows us to give information to the Rust compiler about things we want it

07:39.320 --> 07:40.480
to run.

07:40.480 --> 07:51.040
So in here we create with the declare tool lint macro a lint called warn generics.

07:51.040 --> 07:52.040
In MAG.

07:52.040 --> 07:53.040
In capital letters.

07:53.040 --> 07:55.520
I can't do that.

07:55.520 --> 07:57.200
It's warn by default.

07:57.200 --> 08:02.880
And we add a message when it will, in case you want information about it, it says warns

08:02.880 --> 08:06.400
if any item has generics.

08:06.400 --> 08:10.560
It's an early lint pass.

08:10.560 --> 08:15.240
So it means we only have access to the AST information.

08:15.240 --> 08:20.280
I voluntarily picked this one because to be honest the code is much, much shorter and

08:20.280 --> 08:24.800
simpler and for 15 minute talks it will be better.

08:24.800 --> 08:32.200
The other thing we need to do is to implement some very basic traits provided by the compiler

08:32.200 --> 08:33.840
which we don't need to care about.

08:33.840 --> 08:35.400
So they provide a macro for that.

08:35.400 --> 08:42.640
So declare lint pass which is in our case allowing you to declare a structure called

08:42.640 --> 08:44.240
warn generics.

08:44.240 --> 08:48.040
And we link it to the warn generics lint.

08:48.040 --> 08:54.440
And after that at the end we have the very empty implementation of the early lint pass

08:54.440 --> 08:57.680
trait for our type.

08:57.680 --> 09:06.120
This visitor trait, if some don't know the visitor, how to say, pattern, visitor pattern,

09:06.120 --> 09:08.760
let's say.

09:08.760 --> 09:15.040
The visitor pattern allows you to have access to, literally, you implement whatever you

09:15.040 --> 09:19.360
need to have and then, for example, visit function.

09:19.360 --> 09:24.760
Whenever the visitor will encounter a function, it will call this method and it will be ours.

09:24.840 --> 09:27.320
If we don't care about the rest, they are already implemented.

09:27.320 --> 09:28.640
We don't need to care about them.

09:28.640 --> 09:29.640
So very convenient.

09:29.640 --> 09:35.240
In our case, we only want items that could have generics, so very likely functions and

09:35.240 --> 09:37.200
n-us and everything like that.

09:37.200 --> 09:42.520
So it will be pretty easy normally.

09:42.520 --> 09:44.560
So now we implement the lint.

09:44.560 --> 09:47.440
So as I was saying, check item.

09:47.440 --> 09:49.360
We don't have anything else to do.

09:49.360 --> 09:55.440
It provides a context, the context of the compiler at this stage, an early context, and

09:55.440 --> 09:58.520
we have the actual item.

09:58.520 --> 10:00.200
And then it's pretty simple.

10:00.200 --> 10:03.720
We have methods provided by the compiler and everything.

10:03.720 --> 10:10.280
So we check if our, I hope everyone knows the syntax of first, but we check that we

10:10.280 --> 10:11.780
have generics.

10:11.780 --> 10:13.760
We check that with some generics.

10:13.760 --> 10:19.280
We check that the generics are not empty because otherwise there is no point.

10:20.040 --> 10:25.560
If we have generics and everything, then we will say, okay, we found generics.

10:25.560 --> 10:32.200
We don't want generics because, because, and let's then emit our lint.

10:32.200 --> 10:34.160
So first, the lint name.

10:34.160 --> 10:35.520
Second, the span.

10:35.520 --> 10:43.360
The span is how the rest compiler map your size to your actual source code.

10:43.360 --> 10:46.960
It's basically to your size beginning and an end.

10:46.960 --> 10:49.640
And you don't have to care about what it's pointing to.

10:49.640 --> 10:56.080
You just say, okay, the type I want to lint about is starting here, ending here.

10:56.080 --> 11:00.400
You underline you do whatever you do and I don't care.

11:00.400 --> 11:06.440
And we have our message saying, no generics here because we don't want generics.

11:06.440 --> 11:11.280
And the last thing is in case you wanted to add more information, like for example, we

11:11.280 --> 11:18.440
could say, the help and we could add a help message and we can do that a lot more.

11:18.440 --> 11:25.520
In case some of you don't know what it is, the syntax with the straight bar is a closure.

11:25.520 --> 11:28.560
So a closure taking a diagnostic type argument.

11:28.560 --> 11:37.000
Now, the interesting part is now how can we run this lint?

11:37.000 --> 11:42.360
And as you can see, not much code because RustyTools is doing pretty much everything.

11:42.360 --> 11:46.000
So first, we get the cargo args because it's a cargo command.

11:46.000 --> 11:48.720
We will run the cargo tools.

11:48.720 --> 11:53.040
We don't want the two first arguments because cargo and tools are not something that we

11:53.040 --> 11:55.240
are interested into.

11:55.240 --> 12:02.480
We pass the rest of the arguments, if any, into the RustyTools cargo integration command,

12:02.480 --> 12:10.080
which we internally call cargo, build everything with its own version because it's not necessarily

12:10.080 --> 12:11.560
the case.

12:11.560 --> 12:16.840
And once everything is built, it will generate the command line that you actually need to

12:16.840 --> 12:24.240
pass the Rusty compiler to be able to run our linter, which we do with WistLint.

12:24.240 --> 12:32.460
So this time, args is what cargo provided us so we can now generate and run our lint.

12:32.460 --> 12:36.980
So we just give it access because it's already done by RustyTools.

12:36.980 --> 12:44.740
And inside this WistLint, we need to actually say to the compiler, OK, I created a lint.

12:44.740 --> 12:46.140
It's called not an void call.

12:46.140 --> 12:47.140
I did badly.

12:47.140 --> 12:49.780
It's a one generics.

12:49.780 --> 12:51.460
And that's it.

12:51.460 --> 12:52.460
We have everything.

12:52.460 --> 12:53.460
We can now live.

12:53.460 --> 12:59.820
And the compiler will do everything when living as a WistLint function.

12:59.820 --> 13:03.420
So now it's always nicer to be able to run a cargo tool.

13:03.420 --> 13:10.140
So you just run a cargo install dash dash pass if it's local, otherwise not.

13:10.140 --> 13:12.820
And I named it in this case tools inner.

13:12.820 --> 13:15.340
You will understand why later.

13:15.340 --> 13:17.660
So we just run it.

13:17.660 --> 13:26.100
And it doesn't work because we are not using the same version of the compiler.

13:26.100 --> 13:27.420
Congrats.

13:27.420 --> 13:33.780
So in this case, what's important to note is that you actually very much need to use

13:33.780 --> 13:40.180
the same version of metadata as the files generated by the compiler to be able to use

13:40.180 --> 13:41.780
them with the lint.

13:41.780 --> 13:45.580
Rusty doesn't understand itself if it's not exactly the same.

13:45.580 --> 13:48.780
Like if it's just a commit difference, no, I don't know him.

13:48.780 --> 13:49.780
Don't care.

13:49.780 --> 13:52.500
No problem.

13:52.500 --> 13:58.700
So now we can actually go around this limitation by providing the version like this.

13:58.700 --> 14:03.140
So if we do, I thought I had an error output.

14:03.140 --> 14:07.700
So if we do, we actually have the tools running.

14:07.700 --> 14:12.100
But to be fair, we can't really ask our user to do that themselves.

14:12.100 --> 14:16.160
It's pretty bad user experience.

14:16.160 --> 14:23.360
So we will go around that and do this very long file as you can see, which for this case

14:23.360 --> 14:25.920
will be called the cargo tools.

14:25.920 --> 14:31.000
And this one will literally run this command that we saw here itself.

14:31.000 --> 14:32.800
And that's it.

14:32.800 --> 14:34.360
It does just that.

14:34.360 --> 14:40.840
We just wrap our linter and it's just running.

14:40.840 --> 14:42.360
So now we install it.

14:42.360 --> 14:44.840
We run it.

14:44.840 --> 14:46.440
And again, I don't have output.

14:46.440 --> 14:48.880
It's very shaming.

14:48.880 --> 14:54.320
And believe me, it works.

14:54.320 --> 14:55.320
So yeah.

14:55.320 --> 15:02.440
I voluntarily, like I said, didn't show a late linter pass to have access to the compiler

15:02.440 --> 15:03.640
and everything.

15:03.640 --> 15:08.960
But I wrote a blog post explaining that much more in depth.

15:08.960 --> 15:14.800
Inside it, you have an example with an unwrap if I remember, saying, yeah, don't use unwraps

15:14.800 --> 15:16.200
use something else.

15:16.200 --> 15:21.160
And you see how we actually get the real type information because when you call unwrap,

15:21.160 --> 15:25.520
you need to check that unwrap is actually called on the result on an option.

15:25.520 --> 15:29.880
But for that, you need to actually get the type check information because if it's, for

15:29.880 --> 15:35.600
example, self with a capital letter double colon unwrap and then you pass your type,

15:35.600 --> 15:37.680
you actually need to infer the type.

15:37.680 --> 15:39.560
And for that, you need type check information.

15:40.160 --> 15:46.880
You will see a lot of things that are seen very easy but are quite not so easy.

15:46.880 --> 15:53.320
For example, if you want to have, I don't know, which type this implementation is being

15:53.320 --> 15:58.200
implemented on, funnily enough, it's quite difficult.

15:58.200 --> 16:05.840
You can have the trade very easily but the type it's being implemented on, not so much.

16:05.840 --> 16:07.960
And thank you for your attention.

16:07.960 --> 16:13.600
More information on my blog and you have my email and social media and everything.

16:13.600 --> 16:14.880
And thank you for your attention.

16:21.880 --> 16:26.520
So we have about two minutes for questions if anyone has them.

16:26.520 --> 16:29.520
Yes, come right to the back.

16:38.960 --> 16:41.760
Hello, thanks for this presentation.

16:41.760 --> 16:43.760
No, don't share at all.

16:43.760 --> 16:45.360
Okay.

16:45.360 --> 16:48.360
Hello, again, thanks for this presentation.

16:48.360 --> 16:54.200
A few years ago, I wrote a refinement type system for Rust as a linter.

16:54.200 --> 16:59.400
I had the courage to maintain it for about one or two versions of Rust.

16:59.400 --> 17:04.080
A few months ago, I tried to pick it up again and everything was broken,

17:04.080 --> 17:07.560
bit rotten, two tiers, everything had changed.

17:07.560 --> 17:12.840
Do you know if there are any plans to make things a bit less messy?

17:12.840 --> 17:17.200
Because right now it's really, really, really painful to maintain a linter.

17:17.200 --> 17:19.200
No, it's just pain, enjoy.

17:25.640 --> 17:27.960
It's a shame.

17:27.960 --> 17:32.960
No, in fact, it's actually better now because we have less function to worry about.

17:32.960 --> 17:37.080
For example, a lot of APIs that were existing before, only for Rust.

17:37.080 --> 17:39.800
Because Rust.doc is a compiler extension.

17:39.800 --> 17:45.400
Being less and less used because we said, okay, we now stop accepting completely broken code.

17:45.400 --> 17:52.000
And soon enough, we'll be very likely using the same API as Lins.

17:52.000 --> 17:57.960
So normally it should be still breaking as much, but not as much.

17:57.960 --> 17:59.960
I don't know.

18:01.880 --> 18:04.280
How is this related to Clippy?

18:04.280 --> 18:06.280
I don't hear you at all.

18:07.240 --> 18:09.240
Ah.

18:09.240 --> 18:16.840
Basically, it's working the same way, but it exists because in Clippy,

18:16.840 --> 18:21.160
not all Lins can be implemented if you have specific needs for your project

18:21.160 --> 18:30.120
because you need to have higher security levels or you don't want certain code pieces or everything.

18:30.120 --> 18:33.080
You can't expect them to be implemented in Clippy.

18:33.080 --> 18:37.800
So you implemented them yourself and that's very much why RustyTools exists.

18:37.800 --> 18:41.400
So you can actually do it without having to set up everything yourself.

18:44.200 --> 18:46.200
Perfect. Thank you so much.

