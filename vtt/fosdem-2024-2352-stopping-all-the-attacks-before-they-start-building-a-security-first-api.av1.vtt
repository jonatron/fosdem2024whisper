WEBVTT

00:00.000 --> 00:11.000
Welcome, Warren, and first yours.

00:11.000 --> 00:12.000
Thank you.

00:12.000 --> 00:13.000
That's not necessary.

00:13.000 --> 00:17.840
Sorry for starting a little bit late.

00:17.840 --> 00:20.200
This is building a security first API.

00:20.200 --> 00:26.160
I'm Warren Parade and I'm the CTO at Authress, which is a widely used authentication authorization

00:26.160 --> 00:27.160
API.

00:27.160 --> 00:30.560
That means we get a lot of requests, API requests, that is.

00:30.560 --> 00:32.920
So let's talk about that a little bit.

00:32.920 --> 00:36.680
Today in the world, there's about one trillion requests per second.

00:36.680 --> 00:39.080
Get on the slide.

00:39.080 --> 00:46.720
This is public internet and from recent research published by Akamai, about 83% of these requests

00:46.720 --> 00:53.320
are purely API related, machine clients, services, IoT devices.

00:53.320 --> 00:58.160
From our own research, 4.9% of these requests are malicious in nature.

00:58.160 --> 01:03.960
That means for every 20 requests your service gets, one of them is from a malicious attacker

01:03.960 --> 01:06.440
that's attempting to compromise your service.

01:06.440 --> 01:07.440
That's a lot.

01:07.440 --> 01:11.680
And I think we're all in this room right now because we know we have to do something about

01:11.680 --> 01:12.800
it.

01:12.800 --> 01:14.960
But there's a lot that we could be doing.

01:14.960 --> 01:18.880
So many things, in fact, that if I were to stand up here and talk through each and every

01:18.880 --> 01:22.040
one of these, we'd be here long after the conference was over.

01:22.480 --> 01:23.920
Luckily, I'm not going to do that.

01:23.920 --> 01:28.200
But also, doing that may not actually have the impact that you wish it to.

01:28.200 --> 01:32.920
That's because some of these may not be relevant to the service that you're building, functionality

01:32.920 --> 01:35.880
that actually is in your API.

01:35.880 --> 01:40.440
To figure that out, we actually need to do and build a threat model.

01:40.440 --> 01:46.680
A threat model is intentionally deciding what a malicious threat actor could potentially

01:46.680 --> 01:50.360
do to compromise your service.

01:50.360 --> 01:54.200
This is going to be unique based off of the data that you're saving, the way you've built

01:54.200 --> 02:01.920
your service, the infrastructure, and also your cloud provider of choice.

02:01.920 --> 02:08.400
However, I'm going to say that some threats are ubiquitous across many, if not all, APIs

02:08.400 --> 02:09.400
that we're building.

02:09.400 --> 02:13.560
So what I'm hoping to do is build up a common threat model that we can utilize to actually

02:13.560 --> 02:17.280
target solutions to these issues.

02:17.280 --> 02:18.360
So let's start.

02:18.360 --> 02:21.000
The first one is injection attacks.

02:21.000 --> 02:26.640
These come in many forms, where a malicious attacker attempts to construct a custom request

02:26.640 --> 02:33.440
into your service to cause it to execute unexpected code paths or flows.

02:33.440 --> 02:36.400
Common example are SQL or database injection attacks.

02:36.400 --> 02:41.000
These attempt to execute an unexpected SQL command against your database, such as drop

02:41.000 --> 02:44.640
all tables if we're lucky.

02:44.640 --> 02:47.080
Another type is host command injection.

02:47.080 --> 02:54.400
So executing a privileged action against our host operating system or virtualization

02:54.400 --> 02:55.400
layer.

02:55.400 --> 02:59.840
And the last kind is server side request forgeries.

02:59.840 --> 03:06.080
That's just a convoluted way of saying that your service has credentials that are used

03:06.080 --> 03:11.680
to interact with a third party integration, and an attack may attempt to utilize those

03:11.680 --> 03:14.360
credentials on its behalf.

03:14.360 --> 03:17.000
So let's add all of these to our common threat model.

03:17.000 --> 03:18.480
But we can go further.

03:18.480 --> 03:26.280
The application security program, OWASP, has listed the top two most concerning things.

03:26.280 --> 03:28.600
Number two is broken authentication.

03:28.600 --> 03:33.280
We don't have any authentication on our API whatsoever, or what we have added isn't

03:33.280 --> 03:36.160
sufficient to actually identify malicious attackers.

03:36.160 --> 03:37.160
And this is number two.

03:37.160 --> 03:39.040
That should be telling us something.

03:39.040 --> 03:43.040
Number one is actually broken object level authorization.

03:43.040 --> 03:51.320
This lack of authentication, but lack of authorization to validate whether or not the request that's

03:51.320 --> 03:56.640
coming in actually should be allowed to execute.

03:56.640 --> 04:00.240
Usually it's due to a lack of granular access control.

04:00.240 --> 04:02.520
And we can go further.

04:02.520 --> 04:07.280
These are only the one directly at our API, but we have infrastructure to consider as

04:07.280 --> 04:08.280
well.

04:08.280 --> 04:13.280
An malicious attacker could attempt to utilize our API indirectly to affect our infrastructure

04:13.280 --> 04:17.320
via a DDoS attack.

04:17.320 --> 04:25.720
Or it could attempt to inject a malicious code into one of our dependencies through

04:25.720 --> 04:29.840
a supply chain injection attack, software or otherwise.

04:29.840 --> 04:34.120
And lastly, they could attempt a physical intrusion into our data center if we have

04:34.120 --> 04:38.280
something on prem or a virtualization later or a cloud provider or the cloud provider

04:38.280 --> 04:42.280
itself.

04:42.280 --> 04:47.400
And the attacks aren't just specific or non-specific to services in general.

04:47.400 --> 04:50.680
You have to think about how the functionality of your service is relevant, what you're currently

04:50.680 --> 04:51.680
building.

04:51.680 --> 04:56.400
A malicious attacker may attempt to utilize how your resources are built, how your end

04:56.400 --> 05:00.400
points are functioned specifically in your case.

05:00.400 --> 05:08.400
In AuthWrist, we offer multi-tenant security capabilities that allow our tenants, our customers,

05:08.400 --> 05:15.960
to create customized identity providers, custom user logic, even give us custom URLs.

05:15.960 --> 05:21.600
They can attempt and have attempted to utilize that configurability to compromise adjacent

05:21.600 --> 05:26.600
tenants at customers across our whole product.

05:26.600 --> 05:31.160
Okay, that's I think enough for a threat model that we can all agree are problems across

05:31.160 --> 05:32.160
the board.

05:32.160 --> 05:35.760
Now I want to jump to actual solutions.

05:35.760 --> 05:37.960
First up is input validation.

05:37.960 --> 05:41.760
To deal with the threat of injection attacks, we can add input validation.

05:41.760 --> 05:46.960
And I honestly, I feel kind of silly putting this slide up here because I feel like most

05:46.960 --> 05:49.600
of us know about this problem.

05:49.600 --> 05:54.160
But I feel like every single day, every week, I hear about some problem with some public

05:54.160 --> 06:00.320
company who had an issue that could have been resolved by verifying that the request

06:00.320 --> 06:04.040
they are getting matched their expectations.

06:04.040 --> 06:08.280
Well, we already thought about our expectations a little bit.

06:08.280 --> 06:11.920
And if you were listening in the last talk, we learned about the open API specification,

06:11.920 --> 06:16.080
which documents our API in a programmatic way.

06:16.080 --> 06:22.440
Well, we could potentially take that programmatic documentation and utilize it to verify those

06:22.440 --> 06:27.080
same expectations on the request we're getting into our service.

06:27.080 --> 06:32.440
Here's an example from Authris where we have group management.

06:32.440 --> 06:34.840
This actually creates user groups.

06:34.840 --> 06:37.760
And on the left, you can actually see the schema for this endpoint.

06:37.760 --> 06:41.560
It's fairly bare here and uses a common component groups.

06:41.560 --> 06:47.840
On the right, you can see the example of an open API Explorer tool automatically rendering

06:47.840 --> 06:50.880
it.

06:50.880 --> 06:57.160
So we can take the schema and what I want to do is build up a place where we can store

06:57.160 --> 06:59.520
the validation of all of our endpoints.

06:59.520 --> 07:04.120
So when we add additional endpoints to our service, they will automatically get the security

07:04.120 --> 07:05.440
of input validation.

07:05.440 --> 07:07.600
So let's create a security middleware.

07:07.600 --> 07:10.120
And I've got one here in JavaScript.

07:10.120 --> 07:12.320
But you can be using, of course, any language.

07:12.320 --> 07:18.360
There are open API specification-based tools that work in whatever framework you're using.

07:18.360 --> 07:23.160
And I'm loading the spec up here and passing in the method, the path, the body, the headers.

07:23.160 --> 07:26.720
And this will get executed on every single request that we get to our service, irrelevant

07:26.720 --> 07:30.840
of the endpoints that we have.

07:30.840 --> 07:35.240
And just like that, hopefully we've eliminated injection attacks.

07:35.240 --> 07:36.520
But why stop there?

07:36.520 --> 07:42.440
Now that we're opening up the request to do validation, we can start thinking about authentication.

07:42.440 --> 07:46.480
And authentication is required because if we don't know who the user is, we don't know

07:46.480 --> 07:48.360
if they're a potential malicious attacker.

07:48.360 --> 07:50.720
We have no way of identifying them across requests.

07:50.720 --> 07:54.040
And while we could be using something like IP addresses or some fingerprinting that's

07:54.040 --> 08:03.640
blocked by most browsers today, none of them are as effective as just using user identification

08:03.640 --> 08:05.920
through authentication.

08:05.920 --> 08:10.360
And like this, we can hopefully close out the broken authentication threat that we have

08:10.360 --> 08:13.120
in our threat model.

08:13.120 --> 08:16.640
And usually entails having a trusted identity provider.

08:16.640 --> 08:22.960
Someone that can generate access tokens on behalf of our clients, who may be machines,

08:22.960 --> 08:28.500
IoT devices, even end users, those tokens usually look like JWTs.

08:28.500 --> 08:34.760
And they'll pass us those JWTs into our API through the authorization header.

08:34.760 --> 08:38.560
From there, we'll grab some data from the identity provider that allows us to verify

08:38.560 --> 08:40.760
those tokens.

08:40.760 --> 08:43.480
So let's just see what JWT actually looks like.

08:43.480 --> 08:46.280
And I'm sure someone's going to call me out and say it's pronounced jot according to

08:46.280 --> 08:47.280
the RFC.

08:47.280 --> 08:49.200
So I'm just going to say I absolutely know that.

08:49.200 --> 08:51.320
But not everyone knows what a JWT is.

08:51.320 --> 08:55.800
And so it's easy to remember by the letters rather than how to pronounce it.

08:55.800 --> 09:01.880
So I'm just going to keep saying that a JWT has properties that can be completely configured,

09:01.880 --> 09:06.800
but at least it contains ones that have the identity provider where the token came from.

09:07.640 --> 09:10.920
User ID that the token represents.

09:10.920 --> 09:13.320
Usually there are short lived token that expires.

09:13.320 --> 09:17.800
I created this one and it's actually going to expire soon during the conference.

09:17.800 --> 09:21.240
And signature that allows us to verify it.

09:21.240 --> 09:25.480
So now let's extend our security middleware to close out the broken authentication.

09:25.480 --> 09:30.480
We can just add another method in here that allows us to extract those important fields

09:30.480 --> 09:34.480
out of the JWT and then verify them.

09:34.480 --> 09:36.600
And maybe we're done.

09:36.600 --> 09:40.840
Now I think we got to be careful not to fall into a trap here.

09:40.840 --> 09:43.960
All of our endpoints need the same sort of authentication.

09:43.960 --> 09:47.480
All the services in our system may have a similar concern, right?

09:47.480 --> 09:49.000
We want to verify on every endpoint.

09:49.000 --> 09:54.720
We may be tempted to delegate that security to another team in our company or a single

09:54.720 --> 09:57.320
component where all the requests pass through.

09:57.320 --> 10:02.480
However, fundamentally every single one of your endpoints is at stake and you're likely

10:02.480 --> 10:05.960
on the team accountable for the security of those endpoints.

10:05.960 --> 10:10.680
So when we add another component such as an API gateway into our system, we're really

10:10.680 --> 10:12.360
left with two options.

10:12.360 --> 10:17.160
The first one is to completely ignore that component, get the tokens into our service

10:17.160 --> 10:19.120
and verify them.

10:19.120 --> 10:26.080
The alternative is to not trust that identity provider that's giving us the tokens and somehow

10:26.080 --> 10:29.920
trust the API gateway instead.

10:29.920 --> 10:33.520
If you're doing that, you may think, well, our identity provider isn't necessarily providing

10:33.520 --> 10:36.080
us what it needs to do.

10:36.080 --> 10:39.400
Maybe think about changing it.

10:39.400 --> 10:41.840
And like this, we can eliminate broken authentication.

10:41.840 --> 10:45.840
But it's important to remember that identity is not security by itself.

10:45.840 --> 10:49.480
Just because we know who the user is doesn't mean that they're actually allowed to perform

10:49.480 --> 10:54.040
the action on our API that they're attempting to request.

10:54.040 --> 10:59.320
To do that, we need to introduce authorization.

10:59.320 --> 11:05.040
Admission is verifying that the machine, service, or user actually has permission to call the

11:05.040 --> 11:07.000
endpoint that they're calling.

11:07.000 --> 11:12.840
And to stop the broken object authorization, BOLA, for every endpoint, we need to consciously

11:12.840 --> 11:18.600
decide what is the purpose of this endpoint for the product, what permissions make sense

11:18.600 --> 11:22.040
to actually check, and who should have access.

11:22.040 --> 11:27.400
The simplest thing we can do is add permissions to our JWT.

11:27.400 --> 11:33.200
Users get blanket permissions to everything basically via a property in the JWT.

11:33.200 --> 11:36.600
And you'll notice that there are no resources listed here.

11:36.600 --> 11:37.600
It's just a list of permissions.

11:37.600 --> 11:42.120
And this is the bare minimum to provide authorization in your API.

11:42.120 --> 11:47.840
And it only works really in simple cases that where most of your data is public, users don't

11:47.840 --> 11:52.080
really have that many roles, or the users don't really interact with each other.

11:52.080 --> 11:57.040
However, in all but the simplest cases, it's likely not sufficient because it doesn't

11:57.040 --> 11:59.400
provide granular enough control.

11:59.400 --> 12:01.160
You can't specify the resources here.

12:01.160 --> 12:07.880
And in order to stop the broken object authorization, we need to achieve granular access control.

12:07.880 --> 12:10.320
So we need a different access control strategy.

12:10.320 --> 12:13.080
And like that, we'll introduce resource-based.

12:13.080 --> 12:21.000
In resource-based, individual users get assigned specific permissions to resources.

12:21.000 --> 12:25.800
And with that, we can actually verify that they are authorized to call our endpoints,

12:25.800 --> 12:27.080
or the specific endpoint.

12:27.080 --> 12:31.280
Okay, let's extend our security middleware and close out the Bola threat.

12:31.280 --> 12:36.000
And we'll do that by just adding another line of code to our security middleware.

12:36.000 --> 12:40.920
And here I have an example from the author's SDK, but of course you can use any SDK, any

12:40.920 --> 12:43.680
product that allows you to do this verification.

12:43.680 --> 12:48.240
Or if you're feeling adventurous in the land of security, you can try to do it yourself,

12:48.240 --> 12:52.760
not something I normally recommend.

12:52.760 --> 12:55.880
And with granular access control, you can actually scope down the permissions of each

12:55.880 --> 12:59.960
of your endpoints to only what is absolutely required.

12:59.960 --> 13:04.800
And this is known as the principle of least privilege.

13:04.800 --> 13:09.600
Now it should be self-evident that the more granular our permissions are, the more secure

13:09.600 --> 13:11.400
our API is.

13:11.400 --> 13:16.360
Because if we don't have granularity, then users likely probably have access to do too

13:16.360 --> 13:17.640
much in our service.

13:17.640 --> 13:22.360
And a malicious attacker that gains access to or impersonates one of our users while

13:22.360 --> 13:25.400
having access to potentially all of their data.

13:25.400 --> 13:29.800
The only way to prevent Bola is have a granular access control strategy and implore the principle

13:29.800 --> 13:31.300
of least privilege.

13:31.300 --> 13:37.640
Don't be this company that asks to delete all of my emails and all of my calendars.

13:37.640 --> 13:40.000
It's just totally unnecessary.

13:40.000 --> 13:45.200
Also don't be that company that lets people do this.

13:45.200 --> 13:47.760
I should at least be able to uncheck just the delete part.

13:47.760 --> 13:51.200
Yeah, sure, maybe I trust you to read and compose some emails.

13:51.200 --> 13:55.440
Read just some, not all of them.

13:55.440 --> 14:02.400
And this is actually about as far as we can get with static code in a middleware that's

14:02.400 --> 14:04.320
running.

14:04.320 --> 14:08.120
If we want to deal with some of the threats around our infrastructure, we need to take

14:08.120 --> 14:13.680
it to the next level and add some monitoring and logging.

14:13.680 --> 14:19.480
We've taken care of most of the threats at this point, but there are still some left,

14:19.480 --> 14:21.120
right?

14:21.120 --> 14:30.720
Now if we take a look at how the DDoS text works, taking the next step is potentially

14:30.720 --> 14:36.160
throwing some sort of additional component into our architecture that allows us to detect

14:36.160 --> 14:37.160
when there's a problem.

14:37.160 --> 14:41.320
And we can do that by adding what's usually known as an API firewall or a web application

14:41.320 --> 14:42.320
firewall.

14:42.320 --> 14:47.120
We'll attempt to dynamically block attacks as they happen.

14:48.120 --> 14:54.080
It can contain dynamic rules that look for suspicious activity and are executed based

14:54.080 --> 15:01.680
off of multiple request patterns.

15:01.680 --> 15:05.800
Some requests we'll get through and we'll end up logging them.

15:05.800 --> 15:07.200
We have to make sure we're logging them.

15:07.200 --> 15:11.560
And then we can process that and potentially look for patterns within our service, maybe

15:11.560 --> 15:13.800
a couple of 200 in a particular way.

15:13.800 --> 15:16.840
And we can use that to dynamically update our rules.

15:16.840 --> 15:21.520
And if we identify something that the firewall isn't blocking at that moment, well, we can

15:21.520 --> 15:25.160
actually update those rules and stop an attack as it happens.

15:25.160 --> 15:30.200
And those updated rules will continue to live on into the future.

15:30.200 --> 15:37.560
So you throw in some monitoring and logging and you notice something, a spike that looks

15:37.560 --> 15:38.560
like this.

15:38.560 --> 15:39.560
Is this a problem?

15:39.560 --> 15:41.080
Does it look like an attack?

15:41.080 --> 15:43.080
Who thinks this is an attack?

15:43.360 --> 15:44.360
No one.

15:44.360 --> 15:47.560
Everyone thinks that this is totally normal behavior.

15:47.560 --> 15:51.000
I mean, users change things all the time.

15:51.000 --> 15:55.720
So your customer causes this to happen in your service and you're like, whatever, it's not

15:55.720 --> 15:57.000
a big deal.

15:57.000 --> 16:01.560
And it may not be anything.

16:01.560 --> 16:04.720
Realistically, spikes like this don't mean that much.

16:04.720 --> 16:06.360
What's important is what's relevant for your product.

16:06.360 --> 16:10.880
For us, we monitor and validate what we call the authorization ratio.

16:10.880 --> 16:15.800
That's successful, authorized request to ones that are actually blocked, where the permissions

16:15.800 --> 16:19.760
don't match or something fundamentally changed about how it's being used.

16:19.760 --> 16:23.440
Even though this came up as one spike, the truth is that this was actually two individual

16:23.440 --> 16:29.560
problems that are API firewall, caught, and our anomaly detection, which this is actually

16:29.560 --> 16:31.520
ran to grab and pull out.

16:31.520 --> 16:37.080
This is actually from Grafana.

16:37.080 --> 16:41.320
Depending on the severity of the attack, the rules may completely shut out all requests

16:41.320 --> 16:45.040
from a particular customer or a specific service client, depending on what's actually going

16:45.040 --> 16:46.040
on.

16:46.040 --> 16:47.040
OK.

16:47.040 --> 16:52.320
I said a lot of things, so I would like to summarize.

16:52.320 --> 16:58.520
The most important thing we can do is identify our threat model.

16:58.520 --> 17:04.120
We built one here and it includes injection attacks, broken user authentication, Bola,

17:04.120 --> 17:07.720
and DDS attacks amongst some other ones.

17:07.720 --> 17:15.240
Then we created custom solutions specifically to deal with our threats, validating our inputs,

17:15.240 --> 17:22.240
having user identity, granular access control, and then adding dynamic rules.

17:22.240 --> 17:27.520
This is great when everything goes to plan, but sometimes it doesn't.

17:27.680 --> 17:33.960
And when it does, we need to really understand what we're doing.

17:33.960 --> 17:36.320
So let's take a look at some things not to do.

17:36.320 --> 17:37.520
The first one is missing our threat model.

17:37.520 --> 17:38.960
I think I've said this enough.

17:38.960 --> 17:44.440
If we don't have a threat model, then we don't know what we're building is sufficient, useful,

17:44.440 --> 17:45.600
or even relevant.

17:45.600 --> 17:50.440
It's probably even harmful.

17:50.440 --> 17:54.960
Throwing security over the wall.

17:54.960 --> 17:59.480
It's nice to be able to utilize components from another team to help us build up a more

17:59.480 --> 18:00.480
secure API.

18:00.480 --> 18:05.000
But fundamentally, your APIs are your responsibility.

18:05.000 --> 18:09.920
If something happens, who is held accountable for the lack of security there?

18:09.920 --> 18:17.440
It isn't a replacement to use another team.

18:17.440 --> 18:19.080
Internal services.

18:19.080 --> 18:21.360
There's no such thing as an internal service.

18:22.360 --> 18:26.680
There's just services that don't have any external requests yet.

18:26.680 --> 18:31.600
Lateral attacks from other services from malicious threat actors may still end up in your API,

18:31.600 --> 18:38.240
utilizing a proxy, a gateway, or another service that could be one of your only customers

18:38.240 --> 18:44.920
inside your company.

18:44.920 --> 18:49.360
At some point, your service is going to become public or have public callers, potentially.

18:49.360 --> 18:52.960
And if you haven't built your service with security in mind, then you likely have some

18:52.960 --> 18:59.960
of the threats that we've actually added into our threat model already today.

18:59.960 --> 19:07.040
So treat all your callers as externals and that your API could be considered public.

19:07.040 --> 19:08.280
Building monoliths.

19:08.280 --> 19:14.600
I think at this point by 2024, we should know that microservices are more secure than monoliths.

19:14.600 --> 19:19.840
Sources have dedicated boundaries of which we've implemented authentication and authorization

19:19.840 --> 19:22.080
at those boundary layers.

19:22.080 --> 19:25.920
If something were to happen in one of our services and it becomes compromised, there's

19:25.920 --> 19:28.720
a bulkhead door that's closed by default.

19:28.720 --> 19:33.880
Whereas in a monolithic system, if any component becomes compromised, then our whole system

19:33.880 --> 19:36.000
becomes compromised.

19:36.000 --> 19:39.880
And the last one is building it yourself.

19:39.880 --> 19:45.120
Try to build or maintain a component that isn't your core competency.

19:45.120 --> 19:50.160
And while it may seem like a clever way to get around a supply chain attack, in reality,

19:50.160 --> 19:54.800
it means you're just volunteering to take full responsibility for whatever that component

19:54.800 --> 19:57.960
is and all the vulnerabilities that show up there.

19:57.960 --> 20:02.280
You and your team are probably not going to be able to beat out a team of experts who

20:02.280 --> 20:07.520
manage some open source component out there that is being checked continuously.

20:07.520 --> 20:12.360
Now the counter example argument to this is, well, what if it's a critical component?

20:12.360 --> 20:16.200
Well, the truth is everything in our service is a critical component in some way or else

20:16.200 --> 20:19.160
we probably wouldn't have included it.

20:19.160 --> 20:22.960
You're not going to get very far with the resources you have attempting to build and

20:22.960 --> 20:28.440
maintain literally everything in your stack, including making your own electricity.

20:28.440 --> 20:29.640
Okay.

20:29.640 --> 20:34.240
So hopefully at this point, you know exactly what you need to do to add some additional

20:34.240 --> 20:36.920
security to your service.

20:36.920 --> 20:42.720
I have a quick link to the presentation if anyone actually wants it.

20:42.720 --> 20:45.480
I see too many people getting on phones.

20:45.480 --> 20:50.000
It's going to be available online, so you don't necessarily have to, but if you really want

20:50.000 --> 20:51.000
to.

20:51.000 --> 20:52.000
Okay.

20:52.000 --> 20:53.000
One more.

20:53.000 --> 20:54.000
Five, four.

20:54.000 --> 20:55.000
Okay.

20:55.000 --> 20:56.000
Okay.

20:56.000 --> 20:57.000
And thank you.

20:57.000 --> 20:58.000
Okay.

20:58.000 --> 20:59.000
And thank you.

20:59.000 --> 21:00.000
Okay.

21:00.000 --> 21:10.000
Now we have some time for some questions.

21:10.000 --> 21:11.000
Yeah.

21:11.000 --> 21:12.000
Perfect.

21:12.000 --> 21:16.120
Five minutes for questions.

21:16.120 --> 21:17.120
Go ahead.

21:17.120 --> 21:23.360
I'm not sure are you operating in the Europe company?

21:23.360 --> 21:25.000
Our company is global.

21:25.000 --> 21:27.000
So yes, Europe is included.

21:28.000 --> 21:29.000
Oh, yes.

21:29.000 --> 21:30.000
Sorry.

21:30.000 --> 21:32.000
It's our company operating in Europe.

21:32.000 --> 21:33.000
Yes, for sure.

21:33.000 --> 21:34.000
It's operating in Europe.

21:34.000 --> 21:40.000
The reason I ask is that we have some new regulations according to data protection.

21:40.000 --> 21:42.000
Yeah, for sure.

21:42.000 --> 21:48.000
And the IP address is considered to be one identifying characteristic for a person.

21:48.000 --> 21:49.000
Yes.

21:49.000 --> 21:50.000
Yeah.

21:50.000 --> 22:09.000
How do you deal with the GDPR or whatever local regulation is for identifying information

22:09.000 --> 22:10.000
such as IP addresses?

22:10.000 --> 22:14.000
I mean, the sad story about IP addresses is like forget about it honestly.

22:14.000 --> 22:19.000
Because with IPv6, which is going to be here pretty soon, you're not going to be able to

22:19.000 --> 22:22.000
do anything remotely reasonable with IP addresses in the first place.

22:22.000 --> 22:24.000
So stop logging them.

22:24.000 --> 22:28.000
For us, what we actually do is edge computing for those customers.

22:28.000 --> 22:33.000
So wherever they're coming from, most of their data stays at the edge as much as possible.

22:33.000 --> 22:37.000
So if you do have those regulations, try to keep it there and don't send it other places.

22:37.000 --> 22:41.000
All the logs are resident to that data center or those databases in that location.

22:41.000 --> 22:44.000
It still allows you to perform security on the edge.

22:44.000 --> 22:49.000
And wherever you're running your stack, whether it's on-prem data centers, hopefully not in

22:49.000 --> 22:54.000
every single country or some cloud provider, they're usually following those regulations as well.

22:54.000 --> 23:01.000
So as long as you keep the data as close to that region as possible, you're abiding by the law as best in your ability as you possibly can.

23:01.000 --> 23:06.000
Go ahead.

23:06.000 --> 23:13.000
Yeah. We do validate all incoming requests against the schema, but that doesn't necessarily mean you're safe.

23:13.000 --> 23:18.000
So two easy examples could be a build just really, really long that leads to a DDoS.

23:18.000 --> 23:24.000
Or they could be some SQL in there and a laser developer stripping it before it goes into the database.

23:24.000 --> 23:31.000
So is there a way to add that kind of validation to the OpenAPI schema or would you have that as a separate set?

23:31.000 --> 23:33.000
Can you add extra validation to the OpenAPI schema?

23:33.000 --> 23:35.000
You absolutely can.

23:35.000 --> 23:37.000
There are even vendor extensions.

23:37.000 --> 23:46.000
I mean, if you want to put your whole everything in your OpenAPI schema, you can have, there are tools out there to dynamically generate the whole service if you want to.

23:46.000 --> 23:51.000
I don't know if I'd recommend going that far, but you absolutely can.

23:51.000 --> 23:59.000
Just to be clear, you can't block everything because you don't even know if you are blocking everything realistically, right?

23:59.000 --> 24:04.000
Something that undiscovered zero-day that's sitting out there could still be waiting and happening.

24:04.000 --> 24:09.000
So there is no full guarantee that you've actually even blocked everything.

24:09.000 --> 24:10.000
Go ahead.

24:10.000 --> 24:13.000
What are your pro tips regarding the use of refresh tokens?

24:13.000 --> 24:17.000
My pro tips for using refresh tokens.

24:17.000 --> 24:28.000
You probably don't need refresh tokens ever, and if you're using them and you believe this is standard or common, you probably don't fully understand the use case for them.

24:28.000 --> 24:35.000
Unless you're dealing with a third-party technology or interface integration, you don't need refresh tokens.

24:35.000 --> 24:37.000
Just forget they even exist.

24:37.000 --> 24:39.000
So it was just within your own system.

24:39.000 --> 24:41.000
There's no need for refresh tokens.

24:41.000 --> 24:44.000
There's plenty of alternatives that are more secure.

24:44.000 --> 24:47.000
I have a whole talk on that, I guess.

24:47.000 --> 24:49.000
Does that answer your question?

24:49.000 --> 24:51.000
Okay.

24:51.000 --> 24:53.000
Anyone else?

24:53.000 --> 24:56.000
I still have a couple minutes.

24:56.000 --> 24:58.000
Don't be shy.

24:58.000 --> 24:59.000
Yeah?

24:59.000 --> 25:00.000
Go ahead.

25:00.000 --> 25:01.000
Why?

25:01.000 --> 25:02.000
Why what?

25:02.000 --> 25:03.000
About the tokens.

25:03.000 --> 25:04.000
Why?

25:04.000 --> 25:13.000
Refresh tokens allow you to impersonate in your own service one of your users to access their resources.

25:13.000 --> 25:19.000
So Google Drive, for instance, a refresh token allows you to access Google Drive as your user.

25:19.000 --> 25:24.000
If you don't have integrations with third parties, then there's no reason to have refresh tokens.

25:24.000 --> 25:27.000
There's no third-party system where you need to impersonate a user.

25:27.000 --> 25:29.000
Your own users don't need to be impersonated.

25:29.000 --> 25:33.000
You already can perform every action within your service that you want.

25:43.000 --> 25:44.000
There's a lot?

25:44.000 --> 25:45.000
Yeah, okay.

25:45.000 --> 25:46.000
Thank you.

25:46.000 --> 25:47.000
That's...

