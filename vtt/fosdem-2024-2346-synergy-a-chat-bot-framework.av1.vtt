WEBVTT

00:00.000 --> 00:01.000
Thank you.

00:01.000 --> 00:02.000
Welcome to Ricardo from Boxville.

00:02.000 --> 00:03.000
Thank you very much.

00:03.000 --> 00:04.000
Hey, okay.

00:04.000 --> 00:09.000
I did a timing run of this, but I had like zero sleep in 48 hours.

00:09.000 --> 00:22.000
So either it's going to run shorter or longer, maybe right on time we'll see, but we'll get

00:22.000 --> 00:24.000
the tape in.

00:25.000 --> 00:27.000
Second.

00:29.000 --> 00:30.000
There we go.

00:30.000 --> 00:31.000
All right.

00:31.000 --> 00:34.000
So, imagine it.

00:37.000 --> 00:39.000
It's the future.

00:39.000 --> 00:41.000
The year 2018.

00:41.000 --> 00:46.000
And at Fastmail, all of our critical systems run through our chat bot.

00:46.000 --> 00:47.000
Right?

00:47.000 --> 00:49.000
Like you want to deploy, you go to the chat bot.

00:49.000 --> 00:52.000
You want to set up a task for somebody else to do.

00:52.000 --> 00:54.000
You want to remind her, you go to the chat bot.

00:54.000 --> 01:00.000
And the chat bot is written in IR, for an IRC service because we're cutting edge company.

01:00.000 --> 01:02.000
And it's in charge of everything.

01:02.000 --> 01:03.000
Right?

01:03.000 --> 01:06.000
And then I got this email from Slack and it said, hey, just so you know, in like three

01:06.000 --> 01:08.000
weeks we're turning off the IRC gateway.

01:08.000 --> 01:12.000
And I talked to the shareholders who said they didn't want to close the company.

01:12.000 --> 01:16.000
So it turned out that we had to take this thing.

01:16.000 --> 01:21.000
This is Synergy, our bot, and go through a raging quick process to upgrade her.

01:21.000 --> 01:25.000
To talk to Slack.

01:25.000 --> 01:27.000
So this talk is about that project.

01:27.000 --> 01:33.000
But it's also about the fact that when we did that, we totally rewrote not every line

01:33.000 --> 01:39.000
of code, but all the lines of the interesting code to make it not horrible to deal with.

01:39.000 --> 01:42.000
Because it was, this is the three of us who did this.

01:42.000 --> 01:46.000
Matt Horsfall, who's at the top middle there, is a frequent person at Pearl Things.

01:46.000 --> 01:48.000
He happened to be in town.

01:48.000 --> 01:49.000
He mostly works remote.

01:49.000 --> 01:51.000
And we said, great, let's drop everything else we're doing.

01:51.000 --> 01:53.000
I've been sitting in a room for five days and rewired our chat bot.

01:53.000 --> 01:54.000
And it was great.

01:54.000 --> 01:59.000
It was written originally for Pearl 516, which at the time was cutting edge.

01:59.000 --> 02:02.000
And it was written using Poe, which was not cutting edge.

02:02.000 --> 02:04.000
Who here has ever used Poe?

02:04.000 --> 02:05.000
Yes.

02:05.000 --> 02:06.000
Yeah?

02:06.000 --> 02:07.000
Okay.

02:07.000 --> 02:08.000
Sorry.

02:08.000 --> 02:10.000
This is me looking excited back when I was younger.

02:10.000 --> 02:11.000
Like, yeah, Poe.

02:11.000 --> 02:12.000
No.

02:12.000 --> 02:13.000
This is Poe code.

02:13.000 --> 02:16.000
It's, look, you don't need to know everything about this code, but there it is.

02:16.000 --> 02:19.000
The thing you should notice is that it's pretty weird.

02:19.000 --> 02:22.000
Like, dollar underscore square bracket arg zero.

02:22.000 --> 02:24.000
What the hell even is that?

02:24.000 --> 02:26.000
Like dollar underscore heap.

02:26.000 --> 02:29.000
I use Pearl so I don't think about a heap, right?

02:29.000 --> 02:30.000
Like that's what I'm doing.

02:30.000 --> 02:31.000
It's, it's a mess.

02:31.000 --> 02:34.000
So what you need to know about Poe to understand this talk is like nothing.

02:34.000 --> 02:35.000
Don't worry about it.

02:35.000 --> 02:42.000
But in, even in 2005, right, when I first, very first started writing the first line of this code,

02:42.000 --> 02:43.000
it felt weird to use.

02:43.000 --> 02:45.000
And it's not really Poe's fault.

02:45.000 --> 02:49.000
The problem is that for a long time, any kind of concurrency felt weird.

02:49.000 --> 02:52.000
At least for me and at least in Pearl, right?

02:52.000 --> 02:56.000
Anything you're going to do, you're like, why is my code now coming from outer space?

02:56.000 --> 02:59.000
And Poe is just more weirdness that I didn't want to deal with.

02:59.000 --> 03:03.000
So my strategy for building the software is really simple, right?

03:03.000 --> 03:05.000
Do as much as possible without Poe.

03:05.000 --> 03:07.000
Don't write the Poe code.

03:07.000 --> 03:09.000
That's where everything gets messed up.

03:09.000 --> 03:13.000
So only use it when you absolutely need to, like all this asynchronous talking to the network server.

03:13.000 --> 03:15.000
And you can simplify that.

03:15.000 --> 03:18.000
You can make that statement generic by saying concurrency is weird.

03:18.000 --> 03:21.000
So weirdness is hard to cope with in your program.

03:21.000 --> 03:26.000
So minimize the weirdness by writing less concurrency in your code, right?

03:26.000 --> 03:29.000
Minimize how much your code has to do concurrency.

03:29.000 --> 03:31.000
So you imagine the program looks like this.

03:31.000 --> 03:33.000
You've got like that magic IRC thing.

03:33.000 --> 03:34.000
That's where all the Poe lives.

03:34.000 --> 03:35.000
That's where it's weird.

03:35.000 --> 03:39.000
And then like a thing that gets messages and dispatches them to something that does something.

03:40.000 --> 03:43.000
And we tell ourselves that it works like this, right?

03:43.000 --> 03:47.000
The concurrency lives over here and then there's the good code that we wrote.

03:47.000 --> 03:54.000
And the magic IRC thing does its magic and it calls the dispatcher and the dispatcher calls the handler and sends them the IRC thing and you're good, right?

03:54.000 --> 03:55.000
That's it.

03:55.000 --> 03:58.000
And the problem is that's not how it works, okay?

03:58.000 --> 04:03.000
Like some abstractions let you believe lies and they're good and some let you believe lies and they hurt you.

04:03.000 --> 04:07.000
So you imagine it, like subroutines form a stack, right?

04:07.000 --> 04:10.000
Subroutine calls a subroutine calls a subroutine and it returns and it returns and returns.

04:10.000 --> 04:13.000
And you can violate that but like don't tell me about it.

04:13.000 --> 04:16.000
The handler down here has to return.

04:16.000 --> 04:22.000
So either the dispatcher is getting the return value from the handler and passing it back to IRC to send a reply.

04:22.000 --> 04:28.000
Or the handler is doing some weird thing to send a reply before it returns, right?

04:28.000 --> 04:29.000
So what's actually happening?

04:29.000 --> 04:30.000
Let's say it's the first one.

04:30.000 --> 04:33.000
We're going to like engage in a little Socratic method.

04:33.000 --> 04:36.000
A little go through the logical process.

04:36.000 --> 04:39.000
Message comes in to IRC, a network message.

04:39.000 --> 04:42.000
And it turns it into something that can go to the dispatcher.

04:42.000 --> 04:43.000
Dispatcher sends it to the handler.

04:43.000 --> 04:44.000
Handler sends it to the IRC thing.

04:44.000 --> 04:46.000
The circle of life, right?

04:46.000 --> 04:47.000
Great.

04:47.000 --> 04:48.000
No.

04:48.000 --> 04:51.000
What actually happens is it comes in from the network and it goes to the dispatcher and it goes to the handler.

04:51.000 --> 04:53.000
The handler is like, I got this but it's going to take a minute.

04:53.000 --> 04:55.000
I need to look up 70 million rows in the database.

04:55.000 --> 05:00.000
And meanwhile, everybody at IRC is still sending these other messages.

05:00.000 --> 05:03.000
And you're not talking to the network anymore.

05:03.000 --> 05:05.000
You're like asynchronous thing is sitting there like,

05:05.000 --> 05:09.000
I would be so busy being asynchronous if you would just yield to me.

05:09.000 --> 05:13.000
And you don't because you're voting, putting concurrency everywhere you can.

05:13.000 --> 05:15.000
And pretty soon the whole thing falls apart.

05:15.000 --> 05:17.000
And like you lose all your messages and everybody's like,

05:17.000 --> 05:19.000
why aren't my deploys working?

05:19.000 --> 05:20.000
Because of IRC.

05:20.000 --> 05:22.000
So the other option has to be true, right?

05:22.000 --> 05:23.000
The handler is doing a thing.

05:23.000 --> 05:25.000
So a message comes into IRC.

05:25.000 --> 05:26.000
It goes to the dispatcher.

05:26.000 --> 05:27.000
It goes to the handler.

05:27.000 --> 05:28.000
The handler has to do something.

05:28.000 --> 05:30.000
So, because this thing's happening.

05:30.000 --> 05:33.000
So it sends it back to IRC but now it's blue.

05:33.000 --> 05:34.000
Right now it's a different message.

05:34.000 --> 05:36.000
It's not the, you've got a message.

05:36.000 --> 05:38.000
I want to send a message and everything's good.

05:38.000 --> 05:40.000
This is no longer just IRC.

05:40.000 --> 05:41.000
It's all your async.

05:41.000 --> 05:44.000
Your stuff comes in, it goes over there, it keeps going, you're good.

05:44.000 --> 05:46.000
Now you need something to handle both kinds of messages.

05:46.000 --> 05:49.000
One for, you know, you've got a message, you're going to do something.

05:49.000 --> 05:50.000
One you're going to send a reply.

05:50.000 --> 05:52.000
These boxes should be labeled differently.

05:52.000 --> 05:53.000
You're fine.

05:53.000 --> 06:01.000
Every kind of message that comes in, you've written your own simple, pretty much blocking, but okay handler.

06:01.000 --> 06:02.000
You don't even need to dispatch anymore.

06:02.000 --> 06:03.000
You just tie it into the message.

06:03.000 --> 06:05.000
Here's where I go and you call me.

06:05.000 --> 06:06.000
Great.

06:06.000 --> 06:07.000
Your code got simpler.

06:07.000 --> 06:13.000
The problem is making a ticket involves like talking to the database which in non-blocking

06:13.000 --> 06:17.000
terms means starting to talk to the database, doing the talk to the database, finishing

06:17.000 --> 06:19.000
talking to the database, dealing with an error.

06:19.000 --> 06:23.000
So you have to write all of these little pieces of code wonderfully.

06:23.000 --> 06:25.000
They're not concurrent, right?

06:25.000 --> 06:28.000
They just block if they need to or they just get called once.

06:28.000 --> 06:29.000
They're not doing anything weird.

06:29.000 --> 06:32.000
And then your program looks like this.

06:32.000 --> 06:33.000
Ah!

06:33.000 --> 06:40.000
There's, they call this, this is roughly like the dumb ass version of the actor model.

06:40.000 --> 06:42.000
So like Zoolander code.

06:42.000 --> 06:46.000
But it's not, it can be good.

06:46.000 --> 06:47.000
I just came from the Erlang room.

06:47.000 --> 06:48.000
The Erlang room is cool.

06:48.000 --> 06:52.000
Actors are cool, but you don't write pearl code that way which means your pearl code feels

06:52.000 --> 06:55.000
weird and we actually want to write pearl code that feels like pearl code.

06:55.000 --> 06:57.000
So here's what we do.

06:57.000 --> 07:02.000
We make a message and the message is going to contain its own reply handler, right?

07:02.000 --> 07:05.000
You're like, I'm going to send you a message and don't worry, you don't need to go write

07:05.000 --> 07:06.000
all these million things.

07:06.000 --> 07:10.000
When I send you the message, I put like a self-addressed stamped envelope.

07:10.000 --> 07:13.000
If this happens, send this envelope and that's your little reply handler.

07:13.000 --> 07:15.000
And now your code still looks like pearl code.

07:15.000 --> 07:17.000
You're good.

07:17.000 --> 07:19.000
And you do this all over the place.

07:19.000 --> 07:22.000
Like when you're setting up the listener, you're like, yeah, okay, I'm going to bind to the

07:22.000 --> 07:24.000
socket and if there's an error, here's what you do.

07:24.000 --> 07:26.000
And if you do connect, here's what you do.

07:26.000 --> 07:29.000
And by the way, after you've connected, once you start receiving packets, here's what you do.

07:29.000 --> 07:30.000
Right?

07:30.000 --> 07:32.000
And you're nesting all these envelopes and it's great.

07:32.000 --> 07:35.000
Like you've all got a pile of top level envelopes and you're like, yeah.

07:35.000 --> 07:39.000
So I'm going to listen and then maybe bind and then maybe connect and then maybe accept.

07:39.000 --> 07:41.000
And over here, like I'm going to do an L stat, the block in the file.

07:41.000 --> 07:42.000
So now it's easy.

07:42.000 --> 07:45.000
I'm going to create a file over here and then do some stuff with it.

07:45.000 --> 07:51.000
I'm going to k-pole and like we've got all these nested things and everything piles up

07:51.000 --> 07:55.000
and everything is like an envelope, an envelope, an envelope and it doesn't look like

07:55.000 --> 07:56.000
pro-code anymore.

07:56.000 --> 07:58.000
There's a name for this pattern by the way.

07:58.000 --> 08:03.000
They call it callback hell because this is what it feels like.

08:03.000 --> 08:04.000
Thank you.

08:04.000 --> 08:08.000
Like all of your code is just all callbacks.

08:08.000 --> 08:10.000
There's no named subroutines anymore.

08:10.000 --> 08:13.000
So you wanted to write this code.

08:13.000 --> 08:14.000
Okay, this is all you wanted.

08:14.000 --> 08:15.000
You just wanted to make a ticket.

08:15.000 --> 08:17.000
You got a message from the network.

08:17.000 --> 08:18.000
Put the whole thing up here.

08:18.000 --> 08:21.000
I was going to go through it line by line but whatever.

08:21.000 --> 08:24.000
You get a message and you parse it and it's like here's the ticket you should make.

08:24.000 --> 08:25.000
That's the plan.

08:25.000 --> 08:28.000
And then you say if they're allowed to make the ticket, good.

08:28.000 --> 08:30.000
But if they're not, you reply no and you return, right?

08:30.000 --> 08:31.000
You're done.

08:31.000 --> 08:32.000
Crash early.

08:32.000 --> 08:35.000
And then you make the ticket and then you reply, I made the ticket.

08:35.000 --> 08:36.000
That's the code you want to work.

08:36.000 --> 08:40.000
This is the perfect platonic expression of a chat bot.

08:40.000 --> 08:42.000
I got a message and I did a thing.

08:42.000 --> 08:45.000
And the problem is these three things block.

08:45.000 --> 08:49.000
And this is where your whole program just starts falling apart because you've got

08:49.000 --> 08:53.000
like 75 kinds of event handlers that all look like this and they all block.

08:53.000 --> 08:54.000
So it's okay.

08:54.000 --> 09:00.000
You can fix this problem by using sequencing, by leveraging promises or futures.

09:00.000 --> 09:05.000
And all you have to do is make your code look like this.

09:05.000 --> 09:09.000
This is just another kind of callback hell, right?

09:09.000 --> 09:14.000
You're just saying here's all this stuff to line up all up and like you will end up being

09:14.000 --> 09:15.000
like I'm living in the future.

09:15.000 --> 09:16.000
It's amazing.

09:16.000 --> 09:21.000
I can like write all my non-blocking code, but you're so sad inside because it's all

09:21.000 --> 09:25.000
these anonymous subroutines that you can't debug and like they're real bad.

09:25.000 --> 09:27.000
So remember when I said this earlier, right?

09:27.000 --> 09:28.000
Concurrency is weird.

09:28.000 --> 09:31.000
So minimize it by minimizing the concurrent code.

09:31.000 --> 09:32.000
That was bullshit.

09:32.000 --> 09:33.000
Don't do that.

09:33.000 --> 09:35.000
You need to lean into it, right?

09:35.000 --> 09:37.000
You need to, the problem is this.

09:37.000 --> 09:41.000
When you minimize the concurrent code, you write crappy programs because you write programs

09:41.000 --> 09:45.000
where you're like all the weird shit's over here and everything else is coping with it.

09:45.000 --> 09:46.000
Right?

09:46.000 --> 09:48.000
All of your code is just, I'm here to cope.

09:48.000 --> 09:49.000
Don't do that.

09:49.000 --> 09:52.000
What you want to do is get the language to hide that complexity for you.

09:52.000 --> 09:54.000
The language is like, don't worry.

09:54.000 --> 09:58.000
You write the code you want to write and I'm going to make it work.

09:58.000 --> 10:02.000
And then you make the code concurrent at the slightest provocation.

10:02.000 --> 10:04.000
You're like, oh, this might be able to block concurrent.

10:04.000 --> 10:05.000
That's what you do.

10:05.000 --> 10:07.000
And you can do that now because of asynch await.

10:07.000 --> 10:09.000
And that's what I'm going to talk about for a little while.

10:09.000 --> 10:12.000
I promise I'm going to talk about the chatbot.

10:12.000 --> 10:15.000
So you take this ugly ass code, right?

10:15.000 --> 10:19.000
Where you're like, do this and then call this other code, but then call this other code.

10:19.000 --> 10:21.000
And if it fails, you don't need to read this.

10:21.000 --> 10:22.000
I've read it once.

10:22.000 --> 10:23.000
That's enough for all of us.

10:23.000 --> 10:25.000
You write this.

10:25.000 --> 10:29.000
It's just like that beautiful perfect platonic code except I stuck some green stuff on here.

10:29.000 --> 10:30.000
Right?

10:30.000 --> 10:32.000
This sub is now asynchronous.

10:32.000 --> 10:33.000
It can yield.

10:33.000 --> 10:37.000
Then this line of code, I will yield here if I need to.

10:37.000 --> 10:38.000
That's all you're saying.

10:38.000 --> 10:41.000
I identify this code might be blocking.

10:41.000 --> 10:42.000
I don't know.

10:42.000 --> 10:44.000
Let's something else figure it out.

10:44.000 --> 10:46.000
And how does this actually work?

10:46.000 --> 10:56.000
Well, when you do this, something, it's called future asynch await, something takes this and it like pulls apart the whole subroutine into different units.

10:56.000 --> 10:58.000
And it's like, I'll put these together the right way.

10:58.000 --> 10:59.000
Don't sweat it.

10:59.000 --> 11:01.000
I'm going to make it work.

11:01.000 --> 11:06.000
And kind of what it puts it into together into is this.

11:06.000 --> 11:07.000
Kind of.

11:07.000 --> 11:15.000
The reality is what it's really doing is really gross and scary and it involves like mangling optries and putting them together.

11:15.000 --> 11:18.000
But that's what all pearl code is anyway.

11:18.000 --> 11:27.000
All this time that you write pearl, it's just building some crazy ass optry and like maybe there's one person in this room who thinks about optries every day.

11:27.000 --> 11:29.000
Hi, Paul.

11:30.000 --> 11:32.000
Most of us.

11:32.000 --> 11:37.000
Most of us don't have to do that and you still don't have to.

11:37.000 --> 11:44.000
So the conclusion of this long digression about asynch await is you should embrace this weirdness, right?

11:44.000 --> 11:47.000
Make your code concurrent easily all the time.

11:47.000 --> 11:53.000
Embrace the stuff so hard that like all the weirdness becomes part of you and you don't think about it.

11:53.000 --> 11:59.000
But the weirdness is there making you powerful and making your code better and just use future asynch await.

11:59.000 --> 12:00.000
Okay.

12:00.000 --> 12:01.000
It's not.

12:01.000 --> 12:02.000
I'll talk more about it later if somebody asks.

12:02.000 --> 12:04.000
I like talking about it's very good.

12:04.000 --> 12:06.000
So let's talk about synergy.

12:06.000 --> 12:11.000
If there's an unopened bottle of water in this room, I would definitely drink it.

12:11.000 --> 12:12.000
Okay.

12:12.000 --> 12:15.000
So you can find synergy here.

12:15.000 --> 12:17.000
The link will show up again later.

12:17.000 --> 12:18.000
You can ask me for it.

12:18.000 --> 12:19.000
You can install it.

12:19.000 --> 12:20.000
It's super cool.

12:20.000 --> 12:23.000
If you install it and it doesn't work, I'm sorry.

12:23.000 --> 12:25.000
And that's all you're getting out of me.

12:25.000 --> 12:26.000
I might answer a question.

12:26.000 --> 12:27.000
We don't support this.

12:27.000 --> 12:31.000
This is software written in the open and not a public project.

12:31.000 --> 12:33.000
We want everybody to use an adopt.

12:33.000 --> 12:38.000
If you come and find bugs, we might fix them and we might say, that's a cool bug you found.

12:38.000 --> 12:40.000
Here's how it works.

12:40.000 --> 12:43.000
There's basically three abstractions in synergy that you need to know about.

12:43.000 --> 12:46.000
Channels where messages come and go.

12:46.000 --> 12:51.000
And when I say messages, because in, you know, concurrent object oriented networking code,

12:51.000 --> 12:52.000
messages can mean a lot of things.

12:52.000 --> 12:54.000
Messages means chat messages, right?

12:54.000 --> 12:56.000
Like, hello, how are you?

12:56.000 --> 12:57.000
Those messages.

12:57.000 --> 13:01.000
And a reactor, which decides, should I react to this message?

13:01.000 --> 13:03.000
So that is the synergy software diagram.

13:03.000 --> 13:04.000
There you go.

13:04.000 --> 13:05.000
That's it.

13:05.000 --> 13:07.000
You understand synergy now.

13:07.000 --> 13:08.000
And I'm almost not joking.

13:08.000 --> 13:12.000
Like, it's really about the simple, which is why it's nice to use.

13:12.000 --> 13:14.000
But let's look at the code.

13:14.000 --> 13:16.000
And answer the question.

13:16.000 --> 13:21.000
Most of the time, when you work with synergy, you connect synergies, channels to your chat system,

13:21.000 --> 13:23.000
and then everything is about the reactors.

13:23.000 --> 13:25.000
What does the bot actually do?

13:25.000 --> 13:27.000
So that's what we should look at first.

13:27.000 --> 13:28.000
This is a reactor.

13:28.000 --> 13:32.000
It's a reactor that I use a lot when I don't understand why synergy did something.

13:32.000 --> 13:39.000
I ask for the uptime and synergy says, I've been up for four seconds and I say, aha, well, you just crashed.

13:39.000 --> 13:40.000
Here's how it works.

13:40.000 --> 13:41.000
It's a package.

13:41.000 --> 13:43.000
It's a class.

13:43.000 --> 13:45.000
Everything in synergy is written with moose.

13:45.000 --> 13:50.000
And this one does a role called synergy role reactor command post.

13:50.000 --> 13:52.000
So the role reactor means it's a reactor.

13:52.000 --> 13:57.000
And command post is so that later at the bottom, we can say, here's a command.

13:57.000 --> 13:59.000
You can write reactors in lots of different ways.

13:59.000 --> 14:05.000
I've been spending lots of my free time converting all of the old style reactors, which was called easy listening,

14:05.000 --> 14:07.000
into new style, which is command post.

14:07.000 --> 14:08.000
You do whatever you want.

14:08.000 --> 14:09.000
I don't care, but use command post.

14:09.000 --> 14:12.000
It just lets you write a bot really easily.

14:12.000 --> 14:15.000
And then the meat is a single way.

14:15.000 --> 14:19.000
The command takes a sub and that's what runs.

14:19.000 --> 14:22.000
So when someone says, hey, synergy, what's your uptime?

14:22.000 --> 14:29.000
This sub routine runs and it says, well, figure out how long I've been up the duration since the process started and reply.

14:29.000 --> 14:35.000
So we got a message in this event and we call reply on it.

14:35.000 --> 14:37.000
So you are the best.

14:37.000 --> 14:39.000
I am guilty.

14:39.000 --> 14:44.000
I have here actually stuck into the message, the ability to reply directly to it.

14:44.000 --> 14:46.000
There is some small amount of callback hell.

14:46.000 --> 14:48.000
That's maybe the last instance of it you'll see.

14:48.000 --> 14:50.000
So this is a reactor.

14:50.000 --> 14:58.000
You don't really need to know almost anything about asynchronous code other than make sure you write async and await in the right place and everything will work.

14:58.000 --> 15:05.000
So you could at this point install synergy, connect to something and be happy.

15:05.000 --> 15:07.000
But we're going to keep talking.

15:07.000 --> 15:10.000
The one last thing I should talk about on this slide is dollar event.

15:10.000 --> 15:14.000
Dollar event is the object that represents the message.

15:14.000 --> 15:26.000
I'm really sorry that I've called it both message and event taking, you know, two useful names that mean the same thing and using them to mean the same thing when I could have made them mean different things.

15:26.000 --> 15:27.000
I guess that's better.

15:27.000 --> 15:30.000
Here's what the event looks like.

15:30.000 --> 15:31.000
And then has text.

15:31.000 --> 15:34.000
That's whatever the user typed and has a channel it came from, right?

15:34.000 --> 15:36.000
So we said channels are how you connect to your chat network.

15:36.000 --> 15:37.000
That's the channel.

15:37.000 --> 15:39.000
It has a from address.

15:39.000 --> 15:42.000
If you are an IRC, that's like the channel again.

15:42.000 --> 15:44.000
Sorry.

15:44.000 --> 15:47.000
It has the user it came from if it came from a known user.

15:47.000 --> 15:50.000
And was it said in a public channel or in DMs?

15:50.000 --> 15:52.000
Was it said at me?

15:52.000 --> 15:53.000
Right.

15:53.000 --> 15:55.000
So like did someone say synergy?

15:55.000 --> 15:56.000
What time is it?

15:56.000 --> 15:58.000
Or did someone just say what time is it?

15:58.000 --> 16:02.000
Because you don't want the box to respond to everything and send a reply and send a reply.

16:02.000 --> 16:04.000
But this time it was an error.

16:04.000 --> 16:05.000
That's it.

16:05.000 --> 16:08.000
So this is basically the stuff a normal reactor does.

16:08.000 --> 16:09.000
So now you know, right?

16:09.000 --> 16:11.000
Channels, reactors, and you've seen a specific reactor.

16:11.000 --> 16:12.000
Great.

16:12.000 --> 16:14.000
Now you know how to handle events.

16:14.000 --> 16:18.000
You get an event object and you call reply on it and you do whatever you want in that sub.

16:18.000 --> 16:21.000
Where they come from, they come from channels.

16:21.000 --> 16:25.000
I'm going to talk about how channels work and how you can make one.

16:25.000 --> 16:28.000
But the short answer is don't.

16:28.000 --> 16:29.000
There's a Slack channel.

16:29.000 --> 16:34.000
You might remember from the top of this talk that we needed a Slack channel and that's why we wrote this whole stupid thing.

16:34.000 --> 16:35.000
Synergy's not stupid.

16:35.000 --> 16:37.000
Synergy's great.

16:37.000 --> 16:43.000
There's a Discord channel because I don't do my personal chatting on Slack.

16:43.000 --> 16:46.000
There's an IRC channel, although it doesn't work.

16:46.000 --> 16:49.000
I'm probably going to try and bug Paul to get some help on it.

16:49.000 --> 16:51.000
It works for a while and it falls over.

16:51.000 --> 16:53.000
There's a Twilio channel so you can SMS with your bot.

16:53.000 --> 16:55.000
There's a console channel we'll talk about.

16:55.000 --> 16:59.000
And there's a test channel because of course you can write automated tests for the thing.

16:59.000 --> 17:01.000
Channels are kind of a pain to write.

17:01.000 --> 17:06.000
This is the place where you can minimize all the complexity for those things that you thought that you could make not concurrent.

17:06.000 --> 17:08.000
You have to make those concurrent but it's easy.

17:08.000 --> 17:15.000
But at some point connecting to a remote web service over web sockets and handling different kind of frames and dispatching and all that and reconnecting.

17:15.000 --> 17:17.000
That's complicated.

17:17.000 --> 17:19.000
So there's an irreducible complexity here.

17:19.000 --> 17:24.000
The good news is you won't need to write one but I'm going to show you very roughly what it would look like.

17:24.000 --> 17:26.000
You'd have something like this.

17:26.000 --> 17:31.000
So this is a stupid subroutine that's like every five seconds sends an event.

17:31.000 --> 17:32.000
What does it do?

17:32.000 --> 17:37.000
It makes an event object saying the user said boop and it tells the hub to handle that event.

17:37.000 --> 17:40.000
The hub is that box and the diagram with Synergy's face on it.

17:40.000 --> 17:44.000
It drops it in there and everything good happens goes to all the reactors.

17:44.000 --> 17:48.000
But to see how the channel really works we're going to look at the console channel.

17:48.000 --> 17:51.000
The console channel is for working at the terminal.

17:51.000 --> 17:53.000
I'm sorry if you can't read this stuff.

17:53.000 --> 17:55.000
I did what I did.

17:55.000 --> 17:57.000
So here I'm going to run Pizzazz.

17:57.000 --> 18:00.000
Pizzazz is my local testing instance of Synergy.

18:00.000 --> 18:06.000
It just fires up Synergy with a bunch of reactors sitting in the console so I can test with it.

18:06.000 --> 18:10.000
I run it to get my little, you know, I've started up and I say uptime.

18:10.000 --> 18:12.000
That's the reactor we've all seen how it works.

18:12.000 --> 18:15.000
And Synergy replies and says I've been online for one second.

18:15.000 --> 18:17.000
So that's it, right?

18:17.000 --> 18:20.000
This is how I use Synergy when I'm developing.

18:20.000 --> 18:24.000
I stick the reactors into the console and I test there.

18:24.000 --> 18:28.000
Because if you've ever tried connecting a chat bot to Slack,

18:28.000 --> 18:33.000
you'd think that for a company that makes a chat product they'd want to make it easy.

18:33.000 --> 18:34.000
But they do not.

18:34.000 --> 18:39.000
It is a real pain in the butt and about every 18 months they change the way you connect a bot.

18:39.000 --> 18:42.000
Discord's much easier and it's documented in the repository how to do it.

18:42.000 --> 18:44.000
Slack I haven't bothered.

18:44.000 --> 18:46.000
But if you look at the top of the screenshot,

18:46.000 --> 18:51.000
you see console online, console channel online, console channel online.

18:51.000 --> 18:53.000
Why are there multiple console channels?

18:53.000 --> 18:54.000
That's a great question.

18:54.000 --> 18:55.000
I'm glad you asked.

18:55.000 --> 18:57.000
Here's another reactor.

18:57.000 --> 18:59.000
This is the announced reactor.

18:59.000 --> 19:07.000
Back when we are on IRC, we didn't have our chat for work on our phones, right?

19:07.000 --> 19:09.000
That before Slack at all.

19:09.000 --> 19:11.000
We just didn't have it on our phones.

19:11.000 --> 19:14.000
But you might be at lunch and lunch is running long and you want to say,

19:14.000 --> 19:15.000
I'm really getting back.

19:15.000 --> 19:17.000
And there was a Twilio channel, right?

19:17.000 --> 19:19.000
So you text the bot and you say,

19:19.000 --> 19:21.000
announce I'm still eating.

19:21.000 --> 19:25.000
And then Synergy would receive this message on the Twilio channel.

19:25.000 --> 19:27.000
It would go to this reactor and this reactor says,

19:27.000 --> 19:32.000
okay, I got in the vent and it's not from the channel I want to send to.

19:32.000 --> 19:33.000
The two channel name.

19:33.000 --> 19:35.000
We'll come back to that.

19:35.000 --> 19:37.000
And if it is, I say, like, what are you doing?

19:37.000 --> 19:40.000
You're telling me to announce something but you're already in the announcement room.

19:40.000 --> 19:45.000
And otherwise, she'll look up the channel, the two channel, and send a message there.

19:45.000 --> 19:47.000
Send a message there saying this.

19:47.000 --> 19:50.000
So when I would text the bot saying I'm still at lunch,

19:50.000 --> 19:56.000
the bot will post a message in IRC saying, Rick says he's still at lunch.

19:56.000 --> 20:02.000
And this all works because you can have multiple channels in your Synergy.

20:02.000 --> 20:05.000
This is one of the really keen things about writing asynchronous code.

20:05.000 --> 20:08.000
You can have lots and lots and lots of things in your process and they all work.

20:08.000 --> 20:10.000
You can have lots of consoles that talk to each other.

20:10.000 --> 20:16.000
So here, in my testing environment, I've spun up several console channels.

20:16.000 --> 20:20.000
Now only one of them is getting my input because I can only type to one terminal at a time

20:20.000 --> 20:23.000
unless I want to do something really weird.

20:23.000 --> 20:25.000
And I've set up the announce plugin.

20:25.000 --> 20:28.000
And I can say announce, yeah, I was going to do a live demo of this,

20:28.000 --> 20:31.000
but I didn't because I've got enough going on.

20:31.000 --> 20:36.000
And what you see is on the input-output terminal Synergy says, great, I announced it.

20:36.000 --> 20:37.000
Thank you.

20:37.000 --> 20:40.000
And on the announcement thing, you see the message come in there.

20:40.000 --> 20:43.000
So this testing environment is simulating multiple channels.

20:43.000 --> 20:49.000
I still have a purple channel which you won't see in this deck representing Twilio.

20:49.000 --> 20:52.000
So you can say like this should page somebody's phone with an emergency

20:52.000 --> 20:57.000
and you'll get the page showing up here like, yeah, I would have sent a text message, you're good.

20:57.000 --> 21:00.000
So it's all nice and simple.

21:00.000 --> 21:05.000
The one thing you might be wondering is what's up with two channel name?

21:05.000 --> 21:13.000
So in the world where that's like IRC, two channel name here might be private IRC server, just a string.

21:13.000 --> 21:18.000
And it says that's how you're going to go find the channel off the hub.

21:18.000 --> 21:20.000
Which channel am I sending to this one?

21:20.000 --> 21:22.000
But where did it come from?

21:22.000 --> 21:23.000
Like how is this set up?

21:23.000 --> 21:24.000
How is it configured?

21:24.000 --> 21:28.000
Well remember all the channels and all the reactors and everything else, they're moose objects.

21:28.000 --> 21:33.000
So there's an attribute on the object called two channel name and it's a string.

21:33.000 --> 21:38.000
Now if that's all we did we'd be a little screwed up because at some point someone would try announcing

21:38.000 --> 21:41.000
and we'd realize we had a typo in there and it would crash at run time.

21:41.000 --> 21:45.000
So also when the reactor starts up, when the wind synergy is really booting up and connecting,

21:45.000 --> 21:50.000
she'll say, do I actually have a channel called that?

21:50.000 --> 21:52.000
And if not, crash early, crash early everybody.

21:52.000 --> 21:53.000
But that's it.

21:53.000 --> 21:58.000
Everything, all the reactors work this way, they're all configured with attributes on the objects which is what you want.

21:58.000 --> 22:00.000
That's just one more turtle, right?

22:00.000 --> 22:02.000
But where did it come from?

22:02.000 --> 22:04.000
This is the bottom turtle.

22:04.000 --> 22:06.000
It comes from a config file.

22:06.000 --> 22:12.000
So you've got a config file where you list all the plugins that you want, all the reactors, all the channels, and all their properties.

22:12.000 --> 22:19.000
And somewhere in here at the top you'll see the announced channel, the announced reactor, and it says here's the address that I send to,

22:19.000 --> 22:22.000
and here's the channel on which I will send to that address.

22:22.000 --> 22:26.000
And then you'll see all these other reactors that are configured just the same way, the clocks reactor.

22:26.000 --> 22:28.000
Which time zones do I care about?

22:28.000 --> 22:30.000
Melbourne and New York.

22:30.000 --> 22:35.000
There's a DC reactor that you can use to run DC calculator programs.

22:35.000 --> 22:37.000
I didn't write that.

22:37.000 --> 22:39.000
Okay.

22:39.000 --> 22:44.000
So now we've written channel, we know how channels work, and we know that all the stuff comes from configuration.

22:44.000 --> 22:45.000
That's great.

22:45.000 --> 22:47.000
Now we're going to talk about linear.

22:47.000 --> 22:49.000
Linear is not part of Synergy.

22:49.000 --> 22:52.000
If any of you don't know about it, linear is a bug tracker.

22:52.000 --> 22:56.000
It's like a work tracking system we use for running our scrums and stuff.

22:56.000 --> 22:57.000
It's really, really good.

22:57.000 --> 22:59.000
I like it a lot, and I'll tell you all about it when you want.

22:59.000 --> 23:04.000
But what you do need to know is that linear, like a lot of web services, does webhooks.

23:04.000 --> 23:10.000
So you can say something happened to one of my issues, and a post gets sent to wherever you want,

23:10.000 --> 23:13.000
saying a thing happened to one of your issues, and you can respond.

23:13.000 --> 23:17.000
This is great for like, I track a calendar, right?

23:17.000 --> 23:21.000
And if somebody moves an event on the calendar, I get a post telling me this thing's been rescheduled.

23:21.000 --> 23:23.000
Consider whether your whole day has just been upended.

23:23.000 --> 23:25.000
Webhooks are great.

23:25.000 --> 23:28.000
And linear uses them, and we want to react to them.

23:28.000 --> 23:30.000
One of the things we use them for is escalation.

23:30.000 --> 23:36.000
Escalation inside a fast mail basically means a customer made a ticket, the support team who are great.

23:36.000 --> 23:38.000
They don't really know what's supposed to happen next.

23:38.000 --> 23:41.000
They escalate by taking the ticket and saying escalate it.

23:41.000 --> 23:44.000
They put a flag on it, and it goes to the developers.

23:44.000 --> 23:47.000
And when we do that, we want to do something like this, right?

23:47.000 --> 23:52.000
Make a message that just says, this issue got escalated by so and so, and here's the link.

23:52.000 --> 23:54.000
And we send it to the escalation address, right?

23:54.000 --> 23:57.000
Which is pound escalation and fast mail slack.

23:57.000 --> 23:59.000
And this is straightforward.

23:59.000 --> 24:04.000
I think if you've followed things so far, you follow this, except you might be wondering, where do you put this code?

24:04.000 --> 24:08.000
Right? Like, it's got to go someplace, so that's a good question.

24:08.000 --> 24:15.000
But you're not going to put it in a command, like uptime, because there's no command to say like, hey, check it, you got a webhook.

24:15.000 --> 24:17.000
That's not what a webhook's about.

24:17.000 --> 24:18.000
And it's not in a channel.

24:18.000 --> 24:24.000
Remember when I had to, like, tediously explain that channels are about chat messages, not just generic messages?

24:24.000 --> 24:25.000
So it's not in a channel.

24:25.000 --> 24:27.000
Where is this post going to go?

24:27.000 --> 24:30.000
The answer, the answer is it goes in a reactor.

24:30.000 --> 24:32.000
It doesn't need to be in a reactor.

24:32.000 --> 24:35.000
It's where we happen to have put it, but it's not because it's a reactor.

24:35.000 --> 24:39.000
It's because it's got this role called HTTP endpoint.

24:39.000 --> 24:45.000
And you say, in addition to reacting to chat messages, this thing is a web handler.

24:45.000 --> 24:50.000
And you say, I wanted to take the path linear notification.

24:50.000 --> 24:56.000
So when you connect this thing up, slash linear dash notification will now be a path that you handle.

24:56.000 --> 24:58.000
And how do you handle it?

24:58.000 --> 25:04.000
Well, you've got some async sub that is a plaque handler, because if you're writing web stuff in Perl, you probably want to do it with plaque.

25:04.000 --> 25:10.000
And that's kind of, I mean, look, there's a whole bunch of code here that's figuring out, like, getting the thing, authenticating it, figure out who's who.

25:10.000 --> 25:11.000
But this is basically it.

25:11.000 --> 25:19.000
You say this hunk of plug-in, and anybody can write a plug-in, requests a path for web service and mounts a plaque application on there.

25:20.000 --> 25:23.000
You know, and then at the end it says, like, yeah, and then return 200.

25:23.000 --> 25:25.000
So now this is HTTP endpoint.

25:25.000 --> 25:27.000
How does that work?

25:27.000 --> 25:28.000
Synergy runs a web server.

25:28.000 --> 25:42.000
And you say, I want web service to be provided on this port, and all of the channels, all the reactors, all the every other thing that has a HTTP endpoint, mounts onto those paths, conflicts are detected at start time and it crashes.

25:42.000 --> 25:48.000
And then when a request comes in, Synergy dispatches to the right place, and because they're all asynchronous, they can all interact.

25:48.000 --> 25:50.000
And that's a really important point, right?

25:50.000 --> 25:57.000
All of this whole diagram, this, all of the, every reactor, every channel, every HTTP endpoint, they're all in one process.

25:57.000 --> 26:00.000
It's just like one program that's running with everything loaded in it.

26:00.000 --> 26:03.000
And to share data, they share memory.

26:04.000 --> 26:07.000
There's no IPC, and this is a big win.

26:07.000 --> 26:17.000
Like, I don't want to say that IPC is bad, and IPC is the enemy, and I certainly don't want to say everybody should share memory.

26:17.000 --> 26:21.000
To share information, like these are big, broad claims.

26:21.000 --> 26:23.000
But we do have to talk about IPC sometimes.

26:23.000 --> 26:26.000
IPC solves problems, right?

26:26.000 --> 26:28.000
What does IPC mean by the way?

26:28.000 --> 26:31.000
It's inter-process communication that lets you have two processes talk to each other.

26:31.000 --> 26:36.000
But that's not the solution to a specific problem, right?

26:36.000 --> 26:38.000
That's not valuable per se.

26:38.000 --> 26:44.000
It's valuable because you have a problem that you could solve by having two processes talk to each other.

26:44.000 --> 26:49.000
And the question is, when does that problem arise, and when is IPC the right solution?

26:49.000 --> 26:57.000
Well, a good one is, right, if you have different parts of your system that scale differently, need different kinds of resources, need different access to things,

26:57.000 --> 26:59.000
maybe different processes are useful.

26:59.000 --> 27:01.000
You can scale up more workers, thank you.

27:01.000 --> 27:04.000
You can scale up more workers, you can scale down workers, that might be really useful.

27:04.000 --> 27:06.000
Maybe you have security constraints.

27:06.000 --> 27:13.000
This process needs access to certain constrained resources, needs to have these namespaces, needs to talk to the kernel, whatever.

27:13.000 --> 27:16.000
And this part of the program, the part of the system doesn't.

27:16.000 --> 27:18.000
That's a good reason to have two processes.

27:18.000 --> 27:22.000
And maybe you have to do work where multiple things need to be happening at once,

27:22.000 --> 27:28.000
and you have multiple processes to eliminate blocking, causing your code to be sequential when it's not going to be sequential.

27:28.000 --> 27:33.000
This is, you know, where we often would have multiple programs running or things forking.

27:33.000 --> 27:35.000
And it's fine.

27:35.000 --> 27:44.000
But remember that any time that we add a solution to a new problem to our program, we're almost always adding more code.

27:44.000 --> 27:50.000
And when we're adding more code, we're deforming the program from that ideal platonic version that we're like,

27:50.000 --> 27:52.000
well, if I could just write it, it would look like these eight lines.

27:52.000 --> 27:56.000
And then we go add all the code that solves all the problems we don't want to think about.

27:56.000 --> 28:05.000
And what we always want to be doing as programmers is picking the changes that deform our platonic program the least as possible.

28:05.000 --> 28:09.000
And program is always compromised between these things.

28:09.000 --> 28:16.000
Once upon a time, it was pretty clear, especially in languages like Perl, but kind of in a lot of programming,

28:16.000 --> 28:23.000
that if you had to eliminate blocking, the easiest, most effective thing to do was to go to have multiple processes, right?

28:23.000 --> 28:27.000
Fork is a great example. I need to be able to handle a lot of requests. I'm going to fork.

28:27.000 --> 28:29.000
Yeah, that makes sense. Forking's easy. It solves a lot of problems.

28:29.000 --> 28:32.000
And then later you have to introduce IPC because that's how life goes.

28:32.000 --> 28:34.000
But, you know, that's what you're going to do.

28:34.000 --> 28:36.000
I don't think it's this clear cut anymore.

28:36.000 --> 28:46.000
I think that at this point, we all need to be reevaluating when we want to eliminate blocking and have more communication between multiple kind of concurrent operations.

28:46.000 --> 28:51.000
Whether forking IPC is the answer to jump to in Perl anymore, I don't think it always is.

28:51.000 --> 28:55.000
I think it often is not the right answer anymore. And that's because of Asynchowate.

28:55.000 --> 29:02.000
Asynchowate's really, really powerful and it really moves the lever on where you should be picking which solutions.

29:02.000 --> 29:06.000
It's not just a Perl thing, by the way. Hopefully everybody here writes in other languages.

29:06.000 --> 29:09.000
Also, it's important to put your eggs in multiple baskets.

29:09.000 --> 29:12.000
You'll find this abstraction in a bunch of places. It's very good.

29:12.000 --> 29:15.000
Okay, one more thing. I've got a little time left.

29:15.000 --> 29:20.000
So, take a breath. Got quite a bit of time left, which is good.

29:21.000 --> 29:26.000
So, we've got channels and we've got reactors and we understand those.

29:26.000 --> 29:29.000
And we've got these HDP endpoints. And there's some other stuff we've gotten here.

29:29.000 --> 29:31.000
Maybe we'll even talk about more.

29:31.000 --> 29:37.000
But at some point, I thought, you know, it would be really cool to stick inside of Synergy a telnet server.

29:37.000 --> 29:41.000
So, we built a thing. It's not really telnet.

29:41.000 --> 29:45.000
Telnet's actually a protocol and has all kinds of weird stuff in it, like control characters.

29:45.000 --> 29:48.000
And don't learn. It's a netcat server.

29:48.000 --> 29:52.000
So, there's a netcat server built, they call these TCP streams.

29:52.000 --> 29:56.000
There's a netcat server built into Synergy, which is called the diagnostic uplink.

29:56.000 --> 30:06.000
So, here I am back at my terminal. I run my local development server with a diagnostic uplink available on local host 4321.

30:06.000 --> 30:11.000
Because I like those numbers. And when you tell it in, you get greeted with this.

30:11.000 --> 30:16.000
Welcome to Synergy. All right, you have connected to the diagnostic uplink. Would you like help?

30:16.000 --> 30:20.000
Of course I would. I don't know how to do anything. So, I say slash help. It's like, here you go.

30:20.000 --> 30:26.000
You've got some diagnostic commands. You've got notifier commands. Stuff for inspecting or running Synergy.

30:26.000 --> 30:33.000
Because when Synergy is acting, when your critical chat bot is sitting there and acting weird and you don't know why it's doing that,

30:33.000 --> 30:37.000
and you don't know what's happening, you know, you can reboot it. And that's fine. Thank you.

30:37.000 --> 30:42.000
You can, you hope that's going to be okay. You can, like, look at the logs.

30:42.000 --> 30:46.000
And I make a lot of logs. That might help, but most people don't write logs, and that's not going to help.

30:46.000 --> 30:51.000
But another great answer is, like, yeah, just connect to the thing and ask it questions. So, you can say, like, tell me about your configuration.

30:51.000 --> 30:58.000
I'm running a web service here. Here's this file. You can say, I don't show here, show me all the endpoints that your web service listens to,

30:58.000 --> 31:03.000
so I can see all those. You can say, show me all of the notifiers currently connected to the event loop.

31:03.000 --> 31:09.000
And it's going to show you, like, all these things are going on here. They get names as they're generated, so you can see things like,

31:09.000 --> 31:16.000
yeah, there's 47 open web requests all talking to GitLab. Well, that's probably a problem. Really useful.

31:16.000 --> 31:24.000
You can also get this guy. This is so good. Eval. So, you can say, I'm going to connect to the diagnostic uplink and instruct my

31:24.000 --> 31:32.000
Perl program to evaluate a string of Perl code in the context of the running bot. So, here I am saying, hey, bot, tell me your name.

31:32.000 --> 31:38.000
I'm Synergy. Great. What's your reference address and memory? Here you go. These are stupid examples.

31:38.000 --> 31:47.000
You never need to know the ref address of the bot. But you can do things like connect to the bot and instruct it to change its configuration as it runs.

31:47.000 --> 31:53.000
You can connect to the bot and add and remove reactors. You can do anything that you can do with Eval as long as you're happy typing it into one line

31:53.000 --> 32:03.000
because I have not implemented multi-line input. It wouldn't be that hard. I'm super lazy. Okay. That's everything I plan to talk about.

32:03.000 --> 32:07.000
We have a couple of minutes left. I'm happy to take questions. Yes.

32:07.000 --> 32:19.000
This might sound confrontational, but it is not. So, actually, it does. I'm going to make Elixir developer. The code you showed looks very much like how you would actually write an

32:20.000 --> 32:30.000
Erlang language. Yeah. So, why actually use her for use cases like this? No, it's a great question. The question is that it?

32:30.000 --> 32:38.000
Can I just say, well, I would say maybe the async stuff, like the tasks could be per, but actually the...

32:38.000 --> 32:46.000
The framework, yeah. No, it's a great question. The question is why do this in Perl when Erlang has a much better language for it or Elixir?

32:46.000 --> 32:53.000
I'm not to make you put any tone into that at all. That's the question. I think it's a good question. The answer is a boring answer.

32:53.000 --> 32:59.000
Well, the original version was written in Perl and all the little handlers were written in Perl. What was easy to do? Switch this to Perl.

32:59.000 --> 33:07.000
I also really like Erlang and I really like Elixir and I think that they're really well suited for this. In fact, in a lot of ways that we didn't talk about,

33:07.000 --> 33:14.000
like any one of those reactors crashing has to be handled by the hub saying like, oh, an exception happened. Don't worry, I'm going to catch it and recover.

33:14.000 --> 33:22.000
And like if a channel crashed, you have to figure out reinserting the new instance of the channel into the hub and what about its pending messages?

33:22.000 --> 33:30.000
That stuff's all solved, right, on B-machine languages. But we wrote it in Perl because we write Perl. And I think that if I had said,

33:30.000 --> 33:37.000
guess what everybody, we're rewriting the bot in one week and we're doing it with OTP. We would not have written that bot and nobody would have bought me a beer that night.

33:37.000 --> 33:39.000
Yes, in the back.

33:39.000 --> 33:52.000
It's hard that async await is much better than callback hell and also said that some of the loop is kind of callback hell put with upgrades.

33:52.000 --> 33:57.000
So can you expand a bit on how async await is better than callback hell?

33:57.000 --> 33:58.000
Yeah.

33:58.000 --> 34:04.000
And you mentioned that there may be some duplicates, a definite difference in debugging, but anything other than that?

34:04.000 --> 34:12.000
Yes, sure. So the question is how is it the case that using async await is practically better than callback hell?

34:12.000 --> 34:23.000
Larry Wall says that you can never eliminate the complexity in your program. You can only move it around, right? You can move around the lump under the carpet, but the dust is all still there.

34:23.000 --> 34:37.000
And my view is often that what you want to do is take the things that are complicated and obnoxious and pack them into an infinitely dense ball that lives at the center of your program.

34:37.000 --> 34:42.000
And everything else is beautiful and living on the outside. I got one minute, so this is maybe my final concluding remark.

34:42.000 --> 34:49.000
You want to put all the complexity deep, deep down in the middle and have everything else be simpler and built on that.

34:49.000 --> 34:54.000
Callback hell makes the programmer writing the application think about the complexity.

34:54.000 --> 35:00.000
And async await makes Paul think about the complexity. It makes one person cope with that.

35:00.000 --> 35:03.000
And I think that is why it's practically superior.

35:03.000 --> 35:09.000
Just curious how many in this room have endured future async await?

35:09.000 --> 35:14.000
Yeah, who else has used async await? Six, seven people? Yeah.

35:14.000 --> 35:21.000
It's very good. It's very good. It's got problems, but mostly they don't come up.

35:21.000 --> 35:23.000
And I use it every day because mostly they don't come up.

35:23.000 --> 35:30.000
Okay, if you want to run synergy, that's the URL. It's really good. Don't expect to get technical support.

35:30.000 --> 35:34.000
I'm going to change stuff whenever I feel like it. That's it. Thank you very much.

35:44.000 --> 35:46.000
Thank you.

