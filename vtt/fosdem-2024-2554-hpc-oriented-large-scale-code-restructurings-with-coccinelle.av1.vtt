WEBVTT

00:00.000 --> 00:14.880
Hello. This talk is about collaboration with Julia from India. Before this collaboration

00:14.880 --> 00:24.040
I was alone and I was left in a room with 100,000 lines of C code which had to remain

00:24.040 --> 00:32.480
C and had to be optimized somehow. How many of you here ever had such a situation? Perhaps

00:32.480 --> 00:39.120
somebody? One, two, three, perhaps more. Good. And usually, well, you understand that this

00:39.120 --> 00:44.760
was not my code, so I had to modify it. It was the code from people, from many people

00:44.760 --> 00:54.000
who worked in bars and produced code which had a lot of loops which do number crunching.

00:54.120 --> 01:04.000
Those loops have touch numerical quantities and actually had a kind of structure that

01:04.000 --> 01:13.880
you see here. You might recognize. So the layout, the data layout here is called array

01:13.880 --> 01:23.200
of structures. So who would say, oh, I have an optimization for this case from your mind.

01:23.200 --> 01:33.920
Which is this optimization? The most obvious one. So shout. Okay. It's my role to say it.

01:33.920 --> 01:43.320
Well, to change the layout into not, sorry, arrays of structures, but structures of arrays.

01:43.320 --> 01:47.760
So this is like a transposition but brings like an improvement in performance of, let's

01:47.840 --> 01:54.400
say, two, three, four, depending a bit on many conditions. So changing the layout of the code

01:54.400 --> 02:01.680
and also the expressions from what you see here to what you see here might have such a positive

02:01.680 --> 02:09.920
effect on performance. But how to do this if you have 100,000 lines of C code which has to stay C?

02:09.920 --> 02:17.360
Do you cobble together a few scripts? Yeah, why not? But perhaps you then come at some point

02:17.440 --> 02:24.720
whining that doesn't work. So you revert to, oh, you revert perhaps to using some high level

02:24.720 --> 02:32.240
transpiler. Yes, perhaps, but it's complicated. Well, I went that way. But I chosen another

02:32.240 --> 02:40.880
transpiler which is called coxinell. Coxinell has been written with the idea of matching, so finding

02:40.880 --> 02:48.800
bugs in the C code of the Linux kernel and erasing those bugs. But I found out that coxinell,

02:48.800 --> 02:55.920
I think, was also a good tool for factoring large amounts of C code, especially in manipulating

02:55.920 --> 03:05.680
expressions within statements. So expressions, once they are matched in statements, can be

03:06.560 --> 03:13.680
also changed. So coxinell has this pattern language that you see here, which is not in terms of

03:13.680 --> 03:23.280
patterns of text. Those patterns are in terms of the abstract syntax tree, which gets built on the

03:23.280 --> 03:31.760
top of syntactical elements of the C language, which are being, which is being parsed here. And

03:31.760 --> 03:39.200
those entities, the syntactical entities of the C language are of, you have control of them. So

03:40.000 --> 03:47.840
let's look at this key slide here. So we identify, match identifiers, tree identifiers, and we also

03:47.840 --> 03:55.760
give constraints. Like the first identifier Q, which can occur in the code, has to be, has to look

03:55.760 --> 04:02.880
like PRSR. The second one has to be P. The third one can be one of those two ones. So it's like

04:02.880 --> 04:08.000
you give constraints that has to be respected. And then the red line here, the minus line, which

04:08.000 --> 04:15.200
you see here, has to be found in the code. In the arbitrarily complex expressions or statements,

04:15.200 --> 04:25.040
such a form must be found. And once such a form is being found, only then such a change occurs. So

04:25.120 --> 04:32.160
you see this change? It's also expressed in terms of what has been already found. So you can be very

04:32.160 --> 04:39.440
precise if you want. And what you see here on the right panel is an entire program without, with

04:40.000 --> 04:47.120
one line changed from what you see here, red to what you see here, blue. So this is, of course,

04:47.760 --> 04:57.920
construed example to show you that this teeny rule here can syntactically go over your arbitrary

04:57.920 --> 05:06.080
large code and do really a lot of changes here. The complicated part comes if you want to be,

05:06.080 --> 05:15.200
if your code doesn't have regularities, so it's messy. But yeah, but if it's tidy enough, you can

05:15.200 --> 05:22.960
do a lot of things. And we're working on new HPC oriented features in coxinell in this system.

05:22.960 --> 05:33.200
So what does HPC revolves around nowadays? GPUs, modern C++ and modern OpenMP. So this is what

05:33.200 --> 05:39.200
we target. And these are three slides now I will be showing you just to give you a taste of some

05:39.200 --> 05:47.280
key elements we have been putting in the last times. So if you know the CUDA from NVIDIA, API or

05:47.280 --> 05:54.240
language extensions, then you will recognize that here we have some keywords, some the Chevron,

05:54.240 --> 06:01.120
kernel, call syntax, which we support. So this is not standard C or C++. We're supporting this. So

06:01.120 --> 06:08.400
we're putting this language support into the coxinell tool to allow you perhaps to change your

06:08.400 --> 06:13.840
existing code. So to write rules on your huge code, because if it would not be huge, you would

06:13.840 --> 06:18.640
be doing this by hand, right? But if it's huge, you want a tool for power, for the factoring. And

06:18.640 --> 06:25.600
this is what we want to provide you. To, yeah, to derive perhaps a CUDA kernel code from your CPU

06:25.600 --> 06:30.400
code. If you have in mind the regularities and the changes that you need, and you can express them

06:30.400 --> 06:40.160
with this language, I like C++ 23 introduces multi-index operators with square brackets, for

06:40.160 --> 06:48.080
instance. So this is now also possible if it's of use. It can be of use, for instance, with cocos

06:48.720 --> 06:54.880
heavily. So this can help you to transition perhaps to cocos if you really want. And just to, again,

06:54.880 --> 07:03.520
I want to, these are expressions and they act on statements. So you have to imagine that this can

07:03.520 --> 07:08.800
occur in arbitrarily nested statements. So complicated thing is like the one that you have seen at the

07:08.800 --> 07:18.160
beginning of the presentation. And it's up to you to create like chains of rules, which express the

07:18.160 --> 07:22.960
logical dependencies between the things which you want to match and the things which you want to

07:22.960 --> 07:29.760
introduce in the code. So if the code is messy, it will be more difficult. If your code is tidy enough,

07:29.760 --> 07:34.000
you can do extremely powerful things like also experiments with performance. Let's say, oh,

07:34.000 --> 07:39.760
what happens if I change in my entire code base from this style of arranging things, and this

07:39.760 --> 07:45.440
this style of arranging things. Then such experiments might be enabled here. And perhaps you don't,

07:45.520 --> 07:55.600
you're not perhaps obliged into using overly complicated APIs from portable, yeah, from some

07:55.600 --> 08:03.920
vendors. Yes. So, oh, sorry. One last example slide. You can even use coxinell to declutter code. So

08:03.920 --> 08:14.240
here we are removing hand unrolled code. So such a pattern recognizes, but I mean, I have written

08:14.720 --> 08:20.800
on purpose, recognize some hand unrolled code, removes it, and just introduce one pragma from

08:20.800 --> 08:27.600
openMP, which says, hey, unroll this. And this is a standardized pragma. So it's not like GCC,

08:27.600 --> 08:33.120
unroll, Intel, unroll. No. This is finally, since a couple of years, we have this pragma. So let's

08:33.120 --> 08:38.320
say, if you know how to declutter your code, you have rules in your head, you can implement them here,

08:38.320 --> 08:43.040
and have some formal, an informal method for restructuring your code. Good. So you know what

08:43.040 --> 08:49.840
we are doing lately. So we are developing further material and use cases, language support, some

08:49.840 --> 08:57.360
small things and large things. And yeah, that's it. So this work has been supported by the

08:57.360 --> 09:05.360
Gauss Supercomputing Center project, by a collaboration between Bavarian Germany and France.

09:06.320 --> 09:13.120
And if you are tough, you will go through this tutorial, which I created a few years ago.

09:16.080 --> 09:21.280
Yeah, and you can stay tuned with our developments with Coxinell, or you can also come to

09:21.280 --> 09:30.160
WÃ¼rzburg in one month to attend our short introductory tutorial into Coxinell. And if you

09:30.240 --> 09:34.080
want to read our six-page use case article, I really recommend it because

09:36.080 --> 09:41.760
it's more deductical than this 10-minute lightning talk. That's everything.

09:49.120 --> 09:56.320
Thank you very much, Michele. We have time for one question. JP in the back, again.

10:00.400 --> 10:06.160
Thank you so much. Hey, cool talk. Great, great thing. I love Coxinell. I have it right on the

10:06.160 --> 10:12.480
top of my list that I want to work with. The question is, can I express more constraints than

10:12.480 --> 10:20.880
just symbols and identifiers in these rules, like types or like lexical things? So what are the

10:20.880 --> 10:29.280
things that I can express in terms of this rule should only apply if? So for sure, context?

10:30.160 --> 10:38.560
So whatever you write as context, it gets matched. But if it comes to the rule part of those

10:38.560 --> 10:43.680
patches, which we have seen, the top part, you have seen identifier and something. Yeah, you have

10:43.680 --> 10:58.160
also type and other words for function parameters, for positions, for symbols. So there are a lot of

10:58.160 --> 11:05.920
them. And the important part is that the code is being parsed in the first place. Because once we

11:05.920 --> 11:15.360
support your language constructs, we parse your code, then you write a rule which can be, which

11:15.360 --> 11:22.000
is really the code which we have to match. So Coxinell is different parsers. It has different

11:22.000 --> 11:26.480
parsers. We parse your code first, we parse the root first, and then we look for a match.

11:28.720 --> 11:33.840
We are able to parse that. Any construct can be modified. This is the point. Any construct.

11:34.720 --> 11:39.520
So even within a template, you want to change something systematically. Yes.

11:40.480 --> 11:42.160
Okay, cool. Yes, thank you.

11:42.160 --> 11:50.880
Okay, we're doing

