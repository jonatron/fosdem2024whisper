WEBVTT

00:00.000 --> 00:07.000
So up next is 3.

00:07.000 --> 00:09.200
I hope that's reasonably correct.

00:09.200 --> 00:11.400
Yeah, that sounds right.

00:11.400 --> 00:14.560
Of linker thing, let's just say that.

00:14.560 --> 00:15.320
Yeah.

00:15.320 --> 00:17.680
Now talking about whether the mold linker can actually

00:17.680 --> 00:20.520
be used as a system linker.

00:20.520 --> 00:22.120
Yes.

00:22.120 --> 00:23.760
So thank you for coming to this talk.

00:23.760 --> 00:24.920
My name is Rui Uyama.

00:24.920 --> 00:31.440
So I'm the creator of the mold linker as well as the LLVM

00:31.440 --> 00:31.840
linker.

00:31.840 --> 00:35.800
So I wonder if you guys are using my linker.

00:35.800 --> 00:39.560
So raise your hand if you are using mold linker.

00:39.560 --> 00:42.640
And what about LLVD?

00:42.640 --> 00:45.920
OK, maybe almost everyone is using my linker.

00:45.920 --> 00:50.640
So it makes me very comfortable to be here.

00:51.520 --> 00:57.240
Anyways, so the mold linker is my latest attempt

00:57.240 --> 01:00.800
to create the best linker for developers.

01:00.800 --> 01:06.680
And that really matters because in most compilations

01:06.680 --> 01:09.800
and build times, linker dominates, especially

01:09.800 --> 01:14.400
if you are doing a quick edit, debug, compile cycle,

01:14.400 --> 01:18.200
because you edit a single file, build a thing.

01:18.240 --> 01:20.760
The compiler finishes pretty soon

01:20.760 --> 01:24.000
because it compiles just a single file.

01:24.000 --> 01:28.520
But the entire executables need to be built from scratch.

01:28.520 --> 01:30.280
So the link time matters.

01:30.280 --> 01:33.880
So I've been developing the mold linker since September 2020.

01:33.880 --> 01:39.160
So it's been almost three years under a little.

01:39.160 --> 01:41.640
So it's relatively new.

01:41.640 --> 01:44.440
So it's available under the MIT license now.

01:44.440 --> 01:47.480
It's been under a different license

01:47.480 --> 01:49.600
because I was trying to commercialize it.

01:49.600 --> 01:53.000
But it turns out that it didn't work out.

01:53.000 --> 01:57.400
So I decided to go with the published license.

01:57.400 --> 02:02.800
And the main purpose is to offer the fastest linker

02:02.800 --> 02:03.840
to that developer.

02:03.840 --> 02:07.280
So it's order of magnitude faster than the new linker.

02:07.280 --> 02:11.400
And it's also faster than my previous one, LLVD,

02:11.400 --> 02:14.400
as well as the new gold linker.

02:14.400 --> 02:19.200
So as a rough to give you an idea,

02:19.200 --> 02:22.440
the on a decent multi-core machine,

02:22.440 --> 02:26.240
mold can output one gigabyte output per second.

02:26.240 --> 02:28.320
So if your executable is two gigabytes,

02:28.320 --> 02:31.480
and then it takes two seconds on your machine.

02:31.480 --> 02:33.200
And that's pretty fast.

02:33.200 --> 02:37.040
But the modern executables are gigantic as well.

02:37.040 --> 02:41.280
So for example, if you build LLVM with debug info,

02:41.280 --> 02:45.600
the output would be like one and a half gigabyte.

02:45.600 --> 02:50.760
But it can be built in one and a half seconds.

02:50.760 --> 02:54.400
And the mold linker supports almost all major targets,

02:54.400 --> 02:55.200
except MIPS.

02:58.160 --> 03:01.360
And the reason is because MIPS, ABI,

03:01.360 --> 03:05.800
has diverged too much from the other ABI's.

03:05.800 --> 03:10.440
The fact is that the other ABI's have evolved

03:10.440 --> 03:12.120
since 2000.

03:12.120 --> 03:16.800
But the MIPS ABI has stagnated since the collapse of SGI,

03:16.800 --> 03:21.040
because SGI was a de facto player in that field

03:21.040 --> 03:22.200
to set the standard.

03:22.200 --> 03:25.280
And then no one has since then made any effort

03:25.280 --> 03:26.400
to improve the ABI.

03:26.400 --> 03:28.360
So MIPS has diverged.

03:28.360 --> 03:32.080
So at this point, I'm not sure if we want to work,

03:32.080 --> 03:34.400
continue working on MIPS support,

03:34.400 --> 03:38.160
because it seems like no one is really making

03:38.280 --> 03:42.800
a serious effort to refresh the architecture.

03:42.800 --> 03:45.800
But anyways, it supports a lot of architecture,

03:45.800 --> 03:50.800
even including long arch, which is a newcomer in this field.

03:50.960 --> 03:55.520
And despite being pretty new,

03:55.520 --> 03:58.280
I think that the linker is production ready.

03:58.280 --> 04:01.120
And I think that many people are actually using

04:01.120 --> 04:02.480
for production use.

04:03.600 --> 04:06.880
I will talk about that later,

04:07.200 --> 04:11.000
how I tested the linker.

04:13.480 --> 04:16.560
So from the developer's perspective,

04:16.560 --> 04:21.560
so this slide explains what is the model linker

04:22.160 --> 04:24.080
from the developer's perspective.

04:24.080 --> 04:26.400
So it's written in C++,

04:26.400 --> 04:30.440
specifically with C++ 20 features,

04:30.440 --> 04:34.400
and with Intel TVB as a 3D library.

04:34.400 --> 04:38.240
And the one thing that you would notice immediately

04:38.240 --> 04:40.680
if you take a look at the source code of model linker

04:40.680 --> 04:44.080
is that almost all functions and the data structures

04:44.080 --> 04:48.600
are templates rather than just plain functions or structures.

04:49.880 --> 04:54.160
And the templates are specialized for each target.

04:54.160 --> 04:58.240
So for example, if you,

04:58.240 --> 04:59.360
so we have,

05:00.360 --> 05:05.360
and the source code quality,

05:06.120 --> 05:08.600
and ideally have readable source code.

05:08.600 --> 05:13.600
So I put a lot of efforts to make it readable.

05:16.240 --> 05:21.240
So this is an example of how you write

05:22.080 --> 05:24.440
target specific code in mold.

05:24.440 --> 05:27.800
So it uses if constexpr in the source code.

05:27.800 --> 05:31.640
So if you are not familiar with C++ 20,

05:31.640 --> 05:34.360
this is a feature, this is a new feature.

05:34.360 --> 05:38.280
And the beauty of this feature is that

05:38.280 --> 05:42.440
if constexpr is evaluated at compile time

05:42.440 --> 05:43.920
rather than runtime,

05:43.920 --> 05:48.920
so this if constexpr expression will be compiled to nothing.

05:50.160 --> 05:55.160
If this function will not be specialized for PowerPC 64,

05:57.960 --> 05:58.800
V1.

05:58.800 --> 06:03.800
So if as long as you got your new code in this way,

06:05.320 --> 06:08.800
your new code cannot do anything harmful for other targets.

06:08.800 --> 06:11.120
And it cannot be,

06:11.120 --> 06:13.400
it cannot slow down other targets.

06:15.320 --> 06:20.320
So this is another example how we use C++ 20 feature in mold.

06:22.400 --> 06:26.920
So this is a data structure representing

06:26.920 --> 06:29.360
on this format of relocations.

06:31.760 --> 06:34.920
But there are many types of relocations

06:34.920 --> 06:37.760
because we at least have big Indian,

06:37.760 --> 06:40.840
little Indian 32 and a 64 bit version.

06:40.840 --> 06:44.640
So in combination we have already four different versions.

06:44.640 --> 06:49.080
And the beauty of C++ 20 is that you can use

06:49.080 --> 06:53.880
a require your crowds after the template keyword

06:53.880 --> 06:58.880
to specify what kind of type parameters

07:01.400 --> 07:03.520
that you wanna specialize for.

07:03.520 --> 07:04.720
So in this case,

07:04.720 --> 07:09.400
this data structure is specialized for middle Indian

07:09.400 --> 07:14.400
and real way of which is very technical stuff.

07:14.800 --> 07:17.040
But we have two different versions

07:17.040 --> 07:19.640
of relocation data structures.

07:19.640 --> 07:22.360
And below the definition,

07:22.360 --> 07:26.520
we have different versions of data structures

07:26.520 --> 07:27.440
of the same name.

07:29.360 --> 07:32.520
And we even have completely different version

07:32.520 --> 07:37.520
of data structure for specifically for Spark 64.

07:38.360 --> 07:43.360
Because Spark 64 has this weird field

07:43.840 --> 07:47.520
that doesn't exist in any other architecture.

07:47.520 --> 07:51.240
So, but we can just define

07:52.480 --> 07:56.880
this data structure only for Spark 64.

07:56.880 --> 08:00.920
And as long as you guard G code

08:00.920 --> 08:04.600
that access this field with if course expert,

08:04.600 --> 08:07.440
then your code will not be

08:09.720 --> 08:12.020
cause GM, you know,

08:12.020 --> 08:16.080
you are using the missing field of the data structure.

08:16.080 --> 08:20.080
So this is a very beautiful way to compile

08:21.080 --> 08:23.920
your code to a specific target.

08:31.680 --> 08:32.520
So,

08:40.880 --> 08:41.960
it's not loading.

08:44.800 --> 08:47.720
Okay, so this is a machine description

08:47.720 --> 08:52.400
of the of G some specific target.

08:52.400 --> 08:57.000
In this case, it's a machine description for x86 64.

08:57.000 --> 09:02.000
So we have bunch of constexpr static variables

09:04.480 --> 09:05.640
as a parameter.

09:05.640 --> 09:07.720
And it defines, you know,

09:07.720 --> 09:10.640
that whether it's a middle Indian architecture

09:10.640 --> 09:15.200
or big Indian architecture or it's 32 bit or 64 bit.

09:15.200 --> 09:18.000
And basically you,

09:18.880 --> 09:21.800
so if you wanna put the mold link

09:21.800 --> 09:24.120
to new target,

09:24.120 --> 09:26.600
then you define this kind of data structure

09:26.600 --> 09:28.560
where basically copy and paste.

09:30.000 --> 09:34.040
And then make the modification as you needed.

09:34.040 --> 09:36.960
And then it's just as simple as that.

09:38.280 --> 09:43.280
And since this is G's fields are compile time constant

09:46.200 --> 09:49.200
so the compiler knows what the value is

09:49.200 --> 09:53.360
at the compile time so they can optimize code

09:53.360 --> 09:56.080
based on these values instead of,

09:56.080 --> 09:58.080
you know, that dispatching at runtime.

10:01.840 --> 10:06.840
So this is a comparison of the number of lines

10:08.760 --> 10:12.200
that you need to put more linker to the new target.

10:12.320 --> 10:15.640
So on the left hand side, we have code.

10:17.640 --> 10:22.640
So it is not a really precise comparison

10:22.760 --> 10:26.480
because lines of code is not a direct indicator

10:26.480 --> 10:31.480
about how easy or how hard it is to put linker

10:31.480 --> 10:32.280
to the new target.

10:32.280 --> 10:36.560
But it gives you enough idea about the scale of you,

10:37.520 --> 10:40.080
about the amount of work that you have to do.

10:40.080 --> 10:45.080
So apparently for gold,

10:45.680 --> 10:48.720
you have to write tens of thousands of lines of code

10:48.720 --> 10:50.520
for each target.

10:51.960 --> 10:56.960
But the reality is most code in the target specific code

10:58.880 --> 11:01.280
for gold are just a copy paste.

11:01.280 --> 11:06.280
So for example, if you wanna put new gold to like spark

11:07.120 --> 11:09.800
or long arch or whatever,

11:09.800 --> 11:14.440
then you would start copying the entire file

11:14.440 --> 11:17.280
as long arch dot cc or whatever

11:17.280 --> 11:18.840
and then it make the modification.

11:18.840 --> 11:22.080
So you have a lot of copies of code

11:22.080 --> 11:25.760
and that's not a really good way to, you know,

11:25.760 --> 11:28.320
put that thing to the new code.

11:28.320 --> 11:32.960
And on the other hand, we have very little code in mode

11:32.960 --> 11:35.320
to put to the new architecture.

11:35.320 --> 11:40.320
So we have a few, we have some amount of code

11:40.840 --> 11:45.840
outside of these files for target specific architect code

11:45.840 --> 11:50.640
but overall the amount of code is very, very small,

11:50.640 --> 11:53.360
like only a few hundred lines of code.

11:57.040 --> 11:59.840
So testing, testing is the most important

11:59.840 --> 12:01.880
and the difficult part of writing the linker

12:01.880 --> 12:05.240
because as you know that if you write a simple linker

12:05.240 --> 12:09.000
it's not really hard because it's just a program

12:09.000 --> 12:11.280
that takes object files and combines them

12:11.280 --> 12:15.440
into a single executable or shared object file.

12:15.440 --> 12:20.440
But the thing is there are so many edge cases

12:20.600 --> 12:24.600
and because there are like hundreds of thousands

12:24.600 --> 12:26.440
of programs that uses the linker,

12:26.440 --> 12:28.640
essentially every program uses the linker.

12:28.640 --> 12:31.680
So every corner case will be,

12:32.600 --> 12:37.240
there is some use case of corner cases out there.

12:37.240 --> 12:39.240
So testing is very hard.

12:39.240 --> 12:42.120
So we have two tests of how to say the mode

12:42.120 --> 12:47.120
to ensure that you, I will be finding a bug

12:47.120 --> 12:51.140
before you will notice in the production use case.

12:51.140 --> 12:55.200
So the first test is shell script based test

12:55.200 --> 12:57.080
which is a very simple test.

12:57.080 --> 12:59.640
I have a slide, slide for this.

12:59.680 --> 13:04.680
So this is just a test case for the very simple test case.

13:06.480 --> 13:11.200
So we actually compile code and try to link

13:11.200 --> 13:13.840
the object file with mode

13:13.840 --> 13:17.080
and then actually execute it on the machine.

13:17.080 --> 13:20.680
And as you can see that if you have a cross compiler

13:20.680 --> 13:25.680
and the QMU, you can test that this test

13:25.680 --> 13:29.040
for other architecture that's different from the one

13:29.040 --> 13:31.320
that you are running on.

13:31.320 --> 13:36.320
So for example, you can test Spark 64 on x86 machine.

13:36.560 --> 13:40.920
But apparently this test is not enough

13:40.920 --> 13:44.120
for real use cases, right?

13:44.120 --> 13:47.320
So the other test that I was doing,

13:47.320 --> 13:52.320
I'm doing is to try to build all gentry packages

13:52.520 --> 13:57.520
in a business mode in a Docker container to find any bugs.

13:57.760 --> 14:02.160
And the beauty of using gentry is that with gentry,

14:03.080 --> 14:07.080
you can use the exact same command to build any package.

14:07.080 --> 14:10.000
And it can also run the unit test

14:10.000 --> 14:11.720
that comes with the package.

14:11.720 --> 14:15.160
So it's very easy to wait to test

14:15.160 --> 14:16.840
whether you can build the program

14:16.840 --> 14:19.600
and the build program will work or not.

14:19.600 --> 14:23.360
So I did that and it takes a few days

14:23.360 --> 14:26.760
on the 6C4 core machine.

14:26.760 --> 14:27.960
But it works.

14:27.960 --> 14:32.400
But the thing is it is sometimes extremely hard

14:32.400 --> 14:37.400
to debug the stuff when something goes wrong.

14:37.400 --> 14:41.920
But somehow I managed to fix all bugs

14:41.920 --> 14:43.440
that I found this way.

14:45.360 --> 14:50.360
Well, yeah, it was a fantastic experience

14:50.880 --> 14:52.960
to fix all the jits bugs.

14:52.960 --> 14:56.920
But my point is that it is very important

14:56.920 --> 15:01.520
to fix all bugs before you would notice in the world.

15:01.520 --> 15:06.520
Because if mold didn't work out of the box

15:08.120 --> 15:11.080
for your project, the next thing you would do

15:11.080 --> 15:13.120
is just switch back to the original linker

15:13.120 --> 15:18.120
and you will never try it again with the mold linker, right?

15:18.240 --> 15:23.240
So why mold is so fast?

15:23.400 --> 15:26.960
Well, so we use multiseletting,

15:26.960 --> 15:31.920
multiselet parallelization from the beginning.

15:31.920 --> 15:36.920
So that's essentially why mold is so fast.

15:37.720 --> 15:40.840
But the other thing is that mold is simply faster

15:40.840 --> 15:44.080
than the other linkers with single-slated case

15:44.080 --> 15:49.080
is sometimes because we are using optimized

15:49.080 --> 15:50.760
data structures and code.

15:50.760 --> 15:54.360
Actually, the data structure is more important than code.

15:54.360 --> 15:58.120
As Rob Pike once said that you would write code

15:58.120 --> 16:00.400
around data structures and not to other ways.

16:00.400 --> 16:03.160
So designing the right data structure

16:03.160 --> 16:06.920
is important to make faster program.

16:08.080 --> 16:12.520
So here is, I think, a good visualization

16:12.520 --> 16:17.520
of how good mold linker is to use multi-core

16:18.200 --> 16:20.640
all-G cores available on the machine.

16:20.640 --> 16:24.600
So on the left-hand side,

16:24.600 --> 16:28.480
LLD fails to use all-G cores,

16:28.480 --> 16:32.980
but the mold finishes very quickly with all-G cores.

16:34.640 --> 16:39.440
So why, but the question is,

16:39.440 --> 16:44.440
would be why do we want another linker

16:44.960 --> 16:48.600
even though we have LLD?

16:48.600 --> 16:53.600
So my answer is, so LLD is not known, first of all.

16:54.920 --> 16:57.640
And the other thing is that LLD does not stop

16:57.640 --> 16:59.400
or support GCC LTO.

16:59.400 --> 17:03.000
So LLD is actually tightly coupled

17:03.000 --> 17:05.480
to a specific version of LLVM.

17:05.480 --> 17:09.760
So LLD, for example, version 15 can do LTO

17:09.760 --> 17:12.800
only for LLVM 15.

17:12.800 --> 17:17.480
So it of course cannot handle any GCC LTO object files.

17:17.480 --> 17:20.680
So if you wanna do LTO with no faster linker,

17:20.680 --> 17:23.480
then mold is the only viable option.

17:24.680 --> 17:27.640
So what about Gnu Gold?

17:27.640 --> 17:29.640
I think the problem with Gnu Gold

17:29.640 --> 17:31.760
is the lack of clear ownership.

17:31.760 --> 17:36.760
So it looks like it's not really maintained well anymore.

17:36.760 --> 17:41.760
And the original creator of Gnu Gold, which is Google,

17:42.160 --> 17:45.480
has lost the interest of keep maintaining it

17:45.480 --> 17:48.880
because they are now switched to LLD.

17:48.880 --> 17:52.960
So I think the future of Gnu Gold is not clear.

17:52.960 --> 17:57.960
So and the gold is not as fast as my linker too.

17:58.800 --> 18:03.800
So can we improve Gnu LLD

18:04.840 --> 18:08.680
so that Gnu LLD gets as fast as my linker?

18:08.680 --> 18:09.880
My answer is no.

18:10.800 --> 18:12.720
I think that it's almost impossible

18:12.720 --> 18:14.680
to make the thing faster

18:14.680 --> 18:16.720
unless you rewrite everything from scratch.

18:16.720 --> 18:19.360
And if you rewrite from scratch,

18:19.360 --> 18:21.360
that would be the same thing as I did.

18:21.360 --> 18:25.400
So and in my opinion, the source code of Gnu LLD

18:25.400 --> 18:28.600
is not very easy to read.

18:28.600 --> 18:33.600
It's like the source code was written more than 30 years ago

18:33.960 --> 18:35.560
and it's been maintained since then.

18:38.120 --> 18:43.120
But people are still adding new features to Gnu LLD first

18:43.560 --> 18:46.520
and then put to other linkers

18:46.520 --> 18:50.520
because what they are actually using is the other linkers.

18:50.520 --> 18:55.520
But I think that the situation is silly

18:56.160 --> 18:59.560
because people do not really use Gnu LLD anymore

18:59.560 --> 19:01.720
for their real world project.

19:01.720 --> 19:04.880
So I think that it needs changing.

19:04.880 --> 19:09.880
And my question is do we wanna stay with Gnu LLD,

19:10.880 --> 19:13.040
the current Gnu LLD forever?

19:13.040 --> 19:16.240
My answer would be I don't think so

19:17.360 --> 19:19.680
since we have a good replacement.

19:19.680 --> 19:24.680
So if I can, I'm open to donate more to Gnu project

19:29.480 --> 19:31.400
so that we can call it a Gnu mold

19:31.400 --> 19:34.720
if that accelerates that option.

19:34.720 --> 19:36.680
It's not something that I can only decide

19:36.680 --> 19:40.840
but because it means a lot

19:40.840 --> 19:45.560
but I'm open to that option if it makes sense.

19:46.560 --> 19:51.560
So the death missing piece to use mold as the standard linker

19:53.440 --> 19:58.240
is the kernels and the embedded programming support.

19:58.240 --> 20:01.120
So user and the programs are mostly fine.

20:01.120 --> 20:05.680
Well, if you install more as a system linker

20:05.680 --> 20:09.800
you wouldn't notice any difference other than speed.

20:09.800 --> 20:13.440
But the kernels and the embedded programs needs

20:13.480 --> 20:16.480
more special care about memory layout

20:16.480 --> 20:20.280
because hardware for example,

20:20.280 --> 20:22.760
enforces you to put some data structure

20:22.760 --> 20:27.480
or code at a very specific location of the memory.

20:27.480 --> 20:32.400
And if you are programming against MMU this computer

20:32.400 --> 20:37.400
then you wanna layer as the hardware memory is.

20:38.400 --> 20:43.320
So that kind of stuff is usually handled

20:44.200 --> 20:45.360
by linker script as you know.

20:45.360 --> 20:49.200
But the linker script in my opinion has many issues.

20:49.200 --> 20:52.360
The first thing is that it doesn't have any

20:52.360 --> 20:54.680
formal specification of the language.

20:54.680 --> 20:58.680
It only has the manual and we implement to,

20:59.680 --> 21:02.160
so other linkers are trying to mimic the behavior

21:02.160 --> 21:07.160
of Gnu LD but it of course causes compatibility issues.

21:08.480 --> 21:11.600
And the other thing is that the linker script

21:11.600 --> 21:14.160
predates elf file format.

21:14.160 --> 21:18.200
So not all linker script command can translate

21:18.200 --> 21:20.720
directly to elf terminology

21:20.720 --> 21:24.600
and it causes more confusion than necessary.

21:24.600 --> 21:28.880
So, and I think that it is almost impossible

21:28.880 --> 21:31.360
to add a linker script support

21:31.360 --> 21:33.840
without slowing down the linker.

21:33.840 --> 21:36.720
So I think that we need something better.

21:37.720 --> 21:41.320
So this is my current approach to support

21:41.320 --> 21:43.960
embedded programming and counter support.

21:43.960 --> 21:47.280
So I added a very simple command line option

21:47.280 --> 21:49.760
which is called section order.

21:49.760 --> 21:54.760
And that specifies them how to layer the things.

21:55.640 --> 21:59.600
So, and I think that this option alone can satisfy

21:59.600 --> 22:02.120
like more than 90% of the usage

22:02.120 --> 22:04.440
but I'm pretty sure that that doesn't cover

22:04.480 --> 22:07.880
all the usage of linker script.

22:07.880 --> 22:11.040
So I need a help from you guys.

22:11.040 --> 22:16.040
So because especially in embedded programming world,

22:16.680 --> 22:20.000
their programs are not open source

22:20.000 --> 22:22.600
and they are not available on GitHub

22:22.600 --> 22:25.240
and they tend to be in house program.

22:25.240 --> 22:30.240
So I don't know what the real usage is for embedded programs.

22:30.880 --> 22:33.920
If you can tell me that I wanna do this

22:34.280 --> 22:36.680
with the mold linker, then I can implement that for you.

22:36.680 --> 22:41.440
So I would appreciate it if you give me a hint.

22:43.480 --> 22:44.600
All right.

22:44.600 --> 22:47.320
So this is the end of my slides.

22:47.320 --> 22:48.760
Thank you very much.

22:48.760 --> 23:10.760
So you mentioned that it's possible to do link time optimization, like as a feedback

23:10.760 --> 23:16.760
in the GCC, but in general, is it also possible, how easy is it to do link time optimization

23:16.760 --> 23:21.760
inside the linker, like is it possible for the linker to disassemble some instruction

23:21.760 --> 23:25.760
and try to put something else there?

23:25.760 --> 23:35.760
Okay, so the question is how easy it is to do something like link time optimization

23:35.760 --> 23:45.760
but not quite there. So I don't know if I correctly understand your question, but it's...

23:45.760 --> 23:48.760
It's basically optimizations during the linking.

23:48.760 --> 23:50.760
Yeah, of course, but the thing is...

23:50.760 --> 23:55.760
It's not by the compiler, it's all LTO, but it's not by the compiler.

23:55.760 --> 24:00.760
So the way how LTO works in the linker is compiler emits.

24:00.760 --> 24:08.760
So from the user's perspective, all you have to do is to add hyphen FLTO to the command line option

24:08.760 --> 24:12.760
to compiler and the linker, and everything works automatically.

24:12.760 --> 24:21.760
But behind the scenes, the compiler emits intermediate code instead of the actual machine code to the object file,

24:21.760 --> 24:25.760
and then the linker recognizes that intermediate code.

24:25.760 --> 24:36.760
And then it calls the compiler back end to compile all things once to the single object file,

24:36.760 --> 24:44.760
and then the link continues as if that gigantic single object file were passed to the linker.

24:44.760 --> 24:52.760
So in that sense, you can do anything with the intermediate file inside the compiler back end

24:52.760 --> 24:58.760
because the linker doesn't really care what is going on behind the scenes.

24:58.760 --> 25:04.760
So, well, does that answer your question?

25:04.760 --> 25:13.760
Yeah, so you said that you tested more against being all of the factors in gender Linux.

25:13.760 --> 25:16.760
How long did that take? How long does one count take?

25:16.760 --> 25:23.760
So how does it take to test all gender packages against more the linker?

25:23.760 --> 25:31.760
And it takes, if I remember correctly, three, four days on my 64-core machines,

25:31.760 --> 25:39.760
64-core machine with 200 gigabytes, 256 gigabytes memory.

25:39.760 --> 25:47.760
And yeah, it's a very long time, but it's definitely doable on a beefy single machine.

25:47.760 --> 25:49.760
One target?

25:49.760 --> 25:59.760
Only for x86-64 because in order to cross-compile everything to different architectures and run-g test,

25:59.760 --> 26:08.760
you have to do that on QMU, which slows down like 100 times than the real performance on the computer.

26:08.760 --> 26:11.760
Yeah.

26:11.760 --> 26:13.760
Yeah, I can't.

26:13.760 --> 26:15.760
Yeah, sorry.

26:15.760 --> 26:19.760
What kind of mistakes did you make in LLD that you're fixing in mode?

26:19.760 --> 26:23.760
And are there any mistakes in mode that you think are interesting?

26:23.760 --> 26:32.760
So the question is what mistakes did I do in LLD that I fixed in LLD?

26:32.760 --> 26:36.760
And did I make any other mistakes in mode?

26:36.760 --> 26:38.760
That's a good question.

26:38.760 --> 26:45.760
The first thing is the relocation processing in LLD wasn't as good as mode.

26:45.760 --> 26:47.760
So it's complicated.

26:47.760 --> 26:51.760
It's hard to maintain, and it's slower than mode.

26:51.760 --> 26:53.760
So I fixed it.

26:53.760 --> 27:00.760
And the other thing is that LLD uses templates to support L6432, big-endian, little-endian,

27:00.760 --> 27:04.760
but it's just four instances.

27:04.760 --> 27:07.760
So it doesn't instantiate for each target.

27:07.760 --> 27:15.760
So you cannot use the technique that I used for Spark 6c4, that I showed you on the slide, for example.

27:15.760 --> 27:19.760
And did I make any mistake in mode?

27:19.760 --> 27:22.760
Maybe not.

27:22.760 --> 27:25.760
I am pretty satisfied with the quality of mode.

27:25.760 --> 27:29.760
I think that I really made...

27:30.760 --> 27:34.760
I'm personally enthusiastic about the code of the readability.

27:34.760 --> 27:40.760
So I tried to make the source code as readable as just like a book.

27:40.760 --> 27:50.760
And I don't know if I could achieve that goal, but the point is that, well, yeah, it's definitely readable.

27:50.760 --> 27:53.760
One last question.

27:54.760 --> 27:59.760
Are there any plans to ever support any order of that file that helps?

27:59.760 --> 28:06.760
Oh, so the question is, can you support other file formats?

28:06.760 --> 28:09.760
No, I'm planning to ever do that.

28:09.760 --> 28:13.760
Oh, do I have an plan to support other than LLD?

28:13.760 --> 28:21.760
Well, I did for macOS, which is a Unix-like environment,

28:21.760 --> 28:25.760
but it uses a different file format, which is called macOS.

28:25.760 --> 28:31.760
Yeah, but the thing is, and I succeeded to create a faster linker for macOS,

28:31.760 --> 28:34.760
which is much, much faster than the upload linker.

28:34.760 --> 28:43.760
But the thing is, last year in September, they released Xcode 14 with their own new linker.

28:43.760 --> 28:49.760
So there wasn't going on efforts within Apple that I wasn't aware of.

28:49.760 --> 28:52.760
And then their new linker is as fast as mine.

28:52.760 --> 28:58.760
Maybe they wrote my source code as well, because it's available online.

28:58.760 --> 29:02.760
But also, GTIB3, then?

29:02.760 --> 29:06.760
Oh, my linker is now available under the GMIT license.

29:06.760 --> 29:08.760
So it's, yeah.

29:08.760 --> 29:11.760
So maybe you only heard Apple.

29:11.760 --> 29:15.760
Well, Apple haven't released their source code yet.

29:15.760 --> 29:18.760
So, okay, we have to stop.

29:18.760 --> 29:20.760
So thank you again.

