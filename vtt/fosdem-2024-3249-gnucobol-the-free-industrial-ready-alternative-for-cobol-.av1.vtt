WEBVTT

00:00.000 --> 00:14.680
So next we have Fabrice Le Faison and Simon Saubich with GNU Coble, the free software

00:14.680 --> 00:19.560
alternative for Coble.

00:19.560 --> 00:22.120
Thanks for the introduction.

00:22.120 --> 00:28.440
So if you need to just remember one thing from this talk, is that GNU Coble has now

00:28.440 --> 00:32.920
20 years and is ready for industrial use.

00:32.920 --> 00:39.920
He has reached industrial maturity and can compete with the proprietary offers that are

00:39.920 --> 00:43.240
also available.

00:43.240 --> 00:44.880
So let's introduce ourselves.

00:44.880 --> 00:46.120
I am Fabrice Le Faison.

00:46.120 --> 00:48.960
I am the founder of a company called OCamel Pro.

00:48.960 --> 00:54.960
I have been a researcher at INRIA before and I've been in the open source ecosystem for

00:54.960 --> 00:56.280
a long time.

00:56.280 --> 01:01.840
And now I am contributing to GNU Coble since two years ago.

01:01.840 --> 01:09.200
And Simon Saubich is a former, still a Coble developer.

01:09.200 --> 01:12.160
He has been since 2006.

01:12.160 --> 01:17.000
He has been a contributor to Open Coble since 2008.

01:17.000 --> 01:23.800
And now he is the project leader of the GNU Coble project.

01:23.800 --> 01:26.800
So what is Coble?

01:26.800 --> 01:33.920
If you haven't seen a Coble program before, here is a very simple one, Hello World program.

01:33.920 --> 01:37.400
So as you can see, there are three divisions.

01:37.400 --> 01:45.280
One for the identification of the program, then a division for all the storage, so the

01:45.280 --> 01:48.840
global variables and file descriptors and so on.

01:48.840 --> 01:55.560
Here you just have one variable, which is a string of 80 characters with Hello World

01:55.560 --> 01:56.760
inside.

01:56.760 --> 02:01.440
And then you have a procedure division where you have all the statements.

02:01.440 --> 02:05.520
And here you just have one that displays the variable.

02:05.520 --> 02:09.680
So you have seen your first Coble program for a lot of years.

02:09.680 --> 02:13.880
So Coble was born in 1959.

02:13.880 --> 02:21.680
It's a business-oriented language, so it's dedicated just for business.

02:21.680 --> 02:23.640
It's not a generic language.

02:23.640 --> 02:27.040
But he's still evolving almost every 10 years.

02:27.040 --> 02:30.080
There is a new ISO standard.

02:30.080 --> 02:35.720
The last one is from last year in January.

02:35.720 --> 02:39.160
So why Coble matters?

02:39.160 --> 02:43.640
Surprisingly, it's still used in many big corporations.

02:43.640 --> 02:49.640
There are estimates that there are about 80 billion lines of code in the world.

02:49.640 --> 02:53.400
And it's more than for any other language.

02:53.400 --> 03:00.680
It's growing at a rate of between 5% and 15% every year.

03:00.680 --> 03:07.040
And for a lot of corporations, it's just too big to switch to another language.

03:07.040 --> 03:13.000
And another reason why they don't switch is that it's still fast and reliable.

03:13.000 --> 03:16.840
Maybe I can...

03:16.840 --> 03:19.720
So half of me again.

03:19.720 --> 03:24.280
As you have noticed a little bit, it seems to be important because otherwise we don't

03:24.280 --> 03:27.240
have a programming language for this long time.

03:27.480 --> 03:30.600
And as you may have heard, Coble is dead.

03:30.600 --> 03:34.760
I think about every 5 years it's dead and it's still alive.

03:34.760 --> 03:40.320
And it's likely to stay very long because of all this code and all the important thing

03:40.320 --> 03:41.320
it does.

03:41.320 --> 03:46.320
So it's the common saying that if you do use something with your ATM card without knowing

03:46.320 --> 03:52.560
that's not Java, mostly down that's very likely a lot of things that happens in Coble.

03:52.560 --> 03:57.120
So you use Coble with all the money you do every day.

03:57.160 --> 04:06.680
Also your insurances, your car, renting system, things like those run on maybe on mainframes,

04:06.680 --> 04:09.040
maybe on PC, but on Coble.

04:09.040 --> 04:12.200
So if we have this situation, it's an important thing.

04:12.200 --> 04:18.640
It's obviously a bad thing that only proprietary products exist that can execute it because

04:18.640 --> 04:26.000
you cannot reproduce it yourself, neither the big nor the slow ones.

04:26.000 --> 04:31.280
And you can not easily learn it because, yeah, buy a license for some 1000 euros, that's

04:31.280 --> 04:32.560
not really nice.

04:32.560 --> 04:36.400
It also doesn't help to really develop the language.

04:36.400 --> 04:39.280
And we have some proprietary environments.

04:39.280 --> 04:46.000
Very special is IBM with its mainframe because in this case the Coble is very hard bundled

04:46.000 --> 04:49.160
to the hardware and the hardware to the Coble.

04:49.160 --> 04:51.120
So it's very fast.

04:51.120 --> 04:57.400
And we have the PC system with actually a lot of environments, but nearly all were

04:57.400 --> 05:00.160
brought by Micro Focus.

05:00.160 --> 05:05.080
And Micro Focus now was bought itself two times, but that's a different question.

05:05.080 --> 05:06.720
And there's Fujitsu.

05:06.720 --> 05:12.640
And as you may see there aren't even any big European players in this.

05:12.640 --> 05:18.000
So that's another reason that it's good to have free software because free software doesn't

05:18.000 --> 05:21.040
have border and special regulations.

05:21.040 --> 05:23.160
There are open source projects.

05:23.160 --> 05:26.160
Previously there was OpenCoble.

05:26.160 --> 05:32.160
This was now several years ago translated to a GNU project.

05:32.160 --> 05:35.440
So we are actually GNU.

05:35.440 --> 05:37.400
There's Open Source Coble.

05:37.400 --> 05:44.680
They've also kind of forked from OpenCoble, made special for the Japan market.

05:44.680 --> 05:47.840
And those were then later translated to Java.

05:47.840 --> 05:50.520
So there's a Java option too.

05:50.520 --> 05:53.520
There's a newcomer, this GCoble.

05:53.520 --> 05:56.760
If you don't know there's GCC, Developer Room.

05:56.760 --> 06:04.000
One talk will also be about that, how hard it is to pass Coble because Coble is so big.

06:04.000 --> 06:06.520
And then another one is AutoKit.

06:06.520 --> 06:07.920
It's a compiler to .NET.

06:07.920 --> 06:13.640
It's very early in its stage.

06:13.640 --> 06:19.800
So GNU Coble as I said was created long time ago, also long time before I get in.

06:19.800 --> 06:26.720
It actually has roots in TinyCoble but was nearly rewritten to get OpenCoble.

06:26.720 --> 06:32.680
We have two active branches, the one that is easily available for you all.

06:32.680 --> 06:37.440
If you just do app install GNU Coble, jump, add, whatever.

06:37.440 --> 06:41.120
So your normal package manager likely has GNU Coble available.

06:41.120 --> 06:44.160
You just can install it with a glance.

06:44.160 --> 06:46.240
That's the branch GNU Coble 3.

06:46.240 --> 06:51.520
The shiny new thing will be GNU Coble 4.

06:51.520 --> 06:54.840
So this would be building there self.

06:54.840 --> 07:08.720
We have a bit of numbers but you can get it on your own.

07:08.720 --> 07:10.880
So what's the benefit of GNU Coble?

07:10.880 --> 07:14.800
GNU Coble does internally generate C code.

07:14.800 --> 07:16.160
So the C code is quite portable.

07:16.160 --> 07:20.400
You can run it on your Pi, you can run it on your main frame and everything below.

07:20.400 --> 07:23.720
I of course have it on my mobile phone.

07:23.720 --> 07:25.320
So no problem there.

07:25.320 --> 07:29.920
The generated modules are really C89.

07:29.920 --> 07:31.800
So you can run it everywhere.

07:31.800 --> 07:37.600
The runtime library is C89 and uses some new features if they are available.

07:37.600 --> 07:42.380
So on most systems you will have a current environment.

07:42.380 --> 07:44.440
We pass the standard test.

07:44.440 --> 07:47.000
There's a national standard test for it.

07:47.000 --> 07:48.000
97%.

07:48.000 --> 07:55.880
Actually, if you compare with the proprietary, they don't pass 97% but less.

07:55.880 --> 07:59.760
We don't have support for object-orientated Coble.

07:59.760 --> 08:06.520
That's a nice feature from Coble 22 which isn't used that much actually in the production

08:06.520 --> 08:08.640
because you have the old code.

08:08.640 --> 08:10.040
And messages.

08:10.040 --> 08:15.280
This was a very old thing and now gets back in Coble 23.

08:15.280 --> 08:23.720
There's a new messaging system which you can think of, MQ, Rabbit or things like that.

08:23.720 --> 08:25.800
We have a lot of dialects.

08:25.800 --> 08:28.880
And so Micro Focus has one or two.

08:28.880 --> 08:31.780
IBM has its own and we have 19.

08:31.780 --> 08:38.600
So it's relatively easily to transfer from one Coble to GNU Coble, three year Coble,

08:38.600 --> 08:41.200
three year computing.

08:41.200 --> 08:48.440
And for other code that is still missing, so we are not complete supporting all 19 dialects

08:48.440 --> 08:49.440
of course.

08:49.440 --> 08:55.440
But if there are projects, then we can just increase what is needed.

08:55.440 --> 08:59.240
So the compiler also gets increased step by step.

08:59.240 --> 09:03.560
And the ecosystem helps you with all the things that may wear on the mainframe.

09:03.960 --> 09:10.080
Or otherwise if you just do SQL access, there's a standardised exec SQL thing that works in

09:10.080 --> 09:15.640
C and that also works in Coble.

09:15.640 --> 09:23.760
So Coble is still used a lot but GNU Coble also has many users already.

09:23.760 --> 09:29.320
So actually if you think of GNU Coble, of course it's the new name of OpenCoble.

09:29.320 --> 09:34.960
And OpenCoble was forked by Coble IT very early.

09:34.960 --> 09:40.960
And for now I think that there are hundreds of big users of Coble IT.

09:40.960 --> 09:46.400
So in some sense there are also users of GNU Coble.

09:46.400 --> 09:51.800
We at Okamil Pro, we work with the French tax administration, the DGFIP.

09:51.800 --> 09:57.120
And we add them to migrate from Gcos mainframes.

09:57.120 --> 10:01.760
So Gcos is the name of a BUL mainframe that was created in the 80s.

10:01.760 --> 10:06.880
And so they are moving from that dialect to GNU Coble on PC.

10:06.880 --> 10:12.080
So we added the dialect for Gcos to GNU Coble for them.

10:12.080 --> 10:18.120
And recently we had a mail on the GNU Coble bug mailing list from real time.

10:18.120 --> 10:20.440
And they told us, okay, we have a bug.

10:20.440 --> 10:21.600
We found a bug.

10:21.600 --> 10:27.320
But we have been converting many and many programs from micro focus to GNU.

10:27.320 --> 10:30.200
And we didn't find any other problem doing it.

10:30.200 --> 10:32.040
So it's quite a nice result.

10:32.040 --> 10:34.840
Maybe you want to talk about it.

10:34.840 --> 10:43.640
Yeah, and actually I was contacted by someone, it's not on the list, but on the updated one.

10:43.640 --> 10:46.720
That uses GNU Coble for his customers.

10:46.720 --> 10:53.800
And that's a company for banking, so core banking, everything that you have in the banking,

10:53.800 --> 10:58.440
apart from the online banking part, is part of the software.

10:58.440 --> 11:08.200
And there are a lot of, there are some of those customers in the Dachie region that currently use GNU Coble.

11:08.200 --> 11:15.440
And actually they migrated from Solaris and IAX or Plain Rel and Micro Focus

11:15.440 --> 11:19.040
to GNU Coble on different environments.

11:19.040 --> 11:27.680
And those, yeah, those have multiple, a lot of transactions each day where GNU Coble just works.

11:27.680 --> 11:37.960
And they found actually that the GNU Coble environment is much faster than the original Micro Focus one.

11:37.960 --> 11:45.240
What was part of the original introduction of this talk was how we reached this majority.

11:45.240 --> 11:53.520
There's a lot of things on this paper, of course, but I think one of the biggest things is that it's got easier to work with

11:53.520 --> 11:57.040
because people wrote documentation on it.

11:57.040 --> 12:06.320
Other people helped with writing a pure Coble source code debugger using GCC.

12:06.320 --> 12:14.920
There are a lot of approach actually that you can use for debugging Coble with GDB that way.

12:15.920 --> 12:23.560
The tool sets around GNU Coble increased per demand so people can actually do what they normally do with the old compilers

12:23.560 --> 12:27.400
or with the C compilers also on GNU Coble.

12:27.400 --> 12:36.720
And many important things are also people using GNU Coble because you don't know if your compiler is complete if nobody uses it.

12:36.720 --> 12:42.080
But if big companies use it for their software, you may or you'll likely find bugs.

12:42.080 --> 12:44.520
And then you can fix them.

12:44.520 --> 12:55.200
And this also helps because it's quite different if you have just some code, maybe even the NIST suite, which has a lot of code to run.

12:55.200 --> 13:03.960
You don't see where the issue is, but if you run this with thousands of processes in parallel on a nice Linux machine,

13:03.960 --> 13:07.360
then you see quite fast where the bottlenecks are.

13:07.360 --> 13:17.120
So putting this into production helped a lot because this allowed us to tune for the actual issues on performance and also on memory.

13:21.680 --> 13:28.840
So having a nice compiler is great, but you also need to have a good environment around it.

13:28.840 --> 13:36.440
So we started working at OCaml Pro on a studio for Nucobol that we call Super Bowl.

13:36.480 --> 13:44.840
So it's based on LSP, Language Server Protocol that we developed in OCaml for cobalt.

13:44.840 --> 13:47.800
So there is a full cobalt parser in it.

13:47.800 --> 13:56.680
And it gives you access to all the features that you enjoy in a modern editor.

13:56.680 --> 14:05.520
So if you are interested in it, the link is getsuperbowl.com and there is a GitHub repository.

14:05.520 --> 14:10.600
Actually, so it's not on the marketplace of VS Code for now.

14:10.600 --> 14:17.800
It's still being heavily developed, but it can be tested directly from the project on GitHub.

14:17.800 --> 14:20.080
So we have a screenshot.

14:20.080 --> 14:27.320
It's not where you can see that you can go find references, for example, for some identifier.

14:27.320 --> 14:28.880
You can find all the references.

14:28.880 --> 14:32.600
So it's a small screenshot.

14:32.640 --> 14:40.920
So as a conclusion, we wanted to show that Nucobol now is mature to be used in industrial settings,

14:40.920 --> 14:45.560
where usually people use proprietary solutions.

14:45.560 --> 14:49.920
It's nice because it's developed in Europe compared to the other solutions.

14:49.920 --> 14:56.040
And you can use Super Bowl to develop with it, to have a modern environment.

14:56.040 --> 14:59.680
And this year, there is a Google Summer of Code.

14:59.680 --> 15:03.600
And there are projects on Nucobol.

15:03.600 --> 15:10.040
So if you are a student and you want to contribute to Nucobol, it's a nice way to start.

15:10.040 --> 15:16.080
So there is the URL here, but it's easy to find on the web page also, I think.

15:16.080 --> 15:18.880
If you have any questions, please join us outside.

15:18.880 --> 15:23.960
And we'll be happy to reply to all your questions.

15:23.960 --> 15:24.960
Thank you.

15:24.960 --> 15:25.960
Thanks.

15:29.680 --> 15:30.680
Thank you.

