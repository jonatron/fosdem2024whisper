WEBVTT

00:00.000 --> 00:06.720
Okay, good morning everyone.

00:06.720 --> 00:15.200
I'm glad it's my honor and pleasure to welcome you and to open this development room session.

00:15.200 --> 00:21.600
And what I'm going to talk about is a gap between the hardware and software and why

00:21.600 --> 00:26.600
FPGAs are capable and should fill this gap in.

00:26.600 --> 00:30.200
What I see as a gap and what I see as a problem with it.

00:30.200 --> 00:36.120
But before moving to the really interesting stuff, a few words about myself.

00:36.120 --> 00:39.240
Just so you know who is in front of you.

00:39.240 --> 00:42.440
A picture probably you've already recognized.

00:42.440 --> 00:47.560
On the right hand side a few buzzwords I still can remember through my career.

00:48.760 --> 00:52.200
Some of them perhaps a bit too ancient, but anyway.

00:53.000 --> 00:58.760
And the reason and motivation why I've decided to come over here and talk about this

01:00.200 --> 01:05.960
gap between the hardware and software between the FPGA and software development board is that

01:07.320 --> 01:12.040
with years I feel more and more frustrated with the

01:13.320 --> 01:19.640
pace of observing, mostly observing the pace of the software development, how new technologies

01:19.640 --> 01:27.880
appear and disappear, so of course as well, how rapidly it's going, how many young new people

01:27.880 --> 01:33.320
are coming to the software development boards who have no clue about the hardware under this

01:33.320 --> 01:39.080
software and who do not know and doesn't care how to develop this hardware.

01:39.080 --> 01:46.360
And I believe that this difference between the hardware and FPGA development

01:46.920 --> 01:52.920
direction and modern software development environment is just widening with the years

01:52.920 --> 01:56.680
and that is dangerous for the entire industry.

01:56.680 --> 02:02.440
So short outline of the talk, the first part and introduction and we've almost through it already.

02:03.240 --> 02:11.720
Then I will talk a bit or mostly ramble a bit the differences between the hardware FPGA and

02:11.720 --> 02:17.720
software development as they are seen from the low end, from the hardware and FPGA part,

02:17.720 --> 02:21.000
not from the very fancy high end software development board.

02:22.200 --> 02:31.560
Then hopefully if it's still running I can show the live demo what is currently changing in the

02:31.560 --> 02:41.320
world of the FPGA, what is new there and why I believe those changes can fill in the gap

02:41.320 --> 02:47.320
and can brought more software-oriented people into the hardware, into the FPGA and hardware

02:47.320 --> 02:54.840
development. Then of course it's just the very first steps I've been able to make or see them,

02:54.840 --> 02:56.680
then I will talk about there.

02:56.680 --> 03:02.840
Road to head and yeah more about the hardware, some backup sites, contact information and of

03:02.840 --> 03:11.000
course what you can do after this talk or if it would be interesting enough for you.

03:12.120 --> 03:20.840
Since we are done with the introduction and plans, first of all if software people are not

03:20.840 --> 03:24.280
paying too much attention to the FPGA development why should they?

03:26.200 --> 03:30.920
They are perfectly fine with the modern hardware, with the modern development and all the technologies

03:30.920 --> 03:37.960
around it. Unfortunately for the last 10-15 years it's not exactly the case because the

03:37.960 --> 03:44.840
general purpose CPUs are almost reached their capabilities and there is no clear way to progress

03:44.840 --> 03:54.040
for them. For multiple reasons technological complexity, fundamental technological and physical

03:54.040 --> 04:02.280
limitations and so on. The other reason is that the current software payloads are getting more

04:02.280 --> 04:08.840
and more diverse and the very different high variety of different requirements and general

04:08.840 --> 04:16.040
purpose CPUs while they are capable to run all of those payloads they are not well suited for any

04:16.040 --> 04:22.120
single one of them. For the last 10 years with the rise of artificial intelligence and all those

04:22.120 --> 04:33.000
neural networks somewhat unexpectedly GPUs came into the play but this type of neural networks

04:33.000 --> 04:41.400
and modern architectures of neural networks are coming and going on the one hand side and on the

04:41.400 --> 04:47.880
other hand side GPUs after all have not been designed for those kind of payloads and alternative

04:47.880 --> 04:53.880
would be easier to design the new ethics for specific payloads but again there are too many

04:53.880 --> 04:59.000
different variants, too many different architectures and requirements are changing every two, three years

04:59.880 --> 05:08.200
with all the pace and speed of software development and no sensible hardware company is capable to

05:08.200 --> 05:13.560
produce and use silicon every two, three years it will just not pay off for all the investment

05:13.560 --> 05:20.760
especially on the modern technological nodes and with all the investments but there are very

05:20.760 --> 05:26.360
flexible and nice chips which are manufactured in huge volumes on the most modern technologies

05:26.360 --> 05:32.440
and which are suitable with proper programming and with proper support software support and

05:32.440 --> 05:39.560
proper tooling support which are capable to efficiently execute any payload any imaginable

05:39.560 --> 05:51.880
payload. So there unfortunately here we see another roadblock because all the software development

05:51.880 --> 06:02.040
software for the FPGA world is still 40 years old at least if no of course there are new releases

06:02.040 --> 06:09.080
every year or two releases a year but all the underlying technology and the design approach

06:09.080 --> 06:17.320
is still 40 years old which is ages and of course as I've mentioned it seems to be a very boring

06:17.320 --> 06:25.480
subject that not that many people are interested to look at it which I think I might be very wrong

06:25.480 --> 06:30.520
looking at the number of people here and still coming so some people are still interested in the

06:30.520 --> 06:39.960
FPGAs and development for them that's good and encouraging. I've already mentioned all the things

06:41.320 --> 06:51.480
in the mid 80s rise of RTL register transfer layer design methodology was a huge breakthrough

06:51.480 --> 07:02.920
in their ASIC and later on FPGA design and the two languages they are still around us and they

07:02.920 --> 07:13.800
still are prime languages for such a development VHDL and VRIOHDL were developed I think in 1984-1986

07:14.520 --> 07:24.200
and those two languages are still with us and most are actively used nowadays. How many software

07:24.200 --> 07:29.000
development normal programming languages you remember from 80s which are still in active use

07:29.640 --> 07:37.000
Fortran and Lisp they are even older than VHDL and VRIOHDL and probably nothing else but definitely

07:37.960 --> 07:47.880
CER yes of course PDP 7 PDP 11 but also neither of them are on the top or own even 10 or 20 percent

07:47.880 --> 07:57.480
of the development and VRIOHDL shares 46 50 percent with 3 to 4 percent for everything else

07:58.280 --> 08:05.800
so it's quite a different picture compared to what it was about and after all those two languages and

08:05.800 --> 08:12.520
the RTL design methodology were introduced primarily for the ASIC development and only later on they

08:12.520 --> 08:18.920
were by coincidence because they were available new and fancy things at that time they were picked up by

08:20.200 --> 08:31.240
then young FPGA market adopted and still there with more or less nothing new even all the

08:31.240 --> 08:40.360
cheese sales, color, spindle, HDL, system, c, HLS all those new fancy technologies are going to

08:40.360 --> 08:47.160
generate VRILOCH which goes through the custom proprietary VRILOCH synthesis tools which is

08:49.320 --> 08:56.760
oh well you can say that LLVM and GCC are still can generate assembler but that's quite different

08:57.560 --> 09:02.920
but those things which are pretty common and well recognized by the industry and by many

09:02.920 --> 09:10.760
engineers working in the industry are well understood but they are not two main reasons for my

09:10.760 --> 09:18.040
disappointment in the current development the problem as I say it is that the only way we are

09:18.040 --> 09:24.600
programming FPGAs which are reconfigurable at any time you can change all the configuration in them

09:25.320 --> 09:31.320
at runtime anytime any number of times and you can do it really reasonably or relatively fast

09:32.120 --> 09:39.640
all the way we are still using and programming FPGAs is this exact way the IBM 402 or even the

09:39.640 --> 09:46.360
previous generation of tabulators have been programmed you hand wire a bunch of wires you call

09:46.360 --> 09:52.520
it a program then you plug it into the FPGA okay after synthesis and place and road things

09:53.160 --> 09:59.160
then you just put those bunch of wires inside your FPGA and using it as a playing hardware

09:59.160 --> 10:07.880
not changing a single wire at runtime uh partial reconfiguration is somewhat advertised by

10:09.320 --> 10:15.800
both major vendors Xilinx and Altira now Intel and AMD now not Intel again

10:16.680 --> 10:27.320
and they are advertised for 10 15 20 years but real support in either Vivado or Quartus is near zero

10:28.360 --> 10:37.000
you can do it but in real applications it's very very rarely seen the other thing in this

10:37.000 --> 10:43.800
same domain which is advertised for 20 years and still have some limited acceptance is of course

10:44.600 --> 10:51.080
HLS high level synthesis but anyway we have their modern chips manufactured on the most

10:51.080 --> 10:59.240
advanced technological nodes and we are still using them the way we used tabulators 70 80 years ago

10:59.240 --> 11:07.480
just putting wires put them in hardware and using this bunch of wires and the second reason for

11:07.560 --> 11:15.640
disappointment which probably just came from my experiences and embedded systems development

11:16.200 --> 11:22.760
developer that all the development is cross development strictly cross you cannot

11:24.520 --> 11:31.400
40 years ago you can take an xiloc z80 processor you have a machine built on this processor and you

11:31.400 --> 11:37.640
have a c you have fort you have Pascal you have basic and you can program on the same chip you can

11:37.640 --> 11:44.680
develop everything on the same chip nowadays we have an FPGAs which are two three orders of magnitude

11:44.680 --> 11:54.200
more powerful than that 80 but you still need a huge x86 machine to program it to do anything to

11:54.840 --> 12:01.640
even to blink an LED connected to FPGA you still need a somewhat powerful machine and I have to

12:01.640 --> 12:07.320
admit that the modern FPGAs even the smallest of them are much more powerful than the machine on the

12:07.320 --> 12:17.720
left hand side and this machine will not be even close to run anything of the modern FPGA design

12:17.720 --> 12:27.080
tools. Vivado's latest download is something like 11 12 gigabytes, Quartus and Libero

12:27.080 --> 12:34.680
are somewhat around 10 gigabytes as well so you need literally 10 gigabytes or for some proprietary

12:34.680 --> 12:42.600
closed software to develop any application blinking LED for a one single tiny chip which is more

12:42.600 --> 12:55.640
powerful than anything you used 40 years ago so those two things which forced me to look around

12:55.640 --> 13:06.840
and to see if something is possible to change in this world and fortunately there is in 2020 so

13:06.840 --> 13:15.880
almost it almost exactly four years ago I've seen a new FPGA chip appears on the market

13:16.760 --> 13:24.440
then it was not even on the market but only on the show it was an gate made FPGA from Cologne

13:24.440 --> 13:31.800
chip and now I will try to make a live demo it's just a screenshot now but it's always

13:31.800 --> 13:37.640
better to see something live if it works

13:42.440 --> 13:48.120
so what we have here and I will talk much more about the actual hardware we have here

13:49.880 --> 13:59.240
in a few minutes but we have a console of the Raspberry Pi which is just a baseboard for the

13:59.240 --> 14:08.440
Cologne chip based FPGA model with some LEDs connected to it and what I have as a demo here

14:08.440 --> 14:17.320
is that the FPGA is pre-programmed configured with a default image a small software application

14:17.320 --> 14:22.520
unfortunately at the moment written on C which is roughly the same age as the rest of the

14:22.520 --> 14:31.560
technologies discussed here which exercise just a simple AND gate and then at runtime from

14:31.560 --> 14:39.640
inside the chip overload this configuration of the chip exercise it again and I think we will

14:39.640 --> 14:49.080
observe some bugs because the demo is relatively young it's something like two days old this

14:49.080 --> 15:02.200
running version so we just power it up connect to the console stop out of boot then upload and demo image

15:02.200 --> 15:20.520
okay I still remember the name of the image in the morning it's not always the case and trying to run it

15:21.960 --> 15:28.680
at that point I would ask you to observe those LEDs running blinking not the blinking one on the

15:28.680 --> 15:36.520
below but the LEDs on the top one it will show something like an AND gate behavior so two inputs

15:36.520 --> 15:44.360
one output three LEDs blinking and the same will be printed out here the input to the signals and

15:44.360 --> 15:55.320
output signal and then we will see if it works or not so okay for AND gate it's visible

15:55.400 --> 16:04.040
now it will try for five time repeated for five times to configure and now the blinking pattern

16:04.040 --> 16:12.120
is different it's now NOT AND gate and the bug I've announced before it's not intentional for the demo

16:12.760 --> 16:21.560
so you see with two zeros on the inputs there is still an LED on so output is high output is one but

16:21.880 --> 16:32.040
what is shown here is NOT AND AND so there are no changes here it illustrates the problem with

16:32.040 --> 16:40.680
the tool chain and with the changes so what has happened the output which goes to the LED

16:40.680 --> 16:47.320
are changed at runtime and it's observable but the outputs which are going to the internal CPU

16:47.320 --> 16:53.640
subsystem are not modified they've split it through optimization and place and road

16:53.640 --> 16:59.720
somewhere inside the chip and there is a bug so a demo is half running it's running on LEDs

16:59.720 --> 17:08.600
but it doesn't run on their console unfortunately and I had no time to fix this part of the demo

17:08.920 --> 17:18.840
but the most important part and essential thing about this column chip gate mate fpga is that it

17:18.840 --> 17:26.360
allows to change the configuration at runtime but those things are available and have been around

17:26.360 --> 17:32.360
for some years from the other fpga vendors that's so-called partial reconfiguration runtime partial

17:32.360 --> 17:41.400
reconfiguration but what is important and what I have not ever seen in any other fpga maybe it's

17:41.400 --> 17:48.760
available but a well-kept secret from the fpga vendors it's a possibility to change the configuration

17:48.760 --> 17:58.680
and run time from inside the chip itself and it works here tool support and how well it's supported

17:58.680 --> 18:07.560
with the current software is and the question remains to be answered not so good but everything is

18:07.560 --> 18:14.040
well involved and there are much better perspective here for the column chip because the company it's

18:14.040 --> 18:21.000
a small german company probably develop in this fpga and this fpga is their first programmable

18:21.000 --> 18:28.520
solution product before that they were working in the sphere of communication chips and modems and

18:29.160 --> 18:39.480
some asics design yes what was the intention to do this for as far as I know I have no association

18:39.480 --> 18:46.360
with this company directly just know some good technical support people from there to have an

18:46.360 --> 18:55.000
fpga developed one of the motivations to have an fpga developed outside of the us because two major

18:55.000 --> 19:03.960
alterations latest micro chip most of the or all the other fpgs have their ip developed within the

19:03.960 --> 19:12.600
states so the this column chip gate mate fpga is developed in cologne and it's manufactured in

19:12.600 --> 19:20.360
germany near dresden its global founder is factory so to have a kind of technological independence

19:21.160 --> 19:28.840
also to fill in the niche because major fpga players switched or have much more marketing and

19:28.840 --> 19:35.800
economical interest in meat and high-range fpgas this fpga is relatively small so it's

19:37.160 --> 19:45.720
small physically low power consumption and it fill is fill seen the low end of the fpga

19:46.440 --> 19:52.280
market and the other interesting part which as far as I understand was

19:53.880 --> 19:58.440
at least partially a motivation for this development is to have a free and open source

19:58.440 --> 20:07.960
toolchain officially supported synthesis path is yosis so gate mate fpgas are officially supported

20:07.960 --> 20:17.560
by yosis synthesis tools at the moment place and road is a proprietary binary from cologne chip

20:19.160 --> 20:29.000
but the configuration bitstream format is not 100 but partially open and free so

20:31.000 --> 20:36.280
and as far as I know there is a plan to provide the support for place and road for cologne chip

20:36.280 --> 20:45.400
gate mate in next pnr and once it's available maybe well it has been expected in year year

20:45.400 --> 20:52.440
half ago maybe it will be available this year they do have some limited resources working on it

20:53.080 --> 21:00.360
for multiple reasons as usual everything is much more difficult than it seems to be

21:00.760 --> 21:09.240
but once the next pnr support for the place and road for gate mate will be available it will be the

21:09.800 --> 21:16.760
only fpga supported by full for which the full design road is supported by the vendor with free

21:16.760 --> 21:23.320
and open software I know about the latest I see I know about the reverse engineering of cyclone 4

21:23.720 --> 21:32.600
some parts for spartan 3 4 6 I do not remember I'm not that familiar with silence product line

21:33.480 --> 21:37.800
those are available of course but they are not officially supported and provided by the

21:37.800 --> 21:43.560
chip vendors themselves so you still once it's a reverse engineering you never know what other

21:43.560 --> 21:50.040
hidden secrets are inside so I believe that was the motivation and you also have a question

21:54.280 --> 21:58.360
available in non bga packages so I get reasonably sure

22:00.520 --> 22:08.840
unfortunately no but there is a solution for that as well just in a few minutes please

22:11.240 --> 22:16.440
I guess sure the question was if this package is available in something more suitable for

22:17.160 --> 22:24.440
hand soldering not in a bga package unfortunately the answer is no the only available now is bga

22:24.440 --> 22:36.760
324 volts 0.8 so not that good for hand soldering but the rest it used to be a there is a way to try

22:36.760 --> 22:43.880
the chip without soldering it now I can say that there are multiple ways to do that relatively

22:44.360 --> 22:51.560
approachable accessible just an outline perhaps every single person in this room already know what

22:52.280 --> 22:56.680
or can imagine what can be done with those possibilities to change the configuration at

22:56.680 --> 23:03.160
runtime from inside the chip itself with free and open tools but as I see it it's possible if you

23:03.160 --> 23:08.840
have a soft core CPU at runtime you can change its instruction set architecture you can add

23:08.840 --> 23:18.200
your custom instruction to it at runtime nowadays I think most many interpretive languages are running

23:18.200 --> 23:25.240
in some sort of jit technology so they are measuring at runtime critical passes in the

23:25.240 --> 23:31.080
code and compile them into the assembler or native machine code but now there is an

23:31.960 --> 23:37.160
a door is open to make the next step after you compile to the assembly code for the

23:37.160 --> 23:44.040
really critical part of your algorithm you can just add unnecessary instructions to accelerate it

23:44.040 --> 23:51.000
or you can synthesize at runtime a necessary accelerator load it at runtime and use it after

23:51.000 --> 23:57.080
that so it will be a jit not only to the machine level but to the hardware level to the next step

23:59.240 --> 24:05.640
the other parts and I think I've already mentioned it several times this morning that it will allow

24:06.120 --> 24:14.440
a speed up of the development because what the software people I as I see it are used to nowadays

24:14.440 --> 24:19.720
is to have an immediate feedback you type some code interpreter is running it you have a web

24:19.720 --> 24:28.440
browser with a page automatically updated and so on with fdga you write some rtl 40 years old code

24:29.000 --> 24:33.960
then you synthesize it for some hours then hopefully next morning you see a feedback

24:34.920 --> 24:42.760
which slows down the development process tremendously and with this possibility to change

24:42.760 --> 24:47.800
everything at runtime from inside the chip itself it's possible to make an interactive

24:47.800 --> 24:54.520
interactive iterative and incremental development you can just add part revoke some part change part

24:54.520 --> 25:01.640
you don't like so I hope that those technologies will make an FPGA sound much more approachable

25:01.640 --> 25:04.840
and more interesting to develop for them please

25:17.880 --> 25:23.800
the question was if the changes are if it's possible to update just the part of the design or

25:23.800 --> 25:29.080
how well the part changes are insulated from each other

25:31.160 --> 25:41.160
on a stanza will be that I do not know exactly yet but as we as I we saw in this demo it was

25:41.160 --> 25:48.040
possible to update just a single lookup table so just one gate or just one routing path between the

25:48.040 --> 25:56.520
gates generally the configuration format allows to change on the single logic cell

25:57.320 --> 26:05.560
unit of FPGA which makes something like an 18 ports two outputs two triggers plus minus some

26:05.560 --> 26:12.520
routing logic so I would say that this level will be the minimal one but at the moment in the chip

26:12.520 --> 26:17.480
there is no protection and I believe there will never be any kind of such a protection

26:17.480 --> 26:24.120
so you are allowed to change everything and of course you can break the system you are running on

26:24.120 --> 26:29.880
or break the part of the system you are running it that's a question of tool support on how well

26:29.880 --> 26:39.880
the software will support those things of course since you can see the changes at runtime

26:39.880 --> 26:46.920
interactively it makes the technology much more open you can more or less see what's going on inside

26:47.800 --> 26:53.640
hopefully you can just wrote some signal from inside your design to the pin to the led to the scope

26:53.640 --> 27:00.360
logic analyzer so it makes your design more transparent more explorable and I believe it will

27:01.160 --> 27:09.160
encourage more people to try it out because it's not some magic box hidden by gigabytes of software

27:10.840 --> 27:18.280
and of course since it's possible the dream is now seems to be more approachable a fully native

27:18.280 --> 27:24.760
development after all you can instantiate a soft core CPU run your system this soft coins CPU it will

27:24.760 --> 27:31.160
take ages but it's doable and then you can take this bit stream and update part of your design

27:31.160 --> 27:36.360
so you can develop internally sorry there is another one question yes please would you recommend the

27:36.360 --> 27:55.880
set that you are demonstrating for a complete beginner who has never seen any FPGA development

27:55.880 --> 28:07.960
before I would be there enough to say yes and this it might be not easy or trivial for the first step

28:07.960 --> 28:16.040
but it would be really good if this person even if she or he haven't seen an FPGA development

28:17.400 --> 28:23.000
to have some electronic background at least to know or have some ideas about the trigger or logic

28:23.000 --> 28:30.440
gate or Boolean algebra is so definitely not to school children's but there were some experiments

28:30.440 --> 28:36.600
in this direction as well not on my part but I've read about them maybe not even to the first year

28:38.040 --> 28:48.120
graduate students but after two or three semesters of basic discrete algebra and electronics yes

28:48.120 --> 28:56.760
why not before the introduction of very low-quake deal and all those nice and useful industrial

28:56.760 --> 29:04.920
things of course so first bullets are right here it's possible approachable and it's possible

29:04.920 --> 29:11.720
to explore them right now the last one is still somewhat dream ahead and let's take a look what

29:12.440 --> 29:17.400
made those innovations possible but before we have another question yes please

29:29.800 --> 29:36.440
yes so the comment was that last year someone presented a self-hosted FPGA development platform

29:37.160 --> 29:45.000
uh I believe I've read something about it and it was a Yosses running on risk five soft-core CPU

29:47.400 --> 29:57.800
slow yes working for sure but here we can see the next step after it after you have

29:57.800 --> 30:03.960
synthesized the bit stream on the FPGA how do you put it inside the same FPGA

30:07.400 --> 30:15.160
and now it is so yeah that's the next step and I do not try and I am not trying to pretend that

30:15.160 --> 30:19.640
it's something very unique I know that there are many people interested in it and working in

30:19.640 --> 30:25.240
parallel same directions somewhat different directions and that's just good and should be

30:25.240 --> 30:31.320
encouraged and it's nice to share those information and it's one of the reasons why I'm here at Osdame

30:31.320 --> 30:39.880
where everything is open free and so on so what hardware made it possible a few words about the

30:40.600 --> 30:49.320
FPGA itself it's as I said at the moment the only variant is available with 20 000 logic elements

30:50.120 --> 30:56.440
cheap with 40 000 is also available physically in the same package pretty normal

30:57.240 --> 31:07.960
mid or low range FPGA but as you see you can run a processor and it takes less than

31:09.000 --> 31:14.680
20 percent the entire system with memory or reconfiguration control support

31:16.040 --> 31:21.480
and CPU takes less than 20 percent of the available resources of this the smallest in the

31:21.480 --> 31:30.120
chip in the family so there is a path to grow there are some nice programmable PLS 5G

31:31.320 --> 31:42.760
service which allows to support USB 3 or PCI express gen 2 which is not so bad for low end

31:42.760 --> 31:48.520
FPGA it's even good as I said low power unfortunately the only available variant is

31:48.600 --> 31:57.720
in 324 volts bga so not hand solderable but let's wait for a moment for other options we have

31:58.680 --> 32:04.440
FPGA itself has a very regular structure very simple one compared to the modern

32:05.640 --> 32:13.000
edgy legs or ultra scale it's very simple transparent that makes it easier to support it

32:13.000 --> 32:17.960
with the software easy to experiment with it as I said somewhat more transparent and

32:19.240 --> 32:23.160
easy to understand and work with it here is their minimal

32:24.520 --> 32:30.840
cologne programmable element which is as I believe the smallest unit you can change the

32:30.840 --> 32:39.160
configuration for so it has not a conventional lookup table but a tree of two bit lookup tables

32:39.880 --> 32:46.920
and trees depth as two or three steps of two bits lookup tables some fast carrying out passes

32:46.920 --> 32:53.320
between the neighboring cells and input outputs to the global routing and to the chip block frames

32:54.520 --> 33:02.200
which are available on those columns between them so it's very traditional in some parts

33:02.200 --> 33:05.560
architecture what makes it different that it's an

33:08.600 --> 33:17.640
transparent open and somewhat better documented than the proprietary logic cells of their high end FPGAs

33:20.920 --> 33:27.960
and now the question was how to approach this if it's packed in the bga you cannot hand solder

33:28.760 --> 33:37.880
for me this question was the first one I've asked it in 2020 in year 2020 right before the corona

33:37.880 --> 33:46.200
and all the crises and since I am doing a hardware development for many years the easiest answer was

33:46.200 --> 33:54.200
just to develop a model for it I believe that this FPGA is the best thing that happens to the

33:54.200 --> 34:03.960
FPGA world since xc6600 which was open and very well accepted by academic community but then

34:04.520 --> 34:12.280
suddenly died and was is not longer manufactured back when I started to play or when I wanted to

34:12.280 --> 34:19.080
play with this FPGA eval and evolution key from cologne chip was not available yet so I've decided

34:19.160 --> 34:26.760
to be in front of the chip vendor themselves something pretty stupid on my part I have to admit

34:28.440 --> 34:33.160
of course when I develop a model for myself I have all the freedom to experiment with it

34:33.160 --> 34:39.080
model is smaller than the evolution board and you can connect it to something else you can

34:39.080 --> 34:46.600
combine several modulus for me the best way to get to know some new chip I am interested in is to

34:46.600 --> 34:52.680
design some boards on this chip first one may not work or magic smoke will come out of it but then

34:52.680 --> 34:59.880
you know exactly what is going on there and of course it was a fine and nice exercise with

34:59.880 --> 35:07.240
key cat because I've just seldomly used it before that decided to go why not to try it it's a good

35:07.240 --> 35:13.080
one then key cat switched from version six to version seven roughly at that time yes please

35:17.480 --> 35:22.840
make before why I think I'm following everything I found that I sporty I found everything how did you

35:22.840 --> 35:24.040
find it and

35:26.280 --> 35:32.920
why did you take enough documentation to start doing uh document a uh the question was how do I

35:32.920 --> 35:39.240
learn about the existence of this chip because it's relatively under the radars on the FPGA market

35:39.240 --> 35:46.600
definitely not as well advertised as uh altera intel altera again xylings imd

35:47.480 --> 35:55.480
still imd not sure i see and all other players uh first I saw it's mentioned on some mailing

35:55.480 --> 36:03.720
list in earlier 2020 but I do not remember where it was and probably it's impossible to trace down

36:03.720 --> 36:10.920
anymore but then I've just stopped by or at their booth at embedded world and it was uh the very

36:10.920 --> 36:16.600
first time I've explicitly asked the question if it would be possible to change a configuration from

36:16.600 --> 36:24.280
inside and I've got a definite answer yes but uh it's not working yet we do not have a board yet

36:24.280 --> 36:32.200
but we have a chip uh and back then it was an mvp so it was not their custom wafers but mvp run

36:32.200 --> 36:38.360
the very first one so embedded world uh let's say the first contact with the company and where I

36:38.360 --> 36:44.120
learned about them and all the documentation for it available on their site it's free you can download

36:44.120 --> 36:49.400
everything and of course you can learn a lot about the internal structure if you go to the

36:49.400 --> 36:54.760
usis project and look into the sources for the support of it then you know all the internal

36:54.760 --> 37:03.240
details or almost all of them uh what is the current status uh exactly four years from the first

37:03.240 --> 37:10.760
contact this company uh three boards were designed instead of single model all three of them are here

37:10.760 --> 37:19.800
combined in a system and all three of them are working uh the schematic symbol and pcb footprint

37:19.800 --> 37:28.360
for uh gitmate fpga is included in official kikkat kikkat version seven libraries now and I've been

37:28.360 --> 37:36.920
able to push it through which not always an easiest straightforward process um some software

37:36.920 --> 37:42.280
application as you can as you've seen running on raspberry pi to control model to download

37:42.280 --> 37:49.720
configuration into the model to exercise the interfaces of the model uh vhdl examples are

37:49.720 --> 37:57.000
running soft core cpu's are running integration with their modern software-oriented fpga design

37:57.000 --> 38:04.920
frameworks as light x fuses so few soak some others are walking progress so something is

38:04.920 --> 38:11.960
available something is not working yet I think nothing is upstreamed yet completely and uh

38:12.280 --> 38:19.000
as I said it was pretty dumb decision on my part because it took five time longer and the first

38:20.120 --> 38:27.480
prototype board was running in 2022 so two years from the beginning instead of half year

38:28.760 --> 38:36.280
and uh recently in december there is a new model from the bigger companies and myself

38:37.240 --> 38:43.160
from trends electronics and there is an another evolution board from olimix so you

38:43.160 --> 38:50.040
fasted how to start up development with the um uh gitmate fpga without soldering bga yourself

38:51.080 --> 38:57.160
you can use this model you can use evolution kit from cologne chip you can use a model from

38:57.160 --> 39:02.680
trends which is immediately available and you can use an evolution board from olimix when it is

39:02.680 --> 39:07.480
available as far as I understand they are still in prototype production status

39:13.960 --> 39:17.560
if you were late yes hopefully so

39:19.800 --> 39:27.160
so uh model and its design is completely free and open source hardware so what you can do you

39:27.160 --> 39:34.680
can go to github take all the manufacturing files and manufacture it yourself I've tried but it's not

39:34.680 --> 39:40.520
started yet to launch a group gets campaigned so you can order online and if there are sufficient

39:40.520 --> 39:47.800
number of orders it will be manufactured and orders fulfilled uh basically this model is universal

39:47.800 --> 39:54.840
one what I've tried to do is not to prohibit any use of this fpga so most of the functionality

39:55.640 --> 40:01.720
except for single i o bank is available on the external model connector so the other thing you

40:01.720 --> 40:06.760
can do would be to design your own base board for it or just an i o extension board which is

40:06.760 --> 40:14.360
perfectly hand solderable this memory board extension board is just two layers uh uh soldered

40:14.360 --> 40:23.000
and that attached directly to the model so that's all possible uh raspberry pi uh hat adapter is the

40:23.000 --> 40:29.240
only board current I currently have to exercise the model so it's uh connects the model to the

40:29.240 --> 40:38.280
raspberry pi 40 pin gpo so I can power it on measure current consumption program configure the model

40:38.280 --> 40:47.240
and so on uh another small one is just external memory so the soft core cpu inside the fpga is a

40:47.240 --> 40:54.600
bit more happy than only with internal memories and it can boot from there so just a simple one

40:54.600 --> 41:03.160
and it also has been designed as a part of a mechanical exercise because if you connect

41:03.160 --> 41:09.320
all the extension models to this one then the gaps are something like half millimeter and it's a

41:09.320 --> 41:16.360
little bit outside of the connector specification but it works so I need some real proof that it works

41:16.360 --> 41:25.960
and you can see it here now it's available so if you'd like to do something with gate mate fpgs

41:25.960 --> 41:32.040
at the moment once again I believe it's the only fpga which allows to change the configuration from

41:32.040 --> 41:39.640
inside at runtime so it has to be a gate mate fpga but it doesn't have to be a risk five which is

41:39.640 --> 41:47.080
currently there it can be an open spark it can be meeps it can be your own cpu or no cpu at all

41:48.200 --> 41:59.080
all the freedom is yours uh it has not it doesn't have to be a c probably c was the worst choice

41:59.080 --> 42:04.600
and my first intention was to use forth so you can interactively just type something change

42:04.600 --> 42:12.120
configuration exercise it and I have it semi running but I'm not there enough to show it here

42:12.120 --> 42:19.000
at all otherwise it will take another 50 minutes just to see some blink in the led first maybe longer

42:19.000 --> 42:27.800
than that and of course uh yeah any language fourth luah micropython scheme leapscala whatever you

42:27.800 --> 42:35.240
can fit inside you can run it you can change the configuration from this those software and

42:35.240 --> 42:41.000
definitely software people know much more about different environments and how to make it attractive

42:41.000 --> 42:48.120
interest in fast and of course it doesn't have to be a this model but I hope that this model

42:48.120 --> 42:56.600
some weeks days weeks will be available for group gets for online orders currently you can get go to

42:56.600 --> 43:02.520
the project website and there is a link to github with all the designs design examples support

43:02.520 --> 43:09.720
software and from there there will be a new update link to the group gets campaign where you can

43:09.720 --> 43:16.440
order the modulus if you'd like something immediately available then it will be an

43:17.160 --> 43:24.440
get made evaluation kit from colon chip or trends model late on all the mix model so hardware is

43:24.440 --> 43:30.280
coming on now but as I said this model is already running for a year those models are just two

43:30.280 --> 43:43.720
months as they appear yes please uh light x system so in megan is

43:45.960 --> 43:54.120
running but not upstream yet so it's just a set of pages or something but yes that's

43:54.200 --> 43:58.840
oh sorry I haven't repeat the the question is if it's going to be supported by somehow

43:58.840 --> 44:08.200
high level tools me and megan megan light x fuse soak yes those are plans for that and

44:08.200 --> 44:15.080
if anybody is willing to contribute to it please everything is open feel free to do it because

44:16.280 --> 44:23.080
I'm doing it but it takes as I said five times longer than plant sometimes 10 times longer

44:24.760 --> 44:31.480
um I just repeated that everything is open so you are welcome to create a software running on

44:31.480 --> 44:40.920
FPGA create a software for FPGA development to design hardware with FPGAs to design hardware

44:40.920 --> 44:46.120
with FPGA modulus because it's much much easier and this one would be approachable even to people

44:46.120 --> 44:53.080
with near zero hardware design experience that makes a model much more attractive all the complex

44:53.080 --> 44:59.160
problems are already solved you just have to connect the power and some IOS and that's much

44:59.160 --> 45:04.520
easier than the rest of the system design and of course if you find some problems there are

45:04.520 --> 45:13.640
many of them please report send a feedback and share all your results it's open so not only open

45:13.640 --> 45:21.640
source software it's open source hardware as well thank you for your attention and any questions

45:22.600 --> 45:24.200
please

45:30.200 --> 45:37.720
okay I see two three four questions five but I afraid that I overused all the time

45:39.880 --> 45:40.200
please

45:40.920 --> 45:46.200
it appears that writing software is easy it appears that logic gates is easy

45:47.160 --> 45:53.000
you're like in the riddle where everything is probably very oh I wouldn't the question was that

45:53.000 --> 46:00.360
it looks like writing software is easier and connecting gates is easier and that the

46:00.360 --> 46:07.320
complexity starts in the beginning when all of them are mixed but I would only partially agree to that

46:08.120 --> 46:15.000
uh writing software is extremely difficult writing good software and complex software

46:15.000 --> 46:23.480
is amazingly complex problem uh working with the modern hardware connecting gates with modern

46:23.480 --> 46:32.680
technologies and everything is also getting a harder day today uh FPGAs are very complex beasts

46:32.760 --> 46:40.600
where those complexity are multiplied and that makes this area especially interesting

46:40.600 --> 46:50.200
attractive and as with many many other places you have all the innovations and places to grow

46:50.200 --> 46:57.480
where some things are intersecting intersecting and FPGAs are exactly the intersection of hardware

46:57.480 --> 47:04.280
and software okay thank you very much thank you

