WEBVTT

00:00.000 --> 00:13.120
I know everyone's excited for Tessa.

00:13.120 --> 00:17.240
We keep the good talks for the end to make sure you all stay the entire day.

00:17.240 --> 00:18.320
All right.

00:18.320 --> 00:20.960
So we have Tessa in the box.

00:20.960 --> 00:30.720
So please give a warm welcome.

00:30.720 --> 00:32.520
Thank you very much.

00:32.520 --> 00:39.960
Because the end is always a bit chaotic, I was just going to say, could we have a round

00:39.960 --> 00:48.120
of applause for all our volunteers here?

00:48.120 --> 00:52.920
So without further ado, this talk is testing in a box.

00:52.920 --> 00:54.640
It's going to be given by my colleague.

00:54.640 --> 00:55.640
Hi, everyone.

00:55.640 --> 00:56.640
My name is Munti Chirma.

00:56.640 --> 00:58.240
I'm a software engineer at Coltsing.

00:58.240 --> 01:02.600
I've been with them for almost a year and a half, and I specialize in embedded hardware

01:02.600 --> 01:04.920
and software.

01:04.920 --> 01:10.760
And myself, William Salmon, I've been at Coltsing for about six and a half years, and I've

01:10.760 --> 01:18.640
specialized in embedded Linux and Linux integration and testing of those things.

01:18.640 --> 01:27.120
So I'm going to give us a little bit of context as to how this project was motivated and a

01:27.120 --> 01:29.800
bit of a very high level view.

01:29.800 --> 01:34.040
And if you guys are wanting to do similar things, maybe you can take inspiration from

01:34.040 --> 01:37.120
this for persuading your colleagues of the value.

01:37.120 --> 01:40.880
And then that's going to give us some very top level requirements, and then it's going

01:40.880 --> 01:44.880
to talk through how those top level requirements become hardware requirements, and then our

01:44.880 --> 01:47.720
implementation.

01:47.720 --> 01:56.800
So Code Think has been offering software services for over 15 years.

01:56.800 --> 02:01.320
We work with open source software a great amount.

02:01.320 --> 02:07.440
All of our developers have Linux laptops, and all of our infrastructure runs on open

02:07.440 --> 02:09.440
source services.

02:09.440 --> 02:15.320
So we really believe in open source software, and this is kind of our journey into open

02:15.320 --> 02:18.480
source hardware as well, and we're trying to take all of the good things that we've

02:18.480 --> 02:22.200
learned from open source software to open source hardware, but we're a little bit earlier

02:22.200 --> 02:27.240
in that journey at the moment.

02:27.240 --> 02:30.920
So we work with a lot of embedded projects.

02:30.920 --> 02:42.520
We have an awful lot of automotive clients, and we also have some in the financial industries,

02:42.520 --> 02:49.160
and what they all share is that they want to bring lots of different bits of software

02:49.160 --> 02:55.280
together, so they always work in exactly the way that they want, and they want to make

02:55.280 --> 03:00.080
sure that what goes into their things is exactly what they want, but also that it behaves exactly

03:01.080 --> 03:06.880
the way that they want it, so how do they verify that it behaves how they want testing.

03:06.880 --> 03:14.360
So one thing that we found across most of our clients is that they all share some kind

03:14.360 --> 03:23.360
of testing transition, some kind of testing progression, so on your left hand side you've

03:23.360 --> 03:28.360
got your final production, and the reality is that some bugs only ever turn up all the

03:28.400 --> 03:35.400
way out there, but they're very difficult to deal with, and we really want to avoid that,

03:36.200 --> 03:42.480
and then we've got things on the right hand side of this that are very convenient for

03:42.480 --> 03:48.480
us to run our tests with, but maybe don't provide as much value.

03:48.480 --> 03:54.200
So no developer wants to come and contribute bad code.

03:54.240 --> 03:58.840
We have these really creative developers in our industry, many of you have sat here among

03:58.840 --> 04:06.840
us, and we want to make their lives as easy as possible, so we want to provide as much

04:06.840 --> 04:13.360
value on this side of this transition, but also make it as easy as possible to get information

04:13.360 --> 04:16.360
back from the later steps.

04:16.520 --> 04:23.520
So what sorts of things are we battling?

04:24.960 --> 04:31.960
So some things that we find quite problematic, so slow automated tests are problematic because

04:32.600 --> 04:36.240
that's taking a long time to get information back to our developers.

04:36.240 --> 04:40.920
Manual tests are never going to be particularly reproducible, so we really want to squash

04:40.920 --> 04:45.080
those. There are some tests that are just expensive, maybe they involve some kind of

04:45.120 --> 04:49.720
consumable that's expensive, maybe they involve some huge AWS server that we just want to

04:49.720 --> 04:56.720
touch as little as possible, and sometimes maybe there is only one lab car because it's

04:58.080 --> 05:04.080
a brand new car, and so we are really just resource constrained.

05:04.080 --> 05:10.080
It doesn't matter how much money you spend, you've only got one.

05:10.080 --> 05:17.080
So kind of our drivers are that we want to make the early steps as accurate as possible,

05:18.400 --> 05:22.360
so we want to use as representative hardware as possible, we want to have as representative

05:22.360 --> 05:29.360
peripherals as possible. A lot of cars these days have surprisingly complicated networks,

05:29.360 --> 05:36.360
so there's a lot of different bits of hardware to go into making it really accurate, and

05:37.080 --> 05:44.080
so as our code moves along this transition it gets more and more expensive, more and

05:45.280 --> 05:51.320
more difficult to deal with, so another thing, and we get longer and longer feedback times

05:51.320 --> 05:55.560
for our developers, so a key thing is to make the left hand side of this graph as easy as

05:55.560 --> 06:02.560
possible. For our developers to interact with, so making it easy for our developers to trigger

06:02.920 --> 06:09.920
things for later steps in the transition, but also to get information back.

06:11.120 --> 06:16.560
So testing on hardware is what we're all about in this talk, and some things that, so I talked

06:16.560 --> 06:22.340
about this is kind of a requirement for the next step, for Muddit, and so some of the

06:22.340 --> 06:26.040
things that we definitely want to be able to do with this project is completely flash

06:26.040 --> 06:31.040
a rig, because if you're not completely flashing a rig, you're going to end up with the last

06:32.040 --> 06:37.360
MR affecting the next MR, whatever it is, we need to make sure we've got known starting

06:37.360 --> 06:44.360
points, so we need to be able to do that. OTA, over the air updates are a thing that

06:44.800 --> 06:49.240
goes wrong all the time, and have massive consequences, so we definitely need to test

06:49.240 --> 06:56.240
them. As we went through our testing transition, we tend to find the more and more complicated

06:56.520 --> 07:03.040
bugs. One of the reasons for that is that the actual tests that people do kind of get

07:03.040 --> 07:08.360
more and more complicated and more and more integrated, so you need to be able to have

07:08.360 --> 07:15.360
tests that in a single test can interact with the UI, and the various buses involved,

07:15.560 --> 07:22.560
so in automotive often can, and also get down to some peripherals. So one test that we were

07:22.880 --> 07:29.880
working with quite recently involved changing the set point of a car's climate control,

07:30.640 --> 07:37.640
making sure that from the UI, not just some API call, but actually have the UI set the

07:37.720 --> 07:44.720
point, then have that command go down through a bus into a real or a mocked peripheral,

07:45.360 --> 07:49.600
and then have data come back up through the bus of the value slowly changing and make sure

07:49.600 --> 07:56.600
that it all behaves together. By doing that, automatically we can also improve the reproducibility

07:58.040 --> 08:05.040
of that test. Some very top level requirements are we need CI rigs, so we need some rigs

08:06.920 --> 08:13.200
that are only for CI. We mustn't be merging without our automatic tests. We need some

08:13.200 --> 08:17.720
kind of coordinator so we can make the most of those assets that we have. If we have five

08:17.760 --> 08:24.280
rigs and we've got 50 developers, we want those rigs to be absolutely hammered so that

08:24.280 --> 08:28.320
those developers are waiting as short as time as possible. We need to be able to interact

08:28.320 --> 08:34.000
with the UI, and we need to be able to interact with the hardware through various buses through

08:34.000 --> 08:40.000
IO, and we need to be able to control those peripherals. So now that I have gone through

08:40.000 --> 08:45.400
all of those, we have a pretty good set of requirements for our testing infrastructure.

08:46.080 --> 08:50.760
Thanks, Bill. Now that we've talked about different types of tests and requirements for them,

08:50.760 --> 08:57.760
let's go through the basic requirements for testing infrastructure.

09:01.600 --> 09:04.600
Let's see if it's a slide.

09:04.600 --> 09:11.600
All right. I don't know. Anyway, I'll go about it anyways. So, I mean, talking about testing

09:18.280 --> 09:23.800
infrastructure, we need a computer of sorts to talk to your device on the test, and you

09:23.800 --> 09:28.720
need hardware to simulate the actual production application. So that would be, I mean, talking

09:28.720 --> 09:33.560
about car rigs, we're talking about canvases, we're talking about serial in most of the

09:33.560 --> 09:39.200
test images. These ECUs will have serial enabled, so you should be able to probe the ECUs and

09:39.200 --> 09:46.200
get out of it. So you'll have multiple serial dongles. In some cases, the testing application

09:46.240 --> 09:51.240
or the testing requirement is going to be so niche that you'll have to make custom hardware,

09:51.240 --> 09:55.120
and sometimes making custom hardware is not feasible, so the first thing you'll do is

09:55.120 --> 10:00.480
have your own reason of the shelf hardware, and you'll get a working example from there,

10:00.480 --> 10:05.960
but following which, you'll have to make your own piece of hardware. We've done that before.

10:05.960 --> 10:12.960
We've had clients who wanted to test device discovery for Android automotive and CarPlay,

10:13.200 --> 10:18.200
and their ways of testing were quite manual, so they had engineers with spreadsheets and

10:18.200 --> 10:25.200
iPhones, so the engineers would go to a rig, plug in a device, check the output, mark the

10:25.560 --> 10:29.120
representation in a spreadsheet, and based on that, they would make a decision that if

10:29.120 --> 10:34.760
it's behaving as it should be or not. So based on the description, we can make out that that's

10:34.760 --> 10:39.120
a solution to a problem that will not and cannot scale well. So we had to automate that problem

10:39.120 --> 10:46.120
for them, and we made a custom hardware for that and called it the USB switch. So the

10:46.600 --> 10:53.400
USB switch is a bi-directional USB-C switch, which can help you programmatically control

10:53.400 --> 10:57.760
one host between two peripherals and vice versa. It's a completely open source hardware

10:57.760 --> 11:04.760
made with QICAD and the respective firmware and cases are also available with the project.

11:05.440 --> 11:09.840
It supports USB super speed. That's something we've tested internally, not certified, but

11:09.840 --> 11:13.880
that's something we've tested, and recently we've gone through the effort of EMC getting

11:13.880 --> 11:19.000
the hardware EMC tested. It has cleared the EMC tests, and we are in progress of a process

11:19.000 --> 11:24.760
of getting the documentation for it in the open as well. The QR code is going to take

11:24.760 --> 11:30.800
you to the project, so if you want to learn more, come. So now that you've gathered all

11:30.800 --> 11:34.520
the pieces of hardware for your basic testing infrastructure, you put it all together, and

11:34.520 --> 11:41.520
the resulting setup looks something like that. So one good quality of this setup is it's

11:42.520 --> 11:48.800
functional, it works, but it will confuse you when you're setting it up for the first

11:48.800 --> 11:54.040
time and setting it up multiple times and tens of hundreds of rigs maybe sometimes is

11:54.040 --> 11:58.240
going to be quite a challenge. You have to maintain a bit of material, you have to maintain

11:58.240 --> 12:04.600
the documentation for it, and sometimes you'll buy hundreds of field long-books and you can't

12:04.600 --> 12:10.480
buy them anymore, so you'll have variability in your piece of hardware. Again, a trouble.

12:10.520 --> 12:16.520
So that gives us a question, what are the key requirements for a robust testing infrastructure?

12:17.800 --> 12:26.800
So when we talk about long-term support of software, we cannot discount the maintainability

12:27.200 --> 12:32.160
of the supporting testing infrastructure. That means we want to be able to maintain the

12:32.160 --> 12:39.040
inventory of spares. So when you put in the effort to set up a rig, you buy a certain

12:39.040 --> 12:42.280
piece of hardware that comes with its own tooling, and then you put in the effort to

12:42.280 --> 12:45.800
set up that tooling with your testing rig, and then you can't buy it in the next two

12:45.800 --> 12:52.120
years, that's added effort, and that added effort means time, and that time means money.

12:52.120 --> 12:57.800
So you want to be able to buy and manage that piece of hardware that you're putting on your

12:57.800 --> 13:03.520
rigs. And you want to be able to have the testing setup as easy as possible so that

13:03.520 --> 13:07.920
the developers can actually get to use those tests, get value out of those tests rather

13:07.920 --> 13:14.720
than spend time on setting up those tests. And we want to be able to have the setup

13:14.720 --> 13:19.200
as consistent as possible because consistency removes variability from your setup, and that

13:19.200 --> 13:23.520
means that you'll be pulling out less hair when you're debugging problems.

13:23.520 --> 13:30.520
So keeping all these requirements in mind, we kind of made our own solution, and quite

13:31.520 --> 13:38.200
descriptively called it testing in a box. So testing in a box can be seen as a multiple

13:38.200 --> 13:43.680
for testing. It's supposed to be a kind of I.O. for testing and facilitating remote access

13:43.680 --> 13:49.640
to your rigs, and it's designed with modularity in mind. When I talk about modularity, I think

13:49.640 --> 13:56.120
this image depicts the modularity a bit better. So each section in that image is something

13:56.200 --> 14:02.500
that we call as a slice. So at the base of the slice, we have a SBC, an unbased SBC.

14:02.500 --> 14:06.640
On top of that, we have the USB switch slice. On top of which we have a slice which can

14:06.640 --> 14:13.400
hold can dongles. And on top of that, we have our in-house built I.O. board. I'll be talking

14:13.400 --> 14:20.400
about that in the upcoming slides. And the USB switch slices and the can device slices

14:21.240 --> 14:26.040
are stackable, so you can add more USB switches if you want or not have them if you don't

14:26.040 --> 14:33.040
need them. And same goes for the can devices. So I have the hardware with me here. So in

14:36.080 --> 14:43.080
its most basic setup, this small contraption gives you the ability to have a GitLab runner.

14:45.000 --> 14:52.000
It gives you the ability to do UI validation tests with OpenQA. You can do device discovery

14:52.360 --> 14:58.480
tests by programmatically plugging in and out USB devices. And you can check states

14:58.480 --> 15:05.480
with GPIO. And you can also mock or monitor can devices. So essentially checking out all

15:06.360 --> 15:13.360
the boxes that we put on our list collectively in the beginning of the talk. So now to the

15:15.280 --> 15:21.280
fun part. That's the custom built I.O. board that we have for testing the box. Starting

15:21.560 --> 15:28.560
from the left hand side, we have three FT232H, which gives us serial SPI square C and JTAG.

15:31.800 --> 15:38.800
Then we have an R24T for HID emulation. And we have three USB hub, USB two hub inputs.

15:40.000 --> 15:45.760
And all of that then gets connected to your host, which can be an SVC or a laptop with

15:45.760 --> 15:52.760
a single USB C cable. We also have an ESP32C3, which sends serial to the R24T for HID emulation.

15:54.720 --> 16:01.720
And a new pixel, because everybody likes LEDs. And yep, if you want to electronically isolate

16:02.680 --> 16:09.680
your GPIO, you have an optocouples on top. So this is the version one, region B of the

16:10.120 --> 16:15.680
board. And these are the changes we got to make to version two of the testing in the

16:15.680 --> 16:22.680
box I.O. board as a work in progress project. So the idea behind the version two is reducing

16:22.720 --> 16:29.720
the cost, getting the bill of material smaller and with the space that we're going to make

16:30.680 --> 16:35.560
with that, we want to add more functionality to the board. So we're going to be getting

16:35.560 --> 16:42.560
rid of the three FTDI, FT32H and replace it with a single FT4232H, which will give us

16:42.640 --> 16:49.640
4X serial and 2X MPSSE, which is multi-protocol synchronous serial engine. So basically that

16:50.720 --> 16:57.720
will give you your SPI, I2C and JTAG. And we'll be getting rid of the ESP32C3, which

16:58.760 --> 17:03.000
because we are not using it that much, the version one on the board was more of an experiment.

17:03.000 --> 17:07.400
So we saw after you refused that we were not using it that much, so we're getting rid of

17:07.400 --> 17:12.960
that and moving the functionality to the IP2040. And because we'll be getting rid of so many

17:12.960 --> 17:17.960
USB devices, we can actually get rid of one of the USB hubs on the board, which was re-chained

17:17.960 --> 17:24.400
initially, so that again gets the bomb cost lower. And with the space that we're going

17:24.400 --> 17:30.400
to make, we are looking at putting in USB PD on the board. So what essentially you'll

17:30.760 --> 17:36.040
be able to do is that you can put in a battle jack on this board and have USB PD out, so

17:36.040 --> 17:43.040
you can basically power other SBCs from the board itself. I've said a lot of words in

17:43.040 --> 17:46.800
the previous slide, so here's a quick overview of what we're going to be changing and the

17:46.800 --> 17:53.800
benefits. So here is an example of the use case that we have internally for testing the

17:54.800 --> 18:00.800
box. So in this example, we have a laptop, we have an X86 requirement, so we have a laptop

18:01.400 --> 18:05.120
connecting to testing the box, which shows modularity because currently in this case

18:05.120 --> 18:10.040
we're only using the IO board, which is connected to a Jetson Orin, and the output of a Jetson

18:10.040 --> 18:14.480
Orin is being monitored with the capture card. Now I won't be going into much detail about

18:14.480 --> 18:21.480
the actual example, but I'll be talking about the developer workflow. So every time a developer

18:21.720 --> 18:27.840
has to make a change, they can test those changes on their own machines, which runs on

18:27.840 --> 18:34.840
QMU, but when they're very confident that they can push these changes to the main, so

18:34.840 --> 18:40.960
they raise a merge request, and that merge request will trigger a set of pre-much tests.

18:40.960 --> 18:47.960
Those pre-much tests will flush the Orin, it will run a set of tests and check that it

18:48.960 --> 18:53.600
meets the set of requirements, and based on that, once those pipelines are green, the

18:53.600 --> 18:57.960
developer can be sure that, well, that the code hasn't broken the system in a way that

18:57.960 --> 19:02.960
was not intended, and the reviewers also have a metric to basically check the code against.

19:02.960 --> 19:09.960
So any piece of hardware is only as good as the software that comes with it, and we package

19:10.960 --> 19:17.960
together with testing in a box various tools. So we have Ansible scripts that let you easily

19:19.960 --> 19:25.960
set up good cloud runners, easily set up open QA workers, CI templates, we also have CI

19:25.960 --> 19:29.960
templates that you can use, and we also have a self-servicing script that you can use to

19:29.960 --> 19:35.960
set up the UDL rules for the IO board. We also provide an example, which, in a sense,

19:36.960 --> 19:43.960
for that, you need a Raspberry Pi with the AGL, and all you do is put the QAD binary on it,

19:44.960 --> 19:50.960
I'll be talking about that in a bit, and that essentially gives you a fully functional test

19:50.960 --> 19:56.960
in which you are doing UI validation, you are able to run your GitLab CI pipelines, and

19:56.960 --> 20:03.960
test and monitor can signals passing through the entire network. So I've got a couple of

20:05.960 --> 20:10.960
things to talk about. I've mentioned open QA, QAD, and Canvas before, so open QA is a tool

20:10.960 --> 20:15.960
that we use in-house to do UI validation tests, we have found it quite useful. So we have

20:15.960 --> 20:21.960
also contributed to it to make it better, and QAD is a tool that we've written to do user input

20:21.960 --> 20:28.960
simulation in CI, and how you make that work is, it's a small binary which you put in the

20:28.960 --> 20:34.960
right place in the root of S, and that helps your GitLab runner to send it HTTP requests,

20:34.960 --> 20:41.960
and mock the touch inputs that a user would actually, like the user would do. And Canvas

20:41.960 --> 20:46.960
is a tool that we worked on as well, it's something we've made in-house, which helps you

20:46.960 --> 20:53.960
build those tests and make it easier, essentially. So what's next? As I've already mentioned,

20:53.960 --> 20:58.960
we're already working on the version two of the board, it's still a work in progress,

20:58.960 --> 21:05.960
so if you guys want to join the project or have any suggestions, we're willing to, and

21:05.960 --> 21:11.960
we're very happy for some much requests or suggestions. And we're also looking forward to

21:11.960 --> 21:16.960
actually making a can of the expansion board, given that we set up these boxes on various

21:16.960 --> 21:21.960
automotive rigs, and we do use various canned dongles, it would be nice to have a single one

21:21.960 --> 21:28.960
that helps us basically transfer the knowledge between different projects, so we'll be looking

21:28.960 --> 21:35.960
at making one of that as well. And there's many more to come, so stay tuned, and that

21:35.960 --> 21:37.960
will be it for the day. Thank you very much for listening.

21:37.960 --> 21:55.960
So this is a great initiative. So what I'm wondering, like the single board computer or some other

21:55.960 --> 22:03.960
component, can it act as a USB device using the USB gadget subsystem, and can I, with the existing

22:03.960 --> 22:11.960
setup that you have, act both like switching between acting as a USB device and acting as a USB host,

22:11.960 --> 22:16.960
depending on the use case, using the same USB connection to the device of the test?

22:16.960 --> 22:23.960
I mean, I don't see why it's not possible. Like it depends on the single board computer that you're

22:23.960 --> 22:30.960
using, it needs to have a USB, and what single board computer are you using? That could also be a question.

22:30.960 --> 22:37.960
Yeah, I mean, again, for our cases, we got the Rock5Bs, for instance, in this board, which actually does support

22:37.960 --> 22:46.960
USB gadget. But the actual setup of testing the box is not limited to the Rock5B. You can put any system as you want,

22:46.960 --> 22:51.960
as I say, it's modular, so you can actually change it for Raspberry Pi, or a much more beefier compute if you want.

22:51.960 --> 22:58.960
Okay, so it's okay to ask, like how does it connect to the board? How do they connect with the interface?

22:58.960 --> 23:07.960
Just a USB cable. Okay, perfect. Single USB cable.

23:07.960 --> 23:14.960
So, really cool project. It's really interesting thinking about testing hardware, so I have no idea, so this is probably a

23:14.960 --> 23:21.960
question from ignorance, but when it comes to sort of what you call a test rig, how close do you get to, like,

23:21.960 --> 23:27.960
some mechanical hardware where something's moving, and at which point do you have to worry about state control?

23:27.960 --> 23:32.960
You say you have to flash the whole thing, but as soon as you've got hardware in the loop, you've got a state of not just

23:32.960 --> 23:39.960
the electronics, but you've got a state of the hardware, and that's where we've thought about this and decided to let somebody else

23:39.960 --> 23:43.960
think about it, and I hope that's you.

23:43.960 --> 23:46.960
It depends. I've got a mic, so you're off.

23:46.960 --> 23:51.960
Sure, so essentially in this case, like, we try to get as close to the production hardware as possible.

23:51.960 --> 23:59.960
Of course, it is hard to kind of test a moving car, per se, you know, so the idea behind the Cinebox is, as we'll explain

23:59.960 --> 24:06.960
in the testing progression, that we want to get as close as possible to a testing environment, so when you actually go to

24:06.960 --> 24:14.960
test and deploy to the production environment, you find as less bugs as you can, but yes, certain bugs will slip through,

24:14.960 --> 24:24.960
but the more closer you can get in your testing rig, the better it will be when you actually deploy to the end car.

24:24.960 --> 24:35.960
Okay, yeah, very cool. Do you support or have plans to support acting as a SD card for system booting from SD card?

24:35.960 --> 24:39.960
So that is, again, implemented in detail of your tests.

24:39.960 --> 24:49.960
Testing in a box is a multi-tool, so if your actual device supports booting from that, that shouldn't be a problem.

24:49.960 --> 24:54.960
Again, that's implementation in detail of how you want to do your tests.

24:54.960 --> 25:01.960
Booting from SD card. When you say, booting from SD card, do you mean, does any of our hardware boot from an SD card, or?

25:02.960 --> 25:06.960
The device and the test moves from the SD card that image has.

25:06.960 --> 25:09.960
Yeah, I mean, again, as I say, that's an implementation thing, so.

25:09.960 --> 25:16.960
The question was, can the device and the test boot from an SD card?

25:16.960 --> 25:21.960
Yeah, I think my answer is the same. It's an information in detail to the actual thing.

25:22.960 --> 25:29.960
Yeah, so there are various bits of hardware out there for mocking an SD card.

25:29.960 --> 25:39.960
We don't have any examples with that, but if you had something like that, you could potentially use the USB hub to facilitate something like that.

25:39.960 --> 25:48.960
All of the devices that we have allow you to flash the root file system through some kind of GPIO manipulation to put it into a reset mode, and then you can flash it like that.

25:48.960 --> 26:00.960
So the more modern Raspberry Pi's allow you to flash them by putting them into a reset mode, so you don't have to mock the SD card and the more sophisticated rigs we have also support that.

26:00.960 --> 26:08.960
However, if you did really need to do that, then there is hardware out there that we don't currently use in this example.

26:08.960 --> 26:15.960
But if you were doing that, then please send us some patches and we will add documentation for that for the system.

26:15.960 --> 26:19.960
So thank you.

26:19.960 --> 26:29.960
So I noticed that this is extremely neat and modular and self-contained and it's very easy to see what it's doing.

26:29.960 --> 26:33.960
Why is something like this not standard in history?

26:33.960 --> 26:41.960
Because in consumer electronics and in medical, big mess of wires is the standard testing rig and apparently automotive as well.

26:41.960 --> 26:45.960
So why is everyone tolerating this?

26:45.960 --> 26:51.960
Do you want to?

26:51.960 --> 27:03.960
That's a good question. I think some of it comes down to the fact that everyone thinks this is secret source and they spend huge amounts of money on things that are very niche and custom.

27:03.960 --> 27:13.960
So the way that we're developing this is that we think these are really important things to have and so we're working on them.

27:13.960 --> 27:23.960
And like I said, these are tools, so we think that tools should be in the open, so we're doing it in the open and that means we can collaborate and we can all work together on them.

27:23.960 --> 27:29.960
But when things are in little silos, then often the tools are the things that get hurt the most.

27:29.960 --> 27:41.960
So I would say that I think there's a lot of secret source or perception, someone else was talking about secret source before and it was a perception of secret source being really valuable but maybe it's not.

27:41.960 --> 27:51.960
So yeah, I think it's a really good question and maybe it would be better pointed at the OEMs to get themselves together.

27:51.960 --> 27:53.960
Did you want to say something?

27:53.960 --> 27:55.960
I was just saying lines.

27:55.960 --> 28:07.960
Okay, so it's a cool project but if I want to participate in it, could I just buy ready made boards or do I have to make them myself?

28:07.960 --> 28:19.960
So we publish all of the files that you need to go and ask a standard FAB to make them.

28:19.960 --> 28:31.960
So you can take the files from our project, go to a fab of your choice dot com, upload the files and in a few weeks you'll have them.

28:31.960 --> 28:43.960
We are in the process of hopefully CE marking this, so that gives us potential for selling them directly to people.

28:43.960 --> 28:57.960
But in order to make that economically successful we need to move a lot of the items and so I'm not sure if that will happen but we want to make it as easy as possible for everyone to collaborate.

28:57.960 --> 29:03.960
Yeah, if you want to buy them then not from us but we make it very easy for you to do that.

29:03.960 --> 29:11.960
Well, making a small batch production is expensive.

29:11.960 --> 29:16.960
So I was thinking that maybe you make thousands of them just sell to...

29:16.960 --> 29:35.960
In theory but some of the cheap hobby fabs, so this is all chi-cad, if you've got a little chi-cad project and you want it made, you send it off to China or somewhere like that and you get it back not actually that expensive.

29:35.960 --> 29:44.960
I think those companies that are set up for those small batches, if you wanted... how do I word this?

29:44.960 --> 29:59.960
If you wanted a dongle for this that was custom to automotive you might have to pay a few hundred pounds for that custom thing whereas you can get five of these for like a hundred quid or something like that.

29:59.960 --> 30:11.960
So yeah, it's not nothing but actually if you're interested in this niche stuff I hope it's not too high a barrier to entry.

30:12.960 --> 30:24.960
And if you're really interested in helping us out, I don't know. Some of these have made their way out of CoatThink into the wild so I don't know.

30:25.960 --> 30:29.960
Okay, thank you very much for a very interesting talk.

30:29.960 --> 30:55.960
So that concludes the open hardware dev room for 2024. As you make your way out, if you want mine looking down at the floor and if there's any paper or anything that moves, if you want mine picking it up, bringing it with you to one of the garbage cans, we also have a bag up here.

30:55.960 --> 31:12.960
So anything that you find on the way out the door, I also wanted to very definitely thank the other folks who were critical in making this dev room happen. Ian and Clement and John and Wayne.

31:12.960 --> 31:18.960
This is not an individual effort so thank you very, very much for all your help.

