WEBVTT

00:00.000 --> 00:07.000
So welcome to our next speaker, James will talk about TPM.

00:14.000 --> 00:15.000
Please.

00:15.000 --> 00:21.000
Hi everybody. This is completely different from the TPM talk I gave yesterday.

00:21.000 --> 00:26.000
But for those of you who didn't see yesterday, this is all my contact details.

00:26.000 --> 00:31.000
So I've got the usual email, a Fediverse link.

00:31.000 --> 00:35.000
I have been working on the kernel for a long time.

00:35.000 --> 00:41.000
I began in SCSI. I've gone through doing architecture maintenance for PA RITS.

00:41.000 --> 00:44.000
I had a long spell doing containers for parallels.

00:44.000 --> 00:49.000
And finally, I've become a reluctant TPM coder.

00:49.000 --> 00:55.000
And pretty much everybody who codes for the TPM always describes themselves as a reluctant TPM coder.

00:55.000 --> 01:01.000
As far as I can tell, there's no one who actually wants to be known as somebody who actually likes to code for the TPM.

01:01.000 --> 01:05.000
All my contact details are here.

01:05.000 --> 01:12.000
My blog site is about the best source of information for most of the stuff that goes on in the TPM.

01:12.000 --> 01:16.000
Unfortunately, I'm very sort of gadfly stream of consciousness.

01:16.000 --> 01:22.000
So you'll find a ton of stuff on my blog that you're probably not interested in, like legal stuff, Android phones,

01:22.000 --> 01:25.000
whatever else I happened to be working on last week.

01:25.000 --> 01:27.000
But I do try and tag it all.

01:27.000 --> 01:31.000
So there is a TPM tag if you're looking for TPM stuff you can go through.

01:31.000 --> 01:33.000
It's my matrix ID.

01:33.000 --> 01:37.000
And if you need my GPG key, I don't need to do a fingerprint anymore because I do overdain,

01:37.000 --> 01:45.000
which is a DNS sec extension for securely actually identifying me from the domain address of my email.

01:45.000 --> 01:51.000
This is the exact command I was arguing with Linus over about last week when my key had expired

01:51.000 --> 01:54.000
and you couldn't find the new one.

01:54.000 --> 02:03.000
So if we go to the basics of a TPM, it's effectively a separate shielded memory processing device.

02:03.000 --> 02:05.000
This is what one looks like.

02:05.000 --> 02:07.000
This here is actually the TPM chip.

02:07.000 --> 02:11.000
And this big thing here is the low pin count bus connector.

02:11.000 --> 02:13.000
So the chip itself is really tiny.

02:13.000 --> 02:17.000
And often it's actually sold it onto the motherboard.

02:17.000 --> 02:20.000
And they've been around for quite a long time.

02:20.000 --> 02:23.000
TPM 2.0 has agile cryptography.

02:23.000 --> 02:26.000
TPM 1.2 is actually obsolete.

02:26.000 --> 02:30.000
But a lot of you in this room will still have TPM 1.2 in your laptops.

02:30.000 --> 02:34.000
All you have to remember is don't use it.

02:34.000 --> 02:39.000
The actual TPM functions are shielded or asymmetric key handling,

02:39.000 --> 02:41.000
which is where you have a private key.

02:41.000 --> 02:47.000
The private key is only visible to the inside of the TPM and it never comes out, which is why it's shielded.

02:47.000 --> 02:49.000
They can do things like measurements.

02:49.000 --> 02:53.000
So you've seen things like EIMA on various slides.

02:53.000 --> 02:55.000
That's measurement that we do within the kernel.

02:55.000 --> 02:59.000
They can do data sealing, which is effectively for symmetric keys.

02:59.000 --> 03:04.000
The TPM is over such a slow bus and it's such a slow processing engine

03:04.000 --> 03:10.000
that it can do asymmetric primitives itself, but not fast enough for things like disk encryption.

03:10.000 --> 03:14.000
So the way we do disk encryption is if you use a key sealed to the TPM,

03:14.000 --> 03:18.000
it's in a TPM shielded blob, when the conditions are right,

03:18.000 --> 03:21.000
the TPM will actually give the symmetric key to the kernel

03:21.000 --> 03:25.000
and the kernel does all the symmetric primitives, meaning we can do it fast enough.

03:25.000 --> 03:27.000
And this is called data sealing.

03:27.000 --> 03:30.000
And then the final function a TPM has is attestation.

03:30.000 --> 03:32.000
If you're using a TPM for measurements,

03:32.000 --> 03:35.000
you have to prove to somebody else the measurements for what they thought

03:35.000 --> 03:38.000
that's done by an attestation function.

03:38.000 --> 03:42.000
The kernel itself really only does measurement and data sealing.

03:42.000 --> 03:47.000
And actually I got a question yesterday from Ignat Kochagin, who I think is here,

03:47.000 --> 03:52.000
demanding to know why the hell we didn't do shielded key handling in the kernel,

03:52.000 --> 03:57.000
because the kernel has a crypto subsystem, which actually now does asymmetric keys.

03:57.000 --> 04:01.000
So it would be a candidate for actually using the TPM functions for that.

04:01.000 --> 04:04.000
The truth really is that I've put it on my to-do list,

04:04.000 --> 04:09.000
and if we actually get lifetime expanding medical care, I will have time to do it,

04:09.000 --> 04:13.000
but otherwise it's probably not going to happen unless somebody else does it.

04:13.000 --> 04:19.000
Because my to-do list is about a million items long now, but I'm thinking about it.

04:19.000 --> 04:21.000
Let's see.

04:21.000 --> 04:25.000
Oh yeah, the reason you shouldn't use TPM 1.2 is because it had SHA-1,

04:25.000 --> 04:28.000
which is now a fully compromised hash.

04:28.000 --> 04:33.000
TPM 2 generates what's called an internal seed instead of a key.

04:33.000 --> 04:36.000
So usually with TPM 1, when you turned it on,

04:36.000 --> 04:40.000
it generated an RSA, public-private key pair for its root key.

04:40.000 --> 04:42.000
TPM 2.0 doesn't do that.

04:42.000 --> 04:47.000
It generates what's called an internal seed, which is just a long string of random numbers.

04:47.000 --> 04:54.000
And then what it does is it uses a key derivation to go from that long string of random numbers to an actual key pair.

04:54.000 --> 05:01.000
And the point about a key derivation function is it takes one number as an input and outputs a key pair.

05:01.000 --> 05:07.000
And the point is that as long as you use the same number as the input, it always outputs the same key pair.

05:07.000 --> 05:14.000
So for RSA, this means that what you're actually doing is trying to find primes,

05:14.000 --> 05:16.000
which actually makes the thing really slow.

05:16.000 --> 05:21.000
So this is why we tend to use elliptic curve keys with TPMs rather than RSA keys,

05:21.000 --> 05:24.000
because they actually have difficulty finding it.

05:24.000 --> 05:30.000
One function actually the kernel uses the TPM for is secure random number generators.

05:30.000 --> 05:35.000
All TPMs have to have a cryptographically secure random number generator,

05:35.000 --> 05:40.000
because one of their usual functions is actually generating key pairs, generating these seeds.

05:40.000 --> 05:49.000
And so we actually use, on boot, the TPM's random number generator to add entropy to the kernel entropy pool.

05:49.000 --> 05:54.000
If you re-own the TPM, it actually changes its storage seed.

05:54.000 --> 06:01.000
And this is useful because a key is hanging off the root, the storage key sits at the top of the hierarchy.

06:01.000 --> 06:05.000
Every other key you use in the TPM, sealed data, hang off this.

06:05.000 --> 06:10.000
And by hang off, what I really mean is the encryption wrapping for that key,

06:10.000 --> 06:16.000
when it's reduced to, comes outside the TPM, is a function of that storage seed.

06:16.000 --> 06:20.000
If that changes, all of the wrappings are unreadable by the TPM,

06:20.000 --> 06:22.000
and effectively all of those keys are shredded.

06:22.000 --> 06:29.000
So every time you re-own a TPM, you destroy all the keys that were created for that TPM previously.

06:29.000 --> 06:35.000
And so, like me, you use your TPM for, you know, not quite hundreds of keys, but definitely tens of keys.

06:35.000 --> 06:38.000
And, you know, I'm just giving away my laptop.

06:38.000 --> 06:42.000
It's a single operation to shred all of those keys as though they never existed.

06:42.000 --> 06:49.000
Keys to be inserted into the TPM are based on this parent thing.

06:49.000 --> 06:51.000
Actually, that's pretty much what I just explained.

06:51.000 --> 06:53.000
And only the TPM can decrypt them.

06:53.000 --> 06:59.000
So this gives, and the encryption algorithm for TPM 2 is AES 256.

06:59.000 --> 07:05.000
So it's got 256 bits of security as long as AES isn't compromised, it should be pretty good.

07:05.000 --> 07:11.000
State of play is that the TPM itself is really hard to use and really hard to program.

07:11.000 --> 07:15.000
We currently have two completely different library implementations.

07:15.000 --> 07:18.000
They're actually based on two different TPM standards.

07:18.000 --> 07:23.000
Both produced by the TCG, the Trusted Computing Group, but at different levels.

07:23.000 --> 07:29.000
So the Intel library conforms to the sort of upper library specification,

07:29.000 --> 07:35.000
and the IBM one conforms to the lower TPM library specification.

07:35.000 --> 07:39.000
But they're both in user space, so when I did the kernel coding, I couldn't use them anyway.

07:39.000 --> 07:42.000
So this is why I'm a really reluctant TPM coder,

07:42.000 --> 07:46.000
because effectively I had to rewrite all of these library functions.

07:46.000 --> 07:51.000
Now, I don't really want to get into which standard is better, war,

07:51.000 --> 07:54.000
but I actually followed the same standard the IBM one used,

07:54.000 --> 07:57.000
because for low level functions it's much simpler.

07:57.000 --> 08:01.000
And if there's one thing I can't stand, it's being overly complicated,

08:01.000 --> 08:06.000
because it just generates scads of code and I really don't have the time for it.

08:06.000 --> 08:12.000
But that means I also had to rewrite all the cryptographic primitives in this.

08:12.000 --> 08:17.000
And so I have a TPM session handler file that actually contains

08:17.000 --> 08:21.000
all of these cryptographic primitives for the TPM to use.

08:21.000 --> 08:26.000
One of the useful things to go back to the original question about shielded key handling

08:26.000 --> 08:30.000
is that with all of this cryptographic crap in the kernel now,

08:30.000 --> 08:35.000
it will actually be much easier to write shielded key handling for the kernel crypto routines,

08:35.000 --> 08:39.000
because they can piggyback off all of this, which is going to be quite useful.

08:39.000 --> 08:44.000
So the kernel TPM currently is used as well as the random number generator.

08:44.000 --> 08:49.000
It's used for I'm a measurement, entropy seeding, and this thing called trusted keys.

08:49.000 --> 08:54.000
So trusted keys are effectively TPM sealed data blobs that you can pass into the kernel,

08:54.000 --> 08:59.000
and the kernel will give you back as a TPM sealed data blob if you really want.

08:59.000 --> 09:05.000
And the good thing is that Lux disk encryption can actually use these sealed data blobs.

09:05.000 --> 09:08.000
The reason you'd want to use this is for key protection,

09:08.000 --> 09:12.000
because if you keep a TPM shielded key in user space,

09:12.000 --> 09:16.000
and at some point you're going to pass it into the kernel along with its authority,

09:16.000 --> 09:19.000
the point is that key is only ever unwrapped in the kernel,

09:19.000 --> 09:23.000
which is the most trusted entity in an entire Linux system.

09:23.000 --> 09:27.000
It means you don't get it unwrapped in user space and then have the risk that

09:27.000 --> 09:31.000
if you get a user space compromise, they can run off with your disk encryption key.

09:31.000 --> 09:35.000
In order to get at your disk encryption key, they actually have to compromise the kernel.

09:35.000 --> 09:38.000
So it improves the security boundaries.

09:41.000 --> 09:46.000
And the kernel itself exports a TPM device to user space,

09:46.000 --> 09:50.000
and all user space programs use this to send commands over.

09:50.000 --> 09:57.000
The original device was Dev TPM 0, but TPM 2.0 requires something called a resource manager.

09:57.000 --> 10:01.000
It actually technically virtualizes the keys in the TPM,

10:01.000 --> 10:05.000
because a TPM 2.0 has a really, really tiny internal key store.

10:05.000 --> 10:07.000
It can actually store three keys only.

10:07.000 --> 10:12.000
And so if you have multiple users of the TPM, each trying to insert their own keys for use,

10:12.000 --> 10:14.000
you'd rapidly run out of memory.

10:14.000 --> 10:19.000
And so we have a resource manager that basically allows one user at a time to use the TPM.

10:19.000 --> 10:23.000
And they don't see it, but behind the scenes when we switch between those users,

10:23.000 --> 10:28.000
we just take all of the keys out and store them in memory, in the computer's main memory,

10:28.000 --> 10:32.000
so that every user effectively gets an empty TPM to insert their keys in,

10:32.000 --> 10:35.000
so we don't run out of keys, key slots.

10:35.000 --> 10:38.000
And this has been built into the kernel for a long time.

10:38.000 --> 10:42.000
It's called Dev TPM Resource Manager, RM0,

10:42.000 --> 10:46.000
and pretty much every TPM library uses this to communicate with the kernel,

10:46.000 --> 10:49.000
so they don't get out of memory key clashes.

10:49.000 --> 10:56.000
And it works just fine, except for the Intel TPM people complain about it doesn't do session de-gapping.

10:56.000 --> 11:03.000
It's also on my list. I will get around to it, provided medical science comes up with a stretch for at least two lifetimes.

11:03.000 --> 11:07.000
Or somebody from Intel could actually submit the patches and we just do it.

11:07.000 --> 11:09.000
The only reason the current...

11:09.000 --> 11:14.000
So this session de-gapping means that you can't context save sessions for a long period of time,

11:14.000 --> 11:21.000
because if the TPM runs around what's called its sessions clock, it hits a gapping error and nothing works again.

11:22.000 --> 11:26.000
The way around it is you actually have to save and restore the session.

11:26.000 --> 11:30.000
We just don't do that. We could, but I mean nobody's written the patches.

11:30.000 --> 11:33.000
So TPM security.

11:33.000 --> 11:37.000
There's lots of sensitive information going on to the TPM.

11:37.000 --> 11:41.000
So if you're concerned about cryptographic randomness,

11:41.000 --> 11:44.000
the random number we got from the TPM should be a secret.

11:44.000 --> 11:48.000
If anybody snoops that, they can figure out what the kernel's entropy pool looks like,

11:48.000 --> 11:52.000
and therefore all of the secrets that it was generating itself.

11:52.000 --> 11:57.000
If you're doing data sealing, the data will come back to you over the TPM bus in raw format,

11:57.000 --> 12:02.000
and anybody snooping the bus will see the key you sealed, which is pretty bad.

12:02.000 --> 12:08.000
And the point is that you cannot necessarily be assured of a secure channel to the TPM.

12:08.000 --> 12:13.000
Most of them sit on this low-pin count bus, and attacks actually exist that snoop this bus.

12:13.000 --> 12:18.000
So a Canadian company came up with a little dongle that you just simply plug into a laptop,

12:18.000 --> 12:23.000
and helpfully most laptops have a little LPC slot in them, so you just slot this thing in,

12:23.000 --> 12:27.000
and it will snoop the TPM bus. Pretty bad, but it's an evil maid attack in theory,

12:27.000 --> 12:31.000
because you actually have to have physical access to the laptop to see it.

12:31.000 --> 12:35.000
And so I'd probably notice if someone were actually trying to insert that in my laptop.

12:35.000 --> 12:39.000
The problem is the LPC bus contains a lot of weird and wonderful devices,

12:39.000 --> 12:43.000
like keyboard, mice, other weird things, that are actually programmable.

12:43.000 --> 12:47.000
And one of the fears we have is that this attack has been generated,

12:47.000 --> 12:51.000
and you could actually, instead of having to plug a snooping dongle into my LPC bus,

12:51.000 --> 12:56.000
just reprogram one of these reprogramable devices to do the snooping for you,

12:56.000 --> 13:00.000
and what we think is a local attack suddenly becomes a remote attack.

13:00.000 --> 13:08.000
So securing the TPM bus has been priority number one for pretty much everybody doing TPM work for quite a while.

13:08.000 --> 13:13.000
The problem is that the way the Linux kernel currently uses the TPM is completely insecure,

13:13.000 --> 13:19.000
so we're vulnerable to these snooping attacks.

13:19.000 --> 13:22.000
And this is done by using something called TPM sessions.

13:22.000 --> 13:27.000
It makes handling the TPM in the kernel much more complicated,

13:27.000 --> 13:31.000
but I have written all the patches, I'm just trying to get them upstream at the moment.

13:31.000 --> 13:37.000
What it really does is just an ECDH, elliptic curved if you helman key exchange with the TPM,

13:37.000 --> 13:41.000
and then pretty much everything goes over an encrypted channel using this.

13:41.000 --> 13:45.000
I mean, it's not difficult to describe, it's just difficult to do.

13:45.000 --> 13:53.000
And one of the useful things we get once I add sessions to the kernel to do this encryption

13:53.000 --> 13:57.000
is we can also use the sessions now to do key policy.

13:57.000 --> 14:01.000
Key policy is actually a very interesting thing that I'll come to later,

14:01.000 --> 14:05.000
but it does make the whole thing way, way more complicated.

14:05.000 --> 14:09.000
And like I said, the kernel is currently insecure when it uses the TPM.

14:09.000 --> 14:15.000
And these patches I actually did first write in 2018,

14:15.000 --> 14:19.000
so they have technically been around for almost six years.

14:19.000 --> 14:22.000
Trying to get them upstream has been a long, long slog.

14:22.000 --> 14:26.000
I'm hoping that the end is currently almost in sight,

14:26.000 --> 14:30.000
or at least the TPM maintainer has been making positive noises,

14:30.000 --> 14:32.000
which he hasn't for the last six years.

14:32.000 --> 14:36.000
So, you know, if the wind's in the right direction, we might get this.

14:36.000 --> 14:40.000
One of the patches I got up early was standardizing key file format.

14:40.000 --> 14:46.000
So the format that the kernel uses for TPM keys is exactly the same as the format

14:46.000 --> 14:48.000
that all of the user space tools use.

14:48.000 --> 14:52.000
So you can actually use any of the user space key sealing tools

14:52.000 --> 14:55.000
to generate a sealed key for the kernel, which is really useful,

14:55.000 --> 14:58.000
because now we don't have to have religious wars about what tool is best.

14:58.000 --> 15:01.000
Anybody can choose any tool.

15:01.000 --> 15:07.000
And the idea behind this is that since we've had all of these schisms

15:07.000 --> 15:10.000
over what TSS, what library should you use,

15:10.000 --> 15:13.000
as long as the key format is the same,

15:13.000 --> 15:16.000
I honestly don't have to care about all of this crap.

15:16.000 --> 15:19.000
So, you know, anybody can use any tool, any tool chain.

15:19.000 --> 15:22.000
You know, you can be partisan for the Intel one or the IBM one.

15:22.000 --> 15:23.000
It doesn't matter.

15:23.000 --> 15:25.000
They'll still produce keys in the same format.

15:25.000 --> 15:26.000
It will still just work.

15:26.000 --> 15:27.000
This is great.

15:27.000 --> 15:32.000
And all producers and consumers except System D have agreed to standardize on this.

15:32.000 --> 15:36.000
And the key standard is actually sitting there.

15:36.000 --> 15:37.000
Sorry.

15:37.000 --> 15:40.000
Should have put my phone on to do not disturb.

15:40.000 --> 15:42.000
That was bad of me.

15:42.000 --> 15:45.000
And this standard is actually patchable.

15:45.000 --> 15:47.000
So if you see something that's missing or you want to use,

15:47.000 --> 15:50.000
you just send a patch to the...

15:51.000 --> 15:55.000
It's actually the OpenSSLTPM Engine list,

15:55.000 --> 15:57.000
and I'll just add it if it looks useful.

15:57.000 --> 16:00.000
And we're hoping it will eventually become an RFC.

16:00.000 --> 16:02.000
Becoming an RFC is very difficult.

16:02.000 --> 16:05.000
A guy called David Woodhouse, who's also a kernel programmer,

16:05.000 --> 16:09.000
is currently going through the pain of doing it for a different standard.

16:09.000 --> 16:11.000
And I'm just waiting to see what happens to him.

16:11.000 --> 16:13.000
And if he comes back in less than three pieces,

16:13.000 --> 16:16.000
I will try the process as well.

16:17.000 --> 16:21.000
So like I said, the kernel trusted keys already use this key format,

16:21.000 --> 16:24.000
so we're fully interoperable, which is useful.

16:24.000 --> 16:28.000
And one of the things this interoperability gives us

16:28.000 --> 16:31.000
is actually the ability to seal kernel keys

16:31.000 --> 16:34.000
without having access to the kernel's TPM.

16:34.000 --> 16:38.000
This is actually a function of a TPM called import and export of a key.

16:38.000 --> 16:42.000
So as long as I know the public storage root key of my TPM,

16:42.000 --> 16:45.000
I can actually create a key that's cryptographically sealed

16:45.000 --> 16:47.000
and the TPM itself can import it,

16:47.000 --> 16:50.000
and I don't even need access to the TPM to create the key.

16:50.000 --> 16:55.000
Because usually the format of the TPM key is very specific to the TPM.

16:55.000 --> 16:58.000
You can't create it because it's symmetrically encrypted.

16:58.000 --> 17:03.000
So these exportable keys actually have to be asymmetrically encrypted

17:03.000 --> 17:05.000
with the public-private key pair,

17:05.000 --> 17:08.000
making them slightly more difficult to use by the TPM,

17:08.000 --> 17:11.000
more complicated, more difficult to unwrap.

17:11.000 --> 17:14.000
But it gives you the advantage that if you're,

17:14.000 --> 17:16.000
let's say, your use case is in the cloud,

17:16.000 --> 17:20.000
and one of the things you're trying to do is release keys to a cloud TPM,

17:20.000 --> 17:22.000
you can just in your key release program say,

17:22.000 --> 17:25.000
okay, so the storage root key of this TPM is this.

17:25.000 --> 17:28.000
I'll wrap the key to that, just hand it off to the TPM,

17:28.000 --> 17:31.000
and the kernel will just boot.

17:31.000 --> 17:33.000
So, future patches.

17:33.000 --> 17:35.000
What are we going to do with this TPM in future?

17:35.000 --> 17:38.000
Once I've finally finished getting session encryption upstream,

17:38.000 --> 17:40.000
which is sort of the number one priority,

17:40.000 --> 17:43.000
because it's really hot right now that the kernel is the only thing

17:43.000 --> 17:46.000
which is insecure when using the TPM.

17:46.000 --> 17:48.000
And the first one is going to be key policy,

17:48.000 --> 17:50.000
which is a natural follow-on,

17:50.000 --> 17:53.000
because I already had to put all of the session handling code

17:53.000 --> 17:55.000
and the TPM to do encryption.

17:55.000 --> 17:57.000
Policy is just a fairly simple add-on to this.

17:57.000 --> 17:59.000
So the patches are only, I think,

17:59.000 --> 18:05.000
my current cryptographic patch for the kernel expands over a thousand lines.

18:05.000 --> 18:08.000
The policy patch on top of this looks like a couple of hundred lines,

18:08.000 --> 18:11.000
so it should be pretty easy to do.

18:11.000 --> 18:14.000
Once we have policy, the nice thing we can then do

18:14.000 --> 18:19.000
is create keys that can never leave the kernel by policy.

18:19.000 --> 18:22.000
And the way we do this is by using a feature of a TPM,

18:22.000 --> 18:27.000
oh, can do this, so we can use a feature of a TPM called a locality,

18:27.000 --> 18:30.000
which means that the TPM actually,

18:30.000 --> 18:33.000
TIS TPM has registers mapped at several different locations.

18:33.000 --> 18:36.000
When you use a location,

18:36.000 --> 18:38.000
each of these locations is called a locality.

18:38.000 --> 18:40.000
When you use the mapping of that locality,

18:40.000 --> 18:42.000
the TPM is sits of that locality.

18:42.000 --> 18:46.000
The way you're supposed to use it is just to block out the mapping

18:46.000 --> 18:48.000
so that nobody can use it,

18:48.000 --> 18:50.000
and the TPM is sealed of that locality.

18:50.000 --> 18:52.000
For the kernel, it's really easy,

18:52.000 --> 18:54.000
because all user space uses the kernel device.

18:54.000 --> 18:56.000
They can't talk to the TPM directly,

18:56.000 --> 18:59.000
so all user space only talks to the TPM at locality zero.

18:59.000 --> 19:01.000
The kernel ensures this.

19:01.000 --> 19:04.000
And if the kernel talks to the TPM at a different locality,

19:04.000 --> 19:06.000
we know whether your kernel or user space

19:06.000 --> 19:08.000
by the locality you're talking at,

19:08.000 --> 19:10.000
and we can have a policy that says

19:10.000 --> 19:13.000
this key can only be unwrapped at kernel locality,

19:13.000 --> 19:15.000
which means if I try to unwrap it in user space,

19:15.000 --> 19:17.000
the TPM will give me an error.

19:17.000 --> 19:19.000
So effectively, it gives you a key

19:19.000 --> 19:21.000
that can never actually leave the kernel,

19:21.000 --> 19:25.000
which is another useful property for security boundaries.

19:25.000 --> 19:28.000
The problem with this locality scheme,

19:28.000 --> 19:30.000
we thought it was brilliant and easy,

19:30.000 --> 19:33.000
and actually, I'm not the only person who's pissed off about this.

19:33.000 --> 19:35.000
The other thing that I think is really garrulous about

19:35.000 --> 19:38.000
is Intel locked all of the localities apart from zero

19:38.000 --> 19:41.000
unless you do a trusted execution launch, TXT launch,

19:41.000 --> 19:43.000
which is really, really annoying,

19:43.000 --> 19:46.000
because pretty much no one in the world does this.

19:46.000 --> 19:49.000
So we all have these TPMs that have the locality shut off,

19:49.000 --> 19:53.000
and nobody's using TXT, and you just look at Intel and go,

19:53.000 --> 19:55.000
well, nobody uses this crap feature.

19:55.000 --> 19:58.000
Can you just unlock the localities because it serves no purpose?

19:58.000 --> 20:01.000
But unfortunately, we can't get to it.

20:01.000 --> 20:04.000
Today, if I get... Yeah, I should get around to the demo.

20:04.000 --> 20:06.000
I blew through my demo time yesterday.

20:06.000 --> 20:10.000
I'm actually... I have a kernel that operates at locality 2,

20:10.000 --> 20:14.000
and I will demo it, but pretty much it won't work on any of your laptops,

20:14.000 --> 20:17.000
and we have to use alternative means for sealing the keys.

20:17.000 --> 20:20.000
So the alternative way that I'm thinking of doing this

20:20.000 --> 20:24.000
is to reserve a range of NV indices for kernel access only.

20:24.000 --> 20:27.000
Because you can only communicate from user space to the kernel

20:27.000 --> 20:29.000
using the TPM device,

20:29.000 --> 20:31.000
we can snoop the commands,

20:31.000 --> 20:33.000
and if you try and access these NV indices,

20:33.000 --> 20:35.000
we can just say, no, you can't do that.

20:35.000 --> 20:39.000
So effectively, we're behaving like a locality, but for NV indices.

20:39.000 --> 20:44.000
And then what I can do is I can get the kernel to take one of those NV indices

20:44.000 --> 20:48.000
and just put a random password in that index that's known only to the kernel,

20:48.000 --> 20:51.000
and then seal a TPM key that says,

20:51.000 --> 20:56.000
only the person who knows this NV index password can unseal the key,

20:56.000 --> 20:58.000
only the kernel knows that password,

20:58.000 --> 21:00.000
only the kernel will be able to seal the key.

21:00.000 --> 21:04.000
So even if we can't get Intel to cooperate on localities,

21:04.000 --> 21:06.000
which would be the cleanest and best way of doing this,

21:06.000 --> 21:09.000
we have alternative ways of actually enforcing

21:09.000 --> 21:13.000
that only the kernel would be able to unwrap the key.

21:13.000 --> 21:16.000
And this hopefully will be in future patches as well.

21:19.000 --> 21:21.000
And let's see.

21:22.000 --> 21:24.000
Key policy.

21:24.000 --> 21:27.000
TPM2.0 really supports a very rich policy language.

21:27.000 --> 21:29.000
I'll demonstrate some of it.

21:29.000 --> 21:32.000
It can have policies on time of day, reset count,

21:32.000 --> 21:35.000
you know, how many times this thing been rebooted,

21:35.000 --> 21:37.000
what are the values of certain PCRs,

21:37.000 --> 21:40.000
what are the secrets embedded in this object,

21:40.000 --> 21:43.000
what is our value of an NV index, and so on.

21:44.000 --> 21:47.000
This policy can be both AND based and OR based,

21:47.000 --> 21:51.000
so you can have these sort of huge lists of do this and this and this

21:51.000 --> 21:54.000
or do this and this and this or etc.

21:54.000 --> 21:59.000
Problem with this policy is it's described by a single hash value,

21:59.000 --> 22:02.000
which means it's burned into the key at creation time.

22:02.000 --> 22:05.000
And if you think about the way you might use policies

22:05.000 --> 22:08.000
if locking to PCRs, one of the things you do is

22:08.000 --> 22:11.000
I only want a certain set of kernels to boot

22:11.000 --> 22:13.000
and then unlock my root key,

22:13.000 --> 22:16.000
so I'm trying to lock the policy to the PCRs of the kernels,

22:16.000 --> 22:19.000
but I can't predictably know in the future

22:19.000 --> 22:22.000
what the hash value of a kernel will be, you know,

22:22.000 --> 22:24.000
because it hasn't been created yet,

22:24.000 --> 22:28.000
so I need a way of actually updating the policy after the fact,

22:28.000 --> 22:32.000
and this single hash burned into the key doesn't quite cut it for that.

22:32.000 --> 22:37.000
But fortunately, the TPM actually has...

22:37.000 --> 22:40.000
Sorry, this is all about hash construction you don't need.

22:40.000 --> 22:44.000
The TPM actually has a thing called policy secrets,

22:44.000 --> 22:49.000
which allows you to actually execute a signed policy

22:49.000 --> 22:53.000
and add it after the fact to the key,

22:53.000 --> 22:55.000
because the burned-in policy says,

22:55.000 --> 22:58.000
and any other policy that is signed with this key

22:58.000 --> 23:00.000
you shall accept as well,

23:00.000 --> 23:03.000
and then you just keep adding these signed policies to the key,

23:03.000 --> 23:06.000
and hopefully I should be able to demonstrate that as well.

23:06.000 --> 23:10.000
So, let's see, I have 15 minutes left for a demo.

23:10.000 --> 23:13.000
Let's see if I can actually do this.

23:13.000 --> 23:19.000
So, let's get that out of the way.

23:19.000 --> 23:24.000
So, this is...

23:24.000 --> 23:25.000
Everybody can read that.

23:25.000 --> 23:27.000
I don't think I can blow it up much further.

23:27.000 --> 23:29.000
Start the...

23:29.000 --> 23:37.000
So, in user space, I'm going to start the...

23:37.000 --> 23:40.000
TPM server, because I need a TPM for this,

23:40.000 --> 23:47.000
and then I'm going to go into a UFI TPM-based boot.

23:47.000 --> 23:52.000
So, this is actually booting a kernel, hopefully.

23:52.000 --> 23:54.000
And if I just check, yep,

23:54.000 --> 23:56.000
it's actually communicating with the TPM.

23:56.000 --> 24:04.000
It's always wise to check these sort of things.

24:04.000 --> 24:06.000
Okay, so that's my thing.

24:06.000 --> 24:18.000
I can log into it as root.

24:18.000 --> 24:19.000
So, there we go.

24:19.000 --> 24:22.000
I have a TPM that I'm emulating.

24:22.000 --> 24:25.000
This means that I have a non-standard patch here,

24:25.000 --> 24:27.000
because the kernel that I'm booting

24:27.000 --> 24:29.000
actually has these locality patches in it.

24:29.000 --> 24:32.000
So, the TPM I ran is actually now running

24:32.000 --> 24:34.000
at two separate localities.

24:34.000 --> 24:37.000
The user space of this kernel will be in locality zero,

24:37.000 --> 24:40.000
and the kernel is actually in locality two.

24:40.000 --> 24:45.000
So, I can demonstrate the keys that can't be unwrapped,

24:45.000 --> 24:47.000
except at the kernel in locality two.

24:47.000 --> 24:54.000
And let me also get a...

24:54.000 --> 24:58.000
So, this is a user login as me to this thing,

24:58.000 --> 25:04.000
and this is me...

25:04.000 --> 25:06.000
So, this actually just gives me a user space

25:06.000 --> 25:14.000
login to the software TPM in my home directory here.

25:14.000 --> 25:17.000
And so, what I can try and do is actually,

25:17.000 --> 25:19.000
if I get my demo scripts and remind myself

25:19.000 --> 25:23.000
what I was supposed to be doing,

25:23.000 --> 25:28.000
let's just do a very simple...

25:28.000 --> 25:33.000
So, this will just take a piece of data

25:33.000 --> 25:36.000
and seal it for the TPM.

25:36.000 --> 25:39.000
And, sorry.

25:39.000 --> 25:41.000
The data is actually 32 bits long.

25:41.000 --> 25:44.000
The problem with the TPM sealed data

25:44.000 --> 25:49.000
can be anything between one and 128 bytes long.

25:49.000 --> 25:51.000
But the kernel trusted key subsystem

25:51.000 --> 25:54.000
is assuming that you're passing in AES keys.

25:54.000 --> 25:58.000
So, it expects a key length of between 32 and 64 bytes.

25:58.000 --> 26:01.000
So, I just did that sort of randomly.

26:01.000 --> 26:06.000
If I go back to the user space login on the root,

26:06.000 --> 26:08.000
I should just be able to...

26:08.000 --> 26:10.000
Let me...

26:10.000 --> 26:16.000
Before I do this...

26:16.000 --> 26:18.000
We have to have trusted keys actually working

26:18.000 --> 26:20.000
before I can actually do them.

26:20.000 --> 26:23.000
And then...

26:23.000 --> 26:25.000
Oh, yes.

26:25.000 --> 26:28.000
There is another problem with the trusted keys.

26:28.000 --> 26:32.000
So, when I created that key,

26:32.000 --> 26:39.000
I created it...

26:39.000 --> 26:41.000
as effectively a PEM file

26:41.000 --> 26:44.000
because it's really used for the cryptography systems

26:44.000 --> 26:45.000
for OpenSSL.

26:45.000 --> 26:49.000
The kernel key system doesn't read PEM files.

26:49.000 --> 26:53.000
So, one of the things you can do is convert this to a dir file.

26:53.000 --> 26:57.000
So, if I did...

26:57.000 --> 26:59.000
If I looked at the dir file,

26:59.000 --> 27:03.000
that's the standard ASN1 format of a TPM key.

27:03.000 --> 27:04.000
Very easy.

27:04.000 --> 27:07.000
Problem, the kernel doesn't read these either.

27:07.000 --> 27:09.000
The way the kernel key system works

27:09.000 --> 27:16.000
is it actually wants a hex dump of the dir file.

27:16.000 --> 27:23.000
So, I have to do a reverse hex dump into a key file.

27:23.000 --> 27:26.000
So, that string of binaries is effectively

27:26.000 --> 27:29.000
exactly the same as the dir file.

27:29.000 --> 27:34.000
But this is the file that I now actually have to pass into the kernel.

27:34.000 --> 27:37.000
And so, inside the virtual machine,

27:37.000 --> 27:38.000
I can actually...

27:38.000 --> 27:40.000
I've inserted that key into the kernel.

27:40.000 --> 27:42.000
And the fact that I got a number back

27:42.000 --> 27:46.000
means that the...

27:46.000 --> 27:48.000
I can just look at the user key ring

27:48.000 --> 27:50.000
and you can see that I've got this key

27:50.000 --> 27:52.000
actually inserted into the kernel.

27:52.000 --> 27:54.000
So, I wrapped a key outside the kernel

27:54.000 --> 27:56.000
and I inserted it into the kernel.

27:56.000 --> 27:59.000
The usual way you do this is you actually get the kernel

27:59.000 --> 28:02.000
to create its own random key and then pass it back.

28:02.000 --> 28:04.000
And the problem with this format is

28:04.000 --> 28:10.000
the only way the kernel will pass the key back to you

28:10.000 --> 28:15.000
is by this thing called pipe.

28:15.000 --> 28:17.000
And for reasons best known to the kernel,

28:17.000 --> 28:19.000
it only pipes back hex strings.

28:19.000 --> 28:21.000
This is why you have to do the stupid conversion

28:21.000 --> 28:24.000
from PAM to dir to hex string,

28:24.000 --> 28:27.000
which is sort of one of the most annoying things of this.

28:27.000 --> 28:32.000
But let's get on to demoing a key policy.

28:32.000 --> 28:39.000
So, I created the key here.

28:39.000 --> 28:43.000
But what I'm now going to do is seal it to a PCR.

28:43.000 --> 28:49.000
And there's a very useful PCR, which is PCR 16,

28:49.000 --> 28:53.000
which is never used by anything because it's...

28:53.000 --> 28:55.000
Sorry.

28:55.000 --> 28:59.000
We'll use the SHA-256 on 16.

28:59.000 --> 29:00.000
It's always...it begins life as zero,

29:00.000 --> 29:03.000
nobody ever uses it because it's resettable.

29:03.000 --> 29:05.000
And resettable means I can wind it back.

29:05.000 --> 29:08.000
PCRs aren't supposed to be able to be wind back.

29:08.000 --> 29:13.000
But if I seal the key to this...

29:17.000 --> 29:19.000
Sorry.

29:19.000 --> 29:24.000
That's a PCR lock.

29:24.000 --> 29:27.000
So now I've locked this key to that PCR.

29:27.000 --> 29:34.000
I can actually unlink the...

29:34.000 --> 29:39.000
That key and I can just demo that it will re...

29:39.000 --> 29:41.000
Sorry.

29:41.000 --> 29:46.000
Forgot to go through the conversion dance again.

29:46.000 --> 29:48.000
Right.

29:48.000 --> 29:56.000
So I can demonstrate that I can load this key.

29:56.000 --> 30:02.000
But now what I'm going to do is extend that PCR.

30:09.000 --> 30:14.000
As you can see, the user space options for these commands

30:14.000 --> 30:16.000
are very friendly.

30:16.000 --> 30:18.000
And, by the way, this is the same...

30:18.000 --> 30:21.000
The same thing is true of the Intel and the IBM TSS.

30:21.000 --> 30:23.000
They're both equally unfriendly,

30:23.000 --> 30:25.000
just in completely different ways.

30:26.000 --> 30:29.000
But anyway, I extended this PCR and the point is,

30:29.000 --> 30:33.000
if I got this right, I'm not allowed to load the key anymore.

30:33.000 --> 30:36.000
And if I look at what the kernel said,

30:36.000 --> 30:40.000
it said trusted key unsealed failed because of a TPM policy failure,

30:40.000 --> 30:43.000
because I've extended the PCR.

30:43.000 --> 30:47.000
So what I can do now is actually...

30:48.000 --> 30:56.000
Let's demonstrate some signed policy.

30:59.000 --> 31:04.000
So I'm actually going to create a key that is now sealed

31:04.000 --> 31:06.000
to a public policy key.

31:06.000 --> 31:08.000
This key would insert.

31:08.000 --> 31:10.000
I'm going to lock it to the PCR.

31:17.000 --> 31:19.000
Which has a weird value.

31:19.000 --> 31:22.000
I'm going to do the conversion dance again.

31:23.000 --> 31:28.000
And this key I should also now be able to insert, I hope.

31:28.000 --> 31:31.000
Yep, so the key inserted.

31:31.000 --> 31:34.000
Now what I'm going to do is unlink it.

31:38.000 --> 31:41.000
I'm going to move that PCR on again.

31:41.000 --> 31:44.000
So I've now spoiled the value of the PCR,

31:44.000 --> 31:47.000
try and load it and it again refuses to load

31:47.000 --> 31:52.000
because it has a failure of the policy,

31:52.000 --> 31:55.000
because I just moved the PCR on to a different value.

31:55.000 --> 31:57.000
But now what I'm going to try and do for this key

31:57.000 --> 32:01.000
is I'm going to add another signed policy

32:01.000 --> 32:04.000
that locks it to the new value of the PCR.

32:04.000 --> 32:06.000
So this is adding the policy after the fact.

32:06.000 --> 32:08.000
I burned the policy into the key,

32:08.000 --> 32:12.000
but I'm now adding an existing signed policy to that key

32:12.000 --> 32:18.000
with the new PCR value and conversion dance.

32:19.000 --> 32:23.000
This new key should actually now load.

32:23.000 --> 32:25.000
There it goes.

32:25.000 --> 32:29.000
So I took a key that I created earlier.

32:29.000 --> 32:32.000
I didn't know what the PCR value would be,

32:32.000 --> 32:35.000
but thanks to signed policies I was able to add a signed policy

32:35.000 --> 32:38.000
to that key that now accepted the new PCR value.

32:38.000 --> 32:41.000
This is how you would keep the keys up to date

32:41.000 --> 32:43.000
with the state of your laptop.

32:43.000 --> 32:46.000
So the final thing I'll demonstrate is a key

32:46.000 --> 32:50.000
that can never be unsealed except in the kernel.

32:50.000 --> 32:52.000
So let's...

32:53.000 --> 32:55.000
So I'm just going to create a new key.

32:55.000 --> 32:57.000
I'm not going to bother with any of the policy stuff.

32:57.000 --> 32:59.000
I'm going to lock it to...

32:59.000 --> 33:02.000
It looks like locality 4, but this is a bitmap.

33:02.000 --> 33:04.000
So it's actually locality 2 only.

33:04.000 --> 33:07.000
So the way you lock it is just all the complex things.

33:07.000 --> 33:10.000
All the complexities of the TPM.

33:10.000 --> 33:13.000
But the point about this key is

33:13.000 --> 33:16.000
if I try to unseal it in user space,

33:16.000 --> 33:18.000
which is where I am now,

33:18.000 --> 33:20.000
it gives me a locality error

33:20.000 --> 33:23.000
because I'm not in the correct locality to use it.

33:23.000 --> 33:26.000
And now I just do the conversion dance.

33:28.000 --> 33:31.000
And if I try and insert this...

33:31.000 --> 33:34.000
I have to unlink the previous one, don't I?

33:34.000 --> 33:37.000
If I try and insert this into the key, into the kernel,

33:37.000 --> 33:40.000
it works because the kernel is at the right locality too.

33:40.000 --> 33:44.000
So this is finally a demo of

33:45.000 --> 33:48.000
using localities to protect keys

33:48.000 --> 33:51.000
because the data I seal to that key, I can't get back.

33:51.000 --> 33:54.000
And the point is if I got the kernel to generate this key

33:54.000 --> 33:57.000
and I'd sealed it to a locality,

33:57.000 --> 33:59.000
it can give me the key file back,

33:59.000 --> 34:01.000
but nobody can unwrap that key file.

34:01.000 --> 34:03.000
That key file can only be unwrapped by the kernel.

34:03.000 --> 34:05.000
It adds an additional layer of security

34:05.000 --> 34:07.000
to your disk encryption keys or something.

34:07.000 --> 34:10.000
So with that, I think we'll probably go back

34:10.000 --> 34:13.000
to the presentation demo over.

34:14.000 --> 34:17.000
And I'll just come to brief conclusions,

34:17.000 --> 34:21.000
which are the kernel TPM subsystem is evolving

34:21.000 --> 34:24.000
way more slowly than I'd like, but at least it's evolving.

34:24.000 --> 34:27.000
And we hopefully will eventually get

34:27.000 --> 34:30.000
at least to encryption in the kernel,

34:30.000 --> 34:33.000
which means that we should be using the TPM securely,

34:33.000 --> 34:35.000
and hopefully shortly after that,

34:35.000 --> 34:38.000
sort of policy and all of the other wonderful bells and whistles.

34:38.000 --> 34:40.000
And with that, if you like this presentation,

34:40.000 --> 34:43.000
it's all a web page using impres.js,

34:43.000 --> 34:45.000
which of course makes me a web developer,

34:45.000 --> 34:48.000
which is not something most kernel people admit to.

34:48.000 --> 34:51.000
And I'll say thank you and call for questions.

34:51.000 --> 34:54.000
APPLAUSE

35:00.000 --> 35:03.000
No. What a recording.

35:06.000 --> 35:09.000
So, James, I wonder if you can say a few words

35:09.000 --> 35:11.000
about the interaction between the TPM

35:11.000 --> 35:14.000
and virtualization and containers.

35:14.000 --> 35:19.000
So how does it work to keep, like a hypervisor,

35:19.000 --> 35:21.000
from seeing the keys of a virtual machine

35:21.000 --> 35:25.000
or from two containers, seeing the keys of one another?

35:25.000 --> 35:27.000
Well, so the question was,

35:27.000 --> 35:30.000
what do you do about TPMs and virtualization systems,

35:30.000 --> 35:33.000
both containers and virtual machines?

35:33.000 --> 35:37.000
Well, obviously, you saw my demo was using a software TPM.

35:37.000 --> 35:41.000
The traditional way of actually running a TPM

35:41.000 --> 35:45.000
is that you trust the host of the virtualization system.

35:45.000 --> 35:48.000
So the virtual TPM that I was running was running in the host,

35:48.000 --> 35:52.000
and then you make contact with the virtual machine.

35:52.000 --> 35:56.000
The way I was doing it, I was actually using a patched version of QMU

35:56.000 --> 35:59.000
because I don't quite like the Vproxy TPM that we have.

35:59.000 --> 36:02.000
But that's just because I don't like running the software TPM

36:02.000 --> 36:05.000
because I need to run the TPM reference implementation.

36:05.000 --> 36:09.000
The way you're supposed to do it is you have a bank of TPMs running in the host,

36:09.000 --> 36:13.000
one software TPM per virtual machine that needs to use it,

36:13.000 --> 36:15.000
with the ability to save and restore their states.

36:15.000 --> 36:18.000
The state can also follow the virtual machine image,

36:18.000 --> 36:23.000
and this means that you have a virtual machine that actually can use a TPM.

36:23.000 --> 36:26.000
Now, you alluded to the fact that if they don't trust you,

36:26.000 --> 36:28.000
the same thing works for a container as well

36:28.000 --> 36:31.000
because containers can also communicate with the TPM

36:31.000 --> 36:34.000
through basically by mounting the TPM device,

36:34.000 --> 36:36.000
which is quite easy as well.

36:36.000 --> 36:38.000
So you can do all of this if you trust the host quite easily.

36:38.000 --> 36:42.000
If you don't trust the host, you're in a confidential computing environment,

36:42.000 --> 36:44.000
you have a lot more problems.

36:44.000 --> 36:47.000
But the way we're actually trying to solve this

36:47.000 --> 36:54.000
is to put a virtual TPM implementation inside a layer of a confidential virtual machine

36:54.000 --> 36:56.000
that is protected from user space.

36:56.000 --> 37:00.000
So currently only AMD SEV does this.

37:00.000 --> 37:03.000
It has these virtual machine privilege levels.

37:03.000 --> 37:06.000
And when it boots up, it starts an SVSM,

37:06.000 --> 37:08.000
something virtual machine service module.

37:08.000 --> 37:11.000
I always forget what it is, secure virtual machine service module.

37:11.000 --> 37:13.000
And inside that is a TPM.

37:13.000 --> 37:17.000
This TPM effectively initializes itself each time it boots.

37:17.000 --> 37:19.000
So when it powers on, it has a different seed.

37:19.000 --> 37:25.000
But the public keys of that TPM are part of the SVSM attestation report.

37:25.000 --> 37:30.000
That's what binds the TPM to the confidential computing attestation report.

37:30.000 --> 37:33.000
And then the user space of this virtual machine

37:33.000 --> 37:36.000
can use the TPM running securely in the virtual machine

37:36.000 --> 37:40.000
as its own TPM for measured boot, key handling, everything else.

37:40.000 --> 37:44.000
And because it's running in a protected area of the SVSM,

37:44.000 --> 37:49.000
neither the kernel nor the user space can actually get at the contents of that TPM.

37:49.000 --> 37:51.000
It's fully protected from them.

37:51.000 --> 37:53.000
And it's inside the confidential envelope,

37:53.000 --> 37:55.000
so it's completely protected from the host as well.

37:55.000 --> 37:59.000
So effectively we can run a software TPM per virtual machine

37:59.000 --> 38:02.000
inside the confidential computing envelope.

38:02.000 --> 38:05.000
And Intel TDX is also coming up with something like this.

38:05.000 --> 38:10.000
So we should have a solution that works regardless of confidential computing technology.

38:10.000 --> 38:12.000
Does that answer the question fully?

38:12.000 --> 38:15.000
I think I understood it was pretty specific.

38:15.000 --> 38:17.000
Okay, sorry.

38:23.000 --> 38:29.000
Ignat is asking, can you wrap a key to a TPM endorsement key?

38:29.000 --> 38:33.000
Can you wrap a key to a TPM endorsement key?

38:34.000 --> 38:36.000
So the question is, can you wrap...

38:36.000 --> 38:38.000
This is a very technical thing about hierarchies.

38:38.000 --> 38:40.000
The answer is, of course, yes.

38:40.000 --> 38:42.000
Every hierarchy can support keys.

38:42.000 --> 38:45.000
But the usual...

38:45.000 --> 38:49.000
So a TPM actually has a split permission model.

38:49.000 --> 38:52.000
So usually TPMs have four hierarchies.

38:52.000 --> 38:56.000
They have the endorsement hierarchy, the storage hierarchy or owner hierarchy,

38:56.000 --> 39:00.000
the null hierarchy and the platform hierarchy.

39:00.000 --> 39:04.000
So the platform hierarchy is always owned by the firmware and you can never use it.

39:04.000 --> 39:08.000
The null hierarchy actually changes its seed every time it boots

39:08.000 --> 39:10.000
so it's not useful for key sealing.

39:10.000 --> 39:13.000
But the other two are the endorsement and the owner hierarchy.

39:13.000 --> 39:15.000
The problem is when you take owner of a TPM,

39:15.000 --> 39:18.000
you get ownership of the owner hierarchy,

39:18.000 --> 39:21.000
the storage hierarchy, not the endorsement hierarchy.

39:21.000 --> 39:26.000
And in certain TPMs, the endorsement hierarchy is designed

39:26.000 --> 39:29.000
so that it will only work if you know the endorsement password.

39:29.000 --> 39:32.000
And for some split TPM implementations,

39:32.000 --> 39:35.000
the owner might not know the endorsement password.

39:35.000 --> 39:39.000
So what you're asking me is, yes, it's theoretically possible,

39:39.000 --> 39:42.000
but there can be ways that the TPM is set up that it won't work

39:42.000 --> 39:46.000
because you don't know the password to do the key insertion.

39:46.000 --> 39:48.000
Okay, thank you. We're out of time.

39:48.000 --> 39:50.000
Okay, thank you very much.

