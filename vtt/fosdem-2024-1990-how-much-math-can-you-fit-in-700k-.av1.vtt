WEBVTT

00:00.000 --> 00:09.000
So during these two minutes, I'm going to ask a few questions.

00:09.000 --> 00:16.000
I think the sound is better like this. Can you hear me?

00:16.000 --> 00:18.000
Yeah.

00:18.000 --> 00:27.000
So I heard a comment that color was not allowed, so I hope that you won't mind if I use 3D instead.

00:27.000 --> 00:34.000
But the screen and the actual device I'm going to talk about is black and white.

00:34.000 --> 00:39.000
Who uses a calculator from time to time?

00:39.000 --> 00:44.000
Who uses a calculator from the smartphone or whatever?

00:44.000 --> 00:46.000
Yeah, it's the majority.

00:46.000 --> 00:50.000
Who uses HP style calculators?

00:50.000 --> 00:52.000
Not that many. It's mostly.

00:52.000 --> 00:56.000
Who uses calculators for binary computations?

00:56.000 --> 01:03.000
Okay. Complex numbers in matrices, graphing.

01:03.000 --> 01:07.000
Okay. Just checking.

01:07.000 --> 01:11.000
So I don't think that the camera can zoom that far, right?

01:11.000 --> 01:13.000
So I can't show that. I suspect.

01:13.000 --> 01:15.000
Yeah, it'll be hard.

01:15.000 --> 01:20.000
But this is the device I'm talking about. You're going to speak.

01:20.000 --> 01:23.000
I'll hold up a sign. 5 minutes for question time.

01:23.000 --> 01:40.000
Yep.

01:40.000 --> 01:44.000
It's the dots.

01:44.000 --> 01:45.000
Is it also?

01:45.000 --> 01:46.000
For me it is.

01:46.000 --> 01:48.000
I don't know what's wrong with my timer. It's Android.

01:48.000 --> 01:51.000
Okay.

01:51.000 --> 01:53.000
So I'm Christophe D'Alincia.

01:53.000 --> 01:56.000
I'm working as a senior principle software engineer at Red Hat,

01:56.000 --> 01:58.000
working on confidential computing.

01:58.000 --> 02:01.000
I'm giving a talk on this topic this afternoon.

02:01.000 --> 02:06.000
But today I'm talking about a pet project of mine called GB48X,

02:06.000 --> 02:14.000
which is an open source HP48 style calculator for modern ARM hardware.

02:14.000 --> 02:18.000
So I talked about this last year,

02:18.000 --> 02:21.000
and I'm going to show how much progress we made since then.

02:21.000 --> 02:24.000
I start with a reminder of what GB48X is.

02:24.000 --> 02:28.000
We are going to review last year's future plans to see how well we did.

02:28.000 --> 02:31.000
I'm going to talk from one engineer to another.

02:31.000 --> 02:33.000
That's why I asked the questions at the beginning

02:33.000 --> 02:37.000
to see why we need all this math in the calculator.

02:37.000 --> 02:42.000
I'm going to extoll the virtues of 1980s era efficiency

02:42.000 --> 02:46.000
when there were only keyboards, no touchscreen, no fancy mouse,

02:46.000 --> 02:48.000
all that stuff.

02:48.000 --> 02:51.000
I'm going to explain how using much bigger numbers

02:51.000 --> 02:54.000
led to much less memory usage.

02:54.000 --> 02:58.000
And we are going to see a number of bells, whistles,

02:58.000 --> 03:00.000
and engineering units along the way.

03:00.000 --> 03:02.000
So I hope you enjoyed.

03:02.000 --> 03:03.000
Strap on.

03:03.000 --> 03:05.000
What is GB48X?

03:05.000 --> 03:09.000
The idea is really to revive Schullet's Packard's iconic reverse

03:09.000 --> 03:11.000
polish list on modern ARM hardware.

03:11.000 --> 03:14.000
So that's what the original box looked like.

03:14.000 --> 03:16.000
And a quick primer on the project.

03:16.000 --> 03:21.000
We want to simply put, reinvent the best calculators in the world.

03:21.000 --> 03:23.000
Nothing yet, less.

03:23.000 --> 03:26.000
It's designed to run on existing hardware from a company in Switzerland

03:26.000 --> 03:29.000
called Swiss Micro that does these kind of devices.

03:29.000 --> 03:34.000
So you see the DM32 on the right and the DM42 on the left.

03:34.000 --> 03:37.000
The specs for the project are from the HP manuals,

03:37.000 --> 03:39.000
and there are dozens of them.

03:39.000 --> 03:41.000
Unfortunately, they contradict one another

03:41.000 --> 03:45.000
because values calculators do not do exactly the same thing.

03:45.000 --> 03:48.000
So it's implemented in a language called reverse polish list,

03:48.000 --> 03:52.000
or RPL, which is a stack-based language, very powerful.

03:52.000 --> 03:55.000
It's based on common line and menus that you activate

03:55.000 --> 04:00.000
with keys below, function keys below the keyboard, the screen side.

04:00.000 --> 04:03.000
It has many data types and mathematical operations.

04:03.000 --> 04:05.000
I'm going to talk about this later.

04:05.000 --> 04:10.000
And many enhancements in the project compared to what HP did.

04:10.000 --> 04:12.000
Now, is this still minimalist?

04:12.000 --> 04:17.000
Well, you bet, because that machine has 70K of free RAM

04:17.000 --> 04:23.000
and 700K total for the program space, hence the title of the talk.

04:23.000 --> 04:28.000
So it's a low-power Cortex M4 at 80 MHz.

04:28.000 --> 04:33.000
The battery life is up to three years on this kind of battery,

04:33.000 --> 04:37.000
and one of the things that is nice is that the screen is passive,

04:37.000 --> 04:41.000
so when you switch off the calculators, it displays a picture,

04:41.000 --> 04:43.000
and the picture stays there forever.

04:43.000 --> 04:47.000
So that's where I have pictures of my wife and my calculator.

04:47.000 --> 04:50.000
The machine has only 96K of RAM,

04:50.000 --> 04:54.000
and if you remove the bitmap, which is a high-res bitmap,

04:54.000 --> 04:56.000
and the operating system needs,

04:56.000 --> 04:59.000
then you get to the 70K I was talking about.

04:59.000 --> 05:04.000
So 96K is 1.5,64 for the old-timers among us.

05:04.000 --> 05:07.000
It has only 2 megabytes of flash.

05:07.000 --> 05:11.000
It has 8 megs in the chip, but 6 are for a flash disk,

05:11.000 --> 05:16.000
and so there are 700K remaining for your program.

05:16.000 --> 05:18.000
That's less than a Macintosh floppy disk.

05:18.000 --> 05:20.000
They were 800K.

05:20.000 --> 05:23.000
The project did hit these limits quite hard.

05:23.000 --> 05:26.000
I'm going to explain how we worked around that.

05:26.000 --> 05:29.000
So last year I explained that I had to restart from scratch

05:29.000 --> 05:32.000
from a project called new RPL because we hit these limits.

05:32.000 --> 05:35.000
This year around Christmas, I hit the limits again,

05:35.000 --> 05:37.000
so I had to restart from rescratch,

05:37.000 --> 05:40.000
at least as far as the similar computations are concerned.

05:40.000 --> 05:42.000
So I'm going to explain that.

05:42.000 --> 05:45.000
So let's review last year's future plans.

05:45.000 --> 05:47.000
I think there is a problem with this one.

05:47.000 --> 05:49.000
Is this one okay, or is it...

05:49.000 --> 05:51.000
Yeah, okay.

05:51.000 --> 05:55.000
So I said, you know, back in 2023, I was young and naive,

05:55.000 --> 05:58.000
and I said a lot remains to be done.

05:58.000 --> 06:00.000
So I was talking about adding complex numbers,

06:00.000 --> 06:02.000
vector and matrix arithmetic,

06:02.000 --> 06:05.000
about 1500 functions that were left to implement,

06:05.000 --> 06:08.000
and key features like plotting and graphing.

06:08.000 --> 06:10.000
So what did we do?

06:10.000 --> 06:12.000
Well, a lot of this was done.

06:12.000 --> 06:14.000
Complex numbers are available,

06:14.000 --> 06:16.000
and they are actually much better than the original.

06:16.000 --> 06:18.000
For instance, you can have polar and rectangular.

06:18.000 --> 06:20.000
You have the usual notations.

06:20.000 --> 06:22.000
You have stuff like that.

06:22.000 --> 06:24.000
We have vector and matrix arithmetic fully implemented,

06:24.000 --> 06:27.000
and we have algebra, but also with exact computations

06:27.000 --> 06:29.000
like fractions inside matrices.

06:29.000 --> 06:31.000
So you never get a rounding error

06:31.000 --> 06:33.000
unlike on the HP calculators.

06:33.000 --> 06:35.000
That's the test suite.

06:35.000 --> 06:38.000
So the test suite runs on a simulator on Linux or Mac OS,

06:38.000 --> 06:41.000
and it currently runs about 2,200 tests.

06:41.000 --> 06:43.000
Not everything is tested.

06:43.000 --> 06:46.000
That, for instance, is implemented but not tested yet.

06:46.000 --> 06:48.000
And we have plotting and graphing,

06:48.000 --> 06:51.000
at least the basic features, like drawing stuff, etc.,

06:51.000 --> 06:54.000
with some nice enhancements compared to what HP did.

06:54.000 --> 07:00.000
Like, for instance, we can have plots with various sizes

07:00.000 --> 07:04.000
and plot patterns, so I'm going to show that in a moment.

07:04.000 --> 07:07.000
And that lets you draw multiple things on the same screen

07:07.000 --> 07:10.000
and see what the different pieces are.

07:10.000 --> 07:13.000
It just was very fast on the screen here.

07:13.000 --> 07:18.000
So how did we go to use only 70K?

07:18.000 --> 07:22.000
It's a story of ultimate over-engineering.

07:22.000 --> 07:24.000
It's C++ with garbage collection

07:24.000 --> 07:27.000
and ubiquitous bad packing all over the place.

07:27.000 --> 07:29.000
Let me explain what I mean with that.

07:29.000 --> 07:31.000
A C++ object typically looks like this.

07:31.000 --> 07:35.000
You have a class, and the way this is represented in memory

07:35.000 --> 07:38.000
is you have a virtual table pointer,

07:38.000 --> 07:40.000
and then you have the value for the object,

07:40.000 --> 07:42.000
so in that case, for the integer,

07:42.000 --> 07:45.000
you'd have an integer value or an enzyme value.

07:45.000 --> 07:47.000
And then there's some overhead for malloc.

07:47.000 --> 07:49.000
It's self-operated or whatever.

07:49.000 --> 07:51.000
You have, for instance, a linked list or a free list

07:51.000 --> 07:53.000
or something like that.

07:53.000 --> 07:57.000
So overall, for your object representing an enzyme value,

07:57.000 --> 07:59.000
you typically use 12 bytes.

07:59.000 --> 08:03.000
12 bytes, that's on a 32-bit CPU.

08:03.000 --> 08:08.000
That lets you represent all values up to 4 billion,

08:08.000 --> 08:10.000
and it's fixed size.

08:10.000 --> 08:12.000
You can't remove it in memory.

08:12.000 --> 08:15.000
Not good. Let's do better.

08:15.000 --> 08:18.000
So the representation we used looks like something like that.

08:18.000 --> 08:21.000
We use LB128, which is a system that is used,

08:21.000 --> 08:23.000
for instance, in Dwarf all over the place.

08:23.000 --> 08:27.000
And there let's us code the ID that is used

08:27.000 --> 08:31.000
to identify the type of object as one byte for integers.

08:31.000 --> 08:36.000
We have 128 types that we can represent with one byte.

08:36.000 --> 08:40.000
And the value, if it's less than 128, is also on one byte.

08:40.000 --> 08:43.000
So that means that I use only two bytes of memory

08:43.000 --> 08:46.000
that's a 6x factor compared to the other representation

08:46.000 --> 08:49.000
for all values below 128.

08:49.000 --> 08:52.000
And I can move to infinity because the LB128

08:52.000 --> 08:54.000
is a variable size encoding,

08:54.000 --> 08:57.000
so I can essentially have numbers that are as big as I want.

08:57.000 --> 09:00.000
It's now a variable size object, and I can move it.

09:00.000 --> 09:03.000
So it's a vast improvement.

09:03.000 --> 09:05.000
That lets me have a memory organization

09:05.000 --> 09:09.000
where I have at the bottom of memory all the global variables,

09:09.000 --> 09:11.000
the global objects that I keep.

09:11.000 --> 09:14.000
It's essentially a name, a value, a name, a value.

09:14.000 --> 09:16.000
And then, so they are all packed together.

09:16.000 --> 09:18.000
And then on top of that, I have temporaries

09:18.000 --> 09:20.000
that move with a temporary pointer

09:20.000 --> 09:22.000
that moves as you allocate objects.

09:22.000 --> 09:25.000
And then there is an editor, scratch pad,

09:25.000 --> 09:27.000
and the transient stuff on top of that.

09:27.000 --> 09:29.000
Because it's all contiguous,

09:29.000 --> 09:31.000
the way to reach the next object is to skip

09:31.000 --> 09:33.000
by reading the ID and computing the size

09:33.000 --> 09:36.000
to get to the next object.

09:36.000 --> 09:39.000
So on top of memory, you have root pointers

09:39.000 --> 09:41.000
that point back to, like, the stack,

09:41.000 --> 09:43.000
the local variables, that kind of stuff,

09:43.000 --> 09:48.000
that point back to this memory area at the bottom.

09:48.000 --> 09:50.000
And the root pointers can point inside objects.

09:50.000 --> 09:52.000
That's a very important property for performance.

09:52.000 --> 09:56.000
For instance, if you follow the one link,

09:56.000 --> 09:58.000
you'll see that it points just behind,

09:58.000 --> 10:00.000
I think, like, with curly braces.

10:00.000 --> 10:02.000
It means it's part of a list,

10:02.000 --> 10:04.000
and I can put the value that is inside the list

10:04.000 --> 10:06.000
directly on the stack.

10:06.000 --> 10:09.000
So I can do the computations faster that way.

10:09.000 --> 10:13.000
And there is also a series of smart pointer classes,

10:13.000 --> 10:16.000
the names and in other score G in the source code,

10:16.000 --> 10:22.000
that let me have garbage-collected smart pointers.

10:22.000 --> 10:23.000
The allocation is super cheap,

10:23.000 --> 10:26.000
because it's essentially I'm moving the pointer

10:26.000 --> 10:28.000
at the top of the scratch space, like this.

10:28.000 --> 10:32.000
So it's just one addition and one comparison,

10:32.000 --> 10:34.000
and the comparison is to see,

10:34.000 --> 10:37.000
okay, am I out of memory, do I need to garbage-collect?

10:37.000 --> 10:40.000
So a very, very cheap allocation.

10:40.000 --> 10:43.000
The garbage collection itself, as you, you know,

10:43.000 --> 10:45.000
your memory grows and you allocate more and more stuff,

10:45.000 --> 10:48.000
so at some point, memory gets slow.

10:48.000 --> 10:51.000
The unreferenced temporaries, you no longer need them,

10:51.000 --> 10:53.000
so what you do is you copy the reference object down

10:53.000 --> 10:55.000
and you adjust the pointers,

10:55.000 --> 10:59.000
and then you move the editing part of the scratch pad down,

10:59.000 --> 11:03.000
and you reclaim your free space that way.

11:03.000 --> 11:06.000
So the good point of this approach is that there is no memory

11:06.000 --> 11:07.000
of a head at all.

11:07.000 --> 11:09.000
There is not a single byte that is used for metadata

11:09.000 --> 11:12.000
or linked list or anything like that.

11:12.000 --> 11:15.000
The sub-objects, so pointers to objects inside a list,

11:15.000 --> 11:18.000
for instance, don't cost me extra at all either.

11:18.000 --> 11:20.000
If you know something about garbage collectors

11:20.000 --> 11:23.000
and you think of a market-suit garbage collector,

11:23.000 --> 11:26.000
for instance, it needs some metadata about sub-objects,

11:26.000 --> 11:28.000
and so that means you have extra costs

11:28.000 --> 11:31.000
for objects inside objects.

11:31.000 --> 11:34.000
And it's a single-pass garbage collector,

11:34.000 --> 11:37.000
so it's simple code, easy to maintain,

11:37.000 --> 11:40.000
but the downside is that it's slow.

11:40.000 --> 11:42.000
It's essentially a quadratic behavior,

11:42.000 --> 11:47.000
number of stack objects times number of objects

11:47.000 --> 11:51.000
instead of linear or close to linear that you could get otherwise.

11:51.000 --> 11:56.000
So it's a usual trade-off of space for speed.

11:56.000 --> 12:00.000
So why use C++ at all?

12:00.000 --> 12:04.000
Well, it's because of template metaprogramming,

12:04.000 --> 12:06.000
and let me explain why this matters.

12:06.000 --> 12:11.000
So the guy that you see in the photo there is a guy named David van der Vorder,

12:11.000 --> 12:17.000
and he's a Belgian guy who initiated me to C++ metaprogramming

12:17.000 --> 12:21.000
back in 1998 when we were in the C++ HP compiler team.

12:21.000 --> 12:26.000
So the guys you see in the background are the HP compiler team back in 1998,

12:26.000 --> 12:29.000
and that guy is super, super smart

12:29.000 --> 12:31.000
and initiated me to template metaprogramming

12:31.000 --> 12:33.000
before it was even possible,

12:33.000 --> 12:35.000
so we were dreaming about doing these things.

12:35.000 --> 12:38.000
But now you can, and let me explain why it matters.

12:38.000 --> 12:41.000
I'm going to represent code as data using metaprogramming,

12:41.000 --> 12:44.000
not because we can, just for the sake of it,

12:44.000 --> 12:47.000
but because I have to.

12:47.000 --> 12:53.000
So let me talk about bug number 12 in our project.

12:53.000 --> 12:58.000
You compute 1.2 plus 3.4, and it hangs on battery power.

12:58.000 --> 13:00.000
So how do you reproduce this bug?

13:00.000 --> 13:02.000
You don't use the technique shown on the right.

13:02.000 --> 13:07.000
Instead, you simply type 1, 2, 2, 3, 4, plus,

13:07.000 --> 13:10.000
and the calculator sits there, not doing the computation.

13:10.000 --> 13:12.000
And your users call you and say,

13:12.000 --> 13:15.000
did you even test the thing?

13:15.000 --> 13:18.000
So you scratch your head, how did I miss that?

13:18.000 --> 13:20.000
Well, the fact is it hangs only on battery power,

13:20.000 --> 13:23.000
and as soon as you plug the USB cable,

13:23.000 --> 13:25.000
the computation resumes and you get the result.

13:25.000 --> 13:30.000
You can guess that I did my testing with the USB cable on.

13:30.000 --> 13:35.000
So what is this bug?

13:35.000 --> 13:37.000
This one was a bit hard to find.

13:37.000 --> 13:41.000
It turns out that the chip has an execute in place feature

13:41.000 --> 13:44.000
that works, it's supposed to work on the external chip,

13:44.000 --> 13:46.000
something called the QSPI interface,

13:46.000 --> 13:49.000
except it just lacks battery power,

13:49.000 --> 13:52.000
or a power juice when it's on battery.

13:52.000 --> 13:55.000
And so essentially it sits there waiting for the cycle to complete,

13:55.000 --> 13:57.000
and it completes it when you plug the power.

13:57.000 --> 14:04.000
Okay, so that means I have to move as much of my mathematics

14:04.000 --> 14:07.000
into data that I can read from the QSPI

14:07.000 --> 14:09.000
as opposed to code that I cannot put there.

14:09.000 --> 14:13.000
That's why I only have 700K, otherwise I'd have two makes.

14:14.000 --> 14:18.000
So how do I use C++ metaprogramming to do that?

14:18.000 --> 14:21.000
Let's see a description of an interesting math rule,

14:21.000 --> 14:23.000
and that's how you expand polynomials.

14:23.000 --> 14:26.000
So you know the rule, you see the first rule,

14:26.000 --> 14:28.000
for instance, X plus Y times Z,

14:28.000 --> 14:32.000
you turn that into X times Z plus Y times Z,

14:32.000 --> 14:34.000
and you see that's exactly what you see in the code.

14:34.000 --> 14:37.000
So the code contains essentially the mathematical formula

14:37.000 --> 14:38.000
as you're applying.

14:38.000 --> 14:39.000
That's neat, right?

14:39.000 --> 14:41.000
Now, here's a guess.

14:41.000 --> 14:44.000
How many bytes of code does that generate?

14:46.000 --> 14:47.000
Give me a guess.

14:48.000 --> 14:50.000
Nobody wants to want to guess.

14:50.000 --> 14:52.000
Okay, that's the assembly code.

14:52.000 --> 14:54.000
12 bytes.

14:55.000 --> 14:58.000
So that code generates 12 bytes of code,

14:58.000 --> 15:02.000
but it generates tons of read-only data,

15:02.000 --> 15:05.000
which is good because I can move that to my QSPI.

15:06.000 --> 15:10.000
So the magic is this ugly metaprogramming code

15:10.000 --> 15:13.000
that generates constant arrays,

15:13.000 --> 15:16.000
and I taught the C++ compiler how to generate

15:16.000 --> 15:20.000
RPL objects from C++ expressions.

15:20.000 --> 15:22.000
Isn't that cool?

15:24.000 --> 15:27.000
And so that's how you get 12 bytes of code,

15:27.000 --> 15:29.000
tons of data that I don't care about,

15:29.000 --> 15:31.000
I have plenty of that data space free

15:31.000 --> 15:33.000
and no executing place needed.

15:34.000 --> 15:37.000
So in the end, how much math in 700K?

15:37.000 --> 15:39.000
Well, it turns out that for another reason,

15:39.000 --> 15:41.000
I'm now back under 500K,

15:41.000 --> 15:43.000
so I'm within the limit that we all heard about,

15:43.000 --> 15:47.000
the 640K that ought to be enough for everybody, right?

15:48.000 --> 15:51.000
So from one engineer to another, what do we have?

15:51.000 --> 15:54.000
So we have base numbers for engineers

15:54.000 --> 15:58.000
in the computer field, that's really fancy.

15:58.000 --> 16:02.000
In any base, I can compute in base 17 or 34 if you want,

16:02.000 --> 16:04.000
or three.

16:04.000 --> 16:06.000
With any size, you can compute on 13 bits

16:06.000 --> 16:09.000
or 512 bits if you want.

16:09.000 --> 16:13.000
We have complex numbers that's useful for electrical engineering,

16:13.000 --> 16:16.000
and we have phases that are dealt with

16:16.000 --> 16:19.000
with exact results if we can,

16:19.000 --> 16:22.000
so like exact fractions and stuff like that.

16:22.000 --> 16:25.000
We have linear algebra, and here two exact results

16:25.000 --> 16:27.000
when we can.

16:27.000 --> 16:30.000
Statistics, which is useful for field science.

16:30.000 --> 16:33.000
Degree minutes, second support,

16:33.000 --> 16:35.000
so that's if you're doing, you know,

16:35.000 --> 16:37.000
maritime navigation or stuff like that,

16:37.000 --> 16:41.000
that's really handy, you have a really nice shortcut for that.

16:41.000 --> 16:44.000
Unit conversions, if you want to land something on Mars

16:44.000 --> 16:47.000
without crashing it, because some guy in the US

16:47.000 --> 16:50.000
is using really ridiculous units.

16:50.000 --> 16:54.000
And symbolic processing, which is useful for math gigs.

16:54.000 --> 16:57.000
About 1980s era efficiency.

16:57.000 --> 17:00.000
I have this magic menu, it's the key at the top,

17:00.000 --> 17:04.000
next to the A symbol, and essentially it selects

17:04.000 --> 17:07.000
the right menu depending on the type of the object on the stack.

17:07.000 --> 17:10.000
So very few key strokes to get exactly the functions

17:10.000 --> 17:13.000
that are most useful for what I'm working on.

17:13.000 --> 17:16.000
Equation data entry, I use a single key to enter

17:16.000 --> 17:18.000
the symbol that they limit expressions,

17:18.000 --> 17:21.000
and when I'm inside, that's the quotes in RPL,

17:21.000 --> 17:24.000
but once I'm inside an expression, I no longer need these quotes,

17:24.000 --> 17:27.000
so I hit the same key and I get parentheses instead.

17:27.000 --> 17:30.000
And same thing with the equal sign that you see at the bottom,

17:30.000 --> 17:34.000
it evaluates an expression, so it's the eval function of RPL,

17:34.000 --> 17:37.000
but if you're inside an equation, then it says,

17:37.000 --> 17:40.000
well, I'm inserting an equal sign because I'm trading an equation,

17:40.000 --> 17:43.000
and if I'm inside parentheses, it's inserting a semicolon

17:43.000 --> 17:47.000
instead to separate function arguments.

17:47.000 --> 17:50.000
Exactly symbol data entry, that's for your gigs.

17:50.000 --> 17:53.000
So when you type a hash sign,

17:53.000 --> 17:56.000
the cursor changes to a B, that's for base numbers,

17:56.000 --> 18:00.000
and it says now the ABCD keys, you don't need to shift them or anything,

18:00.000 --> 18:02.000
you just get ABCD.

18:02.000 --> 18:08.000
DMS data entry dot dot dot, and yep, and a one key function.

18:08.000 --> 18:10.000
Okay.

18:10.000 --> 18:13.000
Just my conclusion that I cannot answer the question

18:13.000 --> 18:18.000
because I still have 200k to go, so see you next year, guys.

18:18.000 --> 18:20.000
Thank you.

18:20.000 --> 18:22.000
Thank you.

18:22.000 --> 18:24.000
Thank you.

18:24.000 --> 18:26.000
Thank you.

18:26.000 --> 18:28.000
Thank you.

18:28.000 --> 18:30.000
So the next speaker can set up.

18:30.000 --> 18:34.000
Is there any time for questions?

18:34.000 --> 18:36.000
Yes, there's five questions.

18:36.000 --> 18:38.000
We'll have one for the next speaker.

18:38.000 --> 18:40.000
Yeah.

18:40.000 --> 18:42.000
But I don't see the next speaker.

18:48.000 --> 18:51.000
No questions, seriously?

18:51.000 --> 18:54.000
Who wants to help with this project?

18:54.000 --> 18:56.000
I'll just give my laptop.

18:56.000 --> 18:58.000
You know, it's 20.

18:58.000 --> 19:00.000
Okay.

19:00.000 --> 19:02.000
Okay.

19:02.000 --> 19:04.000
Okay.

19:04.000 --> 19:06.000
Okay.

19:06.000 --> 19:08.000
Okay.

19:08.000 --> 19:10.000
Okay.

19:10.000 --> 19:12.000
Okay.

19:12.000 --> 19:14.000
Okay.

19:14.000 --> 19:16.000
Okay.

19:16.000 --> 19:18.000
We'll just give my laptop.

19:18.000 --> 19:20.000
Does that rock?

19:20.000 --> 19:22.000
Does the calculator have a beeper?

19:22.000 --> 19:24.000
Yes.

19:24.000 --> 19:26.000
That's a good question.

19:26.000 --> 19:28.000
So let me...

19:28.000 --> 19:30.000
I'll use the voice.

19:30.000 --> 19:32.000
Oh.

19:32.000 --> 19:34.000
I think it will be a full row.

19:34.000 --> 19:36.000
So here we go.

19:36.000 --> 19:38.000
Okay.

19:38.000 --> 19:40.000
Okay.

19:40.000 --> 19:42.000
Okay.

19:42.000 --> 19:44.000
Okay.

19:44.000 --> 19:46.000
Okay.

19:57.000 --> 20:00.000
Now it's your world of activities.

