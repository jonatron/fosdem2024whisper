WEBVTT

00:00.000 --> 00:07.000
Okay, the setup is done. We are ready for our next talk.

00:09.200 --> 00:12.400
Next talk is by Ikea. Ikea doesn't like things easily.

00:12.400 --> 00:18.600
Why Ikea is using a MacBook, ARM-based laptop, running a complete Linux kernel?

00:18.600 --> 00:23.600
I'm miracle that this works. If anything goes wrong, we just blame Apple.

00:23.600 --> 00:27.900
Remember, if it goes wrong, we just blame Apple.

00:27.900 --> 00:32.900
Ikea doesn't like things easily because I like smartwatches.

00:32.900 --> 00:36.900
This one runs Linux, this one runs JavaScript, and these ones are proprietary ones,

00:36.900 --> 00:41.900
which I won't talk about. But I have non-running Go, and you have one.

00:41.900 --> 00:46.900
And that's what we're going to talk about. Go on our smartwatches!

00:46.900 --> 00:53.900
Well, hello everyone.

00:53.900 --> 01:00.900
So, yeah, I'm Ikea. I'm about six years ago, I was programming using MicroPython.

01:00.900 --> 01:07.900
I was programming some LED strips, of course, but I found that they were a little bit too slow,

01:07.900 --> 01:12.900
because Python is kind of slow. So, of course, I did sensible thing,

01:12.900 --> 01:18.900
and started writing a Go compiler for my controllers.

01:18.900 --> 01:24.900
Nowadays, LED strips work really well in TinyGo, because that's a project, of course.

01:24.900 --> 01:31.900
So I needed a little bit more advanced project, and that's programming this watch.

01:31.900 --> 01:38.900
As you've heard, it's a little bit more advanced,

01:38.900 --> 01:47.900
as you've heard, it's... oh, wait, where did my camera go?

01:47.900 --> 01:52.900
Well, here you can see it. It's the pine time.

01:52.900 --> 02:00.900
It's from pine 64. We also have a stand here and another building.

02:00.900 --> 02:07.900
So you can see it live, maybe. No, it can't.

02:07.900 --> 02:12.900
Oh, it does have color. Cool.

02:12.900 --> 02:17.900
Let's see. Zoom in, maybe.

02:17.900 --> 02:21.900
So, yeah, it's a watch. It shows the time.

02:21.900 --> 02:26.900
It was in digital. It has very sensors.

02:26.900 --> 02:32.900
Step-bunt is wrong, because it doesn't reset at midnight, but whatever.

02:32.900 --> 02:35.900
So, yeah, that's what I'm working on.

02:35.900 --> 02:41.900
Why this watch? Because there are basically very few other open smartwatches.

02:41.900 --> 02:46.900
I know of two or three others, so they're very rare.

02:46.900 --> 02:56.900
And this is a relatively cheap one.

02:56.900 --> 02:59.900
The hardware is pretty standard, really.

02:59.900 --> 03:09.900
A Nordic semiconductor Bluetooth chip with some flash memory in external storage.

03:09.900 --> 03:15.900
It has actually a really nice display, but I'll talk about it more in a minute.

03:15.900 --> 03:25.900
And it has a hard-wired sensor and a step counter, like normal stuff you'd expect in a smartwatch.

03:25.900 --> 03:31.900
So when I started working on it, I decided, oh, wait, you can see it.

03:31.900 --> 03:40.900
Let's see. This is supposed to be... There you go.

03:40.900 --> 03:52.900
So when I started working on it, I realized I could actually use the smartwatch as a way to improve time ago itself.

03:52.900 --> 04:01.900
Because we have a lot of projects that are basically like demos or prototypes,

04:01.900 --> 04:11.900
but not a lot of actual professional projects.

04:11.900 --> 04:23.900
So my goal was to make this like a actual watch could be like you'd buy,

04:23.900 --> 04:36.900
which means I'd have to implement a lot of features you wouldn't implement in just a talk project,

04:36.900 --> 04:44.900
such as it has to be fast, it has to be efficient, user-friendly, there have to be translations,

04:44.900 --> 04:48.900
but also things like security.

04:48.900 --> 04:56.900
So the way I started is by working on a Borg package, which is basically a hardware abstraction layer.

04:56.900 --> 05:02.900
It abstracts a lot of different... It works on a lot of different kinds of hardware,

05:02.900 --> 05:12.900
like the point time, of course, but also this batch, which is the same hardware,

05:12.900 --> 05:17.900
and a few other batches, but might have more in the future.

05:17.900 --> 05:30.900
But because it's hardware abstraction layer, it can just as well work on a desktop computer in a simulation.

05:30.900 --> 05:36.900
And on all these different kinds of hardware, it exposes the exact same API,

05:36.900 --> 05:41.900
which is actually tested in CI because it's easy to introduce differences.

05:41.900 --> 05:52.900
This makes it possible to just write for one platform and then have it work more or less for hours without too much effort.

05:52.900 --> 05:56.900
As an example, I can actually...

05:56.900 --> 06:00.900
Here's the camera again.

06:00.900 --> 06:04.900
This is the Adafruit PyPortal.

06:04.900 --> 06:07.900
Let's turn this around.

06:07.900 --> 06:10.900
It has the same...

06:10.900 --> 06:16.900
It can be a little bit tricky to get working, but it runs the same software.

06:16.900 --> 06:21.900
So for example, the touchscreen is a little bit finicky.

06:21.900 --> 06:31.900
Here you have the same clock running.

06:31.900 --> 06:35.900
So the code I wrote for the smartwatch is entirely...

06:35.900 --> 06:39.900
Well, it's written for the point time, but it's independent of the point time.

06:39.900 --> 06:42.900
There's no point time specific code in the watch code.

06:42.900 --> 06:46.900
So I think that's great.

06:46.900 --> 06:48.900
So the simulator...

06:48.900 --> 06:54.900
Let's move to the next slide somehow.

06:54.900 --> 06:57.900
Yeah, this is the simulator.

06:57.900 --> 07:07.900
It's running like in any other Go program, so you can just go run dot and you run the program.

07:07.900 --> 07:15.900
Let's see what I can quickly get this to work.

07:16.900 --> 07:21.900
So for example, here's the same watch.

07:21.900 --> 07:23.900
You can debug it here.

07:23.900 --> 07:26.900
There's sensors all emulated.

07:26.900 --> 07:32.900
There's a step counter here.

07:32.900 --> 07:37.900
It disables the screen, of course, but you can change it.

07:37.900 --> 07:42.900
So there you go.

07:42.900 --> 07:45.900
But there's another feature.

07:45.900 --> 07:47.900
Can I show this?

07:47.900 --> 07:52.900
I'll try to show this.

07:52.900 --> 07:59.900
Help.

07:59.900 --> 08:03.900
There you go.

08:03.900 --> 08:07.900
Basically, this even emulates the...

08:07.900 --> 08:17.900
Well, it uses the Bluetooth package, which works both on like the point time and on the desktop operating system.

08:17.900 --> 08:29.900
So what I can do now is I can connect the def kit.

08:29.900 --> 08:32.900
Should be connected now.

08:32.900 --> 08:38.900
But it's mostly invisible.

08:38.900 --> 08:43.900
And if I have...

08:43.900 --> 08:53.900
Sorry about this.

08:53.900 --> 08:55.900
Where's my cursor?

08:55.900 --> 08:56.900
There you go.

08:56.900 --> 08:59.900
I can increase the steps.

08:59.900 --> 09:07.900
And it should also increase the steps on the simulator.

09:07.900 --> 09:12.900
But it's apparently takes a while.

09:12.900 --> 09:14.900
Well, this is not going to work right now.

09:14.900 --> 09:16.900
But it does work.

09:16.900 --> 09:21.900
It's not right now.

09:21.900 --> 09:28.900
It most definitely works.

09:28.900 --> 09:39.900
So this is a way to be really productive because you can actually test the whole system, including things like Bluetooth,

09:39.900 --> 09:42.900
which are normally specific to the hardware.

09:42.900 --> 09:50.900
And also the accelerometer, it's not implemented, but you could just easily add settings to change it.

09:50.900 --> 09:54.900
And you can debug the same thing using like Delve or something.

09:54.900 --> 09:56.900
So that should just work.

09:56.900 --> 10:01.900
Here's the Go-Batch in simulation and a game I made.

10:01.900 --> 10:03.900
The only thing I really add...

10:03.900 --> 10:05.900
Wait, I don't have much time left.

10:05.900 --> 10:14.900
The only thing I really add added to each project is like a small configuration part,

10:14.900 --> 10:19.900
which isn't actually built on actual hyperpossess in a statement.

10:19.900 --> 10:21.900
And just set some parameters.

10:21.900 --> 10:28.900
So the simulator knows what screen size to use and even the draw speed.

10:28.900 --> 10:33.900
But you could just as well leave it out and then it uses its standard size,

10:33.900 --> 10:39.900
which happens to be the same as this batch.

10:39.900 --> 10:44.900
Oh, wait, I didn't actually show this.

10:44.900 --> 10:45.900
There you go.

10:45.900 --> 10:48.900
Sorry about that.

10:48.900 --> 10:51.900
Maybe I should have used screen memory.

10:51.900 --> 10:55.900
Anyway, so that's the developer side.

10:55.900 --> 11:02.900
And I think that's really important because debugging hardware can be quite finicky.

11:02.900 --> 11:12.900
And for example, the pintime, either you flash it over the air,

11:12.900 --> 11:16.900
or you can't really debug it in any way.

11:16.900 --> 11:21.900
Or you have like these small thin wires that are really easy to mess up.

11:21.900 --> 11:27.900
So running it on a normal computer is really helpful.

11:27.900 --> 11:30.900
So that's the developer side, which I tried to improve.

11:30.900 --> 11:32.900
Next up is the battery life.

11:32.900 --> 11:38.900
I think I'm going to skip explaining most of these,

11:38.900 --> 11:44.900
but basically there are a lot of really small things that need to be implemented

11:44.900 --> 11:49.900
to make it really efficient.

11:49.900 --> 11:59.900
For example, one is that the chip itself actually runs at a lower voltage.

11:59.900 --> 12:04.900
So it has a linear regulator inside to lower the voltage.

12:04.900 --> 12:06.900
But that's really inefficient.

12:06.900 --> 12:12.900
There's also a DC-DC converter, but it needs some external hardware.

12:12.900 --> 12:16.900
But because it needs external hardware, it's disabled by default.

12:16.900 --> 12:18.900
But it's like one line of code to enable it.

12:18.900 --> 12:21.900
So it's things like this.

12:21.900 --> 12:24.900
Most things are more complicated than this.

12:24.900 --> 12:31.900
All of these things are implemented in the board package that I mentioned before.

12:31.900 --> 12:38.900
So if any of you like to write your own firmware for this watch,

12:38.900 --> 12:46.900
you can just import the board package and it'll basically do almost everything you want without.

12:46.900 --> 12:50.900
Yeah.

12:50.900 --> 12:52.900
So that's battery life.

12:52.900 --> 12:54.900
Then the display.

12:54.900 --> 13:00.900
This was actually a lot of work.

13:00.900 --> 13:09.900
So as I said, the display is like a really nice display, a very high resolution.

13:09.900 --> 13:12.900
By default, it uses 16 bits per pixel.

13:12.900 --> 13:18.900
The only downside is that the connection to the main market controller is like 8 megabits,

13:18.900 --> 13:22.900
which is like 8.5 frames per second.

13:22.900 --> 13:27.900
So quite slow.

13:27.900 --> 13:32.900
I used a few tracks to speed this up.

13:32.900 --> 13:35.900
Yeah, maybe you've seen it before.

13:35.900 --> 13:39.900
It was part of the responsive.

13:39.900 --> 13:50.900
The first one is that I configured the display to use 12 bits per pixel instead of 16.

13:50.900 --> 13:55.900
This low is the image quality, but not really that much,

13:55.900 --> 14:04.900
especially for smartwatch, which doesn't need that high resolution.

14:04.900 --> 14:08.900
The second one is you can just update a part of the display.

14:08.900 --> 14:11.900
You don't need to update the whole display at once,

14:11.900 --> 14:18.900
because the display itself has a frame buffer in it.

14:18.900 --> 14:24.900
The frame buffer in the display is more memory than in the main market controller.

14:24.900 --> 14:26.900
That's how embedded works.

14:26.900 --> 14:29.900
Sometimes we get like that.

14:29.900 --> 14:32.900
The third one is fast scrolling.

14:32.900 --> 14:38.900
Maybe I can show you quickly.

14:38.900 --> 14:41.900
So it may not be very visible,

14:41.900 --> 14:46.900
but this scrolls with very little delay,

14:46.900 --> 14:51.900
except when the touchscreen locks up.

14:51.900 --> 14:55.900
And...

14:55.900 --> 14:57.900
No?

14:57.900 --> 15:01.900
There you go.

15:01.900 --> 15:03.900
This is actually a hardware feature.

15:03.900 --> 15:08.900
Basically you can say from this line to this line,

15:08.900 --> 15:15.900
I'd like to rotate the display by this many pixels.

15:15.900 --> 15:19.900
It works, but it's a pain to implement.

15:19.900 --> 15:24.900
Oh man, I've had so many headaches.

15:24.900 --> 15:26.900
But it worked.

15:26.900 --> 15:32.900
Anyway, so that's one of these really specific things for this place.

15:32.900 --> 15:34.900
And the fourth one is DMA.

15:34.900 --> 15:37.900
DMA, if you don't know,

15:37.900 --> 15:42.900
you can think of it as like a co-processor that does one thing,

15:42.900 --> 15:46.900
one thing well, which is copying data from one place to one other.

15:46.900 --> 15:50.900
And that's basically the only thing it does.

15:50.900 --> 15:52.900
So you can basically copy...

15:52.900 --> 15:58.900
So what you can do is prepare an area of pixels

15:58.900 --> 16:00.900
and then say to the DMA,

16:00.900 --> 16:04.900
like, hey, copy this now to the SPI bus,

16:04.900 --> 16:07.900
which is how the display is connected.

16:07.900 --> 16:09.900
And then it will start copying in the background

16:09.900 --> 16:13.900
and you can just continue rendering the next block of pixels.

16:13.900 --> 16:16.900
And this can actually really improve performance quite a lot

16:16.900 --> 16:20.900
because the CPU is fast for a market controller,

16:20.900 --> 16:22.900
but not actually that fast.

16:22.900 --> 16:25.900
That's 64 megahertz.

16:25.900 --> 16:28.900
I've implemented all four except for the last one

16:28.900 --> 16:35.900
because basically...

16:35.900 --> 16:39.900
Basically, DMA is a little bit harder to implement in a portable way.

16:39.900 --> 16:41.900
That's also Go-style.

16:41.900 --> 16:46.900
The hardware works a lot like the async await button in many other languages.

16:46.900 --> 16:52.900
You can just say, start this project and later say, just wait until it's finished.

16:52.900 --> 16:57.900
But that's not really how things are usually done in Go.

16:57.900 --> 17:03.900
So we will need to figure out a nice API for this.

17:03.900 --> 17:09.900
But it will get there.

17:09.900 --> 17:13.900
Of course, this display is quite complicated

17:13.900 --> 17:17.900
and you really don't want to write for this one display.

17:17.900 --> 17:22.900
So we have a display API,

17:22.900 --> 17:29.900
which is an interface.

17:29.900 --> 17:36.900
Many displays in the TinyGo driver's package use an interface like this.

17:36.900 --> 17:45.900
Of these, the draw bitmap method is the most important.

17:45.900 --> 17:49.900
And as you can see, it has a pixel-built image type,

17:49.900 --> 17:54.900
which is actually a generic type.

17:54.900 --> 18:05.900
This works a lot like a Go slice, except it's for pixels and in two dimensions.

18:05.900 --> 18:12.900
The main reason I did this is because the display is 12 bits per pixel,

18:12.900 --> 18:17.900
so they don't fit well on the byte binary.

18:17.900 --> 18:21.900
So a Go slice only works for,

18:21.900 --> 18:25.900
when each element falls on the byte boundary.

18:25.900 --> 18:36.900
So basically, we implemented a slice-like type for pixel buffers.

18:36.900 --> 18:41.900
I think this is actually going to be really useful in the future

18:41.900 --> 18:47.900
because there are many really weird pixel layouts in some displays.

18:47.900 --> 18:54.900
I have seen a display with nine bits per pixel that doesn't fit in the bytes or two bytes.

18:54.900 --> 18:58.900
There are all the displays with one bit pixel,

18:58.900 --> 19:03.900
like many E-Ink screens or some OLED screens.

19:03.900 --> 19:07.900
I'm not exactly sure whether this pixel-built image type

19:07.900 --> 19:12.900
is how generic they are supposed to be used,

19:12.900 --> 19:20.900
but they are very useful and they are very efficient as well.

19:20.900 --> 19:29.900
So that's the main set of methods that most displays implement.

19:29.900 --> 19:36.900
But some displays also have special support for the scrolling, which I mentioned before.

19:36.900 --> 19:44.900
Actually, the way you use it is by simply doing a type assert on the display drive

19:44.900 --> 19:47.900
and seeing whether it supports scrolling or not.

19:47.900 --> 19:53.900
That's just a regular old Go type assert.

19:53.900 --> 19:56.900
So that's display API, one level higher.

19:56.900 --> 19:59.900
Then another level higher is tinyGL,

19:59.900 --> 20:09.900
which is something I have been working on lately.

20:09.900 --> 20:14.900
It's basically a graphics library for drawing widgets and stuff.

20:14.900 --> 20:21.900
There are many existing libraries which do the same thing,

20:21.900 --> 20:26.900
like what's happening right now?

20:27.900 --> 20:32.900
Lvgl, maybe people have heard of it.

20:32.900 --> 20:41.900
It's a C library and it's very often used for embedded devices to draw widgets and stuff.

20:41.900 --> 20:48.900
It's also used by Infinitime, which is the default firmware on the pintime.

20:49.900 --> 20:55.900
Downsides are that it's written in C, which is difficult to wrap in Go,

20:55.900 --> 20:58.900
and it has a lot of macros and compiles to ARM constants,

20:58.900 --> 21:03.900
which Go really doesn't like.

21:03.900 --> 21:11.900
The only thing we have are build tags, but really you want to avoid them as possible.

21:12.900 --> 21:19.900
Another library that's often used, especially in toy projects,

21:19.900 --> 21:23.900
are some libraries from Iterfruits.

21:23.900 --> 21:29.900
They are kind of slow, though, because they draw each pixel individually,

21:29.900 --> 21:35.900
which means you have to send the x-coordinate, i-coordinate,

21:35.900 --> 21:39.900
the width and the height of the area in your corner paint,

21:39.900 --> 21:46.900
and then one pixel. That's going to be slow.

21:46.900 --> 21:51.900
It doesn't support 12 bits per pixel like I'm actually using.

21:51.900 --> 21:55.900
It doesn't really work for me either.

21:55.900 --> 22:03.900
Then there's TinyDraw and TinyFont, which are libraries used in TinyCo,

22:04.900 --> 22:07.900
that are part of TinyCo.

22:07.900 --> 22:12.900
But they work sort of similar to the one in Iterfruits.

22:12.900 --> 22:17.900
They're great libraries, but they're not super fast,

22:17.900 --> 22:21.900
so that's why I wanted to make something different.

22:26.900 --> 22:29.900
So that's why I made TinyGL.

22:29.900 --> 22:34.900
It works really well together with the board package that I made.

22:34.900 --> 22:37.900
They are independent.

22:37.900 --> 22:41.900
One of them doesn't import the other, so they're separate,

22:41.900 --> 22:44.900
but because they're an interface match,

22:44.900 --> 22:48.900
you can just really easily use one with the other.

22:48.900 --> 22:55.900
Some of the features include that everything it draws is anti-aliased,

22:56.900 --> 23:00.900
including the text circles.

23:00.900 --> 23:07.900
Actually, I do have a circle in the middle of the screen.

23:07.900 --> 23:13.900
There's my cursor.

23:13.900 --> 23:19.900
There's a circle in the middle, which is anti-aliased,

23:19.900 --> 23:22.900
and these lines are anti-aliased,

23:22.900 --> 23:26.900
which actually took me a week to implement or something.

23:26.900 --> 23:29.900
It's kind of difficult.

23:29.900 --> 23:35.900
I actually based the algorithm for the anti-aliasing in these lines

23:35.900 --> 23:42.900
on an algorithm that was originally used in, I think, the second Star Trek movie,

23:42.900 --> 23:47.900
from the 80s, for the Genesis device.

23:48.900 --> 23:53.900
It was really nice reading the paper and seeing the mention of Star Trek.

23:53.900 --> 23:59.900
But computers from back then are somewhat comparable to my controllers today,

23:59.900 --> 24:03.900
so it makes sense.

24:06.900 --> 24:13.900
I am going to write a blog post in the future about how I implemented these lines

24:13.900 --> 24:16.900
because it's way more complicated than it looks.

24:16.900 --> 24:23.900
It basically is polygon rendering because it's like a rectangle instead of just a line.

24:26.900 --> 24:29.900
Yeah, I think that's it.

24:29.900 --> 24:32.900
Some things I want to work on in the future include,

24:32.900 --> 24:38.900
I mentioned before that I think security is important.

24:38.900 --> 24:42.900
Well, I haven't actually implemented any security features yet,

24:43.900 --> 24:46.900
so that's some work in progress.

24:46.900 --> 24:52.900
For example, in Bluetooth you can change the MAC address every 15 minutes, I believe,

24:52.900 --> 25:01.900
and you can bind the devices so they can connect security the next time.

25:01.900 --> 25:08.900
But that needs some work and probably some flash storage, which is another thing I need to do.

25:08.900 --> 25:11.900
And of course translations.

25:11.900 --> 25:16.900
I plan on looking what's available for our go

25:16.900 --> 25:24.900
and seeing whether any of the existing packages would work for a tiny go.

25:26.900 --> 25:31.900
And maybe write my own, but maybe not because I'm not a dialogue experience, but languages.

25:33.900 --> 25:37.900
So that's it. Any questions?

25:38.900 --> 25:41.900
Thank you.

25:46.900 --> 25:49.900
My takeaway is hardware is very hard.

25:49.900 --> 25:52.900
Tiny go, lots of effort.

25:52.900 --> 25:56.900
Any quick questions because I think Ron needs setup.

25:56.900 --> 25:59.900
Hardware is enjoyable, though.

25:59.900 --> 26:04.900
Was there a question? Please raise your hand again because I lost you.

26:04.900 --> 26:07.900
Sorry. Keep holding your hand up.

26:07.900 --> 26:10.900
Thank you.

26:13.900 --> 26:17.900
Hello. How do you power your earrings?

26:17.900 --> 26:19.900
Sorry. Oh!

26:21.900 --> 26:23.900
Sorry, I totally forgot about them.

26:23.900 --> 26:27.900
There's a small lidsim on the back side.

26:27.900 --> 26:31.900
It's a CR1225.

26:31.900 --> 26:34.900
How long does it last?

26:34.900 --> 26:36.900
About 30 hours, I think.

26:36.900 --> 26:40.900
The most crazy thing is that I actually wrote part of it in go.

26:40.900 --> 26:43.900
And assembly.

26:48.900 --> 26:55.900
Second question is how can we get a kit, like a development kit for the watch?

26:55.900 --> 26:56.900
Sorry?

26:56.900 --> 26:59.900
Is there like a development kit that we can buy?

26:59.900 --> 27:05.900
I believe so, but you'd have to look for the Pine 64 store.

27:05.900 --> 27:11.900
There should be a development kit, so you don't end up breaking the device if you make a mistake.

27:11.900 --> 27:15.900
The Pine 64 people have a stand in the stands building.

27:15.900 --> 27:18.900
Go ask there and they will point you to the right place.

27:18.900 --> 27:20.900
Pine 64.

27:20.900 --> 27:23.900
Any other questions? Really quick.

27:23.900 --> 27:26.900
I see none. Applaus!

