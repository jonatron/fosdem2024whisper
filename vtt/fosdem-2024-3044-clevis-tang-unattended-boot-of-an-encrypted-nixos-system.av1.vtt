WEBVTT

00:00.000 --> 00:13.800
All right.

00:13.800 --> 00:21.120
We are now going to get ready for the last talk of the NixOS Dev Room this year.

00:21.120 --> 00:29.400
We have on stage Julien and Kami, who are going to talk about an attended encrypted

00:29.400 --> 00:34.960
file system boots on NixOS, which everyone who encrypts their hard drives knows about

00:34.960 --> 00:38.800
that program of not being able to reboot remotely.

00:38.800 --> 00:46.240
So give them a round of applause.

00:46.240 --> 00:47.720
Thank you very much.

00:47.720 --> 00:55.400
So I'm Julien Malka and this is Kami Mondeau and we are both old students of Ecole Normale

00:55.400 --> 00:59.320
Superior and we did this during our studies a few months ago.

00:59.320 --> 01:05.560
So we are going to talk about Clevis and Tong on NixOS and I have to say and to thank NLNet

01:05.560 --> 01:11.640
for funding this new feature in NixOS.

01:11.640 --> 01:17.360
So the plan is we are going to motivate why it's interesting to have full disk encryption

01:17.360 --> 01:18.840
and remote servers.

01:18.840 --> 01:24.280
We are going to present Clevis, which is the automated encryption framework, given EAPDES

01:24.280 --> 01:30.920
view of the Tong protocol and then talk about our implementation and show you a demo.

01:30.920 --> 01:37.920
So full disk encryption of remote servers, of course, it looks like a good idea, like

01:37.920 --> 01:44.160
critical data or even non-critical data should be protected by full disk encryption nowadays.

01:44.160 --> 01:52.040
Problem is often more difficult to do it on servers because when you have full disk encryption

01:52.040 --> 01:59.840
you need to basically input your passphrase at boot and this requires physical intervention

01:59.840 --> 02:03.880
so it's a bit painful to reboot servers.

02:03.880 --> 02:08.920
One solution that is often used is spawning a SH server in Itardi.

02:08.920 --> 02:14.400
This way you can instead of having physical intervention you can just SH to your server

02:14.400 --> 02:20.480
and input your key and unlock your root partition and continue booting.

02:20.480 --> 02:25.920
But this still requires synchrony new intervention so if your server reboots for some reason

02:25.920 --> 02:31.200
that it was not planned and you are not awake or doing anything else your server actually

02:31.200 --> 02:32.760
doesn't reboot.

02:32.760 --> 02:38.360
So that's why I think this kind of solution is interesting.

02:38.360 --> 02:46.960
Okay, so before Julian dives in the Macalum-Rallye protocol we are going to present the Clevis

02:46.960 --> 02:49.120
automated encryption framework.

02:49.120 --> 02:56.400
So it's a project developed by the team Latchset which is basically just a big set of batch

02:56.400 --> 03:04.560
scripts wrapping around Jose which is the core encryption system and it's a pluggable

03:04.560 --> 03:08.800
framework for automated decryption.

03:08.800 --> 03:15.480
So there's the notion of PINs which is central is a plugin that implement automated decryption

03:15.720 --> 03:21.600
and to encrypt some data with Clevis, well you just have to do Clevis encrypt and then

03:21.600 --> 03:28.680
you write the PIN you want to use, the config, your plain text message and then you get a

03:28.680 --> 03:34.440
ciphered text in the format GWE.

03:34.440 --> 03:40.360
So the first kind of PIN you can use is TPM 2.0 PIN.

03:40.360 --> 03:49.040
So I don't know exactly how works the encryption using TPM but basically the, well Clevis first

03:49.040 --> 03:55.920
Jose first generates a key and then this key is used to encrypt the message and then this

03:55.920 --> 04:04.200
key is itself encrypted and using the key generated by the TPM and it will be decrypted

04:04.200 --> 04:07.640
the same way when Clevis needs to decrypt the message.

04:07.640 --> 04:18.400
So that's very useful if you require TPM 2.0 and not 1.2 for that to work and then the

04:18.400 --> 04:26.440
most useful kind of PIN is the TANG PIN which was designed by the same team of developers

04:26.440 --> 04:33.800
and so it's a server implementation providing services without the need for an X-Crow.

04:33.800 --> 04:41.960
So basically you do Clevis encrypt TANG and you precise the URL of your TANG server and

04:41.960 --> 04:51.120
this will encrypt your message using the protocol that Julien will describe to you later.

04:51.120 --> 04:58.600
And then there's Shamir secret sharing which is a combination of the, it's a way to break

04:58.600 --> 05:05.320
down a secret into multiple pieces and so there's the notion of threshold here it's

05:05.320 --> 05:12.760
T and its value is 2 and so you basically make a combination in your configuration of

05:12.760 --> 05:21.280
multiple PINs, the previous examples being TPM and TANG and here you see there's three

05:21.280 --> 05:29.960
PINs, one TPM and two TANG servers and the threshold is 2 so you have to have two working

05:29.960 --> 05:32.640
PINs in order to decrypt your secrets.

05:32.640 --> 05:41.120
Obviously at the encryption time you need a whole three PINs to be up.

05:41.120 --> 05:43.640
So Julien was explaining.

05:43.640 --> 05:44.680
Thank you Kami.

05:44.680 --> 05:54.320
I'm going to try to explain a bit how the TANG protocol works which might be, I'll try

05:54.320 --> 06:00.520
to explain it as simple as possible but this is extra extra for you.

06:00.520 --> 06:07.760
So basically the TANG protocol looks like the Diffielman key exchange.

06:07.760 --> 06:15.720
The Diffielman key exchange is something used to get a shared symmetric key between

06:15.720 --> 06:23.280
two actors on an unsecured channel and the idea is not that complicated.

06:23.280 --> 06:28.000
The idea is that you need to imagine that we have a mathematical operation star that

06:28.000 --> 06:33.120
is really, that is easy to compute so if I get two numbers A and B I can compute A star

06:33.120 --> 06:40.480
B but on the other hand super difficult to reverse so if I get C which is A star B it's

06:40.480 --> 06:44.760
very difficult to get A and B.

06:44.760 --> 06:48.760
And the idea is that we have also J which is a public parameter and the idea is that

06:48.760 --> 06:55.200
we have a server and the client that each generates a secret SNC and then they send

06:55.200 --> 07:03.400
their secret star J and then they both on their sides multiply by whatever they receive

07:03.400 --> 07:06.160
from the other side.

07:06.160 --> 07:12.240
So at the end on both sides they get C, JS and SJC which is the same thing so they get

07:12.240 --> 07:18.960
a shared key that they can use to encrypt their messages and talk with each other but somebody

07:18.960 --> 07:26.160
listening here cannot do the separation of these operations so it doesn't get any information.

07:26.160 --> 07:31.560
If the math is a little bit too abstract you can imagine this with paint.

07:31.560 --> 07:39.240
We have J which is the common paint then you have secret paints on each side they do the

07:39.240 --> 07:43.680
mixing of paints and they get each a color and from this color it's very difficult to

07:43.680 --> 07:52.240
find which paints were used to do the mixing then they send both their paints and add their

07:52.240 --> 07:58.480
secret to whatever they receive and they get a shared color which is like an analogy for

07:58.480 --> 07:59.480
the shared key.

07:59.480 --> 08:05.840
This is the if the Diffie-Eleman protocol used on the internet to devise a shared symmetric

08:05.840 --> 08:11.440
key to discuss with somebody and the Tongue protocol is derived from this so there is

08:11.440 --> 08:15.120
two sides of this.

08:15.120 --> 08:21.280
The first side is like the provisioning so it looks like Diffie-Eleman, they both generate

08:21.280 --> 08:27.640
the secret, the server sends J times its secret and the client sends nothing.

08:27.640 --> 08:34.960
The client computes what should be the shared key but doesn't send its secret to the server

08:34.960 --> 08:40.000
and so he divides the key, encodes whatever message he wants to encode with this key and

08:40.000 --> 08:41.600
then throws the key away.

08:41.600 --> 08:48.920
So at this point the client has an encrypted message, ciphertext but doesn't know how to

08:48.920 --> 08:52.680
decrypt it because it throws the key away.

08:52.680 --> 08:55.160
When he wants to decrypt it will do this.

08:55.160 --> 09:02.360
So it will generate a new secret E and send to the server J E plus J C. The server will

09:02.360 --> 09:07.040
take this and multiply by its secret and send it back to the client.

09:07.040 --> 09:16.840
At this point the client does this mathematical operation so whatever received minus J S E

09:16.840 --> 09:21.160
and this gives it another key that it used to decode the message.

09:21.160 --> 09:23.920
And here you have the math of why this works.

09:23.920 --> 09:39.040
So if we go Y minus J S E is X S minus J S E. X was J E plus J C so J E plus J C S

09:39.040 --> 09:47.400
and if you compute this it gives you J E S plus J C S minus J S E which gives J C S

09:47.400 --> 09:48.640
which is K.

09:48.640 --> 09:59.240
So with this manipulation it can find the original key again and decrypt the message.

09:59.240 --> 10:02.680
So what does it give us?

10:02.680 --> 10:06.080
So let's say an attacker gain access to the client.

10:06.080 --> 10:10.960
As I said at this point the client discarded the key only as a ciphertext cannot decrypt

10:10.960 --> 10:17.240
so you gain access to the client cannot do anything.

10:17.240 --> 10:21.400
Take access to the tongue server.

10:21.400 --> 10:27.680
Tongue server doesn't receive any information at no point in this protocol so you have access

10:27.680 --> 10:34.520
of the tongue server you cannot get the secret.

10:34.520 --> 10:41.320
And if you intercept all messages here and here because of what I said like the Diffiel

10:41.320 --> 10:47.320
Man assumption it is very hard to reverse these operations you also get no information.

10:47.320 --> 10:54.400
So basically the only way for an attacker to have the secret would be to get access

10:54.400 --> 11:00.720
of the client and the server at the same time or to be on the local network where you have

11:00.720 --> 11:02.680
your tongue server.

11:02.680 --> 11:06.000
That's the principle of how it works.

11:06.000 --> 11:08.200
Let's talk about the Nixxas implementation now.

11:08.200 --> 11:11.960
Okay thank you Julien for the theory.

11:11.960 --> 11:16.760
Now we're going to dive in the Nixxas implementation.

11:16.760 --> 11:19.080
You'll see that it's really simple.

11:19.080 --> 11:23.520
So if you have your Nixxas laptop with you you can do it live.

11:23.520 --> 11:27.040
If you don't well maybe install Nixxas.

11:27.040 --> 11:31.520
And so first you have to deploy your tongue module.

11:31.520 --> 11:34.440
So it was added by a Jeff Proch.

11:34.440 --> 11:37.000
Who is here by the way?

11:37.000 --> 11:43.240
And you can enable it with simply with services.tongue that's enabled.

11:43.240 --> 11:50.400
Then there's only one parameter really important is the IP address is allow which is critical

11:50.400 --> 11:57.200
because it defines the subnet that you trust because every machine on this subnet will

11:57.200 --> 11:59.040
have access to your tongue server.

11:59.040 --> 12:09.760
And if someone gets your secret.jw using only tongue well it can decipher it.

12:09.760 --> 12:12.600
So you put a network that you trust.

12:12.600 --> 12:17.120
Then you don't forget to open the firewall as I did a lot of time.

12:17.120 --> 12:19.600
So you can change the port.

12:19.600 --> 12:25.600
This is the default port in the Nixxas module but you can put it on port 80 if you want.

12:25.600 --> 12:30.040
So now you have your tongue server.

12:30.040 --> 12:38.400
Then the Clevis module it was packaged inside the init.rd already existed as a Clevis as

12:38.400 --> 12:41.480
an Insignix packages.

12:41.480 --> 12:52.480
So basically it works in init.rd both system dstage1 and scripted init.rd.

12:52.480 --> 13:03.640
So what it does is before decrypting the root partition well it tries to do Clevis decrypt

13:03.640 --> 13:11.760
with the secret.jwe which was put inside your init.rd secret.

13:11.760 --> 13:19.920
And if it succeeds then it pipes the value to decrypt the root partition and if it fails

13:19.920 --> 13:25.880
it falls back and interactive unlocking.

13:25.880 --> 13:28.600
So how now how to use it?

13:28.600 --> 13:30.800
First you have to generate the secret.

13:30.800 --> 13:36.160
So it's really easy you just type in your secret and you pipe it.

13:36.160 --> 13:43.640
Be careful because if you have a you will most certainly not have a return carriage inside

13:43.640 --> 13:49.480
your secret so you have to add a dash n when you pipe to Clevis.

13:49.480 --> 13:56.840
And then you write your Clevis configuration as we showed earlier.

13:56.840 --> 14:01.000
Then when you have your secret you can put it in your etc.

14:01.000 --> 14:06.680
in xy folder or in your flake and then you write this line which is booted in the Clevis

14:06.680 --> 14:07.960
devices.

14:07.960 --> 14:15.800
Then you put here the name of the device inside your file system dot slash root partition

14:15.800 --> 14:17.960
configuration.

14:17.960 --> 14:20.600
So it has to be the same name.

14:20.600 --> 14:28.840
And then well this works only if your root partition is encrypted using one of these

14:28.840 --> 14:32.440
three methods.

15:17.960 --> 15:27.960
The client has also a tpm 2.0 device and what we require.

15:27.960 --> 15:37.160
So first you type in your secret in a secret way so it goes to the secret environment variable.

15:37.160 --> 15:43.240
Then we state the config that we wrote previously in JSON format for Clevis.

15:43.240 --> 15:55.320
So you can see a threshold of 2 for a quick but just.

15:55.320 --> 16:04.760
Then you can pipe your secret to Clevis and creep the secret sharing and with the configuration

16:04.760 --> 16:09.240
that you use.

16:09.240 --> 16:14.800
Snow in post.

16:14.800 --> 16:18.520
So this means that the tongue servers have been reached so that's why you actually have

16:18.520 --> 16:21.000
to choose the sign in keys.

16:21.000 --> 16:22.920
Both tongue servers.

16:22.920 --> 16:24.920
So now you have your secret.

16:24.920 --> 16:29.640
You can try and decrypt it.

16:29.640 --> 16:35.360
Your secret works.

16:35.360 --> 16:39.680
And now you have to modify your configuration.

16:39.680 --> 16:45.480
So first thing because we're using the tpm you have to add the canal module.

16:45.480 --> 16:54.200
So I added both but I think you can probably just add one if you know which one.

16:54.200 --> 16:57.760
Then you add the boot in the configuration.

16:57.760 --> 17:10.480
So it has to map.

17:10.480 --> 17:16.480
So it had to match the file system configuration.

17:16.480 --> 17:21.160
Then you can rebuild.

17:21.160 --> 17:27.040
And while we're rebuild we can turn off one of the tongue sockets.

17:27.040 --> 17:29.080
So the tongue one server.

17:29.080 --> 17:38.040
And yes because we defined in the threshold that just one of two is required.

17:38.040 --> 17:44.400
Then we reboot and we see that it's not a reachable error communicating but it's still

17:44.400 --> 17:46.880
boots very quickly.

17:46.880 --> 17:49.920
Then it's locked out partition right.

17:49.920 --> 18:04.240
So it works but then you turn off the second tongue server just to check that.

18:04.240 --> 18:08.760
And then you can see that there are two errors for both tongue servers.

18:08.760 --> 18:12.040
And so there's an error reading the passphrase.

18:12.040 --> 18:16.680
And now you have to type in your password so if you didn't set up an open SSH server

18:16.680 --> 18:30.200
while you're basically you have to reboot your machine from a.

18:30.200 --> 18:31.360
Okay.

18:31.360 --> 18:33.480
So what's left to do?

18:33.480 --> 18:38.520
Well you can add more pins to match your needs.

18:38.520 --> 18:43.400
So one useful one would be Yubiki.

18:43.400 --> 18:50.680
And then if you have like an exotic encryption solution maybe you can try and use them with

18:50.680 --> 18:55.360
Clevis for instance Veracript or I don't know whatever.

18:55.360 --> 18:59.760
So there's many other solutions to use.

18:59.760 --> 19:03.160
So feel free to contribute and thank you very much for your attention.

19:03.160 --> 19:16.840
We don't have a mic so shout the question and repeat it if you have a question.

19:16.840 --> 19:43.560
Question was in case where the tongue servers are down can you still SSH to input your password

19:43.560 --> 19:46.760
or are you just out of luck?

19:46.760 --> 19:56.200
And the answer is I expected to work correctly with the existing SSH server and it's already

19:56.200 --> 20:14.240
featured so you have to configure it to do that but it's possible.

20:14.240 --> 20:21.720
There is none apart from the fact that Clevis is just fancy wrappers around like the same

20:21.720 --> 20:29.440
calls that the system the crypton world features are doing to the TPM.

20:29.440 --> 20:45.040
I don't know which one was first.

20:45.040 --> 20:50.720
So yes the question was can you put the maybe the configuration.

20:51.720 --> 21:00.720
The question was about the configuration and so the threshold was set to two but we asked

21:00.720 --> 21:07.840
for the TPM to be live to be available and only one of the two tongue servers so it was

21:07.840 --> 21:15.680
very quick but there's actually a combination of pins so there's first the TPM then inside

21:15.680 --> 21:22.040
the SSS configuration there's another SSS pin with the threshold of one so this threshold

21:22.040 --> 21:29.640
applied to the TPM and the SSS with two tongues and the threshold of one so I guess it's okay.

21:29.640 --> 21:49.640
Can you repeat it?

21:49.640 --> 21:57.760
Yes how does encryption key management work with the FS as it supports only one passphrase.

21:57.880 --> 22:04.880
The answer to this it's the same passphrase that you encode in a Clevis secret so what it does

22:04.880 --> 22:14.360
it will first try to decrypt the Clevis secret and if the decryption succeeds then it will use

22:14.360 --> 22:23.360
this key as the encryption for the FS otherwise it will ask you to input it like interactively.

22:23.960 --> 22:31.280
So I guess the answer to this question is currently there is only one key phrase that is either in

22:31.280 --> 22:34.360
your brain or encoded in a Clevis secret.

22:34.360 --> 22:35.360
Yes.

22:35.360 --> 22:46.360
Do you know of any possibility to have an encrypted kernel and init.org so like a bootloader we use the TPM to decrypt the kernel and init.org?

22:47.360 --> 23:00.360
I do not know about this no I don't I mean as you described it it maybe it's possible but I do not know of any implementation of this kind of things.

23:00.360 --> 23:24.360
I guess you need something to decrypt your kernel anyway if you're going to have encrypted kernel what is going to decrypt it?

23:25.360 --> 23:30.360
Yes okay then systemdboot becomes the kernel I don't know.

23:33.360 --> 23:53.360
I think that's pushing it a little bit why would you think you want your kernel to be secret it's like if you're thinking about secrets you want to put in init.org that's something different and we have so currently in XS we have an encrypted init.org secrets but there is also a new features coming into systemdboot and then learn something.

23:54.360 --> 24:05.360
So we have an encrypted system init.org secrets encrypted via the TPM and systemdcrypt what's the name?

24:05.360 --> 24:09.360
Credential systemd credential sorry that's maybe what's more what you want.

24:15.360 --> 24:16.360
Yes.

24:24.360 --> 24:44.360
Yeah I agree so the remark was it's sometimes good not to have like a kernel unencrypted because then an attacker reading your boot partition would know exactly which version of the kernel you're using and maybe target some specific vulnerabilities.

24:44.360 --> 24:46.360
Thank you for the remark.

24:54.360 --> 25:15.360
Okay so the remark was you can use a Kexec to load basically any other kernel that you might have decrypted from the first kernel so that you can still have some kind of encrypted kernel.

25:15.360 --> 25:16.360
Thank you.

25:20.360 --> 25:21.360
Yes.

25:22.360 --> 25:36.360
Should I use the same time server for multiple hosts or set up a different host or set up a different time server for other because any host could decrypt I guess.

25:36.360 --> 25:56.360
Well as long as your tank server is in a secure network that you control the access and you have exclusive access or that you have also set up a TPM on your servers but as long as your network is secure I'd say that the protocol implies that

25:56.360 --> 26:18.360
Tanks servers have not access to anything except their own signing key so you can use as many that's what's cool about the Macalum real real protocol is that you can use as many clients as you want the message doesn't even leave the clients when it's encrypted and the key using for encryption also doesn't leave the client so well they have the key.

26:27.360 --> 26:41.360
Okay so the question was if malicious host reaches your private subnet and gets access to what the client or the.

26:41.360 --> 27:10.360
Well if they get access to the GW secret yes well then they can if they have access to the tank server and the GW then they can decrypt so that's why you have to either well put your tank server on something that you control very much or well encrypt your GW token when you put it on your flake or whatever it should not be clear.

27:11.360 --> 27:27.360
Okay so the question was what happens if your tank server is down is down during the reboot of the server.

27:27.360 --> 27:50.360
Well as you saw well depending on your configuration if you have a lower threshold well it would print an error communicating with the tank server first but then it could depending on your configuration still boot or not if you only have set up one tank server it won't boot and then fall back to interactive unlocking.

27:51.360 --> 28:08.360
And if I may add something you may like configure a system so that it after like it times out trying to unlock your your repartition after some while and reboots and then start again and if it was a transient failure of tank server then you might be saved by that.

28:11.360 --> 28:13.360
We can do one short question.

28:20.360 --> 28:37.360
So there we have some documentation on the next menu. This is sorry this is a merge and available in the next and stable right now it's not in 23.11 and you have you have some documentation in the unstable manual.

28:39.360 --> 28:40.360
Thank you.

28:47.360 --> 28:48.360
So.

28:50.360 --> 28:51.360
Thank you.

