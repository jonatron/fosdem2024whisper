WEBVTT

00:00.000 --> 00:11.960
Thank you everyone for coming to my talk.

00:11.960 --> 00:13.560
My name is Ignat.

00:13.560 --> 00:15.560
I work for Cloudfer.

00:15.560 --> 00:18.040
Who here heard about Cloudfer?

00:18.040 --> 00:20.520
Who's using Cloudfer?

00:20.520 --> 00:25.120
Should be more hands, by the way, because even if he didn't hear about Cloudfer, probably

00:25.120 --> 00:27.720
using Cloudfer one way or another.

00:27.720 --> 00:29.960
This is my first time at FOSDEM.

00:29.960 --> 00:34.480
So thank you very much for exchanging your lunchtime for my talk.

00:34.480 --> 00:37.800
I hope it will be really exciting.

00:37.800 --> 00:42.280
And today we're going to talk about Linux kernel upgrades and how you should do them,

00:42.280 --> 00:48.120
and most likely how you should not do them.

00:48.120 --> 00:50.760
So a little bit about myself.

00:50.760 --> 00:53.320
I do Linux at Cloudfer.

00:53.320 --> 00:59.320
I enjoy system security and performance, and I'm passionate about low-level programming.

00:59.320 --> 01:06.160
So the Linux kernel, drivers, bootloaders, and other stuff, reading in unsafe programming

01:06.160 --> 01:07.160
languages.

01:07.160 --> 01:13.480
Okay, before we start, a little bit of show of hands.

01:13.480 --> 01:16.320
So what would you do in this case?

01:16.320 --> 01:19.040
Imagine you're working at the shoot on your laptop.

01:19.040 --> 01:21.720
You're doing stuff.

01:21.720 --> 01:25.440
And yeah, and suddenly this pop-up comes in.

01:25.440 --> 01:30.360
I'm like, oh, updates available.

01:30.360 --> 01:32.440
What would you do?

01:32.440 --> 01:34.440
Like install now?

01:34.440 --> 01:36.440
Who's install now?

01:36.440 --> 01:38.440
Oh, nice.

01:38.440 --> 01:41.000
Well, who's resumed later?

01:41.000 --> 01:43.000
Do later?

01:43.000 --> 01:44.160
50-50.

01:44.160 --> 01:49.440
So those people who raise their hands for install now, what if instead it wasn't your

01:49.440 --> 01:51.640
computer but a production system?

01:51.640 --> 01:54.320
Who would press install now?

01:54.320 --> 01:58.680
No, very few.

01:58.680 --> 02:02.640
But yeah, you like Bitcoin probably, right?

02:02.640 --> 02:03.640
Risky.

02:03.640 --> 02:08.120
Yeah, and usually it's something like that for production system, right?

02:08.120 --> 02:14.080
So it's a difficult choice between remind me later and don't remind me at all.

02:14.080 --> 02:16.600
Please don't install.

02:16.600 --> 02:19.400
And this is natural, I think.

02:19.400 --> 02:24.840
Because it's connected to the fact how do we perceive software updates, especially for

02:24.840 --> 02:27.360
production systems, right?

02:27.360 --> 02:31.800
Well, we don't perceive them really good, right?

02:31.800 --> 02:39.160
So we perceive software updates as kind of these monsters where they come in, they're

02:39.160 --> 02:40.480
nasty, they're bugging you.

02:40.480 --> 02:42.880
They kind of like an update can break your stuff.

02:42.880 --> 02:47.520
Like the traditional engineering motto, if it works, don't touch it, why do we need to

02:47.520 --> 02:49.880
install an update, right?

02:49.880 --> 02:50.880
Yeah.

02:50.880 --> 02:56.320
But the thing is, with regular software updates, we perceive them as monsters, but they're

02:56.320 --> 02:57.320
not really scary.

02:57.320 --> 03:03.160
They're kind of annoying and ugly, but pesky, but not that much.

03:03.160 --> 03:09.880
When it comes to Linux Chrome upgrades forever, it's mostly like this big monster trying to

03:09.880 --> 03:12.880
destroy the universe, right?

03:12.880 --> 03:13.880
And why that?

03:13.880 --> 03:21.200
And again, it's natural because, well, we know how to deal with regular software updates.

03:21.200 --> 03:29.000
Yeah, you have a service, it crashes once a week in production, how do we fix it?

03:29.000 --> 03:36.240
Well, if you use like system D, you'll just set a policy for it to restart it, and yeah,

03:36.240 --> 03:37.240
job is done.

03:37.240 --> 03:38.640
It can go home.

03:38.640 --> 03:42.640
Well, yeah, you'll be kind of restarting a service once a week.

03:42.640 --> 03:47.360
Your service will be in slightly degraded state, but yeah, you'll buy yourself some time

03:47.360 --> 03:49.760
to investigate and fix it later.

03:49.760 --> 03:54.840
When the Linux crash, Linux kernel crashes, however.

03:54.840 --> 03:57.760
Well, technically, this is you, right?

03:57.760 --> 04:03.360
So it's end of the world because you don't have any system D to restart it.

04:03.360 --> 04:06.800
You don't have any metrics and understanding why it happened.

04:06.800 --> 04:08.400
Your service is not reachable.

04:08.400 --> 04:10.080
No SSH to debug nothing.

04:10.080 --> 04:14.000
Well, it's kind of, it's indeed end of the universe.

04:14.000 --> 04:20.320
And that's why usually we're scared of software updates, but when it comes to Linux kernel

04:20.320 --> 04:25.560
updates, we're scared like even more.

04:25.560 --> 04:31.920
And this why like people avoid updating their Linux kernel for the most part, right?

04:31.920 --> 04:34.240
Especially in production systems.

04:34.240 --> 04:36.520
But there are common risks.

04:36.520 --> 04:41.480
If you don't apply software updates regularly, especially for the Linux kernel.

04:41.480 --> 04:49.840
So the first one of them is like your bugs are not getting fixed.

04:49.840 --> 04:52.120
And here's some statistics.

04:52.120 --> 04:58.400
So I will be talking about the Linux kernel release cycles a little bit later to introduce

04:58.400 --> 04:59.400
you.

04:59.720 --> 05:08.680
This is basically the preview is a snapshot of all bug fixes releases of a stable kernel

05:08.680 --> 05:10.800
branch 6.1.

05:10.800 --> 05:17.760
So the latest Linux LTS kernel is 6.6, but because it doesn't have as many releases,

05:17.760 --> 05:22.720
so you don't get pretty graphs, I decided to go to the previous one, 6.1.

05:22.720 --> 05:30.880
And what this graph shows you is the number commits per each bug fix release on a 6.1

05:30.880 --> 05:31.880
stable kernel.

05:31.880 --> 05:38.440
So again, I'll be talking about release types later in this talk, but you at this point,

05:38.440 --> 05:43.120
you should know that these bug fixes releases happen roughly every week.

05:43.120 --> 05:46.240
And these bug fixes releases are what the name says.

05:46.240 --> 05:48.240
They're only bug fixes.

05:48.240 --> 05:52.600
There are no new features, no subsystem rewrite bugs and security vulnerabilities.

05:53.480 --> 06:05.160
And as you can see, so far the 6.1 stable kernel had 67, 76 releases, and out of 76

06:05.160 --> 06:10.600
releases, there are 50 releases with more than 100 commits in them.

06:10.600 --> 06:15.480
So it means 100 bug fixes every week.

06:15.480 --> 06:21.480
Almost every release, really, like 80% or something, right, if I'm doing the mass write.

06:21.560 --> 06:28.480
20 releases, so it's 25-ish percent every four release, every fourth release, so roughly

06:28.480 --> 06:34.720
every month, have more than 200 commits and maybe 200 potential bug fixes.

06:34.720 --> 06:40.200
And there are like these five mega releases with more than 500 commits in them.

06:40.200 --> 06:45.200
And actually, if you look in the graph, it's actually seven, but the last two barely made

06:45.200 --> 06:46.640
it to the 500.

06:46.640 --> 06:51.720
But yeah, these are like these mega releases with a lot of commits.

06:51.720 --> 06:57.840
So if you don't upgrade your kernel regularly, your system runs with all these potential

06:57.840 --> 07:03.640
bugs, like, and every week you delay, you're kind of missing out at least on 100 bug fixes

07:03.640 --> 07:05.640
in your kernel.

07:05.640 --> 07:12.640
Second, what you'll be missing out is on potential performance improvements.

07:13.640 --> 07:22.640
This is a snapshot from Cloud 4 production systems when we started evaluating, we were

07:22.640 --> 07:29.640
using at the time the 5.4 stable kernel and we started to evaluate 5.10 kernel.

07:29.640 --> 07:37.640
And so we did like half and half deployment to set of identical servers, like one with

07:37.640 --> 07:38.640
5.4, one with 7.

07:38.640 --> 07:45.640
And this is like, this graph shows the, you know, like average memory consumption per

07:45.640 --> 07:51.640
server and you can see that on 5.10, we have much less memory consumption.

07:51.640 --> 07:53.640
And people are like, what did we break?

07:53.640 --> 07:55.640
Like, what happened?

07:55.640 --> 07:57.640
And nothing bad happened.

07:57.640 --> 08:02.640
It's actually, yeah.

08:02.640 --> 08:09.640
So that was 5.4, 5.4 versus 5.7.

08:09.640 --> 08:15.640
So we kind of saved something around 5 gigs of RAM per server.

08:15.640 --> 08:20.640
And like, at first we thought something broke, but when you dig later into the mailing list,

08:20.640 --> 08:26.640
you just, you see that like, you know, like some other folks in this case, this was Facebook

08:26.640 --> 08:33.640
now matter, and nice people did some improvements in the kernel code and improved the memory

08:33.640 --> 08:34.640
management system.

08:34.640 --> 08:38.640
And now you are consuming less memory for the same workload, with the same performance.

08:38.640 --> 08:39.640
Right?

08:39.640 --> 08:42.640
So it's like, it's almost like downloading RAM from the Internet.

08:42.640 --> 08:49.640
And you basically get it for free if you just apply an update, like it's open source, right?

08:49.640 --> 08:57.640
And recent news, for example, the latest LTS kernel is 6.6 and it rumored that it has a new

08:57.640 --> 08:58.640
scheduler in that.

08:58.640 --> 09:04.640
And there is a phoronics article that says like, if you're using Nginx, with that scheduler,

09:04.640 --> 09:06.640
it will be much, much more performant.

09:06.640 --> 09:11.640
So you'll get it for free as well if you move to 6.6 potentially.

09:11.640 --> 09:17.640
I mean, I don't have any pretty graphs because it didn't work better for us, but maybe for

09:17.640 --> 09:18.640
you it will.

09:18.640 --> 09:19.640
Yeah.

09:19.640 --> 09:25.640
And I mean, looking a little bit forward to the next talk, after mine, there will be some

09:25.640 --> 09:30.640
discussion, I hope, regarding some security improvements with TPMs and the Linux kernel,

09:30.640 --> 09:36.640
and it will involve some code probably, and you only can get it if you upgrade.

09:36.640 --> 09:46.640
So let's look at the same data, but from the point of view of accumulating changed delta.

09:46.640 --> 09:54.640
So this is basically the same data, number of commits per release, but it's kind of accumulating.

09:54.640 --> 09:58.640
It shows the number of commits since the initial release, right?

09:58.640 --> 10:05.640
And in this graph, you can easily see you can commit, you can calculate changed delta.

10:05.640 --> 10:14.640
For example, if you're on a 6.1.10 bug fix release and you want to upgrade to 6.120, you

10:15.640 --> 10:22.640
can commit changed delta is 1,762 commits, right?

10:22.640 --> 10:29.640
And basically, if you assume, which would be natural to assume the fact that the number

10:29.640 --> 10:36.640
of changes is proportional to risk, so for example, these are like 1,762 bug fixes you're

10:36.640 --> 10:41.640
running with, so it's kind of like the amount of risk you're taking by not upgrading is

10:41.640 --> 10:44.640
proportional to that number.

10:44.640 --> 10:49.640
Now let's say you wanted to upgrade, but for some reason you decided to delay, and you

10:49.640 --> 10:55.640
decided for, like, I don't know, it's end of the quarter you had a big incident, you

10:55.640 --> 11:02.640
have, you know, like your company gets a big contract, so you decided not to change anything

11:02.640 --> 11:07.640
to be more stable for the time being, and you're postponing the upgrade, and when you

11:07.640 --> 11:14.640
actually decide to upgrade now, you're upgrading from 6.1 to 10 to 6.1 to 30, which is like

11:14.640 --> 11:17.640
you just extended your not upgrading time twice.

11:17.640 --> 11:26.640
And you might think naturally that your risk grew 2x, but if you calculate the difference

11:26.640 --> 11:34.640
here, you may see that in some cases, a 2x postponing, 2x not time not upgrading, your

11:34.640 --> 11:40.640
risk actually can grow higher, now your risk grew 2.221.

11:40.640 --> 11:47.640
Right, so the risk sometimes of not upgrading systems and delaying may grow higher than

11:47.640 --> 11:50.640
the time you're not upgrading.

11:50.640 --> 12:02.640
So yeah, for 2x delay of not upgrading, we get 2.21 more risk of hitting above.

12:02.640 --> 12:08.640
If you're not upgrading, security vulnerabilities are not getting patched.

12:08.640 --> 12:18.640
So this is a similar graph, but it now shows only publicly known CVEs patched in a bugfix

12:18.640 --> 12:29.640
release, and just this data is actually crowdsourced, so it might be incomplete, but even from this

12:29.640 --> 12:38.640
you can see that out of 71 releases, for which data is available right now, 56 releases,

12:38.640 --> 12:45.640
like again almost 80%, have at least one CVE patched.

12:45.640 --> 12:54.640
And there is 18 releases again, 20, 25%, with more than five CVEs patched.

12:54.640 --> 13:00.640
So again, if you're not upgrading kernel regularly, you're running not only with security

13:00.640 --> 13:06.640
vulnerabilities, you're running with known, publicly known security vulnerabilities,

13:06.640 --> 13:12.640
for which most likely an exploit is available somewhere on the internet.

13:12.640 --> 13:17.640
Not patching your security vulnerabilities also puts a risk on your compliance, so if

13:17.640 --> 13:24.640
your production systems are subject to some sort of compliance, you have a required time

13:24.640 --> 13:28.640
at which you should be patching these vulnerabilities.

13:28.640 --> 13:34.640
So for example, if you're subject to PCI DSS compliance, like for most payment systems

13:34.640 --> 13:42.640
and stuff, it says that the critical or high security patches or updates should be patched

13:42.640 --> 13:44.640
within one month of release.

13:44.640 --> 13:51.640
So imagine there is a known, publicly known security vulnerability in the Linux kernel

13:51.640 --> 13:59.640
and you have one month to fully roll it out to your production systems.

13:59.640 --> 14:02.640
Who here knows about Acvifox?

14:02.640 --> 14:04.640
What happened to it?

14:04.640 --> 14:06.640
A few hands.

14:06.640 --> 14:12.640
So it wasn't about the Linux kernel, but Acvifox was running an Apache server, an old version

14:12.640 --> 14:18.640
and patched with known security vulnerabilities and people used an exploit on their system

14:18.640 --> 14:21.640
and exultrated some data.

14:21.640 --> 14:24.640
And it was a big mess.

14:24.640 --> 14:27.640
It was really expensive for the company.

14:27.640 --> 14:33.640
It cost its reputation as well as a lot of money, compensation, a lot of lawsuits,

14:33.640 --> 14:36.640
so very, very, very bad.

14:36.640 --> 14:40.640
Which brings us to not so fun fact.

14:40.640 --> 14:48.640
You remember like in the old days when you go to admin forums in 2000 and people were boasting

14:48.640 --> 14:54.640
around how long their server, how stable their servers are posting their uptime.

14:54.640 --> 14:57.640
Like my uptime is two years, three years.

14:57.640 --> 15:03.640
Well, since Apache and Linux kernel requires a reboot, now it's not cool anymore.

15:03.640 --> 15:09.640
So if your uptime is more than 30 days, you're most likely vulnerable and not compliant to something.

15:10.640 --> 15:17.640
So now let's talk about an anti-partness for Linux kernel releases.

15:17.640 --> 15:25.640
If you're managing a production system, for most software updates there is some kind of a change management process

15:25.640 --> 15:35.640
or well understood practices which usually like sysadmins, sres and engineers apply to manage change.

15:35.640 --> 15:40.640
But most of them unfortunately do not apply to the Linux kernel.

15:40.640 --> 15:48.640
So when you go and want to update your production system, oftentimes for a software update,

15:48.640 --> 15:51.640
the change management process will ask you why.

15:51.640 --> 15:58.640
Why do you want to update and which things from the change log on this new version is applicable to us.

15:58.640 --> 16:05.640
Like are we really fixing bugs that are hitting us? Are we really fixing TVs that are applicable to us?

16:05.640 --> 16:11.640
Well, and it doesn't apply here just because of this graph, right?

16:11.640 --> 16:20.640
So remember these bug fix releases happen every week and like with most of the releases having more than 100 commits,

16:20.640 --> 16:27.640
so it doesn't mean that every week you should be going through all the commits and trying to understand

16:27.640 --> 16:31.640
if that particular fix is actually applicable to your system.

16:31.640 --> 16:38.640
For this it's very expensive. You need a huge team of really good Linux kernel experts to understand

16:38.640 --> 16:46.640
if you know like this off by one thing in the memory management subsystem is actually triggerable on your work.

16:47.640 --> 16:51.640
So if you do go this way, mostly you'll be doing something like this.

16:51.640 --> 16:58.640
You will be just continuously stamping releases for no particular reason with no analysis.

17:01.640 --> 17:04.640
Then goes for security vulnerabilities.

17:04.640 --> 17:12.640
You say, yeah, we need like we have five CVs we need to patch due to compliance and then you may ask somebody may ask the question,

17:12.640 --> 17:18.640
is the security vulnerability actually exploitable in our systems? Do we use that subsystem?

17:18.640 --> 17:27.640
Sometimes it's an easy answer if it's in a driver for I2C and you're on a machine which doesn't have an I2C,

17:27.640 --> 17:36.640
then you can say no, but most of the time it's much more hard and like many exploits, many successful exploits

17:36.640 --> 17:40.640
are not like some kind of high severity big vulnerability.

17:40.640 --> 17:47.640
Sometimes attackers manage to change smaller vulnerabilities properly to get an exploit.

17:47.640 --> 17:56.640
So going back to that, like going back to this question if you really think of it like who can answer this question?

17:56.640 --> 18:05.640
Technically this question can be answered by the attacker because if the attacker has the list of the CVs running in the system,

18:06.640 --> 18:11.640
they're highly motivated to break into the system and this is their bread and butter.

18:11.640 --> 18:16.640
They spend like 24 or 7 to design and implement successful exploits.

18:16.640 --> 18:25.640
But unfortunately you're not asking this question to the attacker, you don't know who they are, right?

18:25.640 --> 18:32.640
You're asking for a security patch reviewer, you're going to some team for security people and they're like,

18:32.640 --> 18:36.640
oh is this vulnerability applicable?

18:36.640 --> 18:40.640
And they're highly motivated to go home on time, right?

18:40.640 --> 18:46.640
And they need to review several patches a day, not only from the Linux kernel but from many other subsystems

18:46.640 --> 18:52.640
and do other stuff like doing security architectures, doing compliance, many things.

18:52.640 --> 18:55.640
So it's kind of you're asking this person, right?

18:55.640 --> 18:58.640
And the quality of that answer will not be great.

18:58.640 --> 19:01.640
They will say like, yeah, maybe yes, maybe no.

19:01.640 --> 19:09.640
So the best course of action is just not ask this question and assume that every CV is applicable to your workload and patch it.

19:11.640 --> 19:18.640
Well, one of the traditional approaches in upgrading stuff, especially the Linux kernel is soaking.

19:18.640 --> 19:25.640
Like let's put it in the cannery somewhere and soak it for one month to ensure we don't get anything.

19:25.640 --> 19:35.640
Yeah, but basically you come back to this by soaking it in a subset of your production, you're not releasing to elsewhere

19:35.640 --> 19:44.640
and you start accumulating change delta and therefore your risk of not upgrading grows and hitting a potential bug.

19:44.640 --> 19:52.640
Same with security vulnerabilities, if you're soaking it somewhere, you're not patching CVs in your production

19:52.640 --> 19:59.640
and you'll have the risk of being hacked and you're probably, for one month's soak, you're probably all,

19:59.640 --> 20:08.640
like if you have a one month's soak time somewhere in a cannery, you're already violating some of the compliance which dictates you have 30 days to roll out everywhere.

20:10.640 --> 20:14.640
But what does high soak time means in practice?

20:14.640 --> 20:20.640
It's usually because we just don't know what we're looking for and what it translates to.

20:20.640 --> 20:25.640
We don't have any success metrics or observability how our kernel performs,

20:25.640 --> 20:33.640
is it performed the same way after upgrade as it was performing before that.

20:35.640 --> 20:37.640
We also don't know our workload.

20:39.640 --> 20:44.640
My team gets questions, the same question from many teams, right?

20:44.640 --> 20:48.640
Will the kernel break my software?

20:48.640 --> 20:56.640
But for every team, the subsystem of interest is different.

20:56.640 --> 21:01.640
For a database team, they're mostly focused on IEO and file system performance,

21:01.640 --> 21:10.640
but for some image processing team, they mostly care about CPU scheduling and CPU performance.

21:11.640 --> 21:16.640
The question should be, will it, I'm interested in this particular subsystem,

21:16.640 --> 21:23.640
will it break my workload within IEO workload or like CPU bound workload

21:23.640 --> 21:27.640
or I'm interested in some hardware or something like that, networking as well.

21:29.640 --> 21:35.640
And probably it indicates lack of sufficient production kernel testing.

21:36.640 --> 21:42.640
Within the Linux kernel, you can also ensure that an update doesn't break someone's workload

21:42.640 --> 21:45.640
if you write a particular Unix test, an integration test.

21:45.640 --> 21:51.640
The Linux kernel has this nice suite called case self-test, which is easily extendable.

21:51.640 --> 21:57.640
If you care about a particular feature in the Linux kernel or a particular behavior,

21:57.640 --> 22:01.640
you can easily write a program which exercises that behavior

22:01.640 --> 22:05.640
and verifies that each upgrade keeps that behavior.

22:05.640 --> 22:12.640
Even though the kernel itself is written in C, you can write these tests in any programming language and even scripts.

22:15.640 --> 22:19.640
Sometimes you just get, yeah, whatever, kernel is just too critical.

22:19.640 --> 22:23.640
Let's have more approvals before we deploy.

22:23.640 --> 22:29.640
Regular software requires one approval and the Linux kernel should require two or three approvals.

22:29.640 --> 22:36.640
And again, this is related to the fact that we perceive kernel as a, you know, like,

22:36.640 --> 22:39.640
bad scary monster which can destroy the universe.

22:39.640 --> 22:45.640
But what if I told you that kernel deploys are inherently safer than any other software?

22:45.640 --> 22:47.640
Would you believe me?

22:49.640 --> 22:50.640
Who believes?

22:51.640 --> 22:53.640
You're in the matrix, yes.

22:54.640 --> 22:59.640
We learned it the hard way actually in CloudFare.

22:59.640 --> 23:04.640
So this is like a map of CloudFare data centers around the world.

23:04.640 --> 23:09.640
It's maybe even outdated, but the gist is like, yeah, we have a lot of data centers around the world.

23:09.640 --> 23:13.640
And with regular software, how do the updates happen?

23:13.640 --> 23:16.640
So from a 1000 feet view perspective.

23:16.640 --> 23:21.640
So engineers update the software package, push it to our registry package.

23:21.640 --> 23:26.640
Registry then the config management picks it up, downloads a new package.

23:26.640 --> 23:32.640
Also the config management may be configured to restart the service which uses the package.

23:32.640 --> 23:36.640
It can be graceful or non-graceful depending on the context.

23:36.640 --> 23:37.640
It doesn't matter.

23:37.640 --> 23:47.640
But the gist is new, bad, or good code can propagate through all this network without proper safeguards in minutes.

23:48.640 --> 23:50.640
And CloudFare learned it this hard way.

23:50.640 --> 23:57.640
So we had several bad outages where we didn't have proper safeguards for stage rollouts of some software.

23:57.640 --> 24:05.640
So we almost caused global wide network outages and these are described in these blog posts.

24:05.640 --> 24:09.640
On the contrary, how does Linux kernel upgrade works?

24:09.640 --> 24:12.640
The gist is it requires a reboot.

24:13.640 --> 24:22.640
So we, and to reboot the server, what we do is we drain traffic from the server, put it out of production, actually reboot.

24:22.640 --> 24:28.640
Then it comes up, it contacts our config management, we wait for it to be reconfigured.

24:28.640 --> 24:33.640
We run some basic acceptance tests and put back the servers into production.

24:34.640 --> 24:38.640
And I mean we would be crazy if we reboot everything at once, so we don't.

24:38.640 --> 24:42.640
So we have automation rebooting servers in one by one or in batches.

24:42.640 --> 24:51.640
So what it means is kind of, it's an inherently natural, slow-paced, gradual rollout with minimal impact.

24:51.640 --> 24:53.640
If things go wrong.

24:53.640 --> 24:55.640
Did we release kernels with bugs?

24:55.640 --> 24:56.640
Yes.

24:56.640 --> 24:59.640
But yes, some servers didn't come up properly.

24:59.640 --> 25:05.640
Some servers started showing errors and there were only a couple of servers.

25:05.640 --> 25:09.640
So we like reverted the release and like there was no visible impact.

25:14.640 --> 25:21.640
One problem is why people are afraid of running kernel releases is they don't understand them.

25:21.640 --> 25:24.640
How the kernel release process works.

25:24.640 --> 25:32.640
So kernel versions are designated by three numbers, like one number dot, another number dot, and then another dot.

25:32.640 --> 25:35.640
Example, like 6.132.

25:37.640 --> 25:41.640
Who here knows about semantic versioning?

25:42.640 --> 25:44.640
Almost everyone.

25:44.640 --> 25:49.640
So the gist of this talk is this is not a semantic versioning system.

25:49.640 --> 25:54.640
Everyone confuses this with a semantic versioning and it's not.

25:54.640 --> 26:06.640
But instead, what really is the first two numbers mean the major version, not major or minor as in semantic versioning.

26:06.640 --> 26:10.640
And the right most number means bug and security fixes.

26:10.640 --> 26:18.640
And when the right most number increments, you most always never get new features or major subsystem rewrites.

26:18.640 --> 26:24.640
So it's not only bug fixes or security vulnerabilities, nothing else, no new functionality.

26:24.640 --> 26:27.640
So how do these releases created?

26:27.640 --> 26:37.640
So the main bleeding edge we call it source code is stored in a git repository managed by this person.

26:37.640 --> 26:39.640
Who knows this person?

26:41.640 --> 26:44.640
We call him benelope dictator, right?

26:44.640 --> 26:47.640
So, yeah.

26:47.640 --> 26:52.640
The features are developed in branches, subsystem branches.

26:52.640 --> 26:58.640
So for example, you have subsystem for drivers, memory management, and that.

26:58.640 --> 27:03.640
And once in a while Linus pulls changes from these branches.

27:03.640 --> 27:05.640
This is where the pull request probably came from.

27:05.640 --> 27:07.640
I don't know, I'll note that for that.

27:07.640 --> 27:13.640
But the original pull request, not like fancy PRs that we have now, but it was an email saying,

27:13.640 --> 27:15.640
hey Linus, can you pull from my branch?

27:15.640 --> 27:17.640
This was a pull request.

27:17.640 --> 27:20.640
And it still is actually in the Linux kernel.

27:20.640 --> 27:25.640
Yeah, so Linus pulls all these changes from subsystem branches.

27:25.640 --> 27:31.640
And once in a while, he branches out the main branch into stable branches,

27:31.640 --> 27:35.640
which designate a major stable kernel release.

27:35.640 --> 27:38.640
And this happens roughly every nine to 10 weeks.

27:39.640 --> 27:47.640
Eventually, when bug fixes get accumulated, you get a tagged version on a stable branch,

27:47.640 --> 27:50.640
which indicates a bug fix release.

27:50.640 --> 27:54.640
So for example, you get 6.2.1.

27:54.640 --> 27:57.640
But how these bug fixes get propagated there?

27:57.640 --> 28:05.640
So they're not, if you have a bug, you do not submit a fix directly to a stable branch.

28:05.640 --> 28:10.640
Instead, you actually have to go through a respective subsystem maintainer

28:10.640 --> 28:17.640
to ensure this bug is not only fixed in the stable branch, but in the main branch and all other branches.

28:17.640 --> 28:24.640
So you actually commit your bug fix to the particular subsystem where the bug is,

28:24.640 --> 28:29.640
which will eventually get propagated to the main branch.

28:29.640 --> 28:34.640
But once it's in the main branch, it's not just merged into the stable branch.

28:34.640 --> 28:39.640
These bug fixes commit, especially mark, and the maintainers for the stable branches,

28:39.640 --> 28:44.640
the stable branches all have maintainers, they basically cherry-pick these bug fixes.

28:44.640 --> 28:50.640
And when enough bug fixes are getting accumulated, they do another bug fix release,

28:50.640 --> 28:53.640
which happens roughly every week.

28:53.640 --> 28:59.640
So yeah, a new major stable kernel is released every nine to 10 weeks,

28:59.640 --> 29:04.640
and it's the so-called merged window where new features get merged.

29:04.640 --> 29:08.640
There are only two weeks of the merged window usually.

29:08.640 --> 29:12.640
And the rest seven weeks are for testing in bug fix.

29:12.640 --> 29:17.640
And so even the major version receives a lot of bug fix in testing in the first place.

29:17.640 --> 29:22.640
And what you have to remember is leftmost version means nothing.

29:22.640 --> 29:32.640
So in Galway we had this problem where we, at some point, when we upgraded for 4.9 to 4.20, it was fine.

29:32.640 --> 29:36.640
But when we wanted to upgrade to 4.20 to 5.0, people were like,

29:36.640 --> 29:40.640
oh, it's the leftmost major version of this.

29:40.640 --> 29:41.640
It's probably really scary.

29:41.640 --> 29:42.640
No, it's not.

29:42.640 --> 29:48.640
It can even have less features than the previous major release.

29:48.640 --> 29:56.640
Linus himself tells that he just increments the leftmost number when he runs out of fingers on his hands and toes.

29:56.640 --> 30:01.640
But for whatever reason, sometimes he increments when the middle number is 19,

30:01.640 --> 30:04.640
sometimes it's 21, and sometimes it's 20.

30:04.640 --> 30:10.640
So apparently he has a variable number of fingers.

30:10.640 --> 30:17.640
Yeah, and bug fix or patch releases are released almost around once a week.

30:17.640 --> 30:21.640
They are denoted by the rightmost version number.

30:21.640 --> 30:25.640
They're usually cherry-picked from the main Linux branch.

30:25.640 --> 30:29.640
And the rule is there's always no new features.

30:29.640 --> 30:33.640
Therefore, regressions are quite rare.

30:33.640 --> 30:42.640
They almost always contain critical security patches, and you almost always want to apply it.

30:42.640 --> 30:50.640
Well, the problem with major kernel upgrades is that the major stable branch is kept alive around two, three months,

30:50.640 --> 30:51.640
and then it's abandoned.

30:51.640 --> 30:58.640
It's declared end of life, and no new bug fixes and security patches are backported there.

30:58.640 --> 31:03.640
And the assumption that at this point you will have a new stable merger version available,

31:03.640 --> 31:05.640
and you should just upgrade the merger version.

31:05.640 --> 31:13.640
But sometimes it's very costly to evaluate the major version because you do get new features and potential regressions.

31:13.640 --> 31:23.640
For this, there are so-called long-term stable releases where bugs and security features are backported for at least two years,

31:23.640 --> 31:27.640
and it's usually the last stable release of the year.

31:27.640 --> 31:32.640
Therefore, the so-called LTS stable release is released once a year,

31:32.640 --> 31:42.640
and if you follow these, which we do, for example, it provides you enough time for more rigid evaluation of the next long-term release.

31:42.640 --> 31:50.640
And surprisingly, the releases are quite well described on the kernel.org website slash releases.

31:50.640 --> 31:57.640
I was surprised how many people don't go beyond the main page of kernel.org to read stuff.

31:57.640 --> 32:02.640
So yeah, go and read it. It's quite interesting.

32:02.640 --> 32:09.640
Okay, so what do we do for safe and easy production kernel upgrades?

32:09.640 --> 32:16.640
First, don't create a dedicated deploy procedure for the Linux kernel,

32:16.640 --> 32:26.640
because kernel upgrades are usually less risky than other software who's been convinced today.

32:26.640 --> 32:29.640
Well, some hands, okay.

32:29.640 --> 32:38.640
A simple stage rollout is usually enough, and kernel upgrades are naturally slow paced because they require a reboot.

32:38.640 --> 32:48.640
And because you probably won't reboot everything at once, there is a lot of headroom to abort the deploy if things look wrong.

32:49.640 --> 32:53.640
Do avoid justifying bug fix kernel upgrades.

32:53.640 --> 32:56.640
Apply them with no questions asked.

32:56.640 --> 33:01.640
There is almost always something that is applicable to your workload,

33:01.640 --> 33:06.640
and it contains only bug fixes and security vulnerabilities only.

33:06.640 --> 33:13.640
And also minimize cannery soak times and prefer to use metrics-diven approach.

33:13.640 --> 33:19.640
You can sit in this 30-day window of operating your production kernel everywhere.

33:19.640 --> 33:23.640
So if you require high soak time, think about it.

33:23.640 --> 33:30.640
What metrics or observability will give you more confidence to roll out this kernel faster?

33:30.640 --> 33:36.640
Stay on the long-term branch if validating a major version is costly,

33:36.640 --> 33:39.640
so you have to do a lot of analysis and testing.

33:40.640 --> 33:45.640
You get at least two years of bug fixes and security patches,

33:45.640 --> 33:48.640
but don't wait for the two years, of course.

33:48.640 --> 33:55.640
Better what we do, for example, we start evaluating the next long-term release early in one year when it's available.

33:55.640 --> 34:03.640
Again, apart from just being proactive, it gives us more features early

34:03.640 --> 34:09.640
and sometimes, most of the times, better performance and resource utilization.

34:09.640 --> 34:13.640
And we also don't accumulate too much change delta, as I described before.

34:16.640 --> 34:22.640
If you don't have it, implement and improve production testing for major version validation.

34:22.640 --> 34:30.640
Basically, faith-lab grading the kernel requires you to understand what your workload is.

34:30.640 --> 34:36.640
If you're a web server or a database, what specific subsystems are in the target of your workload?

34:36.640 --> 34:42.640
Because sometimes, even a bug or an improvement in CPU does not apply to databases.

34:42.640 --> 34:52.640
Once you understand your workload, better to write tests which exercise these kernel subsystems and interests required by your workload.

34:52.640 --> 34:59.640
Having these tests also really helps with communicating issues to the upstream community,

34:59.640 --> 35:06.640
because in Cloud for All, our team is quite small and we're not experts in anything,

35:06.640 --> 35:12.640
and I would highly doubt if anyone really experienced in the Linux kernel, including Linus himself,

35:12.640 --> 35:15.640
could be an expert in all the kernel subsystems.

35:15.640 --> 35:22.640
So sometimes, we had a time where we had a bug in KVM, and we know nothing about KVM at that point,

35:23.640 --> 35:32.640
but because we had a reproducible test which triggers the bug, we spent like two weeks trying to understand what's going on,

35:32.640 --> 35:37.640
and we couldn't, but since we had a reproducer, we just posted an upstream mailing list,

35:37.640 --> 35:42.640
and there's always a person saying, oh yeah, here's a fix in 10 minutes,

35:42.640 --> 35:49.640
but you have to create this reproducible self-contained test to actually people to help you.

35:50.640 --> 35:57.640
And yeah, make metric-driven decisions whether to upgrade and not time-based decisions, so many might sometimes.

35:58.640 --> 36:06.640
One thing also helps with metrics and monitoring, and also automating your kernel releases,

36:06.640 --> 36:14.640
is with human risk perception, because sometimes when new people join your team,

36:14.640 --> 36:19.640
they still have this mentality of Linux kernel upgrades are very risky,

36:19.640 --> 36:25.640
and if you require a human to progress and do these upgrades, they will always be reluctant to do this.

36:25.640 --> 36:30.640
Like, automation really helps here to remove the human risk-perseverment factor,

36:30.640 --> 36:38.640
because these days, especially in clover, many teams are not even aware the kernel upgrades are happening.

36:38.640 --> 36:42.640
They're like happening under the hood automatically, and people don't notice it,

36:42.640 --> 36:47.640
just because, and you don't have to ask anyone whether you should upgrade,

36:47.640 --> 36:53.640
because you have this more or less, not perfect, but more or less data-driven approach.

36:55.640 --> 36:59.640
And I think that's it, whatever I want to talk to you today.

36:59.640 --> 37:06.640
So again, Linux kernel upgrades are not more risky than any other software.

37:07.640 --> 37:15.640
You need to patch early and patch often, and your bug fixes kernel releases should be applied with no question asked,

37:15.640 --> 37:24.640
and understanding your workload, metrics, and monitoring on automation will allow your system to stay patched and secure in the long run.

37:25.640 --> 37:27.640
Thank you very much.

37:36.640 --> 37:42.640
May I ask something? I know where that fear, it's a fear that we all have, I guess,

37:42.640 --> 37:51.640
and it comes from things that I can just say one story, so you have like a 5.4, and it's working fine,

37:51.640 --> 37:59.640
and you have some kind of special, maybe, chipset, and it doesn't support everything that chipset can offer, but it runs fine.

37:59.640 --> 38:03.640
So you upgrade to 5.0 something or 6, and it starts to crash.

38:03.640 --> 38:12.640
And then you roll back, and then you next time you will really think twice if you will upgrade to the next version,

38:12.640 --> 38:16.640
which will offer you more support for that chipset, but you still don't know.

38:16.640 --> 38:22.640
Then you wait others to upgrade, and to be sure that it's working fine now,

38:22.640 --> 38:30.640
and that's why you don't run to upgrade really fast, and then let me see if my dead one and that one did it, and it's running fine,

38:30.640 --> 38:35.640
and then it builds fear, you know, these things build fear, that's what can build fear,

38:35.640 --> 38:45.640
that's why it's always good to wait a bit more until 5 of them do it, and then, okay, I can see, so when I'm running fine now, I will do it now.

38:46.640 --> 38:54.640
Well, I mean, based on our experience, I have this same question from our production engineering team many times,

38:54.640 --> 39:01.640
it's like, why do we rush to upgrade? Why don't we wait until all the bugs were fixed and we can upgrade?

39:01.640 --> 39:09.640
And I guess it depends on your workload, but for us specifically, I sometimes call CloudFer as Linux as a service,

39:09.640 --> 39:16.640
because many of our products are using Linux, are stretching the Linux kernel to its edge.

39:16.640 --> 39:25.640
If there is a new feature like, and Linux kernel like XDP, IOU ring, people jump on it and adopt it almost immediately,

39:25.640 --> 39:35.640
and the result of that, because we use these edgy features which many people don't use, there is no one for us to fix these bugs,

39:35.640 --> 39:40.640
like we're hitting them first, so we tried waiting, and when we're waiting, we're still hitting the bugs,

39:40.640 --> 39:52.640
because like nobody else is using that feature in this way, and this is where you just can't, I guess it's the same with very specialized CPU or hardware,

39:52.640 --> 39:59.640
if nobody uses this hardware, you can't wait for the community, someone else to fix your bugs, you have to push them through.

39:59.640 --> 40:09.640
Of course, you see the bugs, it's always helpful to report them, and there will be some people on the mailing list within a moment,

40:09.640 --> 40:19.640
they will send you a one-liner patch to try it out, and usually it works out, but I mean, generally, if your workload is specific enough,

40:19.640 --> 40:26.640
or hardware is specific enough, you can't just wait for all the bugs to be fixed, because it's very applicable only to you.

40:26.640 --> 40:37.640
Okay, good day.

40:37.640 --> 40:47.640
I wanted just to in phase your position to say Linux is safer to upgrade over any other software,

40:47.640 --> 40:54.640
and to me the main reason is because of the strong commitment from this community to ensure that all the stable release are safe to upgrade.

40:54.640 --> 41:01.640
And I know very few other software that takes this contract with the users to say you cannot grab safely.

41:01.640 --> 41:11.640
And I think this is a major point, and I think the Linux community should be recognized for this, because it puts a lot of work to ensure that we are safe to upgrade.

41:11.640 --> 41:13.640
That's something very important.

41:13.640 --> 41:25.640
More than the rollout points you are leveraging, it's much more because I've searched strong contracts to ensure that every stable release is safe to be used.

41:25.640 --> 41:30.640
Yes, you mean you're referring to don't break user space mentality?

41:30.640 --> 41:34.640
Or even don't take a patch which is not already in mainline.

41:34.640 --> 41:39.640
I mean, if you get your patch into the stability, it's because it has been tested and proved to be safe,

41:39.640 --> 41:44.640
and because of the sum of all these patches is not to be safe.

41:44.640 --> 41:48.640
And this strong commitment is very important, I think, for the users.

41:48.640 --> 41:49.640
Yes, yes.

41:49.640 --> 41:50.640
They can press their work.

41:50.640 --> 41:51.640
Yes, yes, yes.

41:51.640 --> 41:58.640
And many times when you submit patches, there are tons of external, even people or systems,

41:58.640 --> 42:03.640
we run your patch in kind of a CI and they will report if there is something back.

42:03.640 --> 42:13.640
Yes, I guess you're right that we have to acknowledge that community puts a lot of effort to these stable releases to be actually stable.

42:13.640 --> 42:17.640
But also, like the release process itself goes a long way.

42:17.640 --> 42:24.640
So, technically, again, you have only two weeks to deploy new features and then you're stuck with seven weeks of bug fixing.

42:24.640 --> 42:31.640
So, yes, the emphasis on stability is a real win, I guess, for this community.

42:31.640 --> 42:36.640
And another thing, the sum of security issues is not only counting the CVs.

42:36.640 --> 42:39.640
Greg made a great presentation around that.

42:39.640 --> 42:42.640
If there is CVs, there's probably a security issue.

42:42.640 --> 42:49.640
But there are also fixes which are not as stacked as CVs, which could be our security issues.

42:49.640 --> 42:57.640
So, to evaluate the security risk of a given version, it's not only counting the CVs, it's much more complex than that.

42:57.640 --> 43:02.640
Yeah, I agree with that. And this is what I partly mentioned, that data is crowdsourced and probably incomplete.

43:02.640 --> 43:05.640
It's kind of like the minimal baseline of risk.

43:05.640 --> 43:07.640
But there is more, of course.

43:07.640 --> 43:12.640
There is like, these are publicly non-vulnerabilities which have been tagged on this project.

43:12.640 --> 43:20.640
There is like a lot of them which are intact with no CVs attached, as well as like a lot of unknown security vulnerabilities hiding in this system.

43:20.640 --> 43:22.640
So, yeah, definitely.

43:24.640 --> 43:25.640
Anyone?

43:25.640 --> 43:26.640
Hi.

43:26.640 --> 43:27.640
Here.

43:27.640 --> 43:28.640
I don't see.

43:30.640 --> 43:31.640
I'm here.

43:31.640 --> 43:32.640
Oh, okay.

43:32.640 --> 43:33.640
Hi.

43:33.640 --> 43:35.640
I have a question about Livepatch.

43:35.640 --> 43:38.640
Do you use in your company?

43:38.640 --> 43:41.640
Livepatch, we don't use Livepatch.

43:41.640 --> 43:45.640
And my personal view on this, I'm not...

43:45.640 --> 43:52.640
So, like, I don't fully see Livepatch technology covering all the use cases.

43:52.640 --> 43:57.640
So, I think it is useful for patching vulnerabilities really fast.

43:57.640 --> 43:58.640
Yeah, yeah.

43:58.640 --> 44:00.640
But on the particular type of vulnerability.

44:00.640 --> 44:01.640
Yes, yes.

44:01.640 --> 44:09.640
With Livepatch, you're basically replacing a piece of code in the kernel with another patch piece of code in the kernel.

44:09.640 --> 44:14.640
But we have to remember that in kernel, kernel API is not stable.

44:14.640 --> 44:21.640
And basically, you can only do that if your patching requires not changing some kind of structure.

44:21.640 --> 44:27.640
It may fall apart if you're required to adding a mutics into the structure if you have a race condition.

44:27.640 --> 44:29.640
And this is where Livepatch fails.

44:29.640 --> 44:33.640
And moreover, implementing Livepatch is very complicated.

44:33.640 --> 44:38.640
And it's kind of like you can crash the system as well because you're messing with the kernel code.

44:38.640 --> 44:46.640
So, in my perspective, in my opinion, the effort is kind of not worse of the return of investment.

44:46.640 --> 44:53.640
Like, if you don't have any company, like a Linux enterprise, Linux distro doing it for you and doing it for yourself,

44:53.640 --> 44:55.640
you're putting a lot of effort to make it.

44:55.640 --> 44:59.640
You can't patch all the security vulnerabilities with that.

44:59.640 --> 45:02.640
You're putting a lot of effort and you don't get much benefit.

45:02.640 --> 45:07.640
If you instead just focus on building a system where you can reboot anything at any time,

45:07.640 --> 45:12.640
that kind of gives you, like, much better, like, long-term result.

45:12.640 --> 45:18.640
Because you just can't reboot with a new kernel and, you know, your system kind of is resilient to that.

45:18.640 --> 45:20.640
And it takes as much effort.

45:20.640 --> 45:21.640
Thank you.

45:24.640 --> 45:25.640
Hello.

45:25.640 --> 45:35.640
Thanks for your detailed explanations and for outlining that the December version doesn't actually work the way we think it does.

45:35.640 --> 45:37.640
Now, I have questions.

45:37.640 --> 45:46.640
So, you mentioned that we usually install the rest of the software out of some side bound that we don't have control over.

45:46.640 --> 45:48.640
And actually, I do that for everything.

45:48.640 --> 45:49.640
Can you kernel?

45:49.640 --> 45:51.640
I don't usually compile it myself.

45:51.640 --> 45:57.640
So, the question is, can we, should we aware, should we be aware of particular tricks?

45:57.640 --> 46:00.640
Because this process is actually mediated by the distribution.

46:00.640 --> 46:05.640
Like, do the people who do the distributions know all the stuff you mentioned?

46:06.640 --> 46:07.640
Yes.

46:07.640 --> 46:19.640
And actually, the model which I described following LTS release and, like, rolling out bug releases regularly is what most distributions actually do.

46:19.640 --> 46:25.640
You might not see it because, for example, Debian, you kind of, they version the package differently.

46:25.640 --> 46:39.640
So, you think you're always on the same version, but you may notice if you're doing, like, regular up-get upgrade that when your new Linux kernel is installed, it actually installs you a new bug fix version, which is hidden under the hood.

46:39.640 --> 46:41.640
So, this is what most distributions do.

46:41.640 --> 46:47.640
They either follow LTS or they take a non-LTS branch and maintain it for longer.

46:47.640 --> 46:54.640
But when you upgrade your system, you just get bug fixes and security vulnerabilities patched as this bug fix release.

46:56.640 --> 46:57.640
Hello.

46:57.640 --> 47:03.640
I'm not completely sure how the kernel process works still.

47:03.640 --> 47:07.640
How about a firmware that's just dropped into the kernel?

47:07.640 --> 47:12.640
Is that included in those bug fixes?

47:12.640 --> 47:14.640
And if so, how are data set?

47:14.640 --> 47:20.640
How are you ensuring that those binary blobs don't change something that breaks everything?

47:20.640 --> 47:28.640
So, in modern distribution, and like within the Linux kernel upstream as well, the binary blobs are now managed separately.

47:28.640 --> 47:31.640
They're managing the separate git repository.

47:31.640 --> 47:36.640
And on distributions, there is a separate package for it usually called Linux firmware.

47:36.640 --> 47:44.640
So, basically, the code for the kernel and the binary blobs are upgraded at different cadence and have different release procedures.

47:44.640 --> 47:47.640
So, they are not included in the code upgrade these days.

47:51.640 --> 47:56.640
Hi.

47:56.640 --> 47:58.640
Over here.

47:58.640 --> 47:59.640
Yeah.

47:59.640 --> 48:14.640
So, you were talking about the fear in upgrading kernels, but to me or when I'm looking at my team, sometimes it's more of the tedious task in having to reboot or to migrate the service.

48:14.640 --> 48:19.640
And then, you know, doing it over and over like Groundhog Day.

48:19.640 --> 48:26.640
Now, my question is, what would you consider a reasonable cadence for that task?

48:26.640 --> 48:45.640
Or do you see even like a need at the system to align on a specific kernel and, you know, and zeroing out the whole system or just having some routine monthly maintenance that jumps a few versions?

48:45.640 --> 48:47.640
What's your take on that?

48:47.640 --> 48:56.640
So, again, for bug and security releases, my preferred kernels is weekly.

48:56.640 --> 48:57.640
So, they released every week.

48:57.640 --> 48:59.640
You have to compile it and roll.

48:59.640 --> 49:06.640
I mean, not roll it out everywhere, but start its rollout at some set of production then more and more and more.

49:06.640 --> 49:14.640
And again, basically, the more you delay, the more change delta you accumulate, the more risky you're bringing.

49:14.640 --> 49:18.640
So, if you do it as regularly as possible, your change delta is small.

49:18.640 --> 49:34.640
And technically, like within a couple of two bug fixes, even if it's something breaks for your particular service, you can kind of bisect it and understand what's happening much more easily than you have to go through, you know, like, thousand and thousand of commits.

49:34.640 --> 49:41.640
So, if it's hard, you have to think about how to make it easier and how to do it more often.

49:41.640 --> 49:57.640
The more often you, it's like gym, the more often you do it, you kind of build that muscle, you build the tooling around it, you build the metrics and observability around it, and then you build, eventually, you build your confidence that kind of, it takes you very fast and effortless to actually do it much, much more.

49:57.640 --> 50:01.640
Yeah, my question is mainly about the time spent.

50:01.640 --> 50:10.640
My question is mainly about the time that you spend, you know, managing that as part of your day-to-day.

50:10.640 --> 50:16.640
Well, again, it's basic calculation of return on investment, right?

50:16.640 --> 50:28.640
If a kernel upgrade is too costly in terms of like spending, you're spending a lot of time doing that, think about if you can invest this time to build some kind of automation.

50:28.640 --> 50:30.640
And that's what we basically did.

50:30.640 --> 50:42.640
Like, when I joined the company eight years ago, like, it was very manual and time-consuming and it required a huge team of SREs to actually do a kernel upgrade, but now they're not even involved anymore.

50:42.640 --> 50:48.640
And, like, it just happens.

50:48.640 --> 50:52.640
Thank you for the interesting talk and nice present for you.

50:52.640 --> 50:53.640
Thank you.

50:53.640 --> 50:54.640
Enjoy it.

50:54.640 --> 50:55.640
Thank you very much.

51:00.640 --> 51:01.640
Thank you.

