WEBVTT

00:00.000 --> 00:11.160
Thanks for the amazing introduction.

00:11.160 --> 00:16.560
And as Jan said, so we're here to talk about the future of calling and matrix.

00:16.560 --> 00:20.720
And we actually bring some pretty cool new things and there's quite a thing going on

00:20.720 --> 00:21.880
at the moment.

00:21.880 --> 00:27.880
So yeah, we really hope from now on there's finally good calling and matrix, or at least

00:27.880 --> 00:35.960
we're doing the first steps and all this will be built upon matrix RTC, which is a underlying

00:35.960 --> 00:39.960
protocol basically, which empowers all the calling in the future.

00:39.960 --> 00:44.440
And that's what we're going to talk about, how this works, how this is structured, and

00:44.440 --> 00:48.520
how calls are built on top of this.

00:48.520 --> 00:54.720
So matrix RTC is actually something a couple of you probably already has encountered in

00:54.720 --> 00:56.760
the form of element calls.

00:56.760 --> 01:01.280
So basically this is a standalone web app where you can just have calls.

01:01.280 --> 01:06.920
It's very similar to JITC, but in the background it's actually running matrix RTC.

01:06.920 --> 01:10.840
And what hasn't reached yet though is that this is really in the federated system.

01:10.840 --> 01:16.080
So what we have here, this single page application is very, very enclosed.

01:16.080 --> 01:19.200
So it's running its own home server and it doesn't federate.

01:19.200 --> 01:21.120
You can't log in with your actual matrix account.

01:21.120 --> 01:25.800
You have to have a custom account for this specific application.

01:25.800 --> 01:30.400
And the change we're going to present now is that we actually have the same technology

01:30.400 --> 01:34.080
but in our federated matrix system.

01:34.080 --> 01:39.640
So before we actually start into the interesting new things, we talk about why we even considered

01:39.640 --> 01:40.920
redesigning all of this.

01:40.920 --> 01:45.600
Because as probably all of you know, there is calling in matrix since quite some time

01:45.600 --> 01:46.600
already.

01:46.600 --> 01:53.640
It's in Niko, it's in the legacy matrix apps, element apps, and it's an element web.

01:53.640 --> 01:57.080
So why not just work on those?

01:57.080 --> 01:58.080
There are issues.

01:58.080 --> 02:03.360
For example, if you call each other at the same time, you get issues that the calls sometimes

02:03.360 --> 02:09.240
don't figure out that two people want to talk to each other.

02:09.240 --> 02:12.960
Sometimes one of your devices never stops ringing.

02:12.960 --> 02:14.360
But why not just fixing those?

02:14.360 --> 02:15.360
Oh, I see a lot of knots.

02:15.360 --> 02:16.520
That's actually super satisfying.

02:16.520 --> 02:21.760
It's really good to see that people know what I'm talking about.

02:21.760 --> 02:23.480
So why not just focus on fixing those?

02:23.480 --> 02:25.320
Why rebuilding something entirely new?

02:25.320 --> 02:28.920
And the thing is, there are some pretty fundamental limitations.

02:28.920 --> 02:32.000
So it's by design just one-to-one calls.

02:32.000 --> 02:33.880
That's just how it's designed.

02:33.880 --> 02:38.640
And it never really was in this specification designed for something bigger.

02:38.640 --> 02:39.640
It's very call specific.

02:39.640 --> 02:43.480
So you can't build any arbitrary real-time application on top of it.

02:43.480 --> 02:45.400
It's just for calls.

02:45.400 --> 02:49.720
And that's something which we think would be cool if that changes.

02:49.720 --> 02:51.440
And the signaling is done over room events.

02:51.440 --> 02:57.440
That's not necessarily a mistake, but it makes things a little slower than necessary.

02:57.440 --> 03:02.640
And also, it's really hard to get right, as we can see with ringing never stops, or we

03:02.640 --> 03:08.280
call each other at the same time, and it doesn't converge to an actual call.

03:08.280 --> 03:11.560
So this is basically our vision, what we want to achieve.

03:11.560 --> 03:17.480
So we want calls to be a great and central part of matrix via matrix RTC.

03:17.480 --> 03:21.220
And those four columns are the core things which we really want to get right.

03:21.220 --> 03:22.740
So we don't just want to have calls.

03:22.740 --> 03:29.180
We want to think beyond calls and build an expandable system that motivates also other

03:29.180 --> 03:30.180
projects.

03:30.180 --> 03:34.060
So we already had this, not with the exact stack we have right now, but something very

03:34.060 --> 03:35.560
similar.

03:35.560 --> 03:41.540
And people like Element build third room, and also Nordic build things like the NeoBoard,

03:41.540 --> 03:46.680
which are also kind of built on a similar thing than matrix RTC.

03:46.680 --> 03:50.520
And we want to make matrix RTC really a thing where it's super easy to build those kind

03:50.520 --> 03:52.560
of things.

03:52.560 --> 03:57.400
The other column which is super important is that it's using a pluggable RTC spec end.

03:57.400 --> 04:00.380
So currently that's LiveKit, and LiveKit is an amazing open project.

04:00.380 --> 04:06.400
So it really fits into matrix from a culture point of view.

04:06.400 --> 04:13.640
So it's an open system, and it really solves all very complicated issues if you use WebRTC

04:13.640 --> 04:15.560
for calling.

04:15.560 --> 04:21.920
It even ships a SFU, and it's just a very, very decent combination, like matrix for the

04:21.920 --> 04:29.000
high level signaling and LiveKit for actually doing the WebRTC shenanigans you need to go

04:29.000 --> 04:30.000
through.

04:30.000 --> 04:33.160
It actually gets quite annoying if you look into the details, and they just do an amazing

04:33.160 --> 04:37.120
job to really get this all nailed down.

04:37.120 --> 04:40.400
And then it has to support large group calls.

04:40.400 --> 04:44.120
Everything which we want to have in the future shouldn't be just for one-on-one calls.

04:44.360 --> 04:45.920
I guess that's pretty obvious.

04:45.920 --> 04:52.440
And last, we want to make it as simple as possible for other clients to support the whole infrastructure.

04:52.440 --> 04:57.240
And we already have two apps from Fremantly, like the Fremantly app itself and FluffyChat

04:57.240 --> 04:58.880
which support it.

04:58.880 --> 05:01.240
And we have Element apps which support it.

05:01.240 --> 05:05.480
And we also, we talk about this in more detail later, want to make it as easy as possible

05:05.480 --> 05:08.640
for others to also add calling.

05:08.640 --> 05:13.400
There's like a widget path you can take, and also LiveKit helps us here, because they provide

05:13.400 --> 05:16.680
pretty decent SDKs.

05:16.680 --> 05:20.520
So if we want to build calling on Matrix, we really want to leverage all the good things

05:20.520 --> 05:21.520
about Matrix.

05:21.520 --> 05:25.160
So here's like a very short, I guess I can really do this quickly because everybody knows

05:25.160 --> 05:30.800
probably, what really makes or what Matrix is really good at.

05:30.800 --> 05:35.600
So what things we really have to pass over through this real-time infrastructure.

05:35.600 --> 05:39.040
And one of this is that it's an open standard.

05:39.040 --> 05:42.000
That's like one of the things I really see as a core of Matrix.

05:42.000 --> 05:43.000
It's super cool.

05:43.000 --> 05:48.560
It's really fast and so it's great out because it's not really that surprising.

05:48.560 --> 05:53.600
Then we have Matrix encryption, which is really powerful and it goes further than just encrypting

05:53.600 --> 05:55.160
for large rooms.

05:55.160 --> 05:58.600
It also has a very good authentication and verification system.

05:58.600 --> 06:04.360
And that's a thing which I think is super essential that you not only can connect encrypted

06:04.360 --> 06:06.800
to other people, but it's also verified.

06:06.800 --> 06:11.400
So you have the guarantee that if everybody is doing this device verification correctly

06:11.400 --> 06:15.920
that all the participants are actual participants you trust and where you trust the devices

06:15.920 --> 06:18.560
are not malicious.

06:18.560 --> 06:22.640
And that is what actually makes security in the end that you don't have any weird third

06:22.640 --> 06:26.800
party being in there which shouldn't get the data streams your streaming.

06:26.800 --> 06:28.280
Then it's a federated system.

06:28.280 --> 06:31.520
So calling definitely has to go this path as well.

06:31.520 --> 06:35.840
And what Matrix is also really good is in having persistent storage.

06:35.840 --> 06:41.240
So it's not just exchanging data, it's also storing data and replicating the stored data

06:41.240 --> 06:43.960
over multiple home servers.

06:43.960 --> 06:47.480
But that kind of comes with the cost that it's not real time, real time, what we need

06:47.480 --> 06:48.480
for calling.

06:48.480 --> 06:56.120
It's more like a, yeah, more in the below second range but not millisecond range.

06:56.120 --> 07:01.600
So having those four columns in mind, how can we now use Matrix to really build up something

07:01.600 --> 07:08.760
like a system that uses the best parts of Matrix while still succeeding in actual real

07:08.760 --> 07:10.000
time?

07:10.000 --> 07:12.280
And this is done by like those three core parts.

07:12.280 --> 07:18.160
We have the Matrix part, then we have Client apps which then use the LiveKit SDK and we

07:18.160 --> 07:22.000
have the RTC infrastructure which is LiveKit in this case.

07:22.000 --> 07:26.160
So starting from the top we can see that we have just a Matrix room which can be on a

07:26.160 --> 07:28.080
federated system.

07:28.080 --> 07:33.560
And the core component in the Matrix system or what the problem Matrix solves here is

07:33.560 --> 07:37.480
that it basically stores which user is currently in which session.

07:37.480 --> 07:42.280
So if I'm joining a room and I'm reading the room state, I immediately can tell who

07:42.280 --> 07:45.760
is in which session and how to connect to those people.

07:45.760 --> 07:49.440
So I know if there's a running call and I know how to connect to them.

07:49.440 --> 07:57.160
And yeah, of course then Matrix also does a lot more sharing keys and providing the accounts

07:57.160 --> 07:59.200
and the verification.

07:59.200 --> 08:03.000
Then as the next in the center part we have the Clients themselves.

08:03.000 --> 08:07.480
So here we have a couple of Clients which have only the green box in there and then

08:07.480 --> 08:13.280
Clients with the green and the blue box and each of those boxes is basically one RTC application.

08:13.280 --> 08:17.760
So to make this example more concrete, one could think of as the green box being Element

08:17.760 --> 08:24.920
Call or just calling in general and the blue box being some document, shared document real

08:24.920 --> 08:29.440
time system or third room or whatever have you.

08:29.440 --> 08:32.840
And some of those members are just in one RTC session and some are in two and this is

08:32.840 --> 08:35.600
also something that should be possible.

08:35.600 --> 08:40.160
And then last at the bottom we have the RTC infrastructure where we primarily want to

08:40.160 --> 08:44.800
use LiveKit but it also would be possible that you use FullMesh or we have this empty

08:44.800 --> 08:45.800
box at the end.

08:45.800 --> 08:50.280
It also should be possible to basically use whatever new technologies emerging.

08:50.280 --> 08:56.480
So if web transport at some point in time replaces web RTC then you could implement a

08:56.480 --> 09:02.360
new infrastructure which then does the same high level signaling over matrix but it still

09:02.360 --> 09:09.040
uses this new technology to have even better or even higher data transmission or whatever

09:09.040 --> 09:13.080
the advantage is.

09:13.080 --> 09:16.600
So now we look into a little bit more detail for those room events.

09:16.600 --> 09:19.240
So before we had them at the top, now they're at the right.

09:19.240 --> 09:24.960
So we have room, multiple member events and each member event has an array of memberships.

09:24.960 --> 09:30.760
We need this array because as seen before we could have a call and at the same time

09:30.760 --> 09:33.240
a real time document.

09:33.240 --> 09:39.440
And the top part of the membership JSON object here is the actual core matrix RTC part.

09:39.440 --> 09:47.160
This data is just there to know how to connect to this specific peer in this RTC world.

09:47.160 --> 09:53.840
So it has this very central field Fokie active where it says the type of Fokie or the type

09:53.840 --> 09:59.520
of connection you want to use in this case live kit plus it has all the necessary information

09:59.520 --> 10:00.800
to connect to this.

10:00.800 --> 10:05.040
And this could also, this is then the part which actually can be replaced with web transport

10:05.040 --> 10:07.560
or full mesh or whatever you.

10:07.560 --> 10:11.520
And then there's another pretty important field and that's the application.

10:11.520 --> 10:15.520
So each membership has a specific application associated with it.

10:15.520 --> 10:21.280
In this case it's M call and that basically also gives the typing for all the other fields.

10:21.280 --> 10:24.840
For M call we have a call ID as well and a scope.

10:24.840 --> 10:30.320
So if it's just a call for the whole room or if it's a breakout call or whatever you

10:30.320 --> 10:34.840
want to add to the calling specification.

10:34.840 --> 10:36.840
But you can also imagine all kinds of other things.

10:36.840 --> 10:42.200
So if we think about third room one possible field could be that you have for example a

10:42.200 --> 10:44.200
country or continent in there.

10:44.200 --> 10:48.600
So when I look at the room state I can immediately tell who is in which country and based on

10:48.600 --> 10:50.200
that I know whom to connect to.

10:50.200 --> 10:56.360
So we can do very high level optimizations in this matrix RTC world already before we

10:56.360 --> 11:01.040
even connect to an SFU.

11:01.040 --> 11:02.040
What time do we have?

11:02.040 --> 11:06.040
Like, oh it doesn't say here because.

11:06.040 --> 11:08.480
Oh, okay this is fine.

11:08.480 --> 11:11.040
And we actually can talk about this as well.

11:11.040 --> 11:17.280
So this is kind of an interesting thing and it's one of 20 problems I could have chosen

11:17.320 --> 11:23.880
which we encountered which I find really interesting to just really get the mindset what those

11:23.880 --> 11:29.600
call member events are and what kind of problems we encounter in such a federated world.

11:29.600 --> 11:32.360
So it's about call history.

11:32.360 --> 11:36.240
Whenever we have a call it's of course super valuable to then see in the room history that

11:36.240 --> 11:37.240
there was a call.

11:37.240 --> 11:42.120
How long the call was, how many participants there have been in this call.

11:42.120 --> 11:46.880
And one idea, one very trivial approach would be that at the end of a call we just send

11:46.880 --> 11:49.520
a summary in the room and the summary contains all the data.

11:49.520 --> 11:53.520
How many people there were, the duration and everything.

11:53.520 --> 11:58.760
But then we encounter specific issues which are very, very common in a federated world

11:58.760 --> 12:00.240
who creates this event.

12:00.240 --> 12:07.280
Like there has to be some kind of glaring and maybe nobody feels responsible for it.

12:07.280 --> 12:11.040
Maybe the one responsible has a client which crashed at the moment where he needed to send

12:11.040 --> 12:12.280
it.

12:12.280 --> 12:16.040
Maybe two people think they're responsible because there were some state which hasn't

12:16.040 --> 12:17.040
resolved yet.

12:17.040 --> 12:22.680
And it also would be redundant data because every state event is of course also part of

12:22.680 --> 12:26.760
the DAG so it is in the history of the room.

12:26.760 --> 12:34.020
So by having another summary event we of course introduce a possible conflict where if you

12:34.020 --> 12:38.960
look through the state history you see that the call was ten minutes long but in the summary

12:38.960 --> 12:43.200
it's twelve minutes long because there was a client side back failing to calculate the

12:43.200 --> 12:44.920
proper call duration.

12:45.800 --> 12:47.360
This slide actually got broken.

12:47.360 --> 12:51.120
Either way it's still visible enough so it works.

12:51.120 --> 12:55.640
The cool thing is if we look at the call member events which we showed before it's very easy

12:55.640 --> 12:58.440
to pass those events as join or leave events.

12:58.440 --> 13:05.480
So if we look on the left hand side with the green border we can see in the unsigned field

13:05.480 --> 13:08.280
we always have the previous state of that event.

13:08.280 --> 13:13.760
So if the previous state was an empty array and the current state is an array with a membership

13:13.760 --> 13:18.760
this can be easily passed as a join event while on the right hand side with the black

13:18.760 --> 13:25.280
border we have a previous content with a membership so somebody was in some kind of RTC session

13:25.280 --> 13:30.000
and now the current content is an empty array which implies that's leave event so it's really

13:30.000 --> 13:33.200
easy to tag those events.

13:33.200 --> 13:39.200
And looking at the next slide we have a visualization of a basically timeline so the left hand

13:39.200 --> 13:45.000
side has to be interpreted as the past and the right hand side as the present and the

13:45.000 --> 13:50.920
red boxes are state event changes which we tagged as leave events with the system we

13:50.920 --> 13:56.440
used before and the green boxes are state event changes which we tagged as join events.

13:56.440 --> 14:01.120
So if we go through a very simple example, member three for example they just had no

14:01.120 --> 14:06.560
changes at all so during the whole period which is shown on screen they were no member.

14:06.640 --> 14:13.040
If we look at member two in the past they were no membership then they had a join event

14:13.040 --> 14:16.880
so from that point on they were in a membership and then a leave event.

14:16.880 --> 14:22.600
So if we now run an algorithm locally that we start from the current or the present and

14:22.600 --> 14:29.680
we just go back collect all the leave and join events we can basically recreate the call

14:29.680 --> 14:30.680
state.

14:30.720 --> 14:37.040
So at each point we know who was joined and who wasn't and then we just loop through this

14:37.040 --> 14:42.920
algorithm until we find a point where nobody was joined and that then is of course the

14:42.920 --> 14:48.560
start so this slide indicated with green border so we have then all the information we need

14:48.560 --> 14:53.000
we have the start, we have the end, we even have the number of participants who joined

14:53.000 --> 14:56.880
we basically even have a heat map at which time there were how many participants like

14:56.920 --> 15:01.800
there's lots of data in there and each client can decide on their own what exactly they

15:01.800 --> 15:04.160
want to do with it and how they want to render this in the timeline.

15:04.160 --> 15:09.840
So yeah this is your part now.

15:09.840 --> 15:14.320
Who on time? Thank you Timo.

15:14.320 --> 15:28.320
So now we are going to look at implementing because well client implementers also need

15:28.320 --> 15:33.240
help and if you are one of those people whose client already has the WebRTC parts implemented

15:33.240 --> 15:38.600
you might be thinking ah shit I need to throw away all of the stuff I've already done.

15:38.600 --> 15:41.280
Not really.

15:41.280 --> 15:45.480
So Timo showed this already but there's this small RTC infrastructure bit which we are

15:45.480 --> 15:48.760
going to look into a bit.

15:48.760 --> 15:57.960
This is MSC3401, well kind of MSC3401 the m.call event has already been removed because it caused

15:57.960 --> 16:02.080
way too many glares and stuff if you want to know more about that you should watch Timo's

16:02.080 --> 16:08.280
matrix community summit talk about why the m.call had no ownership and stuff so it caused

16:08.280 --> 16:10.160
way too many glitches.

16:10.160 --> 16:15.560
The first half is just the matrix RTC stuff which Timo already mentioned about.

16:15.560 --> 16:22.440
The participants send the member events so the room has a history of who joined when

16:22.440 --> 16:29.480
and now if you don't have an SFU you could just say the infrastructure or the foci or

16:29.480 --> 16:36.560
the back end in the matrix RTC as mesh and then you can potentially just use the P2P

16:37.000 --> 16:41.320
MSCs which were already implemented by you or hopefully will be implemented for a mesh

16:41.320 --> 16:45.520
call and a mesh call is basically a P2P call between multiple participants.

16:45.520 --> 16:53.720
It's just not as scalable as you would think but now you can use your existing MSCs, your

16:53.720 --> 16:58.520
existing implementation for mesh calls and you don't even need an SFU or something but

16:58.520 --> 17:04.440
if you are rich and if you do want to set up an SFU then it gets much simpler.

17:04.800 --> 17:09.800
SFU in our case will be LiveKit but all of the signaling bits are now handled by LiveKit

17:09.800 --> 17:11.920
itself over WebSockets.

17:11.920 --> 17:14.800
The previous thing was over two device matrix events.

17:14.800 --> 17:21.920
The first half is the same but basically all of the signaling part is now handled by LiveKit

17:21.920 --> 17:24.360
over WebSockets.

17:24.360 --> 17:29.560
More about LiveKit I'm going to keep saying that SFUs are cool but SFUs are also very

17:29.680 --> 17:34.800
expensive and if you don't want anyone else to use your SFU you probably want to have

17:34.800 --> 17:36.600
some authentication in front of it.

17:36.600 --> 17:43.280
So if you are a home server owner admin and you also host SFU then you probably also will

17:43.280 --> 17:50.880
be hosting a JWT service which basically gets an open ID token from your Synapse server.

17:50.880 --> 17:52.720
You send it to your service.

17:52.720 --> 17:57.360
The service then validates if you are the actual one who generated that token and well

17:57.360 --> 18:04.440
then it generates a JWT token for you which you can use to authenticate with LiveKit SFU.

18:04.440 --> 18:10.040
Right now I believe that the Synapse thingy only checks if you are the actual one who

18:10.040 --> 18:17.440
generated the open ID token but I think there's already work going on for checking if you

18:17.440 --> 18:23.280
are actually in the room so only people who are in the room and if you want to actually

18:23.280 --> 18:30.400
join that room only then you can get access to the SFU.

18:30.400 --> 18:31.840
Some fancy stats.

18:31.840 --> 18:38.600
The LiveKit docs say that with around a 16 core Google virtual machine you can have calls

18:38.600 --> 18:40.440
with around 150 members.

18:40.440 --> 18:46.840
This is I believe 720p no simulcast just draw 720p 150 members feeds.

18:46.840 --> 18:52.280
From my personal testing I used a Hexner CAX21 well not personal but family gave that to

18:52.280 --> 19:01.280
me but it's a four shared VCPUs ARM core thingy and I could get around 70 participants with

19:01.280 --> 19:06.720
simulcast and 720p everything optimized I think.

19:06.720 --> 19:07.880
Ringing.

19:07.880 --> 19:14.240
You might not think ringing is important but ringing is actually very difficult to get.

19:14.240 --> 19:20.200
Mainly because native operating systems are not really friendly with you and will try

19:20.200 --> 19:22.840
to kill your app every possible second.

19:22.840 --> 19:27.560
So they started a GSOC project by the way.

19:27.560 --> 19:31.800
GSOC 2022 project at matrix.

19:31.800 --> 19:35.120
It's basically a three month window and you have to do this particular task.

19:35.120 --> 19:39.240
Well my task was actually implementing the whole WebRTC thing but I implemented the whole

19:39.240 --> 19:48.920
WebRTC thing in two weeks and for the next two and a half months I had to fight ringing.

19:48.920 --> 19:51.240
You need to focus on three cases.

19:51.240 --> 19:54.040
Your app could be in foreground, background and terminated.

19:54.040 --> 19:59.000
By ringing I basically mean if your app is in one of these three cases you need to be

19:59.000 --> 20:03.160
able to somehow ring the application when you get a call.

20:03.160 --> 20:07.120
Pivot it three times and we'll see the three ways.

20:07.120 --> 20:12.960
This is a story yes but hopefully client implementers can learn from this.

20:12.960 --> 20:15.560
This is the coolest part which I wanted to show at FOSTA.

20:15.560 --> 20:18.320
I did not know you could do this.

20:19.320 --> 20:21.720
This is Android specific.

20:21.720 --> 20:24.720
As far as I know only has one way you can do this.

20:24.720 --> 20:29.400
That's using Colkit which is the phone dialer app on the iOS thingy.

20:29.400 --> 20:36.800
I think WhatsApp also uses that but turns out Android also has a way to do that.

20:36.800 --> 20:42.600
It's called telecom manager or the connection service API and what you're seeing on your

20:42.600 --> 20:48.240
screen right now is the Samsung OEM dialer application and what the telecom manager allows

20:48.240 --> 20:54.400
you to do is put any wipe call from your application to the dialer so you don't really have to

20:54.400 --> 21:00.080
handle all of the OS killing your app and stuff because the dialer already has that.

21:00.080 --> 21:01.320
Then you get this fancy UI.

21:01.320 --> 21:08.280
You see all of these buttons, the hold call, Bluetooth, even the merge button works and

21:08.280 --> 21:09.720
I didn't have to do that.

21:09.720 --> 21:15.760
You also don't have to implement a new UI for all of those holding calls or you have

21:15.760 --> 21:18.160
another call when you're in another call.

21:18.200 --> 21:23.120
This was very cool but why this could not be implemented?

21:23.120 --> 21:29.440
For this you need to add your app as a calling account in your dialer app and that is a very

21:29.440 --> 21:30.440
hidden setting.

21:30.440 --> 21:37.280
I could not find a way to programmatically do it and also in some of the regions it's

21:37.280 --> 21:38.280
just blocked.

21:38.280 --> 21:42.280
It's apparently a regional thing so this could not get in.

21:42.280 --> 21:44.720
Frustrated by that I went to try to.

21:44.720 --> 21:45.720
Where?

21:45.720 --> 21:46.720
We just hack it.

21:47.720 --> 21:51.000
Apparently Android has two very nice thingies.

21:51.000 --> 21:56.880
Show on lock screen and the up here on top thingy.

21:56.880 --> 22:00.600
What we basically do is apparently we're out of, well running out of time so this is going

22:00.600 --> 22:01.600
to be super fast.

22:01.600 --> 22:06.720
We just call the up here on top thingy which then brings your app on the top and then you

22:06.720 --> 22:08.880
can use the show on lock screen.

22:08.880 --> 22:13.480
Even if your app is foreground or background and your screen is locked you could potentially

22:13.480 --> 22:16.200
just hack the app to get live and stuff.

22:16.200 --> 22:20.640
It does not work on terminated apps and no way my coworkers would have let me merge this

22:20.640 --> 22:21.640
thingy.

22:21.640 --> 22:22.640
Try three.

22:22.640 --> 22:23.640
Fine.

22:23.640 --> 22:25.640
We'll do it the right way.

22:25.640 --> 22:30.480
By the way, if you are thinking this is an obvious solution this was not obvious for

22:30.480 --> 22:36.280
me because family and Fluffy chat are written in Flutter and when I get a notification I

22:36.280 --> 22:39.960
would have to start the right Android bits then start the right Flutter bits and then

22:39.960 --> 22:43.560
decrypt the event and then show the ringing too much work.

22:43.560 --> 22:47.440
But well turns out after two tries I found out that push notifications already do that

22:47.440 --> 22:48.440
for you.

22:48.440 --> 22:52.200
Well, so we just abuse that now.

22:52.200 --> 22:55.040
You use the Firebase push thingy or the unified push thingy.

22:55.040 --> 22:56.560
They start a worker for you.

22:56.560 --> 22:57.760
They bring up the Flutter engine.

22:57.760 --> 23:02.160
A Flutter engine is basically something which is attached to your Android activity.

23:02.160 --> 23:05.520
Once the Flutter engine has started you can just hook on to that.

23:05.520 --> 23:09.640
You can hook on a VoIP listener to that and then kind of abuse it to see if there's an

23:09.640 --> 23:12.640
invite event coming in and then you show your own UI.

23:12.640 --> 23:13.640
That works.

23:13.640 --> 23:15.000
I hope that's the right way to do it.

23:15.000 --> 23:19.440
Please tell me if that is not.

23:19.440 --> 23:25.480
By the way, if you, like I said, I use the m.call.invite thingies for the thing now.

23:25.480 --> 23:29.840
But that's not a thing with LiveKit because all of the LiveKit stuff happens on WebSockets.

23:29.840 --> 23:31.560
So there's a new MSC for that.

23:31.560 --> 23:36.200
With this you can basically, this uses intentional mentions so you don't spam your whole room

23:36.200 --> 23:38.040
with your notifications.

23:38.040 --> 23:48.040
But you can specify which user IDs you want to spam, ring, and which, what your notification

23:48.040 --> 23:49.040
type is.

23:49.040 --> 23:52.520
It could either be a ring or a notification, yes.

23:52.520 --> 23:53.520
S-Frame key sharing.

23:53.520 --> 24:02.560
No time, but SFUs need another lock because WebRTC and said the SFU stuff uses S-Frames

24:02.560 --> 24:03.560
secure.

24:03.560 --> 24:04.560
Trust me, bro.

24:04.560 --> 24:05.560
Cascading.

24:05.560 --> 24:06.560
Yes.

24:06.560 --> 24:13.440
Right now your calls are, well, right now the calls are technically federated.

24:13.440 --> 24:19.760
So you could potentially have a call inside a room with SFU one and you could have a call

24:19.760 --> 24:23.480
inside another room with SFU two.

24:23.480 --> 24:28.760
The only main limitation right now is that all of your participants who want to be on

24:28.760 --> 24:31.200
a call need to be connected to the same SFU.

24:31.640 --> 24:37.520
With this you can also have like secure deployments where you basically just have the left half

24:37.520 --> 24:43.600
and then all of your communication is within your organization just for the local network,

24:43.600 --> 24:44.600
etc., etc.

24:44.600 --> 24:50.680
But in the ideal future what we want is cross SFU communication where every home server

24:50.680 --> 24:57.000
could have its own SFU and their JWT service, then all of the users from that home server

24:57.000 --> 25:02.720
connect to their own SFU and then the SFUs cross-federate, everything is federated.

25:02.720 --> 25:04.720
Yay.

25:04.720 --> 25:08.440
This is already a thing by the way, but it's a proprietary thing in LiveKit.

25:08.440 --> 25:13.920
So maybe if someone from LiveKit is watching, please open source it so Matrix can use it.

25:13.920 --> 25:16.680
Probably not going to happen.

25:16.680 --> 25:18.080
And how you implement this?

25:18.080 --> 25:21.560
The easy, there's two ways.

25:21.560 --> 25:24.920
You can either implement element call in the widget mode.

25:24.920 --> 25:29.920
I believe there's two SDKs right now, the Rust SDK and the React SDK, which already

25:29.920 --> 25:31.240
support widgets.

25:31.240 --> 25:38.160
So you can just use the iframe in your app, looking at you fractal people, do it already.

25:38.160 --> 25:43.680
And if you don't unfortunately support the widget API, well then you have to go the hard

25:43.680 --> 25:44.680
way.

25:44.680 --> 25:49.680
You need to implement it using the native LiveKit SDKs and, well, LiveKit has a lot

25:49.680 --> 25:50.680
of SDKs.

25:50.680 --> 25:55.280
The Flutter, Android, Swift, Rust, obviously Rust is there.

25:55.280 --> 25:56.280
Yeah, that's it.

25:56.280 --> 25:57.280
Thank you.

25:57.280 --> 25:58.280
Demos.

25:58.280 --> 26:12.160
By the way, if you can join this demo, you, Timo, I think they can use develop.relement.io.

26:12.160 --> 26:13.160
Yes.

26:13.160 --> 26:15.760
Basically maybe you go ahead and show the...

26:15.760 --> 26:16.760
Ah yes.

26:16.760 --> 26:19.440
Yeah, but so they can sign in.

26:19.440 --> 26:21.680
You can either use...

26:21.680 --> 26:22.680
You can either use...

26:22.680 --> 26:24.920
I should have written this down.

26:24.920 --> 26:31.240
You can either use develop.element.io or td-family.github.io slash fluffychat.

26:31.240 --> 26:34.120
I promise you this is not a phishing attempt.

26:34.120 --> 26:38.640
I can show you the CI run from what I deployed it.

26:38.640 --> 26:42.560
But well, and once you go there, just type in this alias and then you should pop up in

26:42.560 --> 26:44.960
a room and you can join a call with us.

26:44.960 --> 26:47.880
Could you repeat the URL?

26:47.880 --> 26:51.920
This is the URL.

26:51.920 --> 26:52.920
It is...

26:52.920 --> 26:53.920
Yes.

26:53.920 --> 26:59.720
Timo, do you want to start it now?

26:59.720 --> 27:00.720
Yeah.

27:00.720 --> 27:05.240
So basically, can people hear me if I talk without the microphone or...

27:05.240 --> 27:10.560
Okay, then you just have to talk with them.

27:10.560 --> 27:13.160
I'm talking.

27:13.160 --> 27:19.280
Okay, perfect.

27:19.280 --> 27:21.200
Yeah, then I can also talk.

27:21.200 --> 27:25.200
So basically what I just did is start a call.

27:25.200 --> 27:32.080
And the cool thing now is that we really have inelement web, inelement x, and infamately

27:32.080 --> 27:36.760
or fluffychat, we have the full new matrix RTC stack implemented.

27:36.760 --> 27:38.920
So all of them are able to...

27:38.920 --> 27:39.920
Can you hear me?

27:39.920 --> 27:40.920
Yeah.

27:40.920 --> 27:43.400
I can hear some weird sounds.

27:43.400 --> 27:45.400
So all of them can talk with this new stack.

27:45.400 --> 27:50.800
So you have to go to develop.element.io and there is a feature flag there.

27:50.800 --> 27:55.320
Oh, to be in the camera, makes sense.

27:55.320 --> 28:01.240
But in general, this is like the big new thing now that everybody can without doing something

28:01.240 --> 28:07.040
highly crazy, just go to develop, activate the new group call experience and then still

28:07.040 --> 28:10.400
and then be able to use the new calls.

28:10.400 --> 28:15.360
So basically what I just did is start a call, but I think I did a private call.

28:15.360 --> 28:22.480
So that's why I did the ringing as well.

28:22.480 --> 28:26.160
So I am joining here.

28:26.160 --> 28:27.160
And TD now...

28:27.160 --> 28:28.920
Someone's already in the call.

28:28.920 --> 28:30.880
Yeah, this was me just joining there.

28:30.880 --> 28:33.160
And I think maybe Kim is in there already.

28:33.160 --> 28:35.120
Oh, there is multiple people.

28:35.120 --> 28:36.120
Interesting.

28:36.120 --> 28:37.520
Well, that's element for you.

28:37.520 --> 28:43.520
You have been seeing this for months now, but now we go to the fancy thing, fluffy chat.

28:43.520 --> 28:49.520
This started a month ago, so this is probably ridiculed with bugs, but well, if it works

28:49.520 --> 28:50.520
yes.

28:50.520 --> 28:51.520
Kaboom.

28:51.520 --> 28:52.520
Nice.

28:52.520 --> 29:07.320
So this is really super, super cool that TD managed to get like in record time.

29:08.280 --> 29:13.960
Fluffy chat into a state where we have again a federated multi client system with calling

29:13.960 --> 29:15.720
with group calls.

29:15.720 --> 29:20.920
So yeah, this is one of the first few multi client...

29:20.920 --> 29:23.320
I think it's the third time we do it now.

29:23.320 --> 29:28.640
Multi client federated matrix RTC call.

29:28.640 --> 29:31.640
With screen sharing apparently.

29:31.640 --> 29:35.920
Questions?

29:35.920 --> 29:42.000
Do you guys want to break it?

29:42.000 --> 29:43.480
How many people can still join?

29:43.480 --> 29:45.480
Oh, we are doing a test.

29:45.480 --> 29:48.480
Might as well.

29:48.480 --> 29:49.480
Yes.

29:49.480 --> 29:52.480
Yeah, are there any questions?

29:52.480 --> 29:57.480
Does LiveKit send any emails back to say who's talking?

29:57.480 --> 30:01.480
Oh, yeah, there's actually lots going on on LiveKit.

30:02.320 --> 30:03.320
Oh, okay.

30:03.320 --> 30:08.840
So the question was if LiveKit is sending any signaling back to let us know who's talking

30:08.840 --> 30:12.360
and yeah, probably also who's showing video.

30:12.360 --> 30:16.360
And there's lots of things LiveKit does, so it's actually pretty sophisticated in that

30:16.360 --> 30:17.360
regard.

30:17.360 --> 30:24.480
And even there's things like if I upstream video, but nobody's consuming my video.

30:24.480 --> 30:29.240
Like let's say we have a conference of 100 people and everybody has me at the bottom,

30:29.240 --> 30:34.600
and LiveKit is communicating to my client that I don't even have to upload video anymore.

30:34.600 --> 30:39.560
And that doesn't only work with upload video and don't upload video, that even works with

30:39.560 --> 30:41.000
a resolution.

30:41.000 --> 30:47.760
So basically if lots of people consume me in just a tiny thumbnail, then my client automatically

30:47.760 --> 30:51.160
notices that I only have to stream the thumbnail.

30:51.160 --> 30:57.760
So there's like lots of optimization happening that at the end from a receiver point of view

30:57.760 --> 31:00.720
you basically just download what you actually see.

31:00.720 --> 31:06.720
And from a streamer point of view, you also only upload what people actually need to see.

31:06.720 --> 31:07.720
Yes?

31:07.720 --> 31:08.720
Who holds this LiveKit?

31:08.720 --> 31:13.720
You said that this is fully federated, but maybe I somehow missed the point where we

31:13.720 --> 31:15.720
talked about whose LiveKit service is used.

31:15.720 --> 31:22.720
Because in the previous iteration with full mesh, I thought the cool thing were that multiple

31:22.720 --> 31:29.720
MaTvic servers are involved, also multiple SFUs or whatever are involved.

31:29.720 --> 31:46.720
Now it seems like it's maybe the LiveKit server for the first one initiated or something.

31:46.720 --> 31:47.720
Yeah, so basically.

31:48.720 --> 31:51.720
This is kind of two questions.

31:51.720 --> 31:56.720
The first part was who's hosting the LiveKit server, where are they coming from?

31:56.720 --> 32:02.720
If it's federated, there should be like, yeah, same similar to MaTvic server, multiple servers,

32:02.720 --> 32:03.720
and that's exactly what's happening.

32:03.720 --> 32:08.720
So the idea is that in the future it becomes very, very common that next to your MaTvic

32:08.720 --> 32:13.720
home server you also host a LiveKit SFU.

32:13.720 --> 32:18.720
It's kind of similar to that lots of people also host a turn server right next to their

32:18.720 --> 32:19.720
MaTvic server.

32:19.720 --> 32:26.720
And then the second part of the question was how do we decide which SFU do we use?

32:26.720 --> 32:33.720
And of course, like what TD presented at the end, where you have the option that SFUs talk to each other,

32:33.720 --> 32:36.720
there you would just always connect to the SFU of your home server.

32:36.720 --> 32:42.720
And if they're federated participants, the SFUs in between each other would figure it out.

32:42.720 --> 32:50.720
Now there's actually a system that the first one, exactly how you also initiated it or presented it,

32:50.720 --> 32:55.720
the first one who's joining defines in their member event which LiveKit SFU to use,

32:55.720 --> 32:57.720
and then everybody's jumping on that SFU.

32:57.720 --> 33:03.720
And since that means if the first one is leaving and maybe others are joining,

33:03.720 --> 33:09.720
but they have a mistake that they put the wrong or different LiveKit SFU into their member event,

33:09.720 --> 33:13.720
we even have real time switching from SFUs.

33:13.720 --> 33:21.720
So it's not, I think it's a one second interruption you get, but it still works really well that if the first one is joining with SFUA,

33:21.720 --> 33:25.720
the second person has SFUB in there, then the first one is leaving the call,

33:25.720 --> 33:29.720
everybody's immediately switching to the SFU from the oldest participants.

33:29.720 --> 33:36.720
But I guess it's quite obvious this is mostly a workaround until we get to the point where the SFUs in between each other

33:36.720 --> 33:41.720
can exchange the streams directly, that would be, of course, much more elegant than we don't need this anymore.

33:41.720 --> 33:44.720
But for now this is exactly how it works, so we can always guarantee,

33:44.720 --> 33:48.720
because that's a very simple glaring algorithm, just take the oldest member state event,

33:48.720 --> 33:53.720
call member state event, that we can always guarantee everyone is on the same SFU,

33:53.720 --> 33:57.720
which is quite important for a call, of course.

33:57.720 --> 33:59.720
Does that answer the question?

33:59.720 --> 34:03.720
Yes, always.

34:03.720 --> 34:10.720
Do you see any technical difficulties with having recording or transcripts?

34:10.720 --> 34:17.720
So the question is about recording and transcripts, and if there's technical difficulties around this.

34:17.720 --> 34:23.720
So basically since this is matrix, the ideal and easiest to cross approach,

34:23.720 --> 34:29.720
or UX, however we want to call it, would be that those kind of things just happen as bots.

34:29.720 --> 34:34.720
So, or recording would happen as bots, where you can easily just have a recording bot,

34:34.720 --> 34:38.720
they are just another participant, they are part of the room, they get into the key sharing,

34:38.720 --> 34:42.720
so it's very transparent for everybody that it's not just those participants,

34:42.720 --> 34:49.720
but also the bot receiving the streams, and then this bot would take care of recording.

34:49.720 --> 34:54.720
And since it's all based on LiveKit and LiveKit is a very, very good infrastructure already,

34:54.720 --> 35:00.720
there are amazing tools for this, so recording should be fairly straightforward.

35:00.720 --> 35:07.720
The transcript question, which was also asked, that is basically an implementation discussion.

35:07.720 --> 35:12.720
You could also have a bot, and then the bot could stream the data into a data channel,

35:12.720 --> 35:17.720
or the bot could stream the data directly into the room, because it's then part of the room,

35:17.720 --> 35:24.720
or you could say you don't want any bot to get the data, and you want to run local systems,

35:24.720 --> 35:31.720
which do the transcription, and then just, yeah, do it locally, like there are multiple solutions for this.

35:31.720 --> 35:33.720
I guess we'll see what the future brings.

35:38.720 --> 35:46.720
This is amazing. I think somebody just joined the room with a, oh, but it's just unmuted.

35:46.720 --> 35:50.720
I thought that is somebody already having implemented recording and now playing live.

35:50.720 --> 35:52.720
That would have been so cool.

35:52.720 --> 35:57.720
I just got super excited, but I guess this is just my echo.

35:57.720 --> 35:59.720
Any other questions?

36:04.720 --> 36:11.720
So basically the current state is that it's just on develop, but it is ready to try out.

36:11.720 --> 36:17.720
I think this is actually something, can you show the path to activate the new group call feature in Element?

36:17.720 --> 36:25.720
So if you go to develop, there is one feature flex, so for now you will only get the option to do jitzy calls and legacy calls,

36:25.720 --> 36:32.720
but if you want to have the new matrix RTC calls or Element calls, you need to go into the settings and then feature flex,

36:32.720 --> 36:38.720
and there's a flag called, yeah, new group call experience, and if you turn this on,

36:38.720 --> 36:45.720
and on the sending and receiving client, it should all work, and on Element X, like the mobile client, Android and iOS,

36:45.720 --> 36:47.720
it also should just work.

36:47.720 --> 36:49.720
Like there you don't even have to activate a feature flex.

36:49.720 --> 36:56.720
You just go into the room, press join, and it should end up in the same room there as well.

36:56.720 --> 36:59.720
Actually, that's a part of the demo we could just do, right?

36:59.720 --> 37:02.720
Do you just want to join with that user?

37:02.720 --> 37:06.720
I think, yeah, this is actually also a thing we can show.

37:07.720 --> 37:18.720
It's basically easily also possible to have multiple devices per user, so that basically implies we have simple continuity,

37:18.720 --> 37:24.720
so I was connected with this computer, and now I just connected here.

37:24.720 --> 37:26.720
Oh, I need to read this.

37:26.720 --> 37:27.720
It's dangerous.

37:27.720 --> 37:33.720
So I'm connected here as well, and now you can't see any streams, right?

37:33.720 --> 37:36.720
It does show streams on my computer.

37:36.720 --> 37:38.720
Maybe they will recover.

37:41.720 --> 37:47.720
I mean, yeah, seems to not work, but it works on this computer.

37:47.720 --> 37:55.720
I mean, I can turn it around, so at least the first row can be convinced that it's actually showing this stream right here.

37:55.720 --> 38:01.720
So if I would hang up here, I basically did a continuity to move the call from here to here.

38:01.720 --> 38:03.720
Oh, and this is also pretty interesting.

38:03.720 --> 38:12.720
I'm not sure probably no one can see it, because it's just on the screen, but Paul has joined with an older version of Element X,

38:12.720 --> 38:16.720
and currently, if you're in an unencrypted room, you will stream unencrypted media.

38:16.720 --> 38:23.720
If you're in an encrypted room, you will have per sender encryption, and that's a part where TD kind of rushed over.

38:24.720 --> 38:30.720
So basically, if you have an older version of Element X, this isn't considered yet,

38:30.720 --> 38:37.720
and since this is an unencrypted room, if you join with an older Element X, you still stream encrypted data,

38:37.720 --> 38:42.720
but my client doesn't expect encrypted data, so that's why it's giving me all kinds of noise.

38:42.720 --> 38:45.720
So basically, this is proof that it's actually encrypted.

38:45.720 --> 38:47.720
So what TD said is...

38:47.720 --> 38:48.720
Trust me, bro.

38:48.720 --> 38:53.720
It's always super hard to demo an encrypted call, but here we are.

38:53.720 --> 38:57.720
We managed to break it, and there you can actually see that it's encrypted, which is...

38:57.720 --> 39:04.720
And the only reason this isn't an encrypted demo today is because we have different encrypt implementations of that.

39:04.720 --> 39:10.720
I believe Element uses room events, and I decided to use two device events, because why not?

39:10.720 --> 39:15.720
But this will get figured out once we start drafting MSCs and stuff.

39:15.720 --> 39:16.720
Exactly.

39:18.720 --> 39:20.720
Last question?

39:26.720 --> 39:28.720
All questions answered.

39:28.720 --> 39:30.720
Cool. Thank you so much.

