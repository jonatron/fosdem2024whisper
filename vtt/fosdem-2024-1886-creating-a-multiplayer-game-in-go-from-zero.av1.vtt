WEBVTT

00:00.000 --> 00:10.780
Thank you everyone. If I can have your attention again please. Because now the fun starts.

00:10.780 --> 00:17.360
We have games, we have drones, we have music. It's finally time to party and the first party

00:17.360 --> 00:29.000
person will talk about gaming in Go. Run for plaza Francesc.

00:29.000 --> 00:35.120
Thank you very much for being here. Before we start, if you want to check the game, it's

00:35.120 --> 00:40.640
available on MazeWorlds.com. If you decide to check it out while you talk, it's fine.

00:40.640 --> 00:46.600
It's still in Earth development so it may have some bugs, it may crash, but don't worry,

00:46.600 --> 00:51.000
just play with it if you want to and have fun. That's why I did it.

00:51.000 --> 00:56.840
So a bit of myself. I'm a Go developer. I've been working in Go in back end mostly for

00:56.840 --> 01:05.120
the past nine years. Before that I was doing JavaScript, Pearl and Ruby. So nothing about

01:05.120 --> 01:11.320
gaming. So I have no knowledge when I started doing this game. Why did I do it? Why did I

01:11.320 --> 01:17.600
decide to build the game for myself? So basically a few years back I was thinking like, oh, I

01:17.600 --> 01:21.840
would like to play a game that I used to play when I was in high school. So when I was in

01:21.840 --> 01:26.080
high school, every Friday with my friends we went to a cyber coffee and we used to play

01:26.200 --> 01:32.080
games like Warcraft or anything like that. And not only Warcraft but mods about Warcraft,

01:32.080 --> 01:37.360
which nowadays some of them have become popular like League of Legends. Maybe you knew about

01:37.360 --> 01:44.120
him. So League of Legends, it came from a mod of Warcraft which is called Dota and also

01:44.120 --> 01:49.000
Dota 2 is a mod that came from Warcraft for the same one. So one of the mods that I used

01:49.000 --> 01:54.240
to play on Warcraft was called Line Toward Wars. And I really loved it, but I've never

01:54.280 --> 02:00.200
been able to find anyone who ported it from the actual implementation to something which

02:00.200 --> 02:04.880
is not reliant to anything of Warcraft because this mod is available in Warcraft 3 which

02:04.880 --> 02:11.720
is from 2007. So remember, it's on Starcraft, it's on Warcraft 3 Reforged which is the new

02:11.720 --> 02:17.560
version that they released. But you always have to have Warcraft as a platform to play

02:17.560 --> 02:22.280
any of these mods. So I said, okay, how hard can it be to do something like that? Based

02:22.320 --> 02:28.840
on that, this mod is not that difficult. So first of all, I started checking out, okay,

02:28.840 --> 02:32.560
I want to build a game and I remember hearing a friend of mine saying, okay, I built a game

02:32.560 --> 02:37.880
for my kid in Lua. So I said, oh, let's check out Lua and see what it has. And with Lua,

02:37.880 --> 02:44.280
I found Lof. This is the name of the library. This library basically is a two-day game engine

02:44.280 --> 02:48.400
and I started doing the tutorial. The first tutorial which is building a small game which

02:48.440 --> 02:52.800
I'm going to show later on. But when I was building the game, I was thinking, okay, I

02:52.800 --> 02:56.560
know what I want to build and I know that we'll need a backend. I know that the backend,

02:56.560 --> 03:00.320
I'm going to build it in Go, I'm not going to do it in Lua. And I most likely need to

03:00.320 --> 03:06.640
share things between the frontend, the client, and the backend. And I don't fancy rewriting

03:06.640 --> 03:11.760
stuff so I said, let's search if there's anything in Go which does the same. And searching

03:11.760 --> 03:17.680
in Go, I found Evitan. Or Evitan, I don't know which is the representation. So an Evitan

03:17.760 --> 03:23.640
in the description is basically a two-day game engine, the same one as Lof. So I said,

03:23.640 --> 03:27.960
oh, that's fine. Let's check the documentation and let's check how it looks like. This is

03:27.960 --> 03:32.760
the simplest, simplest Hello World in a game engine. Hello World is printing Hello World

03:32.760 --> 03:38.680
on the top right of your screen, basically. And as you can see, basically, it has, in

03:38.680 --> 03:43.280
the main, you set the size of the windows that you're going to print out. You set the

03:43.280 --> 03:46.760
title that it will have. Hello World in this case. It's just the title of the windows,

03:46.800 --> 03:51.640
not what it will be inside of it. And then you use Evitan to run the game and then you

03:51.640 --> 03:58.200
pass a stroke. The stroke has to fulfill these four, I guess, three functions. One is for

03:58.200 --> 04:04.280
interface. One is update, draw, and layout. Layout is a simple one. It's basically the

04:04.280 --> 04:08.440
size of the screen outside of where you are. So you can print a small screen on a bigger

04:08.440 --> 04:14.280
screen. Then you have update and draw, which were really interesting for me because were

04:14.320 --> 04:19.520
the same names that the library that I did the first tutorial had. So basically, those

04:19.520 --> 04:24.240
two name functions did the same thing as the ones on love. So I didn't lose my time doing

04:24.240 --> 04:30.320
something in Lua because it was the same. So basically, update where it does is every game

04:30.320 --> 04:35.080
tick, which is 60 times per second, it will call this function. And in this function, you're

04:35.080 --> 04:39.720
supposed to hear for events from the user, like clicking or with a mouse scrolling with

04:39.760 --> 04:44.240
the wheel, clicking, typing anything on the keyboard, you're supposed to hear, to listen

04:44.240 --> 04:48.440
for those events there and do something. And then on the draw function, which is called

04:48.440 --> 04:53.600
every render time of your screen, you're supposed to draw what it was that the user did if you

04:53.600 --> 04:58.840
want to do anything on that. And that's it. That's all the functionality that it gives you.

04:58.840 --> 05:04.160
Aside from all the helpers of listening for stuff, that doesn't matter as it gives you. So if

05:04.200 --> 05:11.200
you want to do anything, you are basically building on top of that. So my first games, I did at

05:12.240 --> 05:17.800
the beginning four games just for me to learn libraries and to be comfortable to then start

05:17.800 --> 05:23.240
doing my own game. So the first one was shoot the enemy. This is the one that I copied from

05:23.240 --> 05:30.240
the Lua library. And just because the a bit in library didn't have any useful at least

05:30.320 --> 05:35.920
at the time. And all the tutorials were examples. So you want to do this? There's an example.

05:35.920 --> 05:40.960
You want to do that? There's an example. It has a lot of examples, but not a tutorial that

05:40.960 --> 05:46.560
kind of drives through all the stuff that you are able to do. So the first one was this one

05:46.560 --> 05:52.560
that I copied from the Lua implementation, which is the only one we're going to play. It's

05:53.120 --> 06:00.120
this one. So you are able to move. The snake is the enemy. It has a life on top left, which

06:01.240 --> 06:07.240
is the number of life, which is 10. And me and the panda. I move the panda with A and

06:07.240 --> 06:14.240
D. And if I play space, I shoot. If it hits, that was lucky. If it hits, it moves faster,

06:14.240 --> 06:18.240
so it's harder for me to finish the game. It's not because I can spam it and just finish

06:18.240 --> 06:24.120
the game easily, but the idea is it's harder for you to finish the game with that. So that

06:24.120 --> 06:30.120
was my first game. This allowed me to know how to print something on the screen, the

06:30.120 --> 06:37.120
image, get the events from my keyboard of moving left and right to move the panda. And

06:37.440 --> 06:44.440
then let me drink a bit and I'm just going to drink. And then having something that moves

06:45.400 --> 06:52.400
automatically, the snake is moving by itself, and then shooting something when they press

06:52.400 --> 06:57.240
something, and that also is moving by itself, which is the bullet, and then detecting the

06:57.240 --> 07:03.160
collision from the bullet to the actual snake and then producing the life. So with that

07:03.160 --> 07:08.480
simple tutorial, you get all that, which is really useful. So then I decided, okay, let's

07:08.480 --> 07:13.480
make something else. I was moving out of the tutorials because that's the basics. As you

07:13.520 --> 07:18.240
saw, the interface is really simple. You have all the updates or whatever you want to do.

07:18.240 --> 07:23.040
So then I decided to make the snake. I'm not going to play this one just because the image

07:23.040 --> 07:29.000
you see is one pixel by one pixel and hitting the actual box is really awkward. So I'm just

07:29.000 --> 07:32.600
going to make a full of my software in that game. But it works. And you have the score

07:32.600 --> 07:37.040
that you have on the top left, so how many of the boxes did you get, and it gets longer,

07:37.040 --> 07:40.760
and then you can go to the edge of the screen and it will appear on the other end. So the

07:40.800 --> 07:46.440
only thing that kills you is eating yourself. So one of the normal snakes. The next one,

07:46.440 --> 07:51.160
the radio, is space and bothers. We all know how it was, so it's basically you can move

07:51.160 --> 07:57.160
the spaceship to the left to the right, you click space, and then you kill the invaders.

07:57.160 --> 08:03.040
Same thing. So nothing much more difficult than the first one, for example, this one.

08:03.040 --> 08:08.440
But then when I finished this, I said, okay, now I know a bit of the basics, but there

08:08.480 --> 08:13.000
are a few things I didn't touch yet on regards of what I want to do, which is the game that

08:13.000 --> 08:17.880
I will tell you later on what it's about. And the thing that I was missing is basically

08:17.880 --> 08:23.480
how units move. So not just moving, but the assets of the unit moving up, moving left,

08:23.480 --> 08:27.200
moving right, and so on. So you print those on the screen, so when you actually do the

08:27.200 --> 08:33.120
movements, you see something moving smoothly, not just the other movements, which are just

08:33.160 --> 08:38.400
moving an image up and down. And not just that, but seeing it move on someone else's

08:38.400 --> 08:42.640
screen. And then you have to have server side, which the client is sending information

08:42.640 --> 08:47.960
to the server, and the server is replicating this state to the other clients and yourself.

08:47.960 --> 08:53.040
So this is a small example of the first implementation that I did. That's an hour on the right side

08:53.040 --> 08:57.760
if I move to the left side. So you can see that the two clients see the same thing, and

08:57.760 --> 09:02.120
there's a server also. But it's the first implementation in which it's simple to see

09:02.120 --> 09:06.520
the things are moving around and doing this stuff. And also the map. This map that you

09:06.520 --> 09:10.640
see in the background is something that I built. It's not complex, but it's something

09:10.640 --> 09:16.000
that then allows me to build what that's the real game that I built, which I called Maze

09:16.000 --> 09:23.000
Wars in this case. So now it looks a bit better. It's a screen show I took maybe a month ago,

09:23.520 --> 09:29.880
so now it looks a bit better, but that's the basics. So what is this game about? Basically

09:29.920 --> 09:35.560
when you start the game, not when you start the app, you have to give it a name, and then

09:35.560 --> 09:41.160
you have to start the game, and then other people join, and it could be up to six people

09:41.160 --> 09:45.400
or minimum of two. In this case, it's two people. So when we are two, you are assigned

09:45.400 --> 09:52.440
one of these lines, up to six. So for example, in this case, I say I'm the one on the left.

09:52.440 --> 09:56.640
The end goal of the game is to steal all the other people's life. Everyone has at least

09:56.680 --> 10:01.680
20 lives. When they start, everyone has 20 lives, and the way I steal those lives is

10:01.680 --> 10:06.240
by sending units. Sending units in the bottom right, you see that there's a screen which

10:06.240 --> 10:11.280
some faces, those are the units. When you click those, the units spawn on the top, gray area,

10:11.280 --> 10:16.360
and they have to pass down until they reach another gray area, which they move to the

10:16.360 --> 10:21.920
next line if there's any, or die. And also when they reach the end, they steal a life

10:21.920 --> 10:25.760
from the other player and they give it to you. That's as simple as that. How to prevent

10:25.800 --> 10:31.600
that? You have to place towers. When you place the towers, the idea is to build the maze for

10:31.600 --> 10:36.600
the units to go through the maze while the towers are attacking the units. And that's

10:36.600 --> 10:41.720
all. That's where I did it, because it's really simple. If you nail it down and reduce it

10:41.720 --> 10:46.760
to the basics, it's something which is really simple. If it were a shooter game or something

10:46.760 --> 10:52.160
like that, I would not even start it because that's another stuff. But this is really easy.

10:52.240 --> 10:57.720
So I said, okay, let's build it. And also this is basically if you ever played any kind of tower

10:57.720 --> 11:03.000
defense, which also came from Warcraft mods, this is basically a tower defense, but that you can

11:03.000 --> 11:09.320
build a path instead of having a predefined path that you have to place towers on. So my list of

11:09.320 --> 11:15.520
things, at least at that time, that I said, okay, I need this in order to do the game. I needed

11:15.640 --> 11:23.520
some assets because I need towers, I need the terrain, I need the units and so on. I need to do the

11:23.520 --> 11:29.920
map. So how is the map of the game? That's the thing that you saw before. Also, I need to be able,

11:29.920 --> 11:34.800
well, the code architecture, so how I'm going to architecture the code in order to not have a

11:34.800 --> 11:39.600
mess later on. So how are things going to be organized and how everything is going to communicate

11:39.680 --> 11:45.840
between each other? That's one of the interesting parts for me. Summoning units, so clicking the unit

11:45.840 --> 11:53.000
and summoning on the other side and then passing down, placing towers, described this, and gold

11:53.000 --> 11:58.880
income and lives, that's also easy, and multiplayer servers and the EXUI. So those are the list and

11:58.880 --> 12:04.200
we are going to go through that and potentially the struggles that I had while that. So the assets.

12:04.920 --> 12:11.560
For the assets, I was searching for something free at the time that was giving me the minimum

12:12.360 --> 12:17.800
kind of interesting assets that I needed. In this case, you need units. You can see that there are

12:17.800 --> 12:21.480
here some of the units that I saw before. On the top right, there's a cycle that is called which

12:21.480 --> 12:28.680
one I, so it had units, at least 10, it has, so it's fine. The hard part is to find towers because

12:28.680 --> 12:32.680
normally on these free assets packs, towers are not something that you were going to find because

12:32.680 --> 12:39.080
it's really specific to this game. So what I used is what you can see on the bottom right, which is

12:39.080 --> 12:44.280
like a sculpture of a monk. So that's what I use as one of the towers and there's another sculpture

12:44.280 --> 12:49.160
as a warrior, which is the other tower that I use. The asset pack is much bigger than this. It's

12:49.160 --> 12:53.240
really, really big. It's just an example that they give you as a few things that we have here.

12:54.120 --> 12:55.560
I'm going to drink a bit more of water.

12:56.360 --> 13:06.040
So yeah, then the map. How did I build the map? The map I use

13:06.920 --> 13:13.240
software which is called Tile, which is basically used for that, to build maps and to be something

13:13.240 --> 13:17.320
for your game. Basically what you do is you import your assets on your bottom right. You see that

13:17.320 --> 13:22.840
those are some of the, some of the map assets of the assets that I showed before and then you are

13:22.840 --> 13:28.440
basically using paints. Let's say this way. You click one of the assets and you can place it on one

13:28.440 --> 13:34.040
of the grid. You see that that's a grid. You can place it. You can, and basically once you have one

13:34.040 --> 13:39.000
line, in my case, I can just copy paste it down because those are all the same. So once I did one,

13:39.000 --> 13:43.800
basically it was to build the map for more play-ups, just copying them. But that's the library that I

13:43.800 --> 13:49.000
use. Once I found it, I was like, okay, that's quite easy and it works really well. Then for the

13:49.080 --> 13:56.840
code architecture, when I was building the game, when I started with Lua, the thing about hearing

13:56.840 --> 14:01.800
for actions, sending actions to somewhere and that somewhere is storing those actions and then

14:02.680 --> 14:08.120
the draw is drawing what happened before. It was really, really ringing my bells on some things I

14:08.120 --> 14:16.440
did before. On the bus, when I was working with JavaScript, I was maybe good at that, but I was

14:16.440 --> 14:23.080
in the train type of React when it came out and React and Redux and all that. When that came out,

14:23.080 --> 14:29.240
I was doing JavaScript, so I was really on tune with that. React before it was using Redux, and I

14:29.240 --> 14:34.360
don't know what it's using now, it used to use Flux, which is the library that Google and

14:34.360 --> 14:40.680
more Facebook are implemented. How it works is basically this is an HTML point of view. The view

14:40.680 --> 14:45.880
is the normal HTML that you have. When the user clicks the view, an action is triggered. This

14:45.880 --> 14:51.080
action is passed to a dispatcher, which is basically serializing all the actions in a specific order

14:51.080 --> 14:57.720
in the order they arrive. Then it's dispatching these actions to the stores. The stores are basically

14:59.720 --> 15:04.840
data maps which listen for those actions. It's a big switch case for the actions that you want to

15:04.840 --> 15:10.680
do actions on with the data that you supposedly have. Once you change your data with the action that

15:10.680 --> 15:17.240
happened, then you trigger an even like I changed. Then the view is hearing for those I change. Then

15:17.240 --> 15:22.840
if it Redux, for example, I react, you change the specific part of the view that it belongs to

15:22.840 --> 15:29.400
a data.change. That's how this works. If you change the view and you add the client that I'm doing,

15:29.400 --> 15:35.960
it's the same stuff. The only difference is that the store is not triggering I change,

15:35.960 --> 15:41.240
though the library does. It's not triggering I change because the draw is already being called

15:41.240 --> 15:46.280
every time that the screen is being refreshed. There's no need for any view to hear from any

15:46.280 --> 15:52.760
changes from the store. Basically, I look for the Flux library in Go. There were some

15:52.760 --> 16:00.360
implementations not fully implemented or not working as expected. I just ported the full

16:00.440 --> 16:06.200
implementation of Flux that is on Google, I don't Facebook for it, and I ported it on Go. If any of

16:06.200 --> 16:12.200
you want to do something like this, there's a library now that works for that. What that gave

16:12.200 --> 16:17.880
me also is a state update, which means that when something changed, I also need to notify the server

16:17.880 --> 16:22.040
that something happened if it's needed for the server to know the data. For example, if I place a

16:22.040 --> 16:26.120
tower, then I can send this action to the server. The server has the same architecture, has a

16:26.200 --> 16:32.040
dispatcher, has the stores, and then the server can apply this information. In my case, that's why

16:32.040 --> 16:37.960
I decide every four times per second, the server is getting these stores, the state that it has,

16:37.960 --> 16:42.440
it serializes the state in JSON, and then it sends this state to all the clients. The clients can

16:42.440 --> 16:48.360
see that someone plays a tower because the state is changed. How this is sent with an action,

16:48.360 --> 16:55.320
I'm using WebSocket. It sends an action via WebSocket to get the action on the client and just

16:55.320 --> 16:59.160
creates an action and push it to the dispatcher, and then everything works as expected.

17:01.320 --> 17:05.800
Yeah, that's architecture that I did. Also, one thing that is really cool that I'm not doing now,

17:05.800 --> 17:11.320
but that could be potentially useful is replayability. If you play a game, some games you

17:11.320 --> 17:16.280
can, you have the ability that after you play the game, you can see, okay, what did I do wrong,

17:16.280 --> 17:21.160
and you can just replay the game. I don't know how this is done, but the only way that I have in

17:21.160 --> 17:26.520
mind of working is something like this, because if I have the actions, I can just replay the actions

17:26.520 --> 17:31.640
in the order that happened, and I have replayability, and that's it. So as long as I'm

17:31.640 --> 17:37.080
replaying on the same moment that happened, I can replay anything at any point of time. So, yeah,

17:37.080 --> 17:41.480
if at some point I want to implement that, I just have it kind of for free. I just have to store

17:41.480 --> 17:50.360
the actions on, that's it. Now, the other interesting part, summoning units. So the first

17:50.360 --> 17:56.680
implementation was the easiest one, so just Y++, just go down, straight down, ignore everything

17:56.680 --> 18:00.600
until you reach the bottom, which is when you die, and then you steal the life, and you give it to

18:00.600 --> 18:06.200
the player. That's fine. I did this implementation just to see that everything was working. You click,

18:06.200 --> 18:11.640
you summon, and it goes on. Fine. Now, the next implementation was when I was already placing

18:11.640 --> 18:17.080
towers. So when I had tower placing, if I summon a unit, it just went straight through the towers,

18:17.080 --> 18:22.840
because it didn't know that those should be avoided. So then I implemented Drieska, just because for

18:22.840 --> 18:27.480
me, like, I have to find the shortest path between point A and point B. I'm going to do that. Well,

18:28.280 --> 18:34.600
I didn't know at the time, but Drieska is not the fastest. If it's a big graph, it takes three

18:34.600 --> 18:39.640
seconds to calculate the path of all the graphs using Drieska. So if we go to the beginning,

18:40.280 --> 18:46.840
you can see the cursor moving. Now I click, now it appears. So it's really slow. And it's

18:46.920 --> 18:50.840
something that basically you cannot play with it. It would be impossible, because also it's blocking

18:50.840 --> 18:56.520
the main thread, because it's doing that. So I was chatting with a friend of mine and said,

18:56.520 --> 19:01.160
okay, this is happening. Do you know something? And he said, yeah, you can try Aster. I don't know

19:01.160 --> 19:06.200
if you test it, but Aster is basically a passing algorithm that is an improvement over Drieska

19:06.200 --> 19:11.800
and based for passing for games. Like, well, that looks like something that is for what I want to

19:12.760 --> 19:18.760
do. So maybe you can notice the difference, but yeah, it's a bit faster than Drieska. I'm

19:18.760 --> 19:22.680
spamming, right? I'm just clicking, clicking, clicking. And you can see it's not going slow. It's

19:22.680 --> 19:27.400
not blocking anything. And it's quite good. Ignore the fact that they are going below the

19:27.400 --> 19:35.320
towers. Just follow the lines. Just ignore the assets at this time. So yeah, I did Drieska.

19:35.320 --> 19:41.080
The only thing that it's noticeable, and I think that now that I changed a few things, it was a

19:41.080 --> 19:47.800
mistake that I did. But basically, the ones that go on this side, you see it basically are doing

19:47.800 --> 19:52.680
edge shapes, which is not good for this game because the towers have a range for attack. So

19:52.680 --> 19:55.960
they're basically going attack me, attack me, attack me, attack me, attack me, and they die.

19:55.960 --> 20:00.120
The good thing would be just doing a diagonal. Let me bring my water.

20:01.080 --> 20:05.080
Right.

20:06.040 --> 20:13.560
So for that, I just tweak a bit A star. Because A star, how it works is basically you have a

20:13.560 --> 20:20.680
Drieska, the same one. But the only difference is that you have, how is it called? A priority queue.

20:21.640 --> 20:26.280
It's time that you want to calculate the distance between, if you want to, it's time you want to

20:26.360 --> 20:34.680
jump to a different node to calculate the graph on that, the path on that node. What you do is you

20:34.680 --> 20:39.000
say, okay, from this node to the end, which is the distance. And from that node to the end,

20:39.000 --> 20:43.160
which is the distance. And then you got all the distance. You push this element to a queue

20:43.160 --> 20:47.320
with the node. And then you get an element from the queue, which is the one that eats more,

20:48.440 --> 20:52.680
more closer to the destination. So basically, if it's just a straight line, it will just

20:52.680 --> 20:58.360
calculate go straight because it's always the fastest route to go straight. And that's how A

20:58.360 --> 21:04.280
star works. What I change about A star, and that's basically my potential, and now it works better

21:04.280 --> 21:09.000
in this way. But what I change is that this algorithm to calculate how close it is, I use

21:09.000 --> 21:14.920
Pythagoras because it's just to have xy and xy just make Pythagoras and go straight line the

21:14.920 --> 21:19.880
difference. But the ideal one that it has to use is Manhattan. Manhattan algorithm is basically

21:19.880 --> 21:23.240
how many jumps left and right, left and right, or pixel, pixel, pixel, pixel, pixel,

21:23.240 --> 21:27.880
no diagonals is the distance between those. And with that, it works much better. But what I did

21:27.880 --> 21:33.560
to change it is basically when I'm pushing elements to this sort of queue, this periodic queue,

21:34.280 --> 21:40.600
what I'm changing is that if the node that I'm pushing isn't the same direction that I was,

21:40.600 --> 21:45.720
I just increase a little bit. So I just decrease the priority. So it's most unlikely that he

21:45.880 --> 21:51.240
will go straightforward or the same direction. And it's more likely that he will switch directions,

21:51.240 --> 21:56.200
basically fiber thing to going on diagonals. And just doing that small change, everything when

21:56.200 --> 22:04.280
like perfectly on the diagonals or whatever. And yeah, that's what I should be for. Placing towers.

22:04.280 --> 22:09.960
Placing towers has not much logic itself, just the fact that when it clicks and how to place it on

22:10.040 --> 22:15.640
the line. The only thing that's noticeable is that the tower is not, you cannot place it

22:15.640 --> 22:21.080
anywhere on the line. You can't place it anywhere on the line. But it has like, you could see that

22:21.080 --> 22:28.920
it's basically jumping around. That is not straight. Why is that? Because when you're building the maze,

22:28.920 --> 22:34.120
it's much better to have something straight because for you, it's easier to finish like the

22:34.120 --> 22:38.680
build that you're doing than if something is one pixel below and someone is one pixel above,

22:38.680 --> 22:42.680
because then most likely you will find that you are blocking the units, which is something that

22:42.680 --> 22:46.360
you cannot do. You cannot block the unit. You cannot just build perpendicular lines and say,

22:46.360 --> 22:49.800
that's it. I finished. That's not possible. You cannot block the path of the units.

22:50.360 --> 22:54.120
So that's another topic. How to detect that the path is blocked.

22:57.160 --> 23:01.960
And how to get the path is blocked. Basically what I do is when you try to place a tower and you

23:01.960 --> 23:07.640
do the action of placing towers, I just try to create a new unit that will go through as

23:08.360 --> 23:13.720
theoretical line with that tower in it. If I don't get any path, then it's wrong. You cannot place

23:13.720 --> 23:20.040
a tower. And if I do get a path, then yes, you can place a tower. And that's for placing towers.

23:20.040 --> 23:25.400
Then I have gold and income, which is easy. You get gold by killing units. You get income by

23:25.400 --> 23:29.720
submitting units. And then every 15 seconds, all the income that you get from submitting units,

23:29.720 --> 23:33.800
from all the game, you get it as gold. And the life is basically subtracting life.

23:34.600 --> 23:38.360
The multiplayer server is something that I spoke with the architecture. But basically,

23:38.360 --> 23:43.320
if you are interested in game servers, this post here is really, really, really interesting.

23:43.320 --> 23:48.040
Because it explains you how different games that you may want to build, for example,

23:48.040 --> 23:53.240
shooter games or things like that, how do they supposed to work in a small scale? For example,

23:53.240 --> 23:56.760
shooter games, the thing that was not useful for me, it's like you are shooting on the past,

23:56.760 --> 23:59.720
you are just shooting on the present, because as everything is happening in life,

23:59.720 --> 24:05.640
the idea on the servers that you are on the past, for example, the implementation is

24:05.640 --> 24:09.640
alternative. Basically, the server is the one ruling everything through the client,

24:09.640 --> 24:13.640
sending information. The client has to override with what the server is sending.

24:13.640 --> 24:19.640
But it's also the server have, the client have a bit of predictions. The unit movement is not

24:19.640 --> 24:26.040
sent with the state. It is, but the one that is doing the movement is the client. So the server

24:26.120 --> 24:30.280
is just sending that this was the path and it didn't change and the client is just

24:30.280 --> 24:36.440
continuing with the path that it was before. And also using Flux and using WebSockets for all of that.

24:38.120 --> 24:42.280
UX UI, first, that was the implementation that I have before, which is really awful.

24:42.840 --> 24:48.520
And then I discover a written UI, which is basically bootstrap. I don't know if you heard

24:48.600 --> 24:55.800
of bootstrap for HTML. Well, it's that. You can create, you can say this container, which

24:55.800 --> 25:02.040
it has rows or it has a grid, and then all the content inside of it will be placed in different

25:02.040 --> 25:08.360
things. And you can do input and you can do buttons and so on. So it's really, really simple for

25:08.360 --> 25:13.080
these types of things. Then cross compilation, which was something that has been discussed with

25:13.080 --> 25:19.480
Go Release before. And this was fun because I never compiled with Cgo enable and this requires

25:19.480 --> 25:27.640
Cgo enable. So I managed to cross compile with Cgo enable for Linux, OS X and Windows.

25:28.440 --> 25:33.560
And using Go Release, just changing a few things on the actual code base and I have to open up

25:33.560 --> 25:38.840
a PR to go release to propose those changes because it's just two lines of changing. And you can

25:38.840 --> 25:44.600
cross compile using Xgo. It's not go, it's Xgo, which is a cross compilation tool. And also you

25:44.600 --> 25:49.080
can play on the browser with Wasm and at some point I will try to do it on Android, which is also

25:49.080 --> 25:55.960
possible. And for the future, the only thing that I, well, from the other things I have to do,

25:55.960 --> 26:00.760
the main one is improving the A star because right now it's the bottleneck. It takes 100

26:00.760 --> 26:06.920
milliseconds to create a path. And if George is spamming it, it's awful for everyone to work with

26:06.920 --> 26:13.240
because everything goes as low. And then add more types of units, add more types of towers and much,

26:13.240 --> 26:19.000
much, much more. That's it. I hope it was interesting for everyone.

26:19.000 --> 26:30.840
Thank you. If you have questions, please ask in the hallway because we want to change speakers

26:30.840 --> 26:35.480
quickly and not wasting any more time. Thank you again and amazing work.

