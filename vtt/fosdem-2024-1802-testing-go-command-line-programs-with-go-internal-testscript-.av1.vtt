WEBVTT

00:00.000 --> 00:14.920
Good afternoon everybody. Who is a Go developer? Very well. Very nice to meet you. My name

00:14.920 --> 00:22.200
is Giuseppe Magia. I work with VMware. I am not the creator of this thing that I'm presenting

00:22.200 --> 00:32.240
today. My company is not involved in this. I'm just a user and since it makes my life

00:32.240 --> 00:43.320
easier, I decide to share with you what I do with it. So the thing that I want to do

00:43.320 --> 00:47.840
theoretically is the things that you see on the screen. But practically what I want to

00:47.840 --> 00:56.920
do is to make you curious about Test Script. So you will try and eventually see how good

00:56.920 --> 01:09.240
it is and what you can do with that. The important thing is that you will learn a few basic things.

01:09.240 --> 01:15.200
I mean, I could talk about Test Script for three hours and probably wouldn't exhaust the

01:15.200 --> 01:21.000
argument. But since we have only 20 minutes, this is what we are going to do. We are going to

01:21.000 --> 01:33.880
show the basics of Test Script so you will know it. We started with why. Why do we need to have

01:34.040 --> 01:45.800
this kind of tool? It's because we have a problem. When we do a command line program, we need to test

01:45.800 --> 01:56.440
it and to test it, we need to build it. Then we need to do something with this build to shake it up

01:56.520 --> 02:03.320
and check that it's doing what it's supposed to do. You can do a lot of things instead of

02:05.960 --> 02:14.200
testing directly the command line program in the shell. For example, you could test the single

02:14.200 --> 02:20.680
functions that are inside the program and you should do that. But this is not the same as

02:20.760 --> 02:26.440
testing the program. To test the program, you need to make sure that the function that works well in

02:26.440 --> 02:38.440
your tests also is linked to the command line command or option that you hope is linked correctly,

02:38.440 --> 02:49.240
but not always. Also, the input that you put in the function that works beautifully and since it has

02:49.320 --> 02:55.160
space in between, it doesn't work on the command line. You need really to test the real thing.

02:57.880 --> 03:03.960
The problem that you have is that to achieve this goal, you need first to compile the program

03:04.920 --> 03:13.640
and second to find a way of testing that program in such a way that it works well with your go

03:14.040 --> 03:25.880
code and it is checked in the right way. By checking the right way, I mean that

03:27.800 --> 03:36.280
you are sure that what you hope to achieve is what exactly happens. Doing this kind of thing

03:37.160 --> 03:46.280
in a shell script is not always easy. Let's talk about this test script and what is it?

03:47.400 --> 03:56.840
It's a Go library. It's also a standalone tool and the best thing is that this is developed directly

03:57.560 --> 04:06.600
by the Go team. They use it to test the Go tool itself and all the tools that come with the Go

04:06.600 --> 04:15.640
program. It has been recently, a few years ago, released in the Go internal package, so you can

04:15.640 --> 04:28.760
use it separately from the Go code. Especially, you can use it for mostly anything. If you are

04:30.040 --> 04:37.240
developing your command line code, a command line program in Go, it's much better, but you could

04:37.240 --> 04:44.520
also use it to test mostly any command line program, even if it's not written in Go. Of course, if it's

04:44.600 --> 04:53.240
written in Go, it helps. Let's see a first example. To test something with test script,

04:53.240 --> 05:01.160
you need two components. The first one is a script. It's a script that says something about

05:01.160 --> 05:07.240
what you want to test and what you want to get. In the script that you see on the

05:07.960 --> 05:17.960
upper part of the screen, there is an echo, a hello world and a keyword, exec, before.

05:19.240 --> 05:27.560
Exec is an internal command of test script that will run something. Then there is a standout

05:28.520 --> 05:37.400
with confirmation. The confirmation is that you should receive something that says hello world

05:37.400 --> 05:51.800
and a new line. Then there is an exclamation point that says standard error and a dot. This

05:52.760 --> 05:57.960
line means I don't want a standard error. I don't want anything in a standard error.

05:57.960 --> 06:06.040
More about this later. Then you need a component in your Go code. The component will just call

06:06.040 --> 06:15.000
the standard, the test script dot run, which contains at least one piece of information,

06:15.000 --> 06:23.720
meaning in which directory you find the scripts. I say scripts plural because in that directory,

06:23.720 --> 06:33.240
you can have one or a thousand scripts that do different things to your program.

06:35.880 --> 06:44.760
Let's modify the first script a little bit. Instead of expecting hello world with standout,

06:44.760 --> 06:55.560
we expect h. Then you have this strange thing that is a regular expression. If you know regular

06:55.560 --> 07:03.800
expression, what we are saying here is I just want two words, one that starts with h and one

07:03.800 --> 07:13.480
that starts with w. Like before, I want the standard error to be nil. This standard error with a dot

07:14.120 --> 07:22.360
suggests that what we are expecting here is not a dumb piece of text but a regular expression.

07:24.200 --> 07:31.560
You can use a dumb piece of text if it suits you, but you can have much more powerful type of

07:31.560 --> 07:40.120
information. For example, you can use several statements to describe better what you expect

07:40.120 --> 07:46.280
from the output of the program. In this case, instead of putting everything in one line,

07:46.280 --> 07:52.760
I put that in two lines. This is often useful if you want to make your test more readable

07:53.320 --> 07:56.600
to express exactly what you are expecting.

07:59.640 --> 08:08.920
More important, the test script environment includes one thing that is called text par.

08:10.200 --> 08:18.040
Text par is a very simple way of encoding files. To encode files, you just put the name of the

08:18.040 --> 08:25.400
file between double dashes and then you put the content of the file there. The file will be

08:25.400 --> 08:33.400
magically created in the environment where the test is executed. The thing that happens there

08:33.400 --> 08:45.880
is that the script will use a different temporary directory to each script. Every script can run

08:45.880 --> 08:56.840
in parallel and it will be more or less isolated from the rest. This data.txt will exist in the

08:56.840 --> 09:00.680
temporary directory created for this script only.

09:03.880 --> 09:10.680
You have some built-in commands that you can use directly to do your tests.

09:11.480 --> 09:17.400
Exactly what we have seen already. Then standard out and standard error, it will

09:22.200 --> 09:29.080
check what happens after you have run your command. A standard input will

09:30.360 --> 09:36.760
create the input for the next command. Then there is the command exists, the checks that the file

09:36.760 --> 09:44.280
exists and stop and skip will interrupt the test. If you put the exclamation point before

09:45.000 --> 09:50.280
the command, it will negate the command. Meaning that you expect that command to fail.

09:53.960 --> 10:01.320
Other commands are compare and compare with environment and then you have n that will set

10:02.280 --> 10:08.520
variables and this can be useful. Then you have something that are also available in shell scripts

10:08.520 --> 10:20.200
like cat, cd, cp, check, change mode and make directory move and remove that works like in a shell.

10:23.240 --> 10:29.080
Then you have conditions. Conditions is like a command but is within square brackets

10:29.880 --> 10:36.120
and you are telling the program that you expect something to happen. For example,

10:37.240 --> 10:44.040
exec file name, you are saying I want to make sure that this program is in the path.

10:45.320 --> 10:52.920
Unix says this will only be true if you are running in a Unix system.

10:53.880 --> 11:01.160
And after that condition, you put a command that will run if the condition is true.

11:02.280 --> 11:07.480
And you can check other things like if you have a network, if you are running a specific

11:07.480 --> 11:16.200
version of Go and so on. There is a specific environment, some specific environment variables

11:16.200 --> 11:25.560
that you have work is where you are running the test in practical. The home doesn't exist but you

11:25.560 --> 11:39.240
can set it if you want. And then there is a temp directory that it created for each script but

11:39.240 --> 11:42.680
you can change it if you need something different.

11:47.000 --> 11:57.800
So if you run the test with verbosity, you will get a lot of information that tells you

11:58.520 --> 12:05.720
what is the environment where you are running and what is everything that is executed. If you

12:05.720 --> 12:14.520
don't put the verbose, the test is silent, it will just succeed silently. You will see some

12:16.200 --> 12:23.800
output only in case the test fails. Let's see some more examples with command,

12:23.800 --> 12:32.200
second condition. So the first line says if it's not Unix, skip it. The second line says if it's

12:32.200 --> 12:48.040
Linux, say exec, good choice. Exec, sec means if the exec doesn't exist, then say the command echo,

12:48.040 --> 12:50.680
the command sec was found and so on.

12:51.480 --> 13:03.000
Remember I mentioned something about compiling the executable and one thing that the test script

13:03.000 --> 13:12.120
can do for you is having a transparent executable. How does it work? Let's say I have this word count

13:12.840 --> 13:23.720
command that I have created in go and I want to test it. So I run exec word count and this command

13:23.720 --> 13:33.160
may fail or may succeed whether word count exists or not. So if word count is in the path, it will

13:33.160 --> 13:41.640
succeed. If it's not, it will fail. But we want to make sure that it always succeeds so we need to take

13:42.360 --> 13:49.000
to tell test script this word count not only I want to exist but I want to be the one that I have

13:49.000 --> 13:59.240
created for which I have the code and to be fresh, not stale. How do we do that? In the test we use

13:59.240 --> 14:05.000
the test main in case you don't remember the test main is something that you put in your test code

14:05.800 --> 14:14.200
and runs before any test function that you may have in that directory, in that package.

14:15.080 --> 14:27.960
So the test main contains a call to test script dot run main which has a map of functions that you

14:27.960 --> 14:37.960
can associate with a name. In this case we have a name that is word count and we have

14:39.240 --> 14:49.080
command run main that returns one integer. In the main code you will have the main that

14:49.080 --> 14:59.880
doesn't run directly the code but will call run main and it will exit with the integer that the

14:59.880 --> 15:13.400
run main returns. So what happens here is that your word count that is in the script is in reality

15:13.400 --> 15:22.120
a call to this function and the funny thing is that there is no separate executable. If you remember

15:22.680 --> 15:33.640
go is a compiled language so whenever you run a test nothing is running like in Python,

15:33.640 --> 15:41.720
it's not interpreted. There is a compilation and the compilation happens in a hidden place

15:42.600 --> 15:52.920
and you will have a piece of code that has been compiled that is a binary and that

15:52.920 --> 16:03.080
binary will be available for your test and the good thing is that there is no additional

16:03.720 --> 16:09.480
binary is the same binary that is used for the test. I'm going to show you an example later.

16:10.440 --> 16:16.600
So let's see something more. I said before that we have built in commands but we may want to have

16:16.600 --> 16:24.600
something more profound like custom commands. So for example I want a command that will sleep

16:24.600 --> 16:33.240
for let's say three seconds and this command is not available because it's not one of the

16:33.960 --> 16:42.280
built in commands but I can build it. So I also can have a command that says I want to check all

16:42.280 --> 16:49.480
the files in a directory and I want all these files to exist. So I want to check files that has

16:49.480 --> 16:57.720
first argument the name of the directory and the rest of the arguments are the file names.

16:58.680 --> 17:13.000
How do I do this? When I run a script run I can have a call an indication of a map of functions

17:13.800 --> 17:21.720
that will produce these custom commands. So the custom commands are a map of functions and each

17:21.800 --> 17:29.960
function has a test script object a negation in case I put a bang there and a list of string

17:29.960 --> 17:39.320
arguments. If the command succeed I do nothing if the command doesn't succeed I call test script

17:39.320 --> 17:49.960
dot fatal and I fail. So for example this is how implement the custom commands in my word count.

17:50.600 --> 17:59.080
I call check files and I call sleep for and if we look at the implementation of each one you see

17:59.080 --> 18:07.800
that the sleep for is a function that accepts a test script a negation and a list of arguments

18:08.440 --> 18:14.520
and it takes that argument to say to determine how many seconds I want to sleep for and then

18:14.600 --> 18:22.680
it calls time sleep. If the first argument was not a number it will fail and the command will

18:23.560 --> 18:34.520
not succeed. A similar thing I do for check files so the first argument will be the directory

18:34.520 --> 18:41.800
and then I will check that the files exist for each one of the of the arguments.

18:44.600 --> 18:50.520
A similar thing I can do for custom conditions so in addition to the conditions that we have

18:50.520 --> 18:57.880
I can implement conditions that suit my environment better for example I may want a condition that

18:57.880 --> 19:09.880
says the version of this particular program must be at least 0.2 and how do I do that I cannot do

19:09.880 --> 19:22.280
this with the the building syntax of test script so I can implement a custom condition.

19:23.800 --> 19:31.320
To do a custom condition is is similar to what we do for the custom commands. I have a function

19:31.880 --> 19:41.320
that function receives one string and will parse that string to determine what we do with that

19:41.320 --> 19:51.400
condition. In addition to that test script allows us to pass arguments that are variable

19:51.400 --> 20:03.240
depending on the environment. So for example I want to pass the current version to the test

20:03.240 --> 20:14.280
or I want to pass the home directory to the version and I can do that with a set environment

20:14.280 --> 20:23.960
function. So back to the custom conditions we receive a string and return a boolean and an error.

20:25.720 --> 20:32.600
What do we do inside that function we parse the string and the string could be a simple

20:32.600 --> 20:39.480
condition or it could be a condition with some arguments that are that we need to parse inside

20:40.440 --> 20:51.640
and see if the the condition is true. In this case we have a version is at least and you see I

20:51.640 --> 21:02.520
have created a condition a function that will check that with the elements that are parsed

21:02.520 --> 21:10.360
just in the first line of the of the function. So I assume that the function the the arguments are

21:10.360 --> 21:18.280
separated by a column and I use them. For example this version is at last we'll check that we have

21:18.280 --> 21:26.440
at least two arguments the first argument will be the version and the second argument will be the

21:26.440 --> 21:39.400
compared version. In the same way I can have this condition exist within seconds that checks that a

21:39.400 --> 21:50.760
file exists at least after at maximum a number of seconds that I wait. This is useful for example

21:50.760 --> 21:57.240
when I test in a database system that is supposed to create something but it doesn't create it

21:57.240 --> 22:07.000
instantly. So I say I want to to see this log file at maximum 10 seconds after the database starts

22:07.000 --> 22:17.560
and if not I get an error. So I'm going to show you a quick demo of something that happens when we run

22:20.760 --> 22:29.560
test script.

22:29.560 --> 22:56.360
So if I run go help test flags

22:59.800 --> 23:10.360
sorry

23:12.120 --> 23:24.360
I get a bunch of options and these are used always by the test. Now if I run

23:25.000 --> 23:35.640
word count minus h this is the real executable that I built with go and I you see I have these

23:36.920 --> 23:47.160
options that are just the options of the of the program but if I run something a little bit different

23:47.640 --> 24:03.400
so let's see a test that I have inside here where I running word count minus h like I did on the

24:03.400 --> 24:14.360
command line and you see I have here the options that are made by the executable but in addition to

24:14.360 --> 24:20.760
that I have also the option that belong to the test. This to show you that what we are running here

24:20.760 --> 24:29.880
is an executable but is the executable that go builds for the test itself and the side effect is

24:29.880 --> 24:44.920
that it contains the the command line options that belong to the test itself. Now back to the

24:50.360 --> 24:56.680
to the presentation what we have learned today is that using test script you can simplify

24:57.560 --> 25:06.840
the testing of any command line program and programs that manipulate tests are

25:08.600 --> 25:16.520
extremely suitable for this kind of testing because test script was created for the go tools

25:16.520 --> 25:22.680
which manipulate tests. You don't need to have a separate executable because the test script

25:23.320 --> 25:31.080
environment will create one for you and you can build the commands and conditions if the

25:31.080 --> 25:42.680
built-in ones are not suitable. If you want to see the slides and if you want to see a full example

25:42.680 --> 25:54.840
of how to use test script to test a common command that I was created with go you can go to

25:54.840 --> 26:05.960
github.com data charmer word count and there is the code for this word count and all the example

26:06.040 --> 26:14.680
that I have shown here and a lot more that are testing the word count in most the conditions

26:14.680 --> 26:26.680
that you may have. So you can see how to test this kind of program in reality. Well in reality

26:28.680 --> 26:35.560
I can have a lot more than that but it will be too too long to show. So this is the beginning of

26:36.280 --> 26:45.240
a project that I have to to illustrate all the characteristics of test script using code

26:45.960 --> 26:56.200
and the first step is to show a simple command line program and all the tests that are needed.

26:56.680 --> 27:12.040
Here you will see also more that you will see in the in that on github all the resources that

27:12.040 --> 27:21.080
you can use to learn more and if you want to learn more right now you can ask me outside

27:21.080 --> 27:30.360
and I may show you some more examples. Do we have time for questions? Three minutes. Any questions?

27:33.800 --> 27:34.040
Yes.

27:34.520 --> 27:41.480
When you still want to do unit tests like is it for CLI to know it for like not click input or would

27:41.480 --> 27:48.680
you always create custom commands for that? You can use so the question was whether I can use

27:49.800 --> 27:57.640
test script for unit tests. So you can use test script for mostly anything. I use it for unit test

27:57.640 --> 28:07.320
and I use it for integration test. For integration test I just put some logic before the test to

28:07.320 --> 28:17.800
create the environment and so it will run a little bit slower but mostly it will I mean doing unit

28:17.800 --> 28:25.240
tests is the easiest thing in the world. So if you if you look at the at the go code most of the unit

28:25.240 --> 28:33.400
tests for the go tool itself are run with test script but also the integration test can be run in that.

28:37.160 --> 28:37.960
More questions?

28:41.640 --> 28:48.440
Okay thanks a lot.

