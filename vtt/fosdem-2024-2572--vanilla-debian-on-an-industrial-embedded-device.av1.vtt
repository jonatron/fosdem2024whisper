WEBVTT

00:00.000 --> 00:26.000
Hello, everyone. Can you hear me? Hello, hello. So, I guess we can start. Is it working?

00:26.000 --> 00:29.000
Hello, hello.

00:29.000 --> 00:34.000
Quiet please. We're about to start the next presentation, guys.

00:34.000 --> 00:50.000
Hello, again. So, welcome everybody. Can you hear me? Can you hear me? Okay, great. Hello. So, I am Francesco.

00:50.000 --> 01:01.000
I'm here to talk about installing the IBM on an industrial embedded device. What I mean with an industrial embedded device, let's say, not a consumer device.

01:01.000 --> 01:14.000
So, it's a device that you might find in industrial automation, building automation, or an agricultural machine, not a baby PI, okay?

01:14.000 --> 01:25.000
And I am an embedded Linux engineer. I'm working with Uboot Linux and Open Embedded and using Debian since a very long time.

01:25.000 --> 01:34.000
And this is my distribution of choice, but I'm not working with Debian lately.

01:34.000 --> 01:42.000
So, what we will cover today. Why this started? I had some hardware available. I mean, that's because it's my job.

01:42.000 --> 01:52.000
Something like that, okay? That I normally work with this with Open Embedded. And I was wondering, why can't I just install Debian on it, okay?

01:52.000 --> 02:01.000
If we're supported by the upstream Linux kernel, everything is in place. What is preventing me to just install it, okay?

02:01.000 --> 02:10.000
And this is where we all started. And this is a little bit of talk, which challenges I had and I was able to get there.

02:10.000 --> 02:17.000
We will mainly talk about ARM and ARM64 devices. We will focus on the Uboot-Booter order.

02:17.000 --> 02:24.000
And the focus really here is about installing vanilla Debian. So, there are a lot of ways you can install Debian.

02:24.000 --> 02:36.000
Debian is running everywhere, not invented by myself. The focus here is really about doing just following the instruction and getting it done.

02:36.000 --> 02:46.000
So, just to set a little bit of the stage, a little bit of overview of an embedded system, but also any system boot today.

02:46.000 --> 02:53.000
After the system on chip, the CPU gets out of the system, they are going to get configured in some way.

02:53.000 --> 03:01.000
This part can be really, really complicated. And at some point, the firmware needs to load the operating system.

03:01.000 --> 03:07.000
What it does, it needs to figure out where is the kernel. It needs to figure out, in our case, where is the device tree.

03:07.000 --> 03:14.000
And put everything in memory prepared and then jump into the kernel entry point.

03:14.000 --> 03:20.000
We will really focus on this step here about preparing the binaries and jumping into the kernel.

03:20.000 --> 03:25.000
This is our focus for this talk.

03:25.000 --> 03:33.000
Something that is important to mention and will make our life easier is where is the firmware stored in Flash.

03:33.000 --> 03:41.000
Traditionally, on your PC, you have an SPI in AirFlash. That is where your UFI is stored and this is completely out of band.

03:41.000 --> 03:45.000
This is not where you are going to install your operating system.

03:45.000 --> 03:53.000
On embedded device, it depends. Sometimes for curse saving, you have only one device in which you store everything, the firmware and the operating system.

03:53.000 --> 03:55.000
Sometimes they are separated.

03:55.000 --> 03:59.000
The order that I am going to consider today is using EMMC.

03:59.000 --> 04:06.000
EMMC have very nice features that allows to do hardware partitioning.

04:06.000 --> 04:11.000
Normally, they have a dedicated partition for the boot firmware.

04:11.000 --> 04:19.000
This enables to not have to warn them about overwriting my firmware while doing the installation and operating system.

04:19.000 --> 04:24.000
This is not possible, for example, using an SD card like you would do with a Raspberry Pi.

04:24.000 --> 04:28.000
Raspberry Pi is booting from an SD card and then you cannot really do that.

04:28.000 --> 04:32.000
This makes the stuff more complicated.

04:36.000 --> 04:42.000
Good. In our case, our firmware is, as I said, U-boot.

04:42.000 --> 04:48.000
U-boot is a platform firmware. It supports a lot of architecture.

04:48.000 --> 04:57.000
In the end, it configures the hardware, as I said before, and then it is able to load the Linux kernel.

04:57.000 --> 05:05.000
Traditionally, let's say the past millennium, this was very coupled with the operating system that was loaded.

05:05.000 --> 05:09.000
Some time, a few years ago, probably 10, 8, I don't know exactly,

05:09.000 --> 05:20.000
there was introduced a new feature called DistraBoot that is trying to solve this task of loading the operating system generic.

05:20.000 --> 05:28.000
How does it work? U-boot is scriptable with shell script sort of and as environment variable.

05:28.000 --> 05:36.000
DistraBoot is implementing with script a generic way to search for a bootable partition

05:36.000 --> 05:41.000
and then to search for a way to boot the operating system that it found.

05:41.000 --> 05:49.000
In short, you tell the board which are your boot devices and then you just include this header that I mentioned earlier

05:49.000 --> 05:52.000
and that's it. It's very easy to integrate.

05:52.000 --> 05:57.000
What it searches for normally is a boot script with a fixed file name,

05:57.000 --> 06:03.000
searching either the first partition or the first active partition and executive content.

06:03.000 --> 06:11.000
It can also parse an x-tlinux.com file that describes how to properly load the OS.

06:11.000 --> 06:16.000
We will focus on the boot script that is more flexible.

06:16.000 --> 06:21.000
It allows really to do everything because it's really code.

06:21.000 --> 06:26.000
The reason we focus on that is that this is what is supported by default on Libyan.

06:26.000 --> 06:33.000
X-tlinux is working in Libyan but if not out of the box experience you get from the Libyan installer.

06:33.000 --> 06:40.000
The boot script normally what it will do in the end will be loading the kernel from some storage device,

06:40.000 --> 06:46.000
loading the device tree, loading your init addy and then we'll just jump into your distribution.

06:47.000 --> 06:54.000
Cool. Let's move on the operating system side.

06:54.000 --> 07:07.000
The Libyan has a package that is called the FlashKernel and it's really a glue package between the operating system and Uboot.

07:07.000 --> 07:14.000
I mean, FlashKernel is a little bit more generic but it's really able to integrate directly with Uboot,

07:14.000 --> 07:17.000
generating the boot script we just talked about.

07:17.000 --> 07:22.000
It's integrated into the Libyan installer, into the ARM one,

07:22.000 --> 07:28.000
and integrates with the kernel packages out of the box using hook.

07:28.000 --> 07:35.000
So it's supposedly to just put everything together.

07:35.000 --> 07:39.000
Given that in theory it should be good.

07:39.000 --> 07:47.000
We have Uboot, we have this package, so what I did was I tried to go through the installation.

07:47.000 --> 07:52.000
I took one model, for instance exactly the one that I just showed you before,

07:52.000 --> 07:57.000
probably the Libyan is still installed there, and I just followed the instruction, okay, as easy as that.

07:57.000 --> 08:03.000
I decided to do a net installation just because it was at the moment the most convenient for me,

08:03.000 --> 08:08.000
but again whatever is copied pasted here is just what you can find on the manual.

08:08.000 --> 08:11.000
And the result, it was not working.

08:11.000 --> 08:13.000
Why?

08:13.000 --> 08:20.000
What I figured out is that FlashKernel needs to know about the actual hardware

08:20.000 --> 08:23.000
to be able to properly generate a boot script.

08:23.000 --> 08:28.000
This is why this is required.

08:28.000 --> 08:34.000
This is required because it generates a boot script that are really matching the exact hardware that we are running on.

08:34.000 --> 08:39.000
So you really need to tell the exact device tree file that will be loaded in the boot script,

08:39.000 --> 08:42.000
and this is going to be part of the boot script.

08:42.000 --> 08:48.000
It's also possible to have custom boot scripts and have a sort of additional customization,

08:48.000 --> 08:53.000
but if your board is properly supported in Uboot, there is really not much to do

08:53.000 --> 08:57.000
apart from telling you use this flavor over the kernel and use this device tree.

08:57.000 --> 09:05.000
I mean, for instance, in Debian ARM port, it's supporting two flavors for the kernel,

09:05.000 --> 09:13.000
ARM-HF and ARM-HF-LPAE, and you need to tell which kernel flower you want to use.

09:13.000 --> 09:18.000
What I did was just opening a merge request on the Debian GitLab instance,

09:18.000 --> 09:22.000
SalsaDebian.org, and I mean, I am not a Debian developer,

09:22.000 --> 09:28.000
nor a maintainer, I'm just a user, but my merge request was just a reviewer and a sceptre.

09:28.000 --> 09:32.000
Now, for instance, it's part of Debian Bookwork.

09:32.000 --> 09:37.000
So it just opens for everybody to contact boot.

09:37.000 --> 09:42.000
Cool. Then I wanted to try something else.

09:42.000 --> 09:50.000
Distribute, at the moment, is considered a deprecated for a couple of reasons.

09:50.000 --> 09:56.000
One of the reasons is that being implemented with shared script is a little bit cumbersome.

09:56.000 --> 09:59.000
It's very difficult to understand how it works.

09:59.000 --> 10:06.000
There are scripts that are set in global variables, and then other scripts will rely on the previous global variables that are set.

10:06.000 --> 10:10.000
I mean, if you look at this for the first time, we will just get lost.

10:10.000 --> 10:21.000
There was also a need, a long-term plan for Uboot to completely move to a Kconfig based system,

10:21.000 --> 10:27.000
configuration system, and for that, there was a need to remove some include file,

10:27.000 --> 10:33.000
as we saw before, Distribute is configuring through a configuration include header.

10:33.000 --> 10:39.000
That's the main reason standard boot was done.

10:39.000 --> 10:45.000
I didn't have any board with this enabled myself, so what I did was just enable this on the board.

10:45.000 --> 10:57.000
I mean, it's trivial. This is just defining the boot targets that are just equivalents to what we discussed a few minutes ago regarding Distribute,

10:57.000 --> 11:00.000
and then enabling a few configuration options.

11:00.000 --> 11:07.000
From the integration to the distribution is pretty much the same.

11:07.000 --> 11:11.000
Standard boot is more generic. It supports also UFI.

11:11.000 --> 11:21.000
I mean, it's more, but in the end, it integrates the same way with the Flash kernel package, and it's able to execute the boot script.

11:21.000 --> 11:26.000
The documentation is linked here, and I mean, it's way more than what I showed here in this.

11:26.000 --> 11:28.000
It was a Flash USB Flash drive.

11:28.000 --> 11:36.000
And with that, I was just running that bootstrap from my PC directly on the target using USB.

11:36.000 --> 11:46.000
And there are a few queers to take into account because the architecture that my laptop is running is x86, while the target was an ARM.

11:46.000 --> 11:54.000
And during the second step of the bootstrap, you are going to execute target binaries.

11:54.000 --> 12:03.000
And this was really easy to be done also because as of today, using QAMU user static package

12:03.000 --> 12:14.000
and using the bin format MISC support in the kernel, it's really possible to run cross-platform-byte-arm binaries on an x86 in a transparent way.

12:14.000 --> 12:21.000
And all of that is just integrated into that bootstrap, and it's just a matter of installing this package.

12:21.000 --> 12:25.000
So I went through my depth bootstrap installation completed.

12:25.000 --> 12:29.000
I did all the required steps, and then it was not working.

12:30.000 --> 12:35.000
What was missing this time apart, of course, this board also was not supported.

12:35.000 --> 12:37.000
Today, this specific word is.

12:37.000 --> 12:42.000
What was missing this time was that the Debian kernel was not supporting the specific architecture.

12:42.000 --> 12:50.000
Again, the Debian kernel development is done on GitLab, on this GitLab project.

12:50.000 --> 13:01.000
And they are just open to taking merge requests, and it was really probably a free-line change to enable this architecture in a decay config.

13:01.000 --> 13:06.000
This is merged at the moment, and with that, finally, it was all working.

13:10.000 --> 13:11.000
Good.

13:11.000 --> 13:12.000
Last.

13:12.000 --> 13:20.000
Till now, I was playing around with old ARM 32-bit architecture, and I wanted to try something more modern and faster.

13:20.000 --> 13:28.000
I was getting older and older with the old ARM processor, so I wanted to try with an ARM 64 system.

13:28.000 --> 13:36.000
What I realized is that the Debian-y standard for ARM 64 just expected to use UFI.

13:36.000 --> 13:40.000
I believe that it would be possible to avoid it.

13:40.000 --> 13:45.000
It's not like it's a master, but if you just take the standard path, this is what is expected.

13:49.000 --> 13:53.000
And they said, okay, you would support a subset of UFI.

13:53.000 --> 13:58.000
This is targeting this specification here that I think of here.

13:59.000 --> 14:01.000
It has a few limitations.

14:01.000 --> 14:05.000
It's not a full-blown UFI implementation.

14:06.000 --> 14:12.000
One of the main limitations at the moment is that it does not support this set of variable up runtime.

14:12.000 --> 14:16.000
We will see in a minute why this is relevant.

14:17.000 --> 14:23.000
In a very simplified way, I hope that there is no expert on UFI here,

14:23.000 --> 14:32.000
what UBoot is doing is searching on a GPT partitioned device for a specific partition called ESP.

14:32.000 --> 14:36.000
It has a specific UID.

14:36.000 --> 14:47.000
And into that, it loads a binary in a UFI format that is more or less a variation of the Windows portable executable.

14:47.000 --> 14:49.000
And it just executed.

14:51.000 --> 14:56.000
Anyway, moving on, UFI was not enabled in the board that I have available,

14:56.000 --> 14:59.000
but there are really no hardware dependency on this functionality.

14:59.000 --> 15:03.000
It's pure software and it was just a matter of enabling it.

15:03.000 --> 15:11.000
You can see it's a lot of configuration options, but there is really just a generic code, nothing hardware specific.

15:17.000 --> 15:18.000
Good.

15:18.000 --> 15:26.000
So I tried again to install Debian and this time, let's say it was working more or less smoothly.

15:26.000 --> 15:33.000
It was possible to get to the end without having to do any kind of customization.

15:33.000 --> 15:48.000
What was a little bit scary was the fact that the installer was erroring out during the while making the system bootable.

15:48.000 --> 15:58.000
What it complained about was exactly about this set runtime variable that I just mentioned before.

16:00.000 --> 16:04.000
That was not working and the message is somehow scary.

16:06.000 --> 16:07.000
How this is working?

16:07.000 --> 16:09.000
UFI is configurable.

16:09.000 --> 16:17.000
There are variables and the operating system is able with setting the boot order and boot 00, boot 001 variable.

16:18.000 --> 16:25.000
To specify which device and really impractice the file name into the ESP partition.

16:25.000 --> 16:27.000
This is really what this is about.

16:28.000 --> 16:33.000
Normally, any modern operating system will install with a specific file.

16:33.000 --> 16:38.000
I believe that for Debian might be something like Debian.EFI, I'm not sure.

16:38.000 --> 16:42.000
However, this is not possible at the moment because of this limitation in Uboot.

16:43.000 --> 16:47.000
Debian is able nevertheless to install with a fallback location.

16:47.000 --> 16:49.000
That is what is used for removable device.

16:49.000 --> 16:56.000
If you think about USB flash device or your CD-ROM, there is a fixed name that is sort of fallback.

16:56.000 --> 17:01.000
Debian is able to install there and with that, I got a bootable system.

17:02.000 --> 17:10.000
I had of course a few small issues about the fact that some functionality were not enabled in the kernel,

17:10.000 --> 17:13.000
but that was straightforward to solve.

17:14.000 --> 17:20.000
What I was wondering here at this moment is which device tree was being used.

17:20.000 --> 17:25.000
Because device tree is really the hardware description of the board.

17:25.000 --> 17:29.000
This is critical for the US to properly use the hardware.

17:29.000 --> 17:38.000
While using this standard boot, this is really well defined and the flash kernel package is really telling you which device tree is using.

17:38.000 --> 17:41.000
With UFI, this is really not visible.

17:41.000 --> 17:45.000
So I started digging a little bit on that.

17:45.000 --> 17:52.000
What is used by default is the internal device tree from Uboot.

17:52.000 --> 18:02.000
Uboot is also using the device tree for its configuration and it is just able to pass it down to the operating system.

18:10.000 --> 18:11.000
Here we are.

18:11.000 --> 18:14.000
So what's next?

18:14.000 --> 18:24.000
As you saw, as of today, with a very small effort, it is possible to run a pure Debian experience on an embedded target.

18:24.000 --> 18:30.000
Something that I assumed here is that you have upstream support for your device.

18:30.000 --> 18:36.000
This was the case for the hardware that I have available, but if you take a random board, this might not be the case.

18:36.000 --> 18:42.000
Without that, Debian is not going to take your 1000 patches just to enable one board.

18:42.000 --> 18:45.000
Okay, this doesn't exist.

18:45.000 --> 18:47.000
Second, the integration.

18:47.000 --> 18:52.000
What is envisioned is that the device tree is really coming from the firmware in the hardware description.

18:52.000 --> 19:04.000
In practice, if you are familiar on how the development of the device tree works, as of now, are stored into the Git repository of the kernel,

19:04.000 --> 19:06.000
it's really an incremental approach.

19:06.000 --> 19:12.000
You would really like to have to update the firmware when you update the device tree.

19:12.000 --> 19:16.000
This is just the reality that we have today.

19:16.000 --> 19:25.000
So it would be very nice to be able to take the device tree from the root file system.

19:25.000 --> 19:27.000
However, it's complicated.

19:27.000 --> 19:31.000
When you boot with UFI, normally you have an intermediate boot loader.

19:31.000 --> 19:33.000
You don't jump directly in the kernel.

19:33.000 --> 19:41.000
So if you boot through grab, grab is able to load the device tree, but the loading on device tree is disabled once the boot is enabled, for example.

19:41.000 --> 19:51.000
And the other issue is that normally the device tree is going through some fix up on the...

19:51.000 --> 19:54.000
Why the boot firmware is executing.

19:54.000 --> 19:56.000
And if we...

19:56.000 --> 20:00.000
The grab is loading, if this fix up are not obvious to do,

20:00.000 --> 20:05.000
there is an implementation that is able to ask Uboot to do this fix up afterwards,

20:05.000 --> 20:13.000
but all of that is available as a patch, is integrated in Ubuntu and not in Debian and not in Mainline.

20:13.000 --> 20:21.000
And then, I mean, we can make this even more complicated if we think about device tree overlays that are binary patches,

20:21.000 --> 20:25.000
and they are normally used for non-discoveryable buses that are common.

20:25.000 --> 20:32.000
Think about an embedded device, I2C, SPI, or an LBDS display.

20:32.000 --> 20:40.000
And that's it. Opening for Q&A.

20:40.000 --> 21:03.000
So, any questions?

21:03.000 --> 21:10.000
Thanks for the nice talk. Just want to ask you, are you aware of the ISI integration tool for Debian?

21:10.000 --> 21:16.000
ISAR. So we are doing heavily Debian on embedded devices, on industrial devices with that.

21:16.000 --> 21:21.000
And it also addresses the topic of not upstream firmware.

21:21.000 --> 21:25.000
I mean, I'm not aware of this. I mean, I will have a look.

21:25.000 --> 21:31.000
I was really focusing here on a pristine and pure Debian experience.

21:31.000 --> 21:38.000
There are tons of way in which you can install Debian, tons of way you can have a custom kernel.

21:38.000 --> 21:41.000
There are really a lot of possibilities to use.

21:41.000 --> 21:46.000
I mean, I could have built probably three slides only on the options that are available.

21:46.000 --> 21:48.000
I was really willing to focus here.

21:48.000 --> 21:52.000
I want to go Debian or follow the instruction and get it done.

21:52.000 --> 22:00.000
This was really my goal here.

22:00.000 --> 22:03.000
Thank you for this presentation.

22:03.000 --> 22:10.000
I just didn't understand when it is booting from UEFI,

22:10.000 --> 22:22.000
it's boot from UEFI, where U-boot is placed, where it is in which partition or in MMC,

22:22.000 --> 22:24.000
or where it is, you said you're...

22:24.000 --> 22:25.000
U-boot.

22:25.000 --> 22:29.000
U-boot, boots from USB, if I understand.

22:29.000 --> 22:34.000
No, I was using USB just for the installation purpose.

22:34.000 --> 22:40.000
So I was just having the board available as it was a USB flash drive for the installation.

22:40.000 --> 22:49.000
After that, U-boot was installed nevertheless together with the UFI implementation on the MMC boot partition.

22:49.000 --> 22:56.000
Okay. This side. Thank you.

22:56.000 --> 23:01.000
Okay. We don't have any time for any more questions, but thank you very much, Francisco.

23:01.000 --> 23:02.000
Brilliant.

23:02.000 --> 23:03.000
Thank you.

