WEBVTT

00:00.000 --> 00:08.080
Okay, so hi, I am Afrayim.

00:08.080 --> 00:14.880
I've been working on GNU Geeks for about eight years now.

00:14.880 --> 00:19.680
So supporting the PSABI's with Geeks.

00:19.680 --> 00:27.680
So the PSABI's are the, say, hey, it's been 20-ish years since we first got X8664.

00:28.360 --> 00:32.480
It would be nice if we compiled for something a little newer.

00:32.480 --> 00:40.880
So the PSABI's are a nice way to go and, let's see if I can see both screens, to go and see,

00:40.880 --> 00:49.440
to support both the older machines and the newer machines at the same time.

00:49.440 --> 00:57.560
So this is the output that I got from my computer running dash dash help on LD.so.

00:57.600 --> 01:08.240
As you can see, my machine supports X8664 v3 and v2 and of course the original, just regular X8664.

01:08.240 --> 01:15.280
So it's, you know, how we actually go and figure out what is supported and what isn't.

01:15.280 --> 01:22.520
So something that I wasn't able to find looking through everything is, where are these directories?

01:22.560 --> 01:32.120
I know the libraries go and slash lib and not really clear where the alternate ones go.

01:32.120 --> 01:34.760
So I did what any normal person would do.

01:34.760 --> 01:42.400
I went to my local checkout of G-Lib C and I searched for G-Lib C hardware caps.

01:42.400 --> 01:52.480
So from the test suite, we got dollar L, G-Lib C hardware caps, our little string and our library.

01:53.440 --> 02:00.120
And we also got that supported on three architectures.

02:00.120 --> 02:07.800
So we can see that X8664 isn't the only one that is looking for faster libraries.

02:07.800 --> 02:21.800
So that gives us on X8664 these four paths where LD.so will actually search for libraries that are supported, more or less.

02:21.800 --> 02:26.440
So we have our slash lib and then the two that are after it.

02:26.440 --> 02:33.240
For the sake of completeness, we also have for PowerPC64 little endian.

02:33.240 --> 02:39.800
We have power nine and power 10 and for S390, we have these other ones.

02:39.800 --> 02:46.800
And I've never seen an S390 machine. I just assume that they exist.

02:46.800 --> 02:57.800
So that works well on a regular distribution where all of the libraries go into slash lib or slash user slash lib.

02:57.800 --> 03:04.800
But in Geeks, everything has its own path that everything gets installed into.

03:04.800 --> 03:09.800
And fancy word at the top there is directed acyclic graph.

03:09.800 --> 03:16.800
So individually I know what all of those words mean, but in general it's like the arrows have.

03:16.800 --> 03:23.800
I'm trying to remember if this one goes up or goes down depending on which part of the stack you're working on.

03:23.800 --> 03:26.800
Sometimes we end up with arrows in different directions.

03:28.800 --> 03:30.800
So I'm assuming we're going down on this one.

03:30.800 --> 03:40.800
So for XPAT, it depends directly on get text minimal, which is different than our regular get text, which would have other inputs in it.

03:40.800 --> 03:50.800
And just like for this case, so the acyclic part is what it sounds like.

03:50.800 --> 03:54.800
There's no circles. There's no repetitions.

03:54.800 --> 04:02.800
Once you build the package, that's it. It goes into its designated folder and nothing else gets installed into there.

04:02.800 --> 04:13.800
So before when we had our library outputs, Geeks doesn't have a slash lib folder and it doesn't have these other folders either.

04:13.800 --> 04:22.800
So we still need to convince Geolib C to actually look for all of these places so that we can find the libraries.

04:26.800 --> 04:28.800
So it's before that one.

04:29.800 --> 04:40.800
The other thing is that reading through the bits, it turns out that we're not just looking for, not just checking all of these directories.

04:40.800 --> 04:43.800
We're looking specifically in slash lib.

04:43.800 --> 04:48.800
And then if your hardware supports it, we will also check the other library locations.

04:49.800 --> 05:01.800
So using, you know, to take your favorite library, Readline, you'd have lib slash lib slash readline dot s o.

05:01.800 --> 05:05.800
And you could have it also in your Geolib C hardware caps directory.

05:05.800 --> 05:15.800
But with Geeks, the first one is going to be in its full path slash gnu slash store slash big hash.

05:15.800 --> 05:18.800
And the other ones will be in other paths.

05:18.800 --> 05:28.800
So while you would have libraries in the other paths also, they don't actually end up in the same spot.

05:28.800 --> 05:34.800
And it goes and says, okay, here's my regular Readline library.

05:34.800 --> 05:40.800
I'm going to search for the Geolib C hardware cap along the same path.

05:40.800 --> 05:43.800
It's not going to find anything even though you've already built them.

05:44.800 --> 05:50.800
So question that I guess keeps on coming up when I was looking at this is, is it worth it?

05:50.800 --> 05:55.800
Does this actually make a difference when you're running the programs?

05:55.800 --> 06:05.800
Do you, how much difference do you really get from having a optimized libraries for your computer?

06:05.800 --> 06:10.800
And answer a little bit is, does it matter?

06:10.800 --> 06:12.800
I mean, the options are there.

06:12.800 --> 06:16.800
They wouldn't be there if it wasn't going to do something.

06:16.800 --> 06:20.800
And other part is people want it.

06:20.800 --> 06:21.800
Users want it.

06:22.800 --> 06:26.800
It might make a difference.

06:26.800 --> 06:29.800
So whether or not it matters, we're still doing it.

06:29.800 --> 06:40.800
And to some extent, wonder is it something like the, I always read that as fun roll loops.

06:40.800 --> 06:45.800
Where it's, does unrolling the loops actually matter?

06:45.800 --> 06:48.800
How much benefit are you getting from it?

06:48.800 --> 06:52.800
So, yeah.

06:52.800 --> 06:55.800
So one of the, oh, I got cut off a little bit.

06:55.800 --> 07:03.800
One of the programs that we were experimenting with was the new NCDU written in Zig.

07:03.800 --> 07:10.800
And so up here, I have a just transcribed output from Difascope.

07:10.800 --> 07:14.800
I actually went and compared the two binaries.

07:14.800 --> 07:22.800
Zig does, Zig inherits the optimizations from the underlying LLVM.

07:22.800 --> 07:34.800
And so I compared NCDU built against standard X8664 and one built for X8664 v3, which would run on my desktop.

07:34.800 --> 07:38.800
And other than seeing that more than 99% of the code was the same,

07:38.800 --> 07:47.800
this part was actually the part that had the largest amount of difference in the generated assembly.

07:47.800 --> 07:56.800
And so I don't know if, is it v0 upper is faster than other options here,

07:56.800 --> 08:03.800
but I also noticed that it ends up with the same number of instructions.

08:03.800 --> 08:14.800
So it's, you know, for a lot of this, we really are getting into very minimal benefits in here.

08:14.800 --> 08:18.800
But anyway, like we said, we're doing it anyway. The options are there.

08:18.800 --> 08:21.800
I'm not going to take no for an answer.

08:21.800 --> 08:24.800
Okay, that didn't get cut off at the bottom.

08:24.800 --> 08:31.800
So one of the libraries that we've already looked at and said this one actually benefits is GSL,

08:31.800 --> 08:35.800
which is one of the math libraries.

08:35.800 --> 08:38.800
So what you're looking at here is scheme code.

08:38.800 --> 08:46.800
This is the actual, this inherits from the actual package definition for GSL.

08:46.800 --> 08:51.800
An actual one has, you see this one's missing a version string.

08:51.800 --> 08:54.800
It doesn't have the source location.

08:54.800 --> 08:56.800
It's missing a couple of things where it's just inherited.

08:56.800 --> 09:02.800
But basically package definition defines the name inversion.

09:02.800 --> 09:04.800
It has the source where to get it.

09:04.800 --> 09:06.800
It says what kind of build system to use.

09:06.800 --> 09:13.800
If there are any arguments in the case of GSL, mostly we skip a bunch of tests.

09:13.800 --> 09:20.800
And then some other metadata that goes with it, home page synopsis, description, license.

09:20.800 --> 09:29.800
So for this one, we go and basically say, okay, so we're going to inherit from GSL.

09:29.800 --> 09:35.800
I'm going to change the name so that we append the PSABI to it so we can actually keep them separate.

09:35.800 --> 09:44.800
The make flags, we're going to actually pass to C flags and CXX flags that we're building for the specific PSABI.

09:44.800 --> 09:56.800
We add the, tell it to use the library dir of output is our, is the output.

09:56.800 --> 10:03.800
It's the per package directory where this library will get installed to.

10:03.800 --> 10:11.800
So instead of installing it to output slash lib, we're going to add glibc hardware caps slash PSABI,

10:11.800 --> 10:15.800
which is the directory we saw before.

10:15.800 --> 10:22.800
And then after the installation, we're going to delete a couple of extra bits that we don't need.

10:22.800 --> 10:30.800
We don't need the binary because we're just using the original GSL binary and the headers and include

10:30.800 --> 10:32.800
and anything in the share directory and the package config.

10:32.800 --> 10:35.800
We're just deleting all of that.

10:35.800 --> 10:43.800
And in the properties, we're going to hide it from the CLI so that we people can't just go and install this one on its own.

10:43.800 --> 10:54.800
And we're going to mark it as not tunable because we don't want to say, hey, build this, build this specific library for this specific sub architecture

10:54.800 --> 11:01.800
but actually tune it for my machine because that's not going to help anybody.

11:01.800 --> 11:14.800
So then when we go and we have the actual library similar to before, we go and we say, okay, go ahead and run through everything like normal

11:14.800 --> 11:23.800
using all of the normal package arguments and build arguments and everything.

11:23.800 --> 11:32.800
And then at the end, after install, we're just going to see here copy the actual libraries into their location

11:32.800 --> 11:39.800
because we can't go and say, here's regular GSL and install the other libraries into its folder.

11:39.800 --> 11:45.800
We say we've built a new one and we're going to copy the optimized libraries in.

11:45.800 --> 11:52.800
So then, you know, same thing for PowerPC. I just didn't put it there.

11:52.800 --> 12:00.800
So in the end, this is the regular one. This is the, you know, just a generic one.

12:00.800 --> 12:04.800
I shortened some of the directories so that it would fit.

12:04.800 --> 12:11.800
So we have the top, the full path, the output for GSL.

12:11.800 --> 12:15.800
This was, no, this is the everything together.

12:15.800 --> 12:27.800
We have the full path of the library, of the output for GSL with all of the hardware capability, all the optimized libraries.

12:27.800 --> 12:32.800
You see we have the one set of binaries. We have the headers.

12:32.800 --> 12:37.800
I've collapsed the libder so that doesn't take up all the space.

12:37.800 --> 12:48.800
And then inside the libder, I actually have at the bottom there, we have the libgsl for, you know, just regular.

12:48.800 --> 12:52.800
And then v2, v3, and v4 I closed so that it would all fit.

12:52.800 --> 13:02.800
And we have just the one package config and through all the testing that I had on various machines,

13:02.800 --> 13:11.800
it would go and using this as an input for everything else, it would go and link against the regular libgsl.

13:11.800 --> 13:22.800
And then at runtime, it would go and actually use the optimized library depending on which machine it was running on.

13:22.800 --> 13:29.800
So Geeks being a functional package manager, we end up with functions for things.

13:29.800 --> 13:44.800
So here, some of the bioinformatics programs that I was working on, we have, so here the idea was PGBB, PGGB.

13:44.800 --> 13:50.800
One of the common ways that it was distributed is as a docker image.

13:50.800 --> 14:01.800
So instead of just compiling everything for the, for baseline or for saying, hey, we've made 500 different images based on what your actual machine you're running on,

14:01.800 --> 14:05.800
is we said, okay, we have a list of, in this case, five libraries.

14:05.800 --> 14:12.800
Go ahead and actually replace all of their occurrences in the graph with these ones.

14:12.800 --> 14:18.800
And then when you go to run it, you get all of the benefits of using the faster libraries.

14:19.800 --> 14:24.800
So, you know, just back to the, is it worth it?

14:24.800 --> 14:28.800
So this one I hadn't really planned on getting into so much.

14:28.800 --> 14:32.800
This one was a blog post from last month.

14:32.800 --> 14:43.800
Somebody had gone and rebuilt parts of Arch Linux with, for x8664 v3.

14:43.800 --> 14:51.800
And they have, so yeah, so the claim was that it was 10% performance improvement.

14:51.800 --> 15:06.800
So the other part that's here that, I guess, yeah, not quite cut off is that the rebuilt one on v3 was also built with o3 flag versus the o2 flag that Arch Linux uses.

15:06.800 --> 15:11.800
And then they just went through a couple of programs to see, you know, is it actually faster?

15:11.800 --> 15:15.800
What type of speed benefit can you get?

15:15.800 --> 15:19.800
So negative times are faster, positive times are slower.

15:19.800 --> 15:24.800
So in this case it was, you know, compressing the kernel was faster, decompressing was slower.

15:24.800 --> 15:30.800
Flak was faster in all cases.

15:30.800 --> 15:33.800
Gawk was, you know, toss up.

15:33.800 --> 15:37.800
Gzip was slightly faster, but that might just be o3.

15:37.800 --> 15:39.800
LZ4 was slower.

15:39.800 --> 15:41.800
Python was slower.

15:41.800 --> 15:43.800
R was the same.

15:43.800 --> 15:46.800
Forbus was faster.

15:46.800 --> 15:49.800
And, you know, XZ, basically the same.

15:49.800 --> 15:52.800
Find decompression was faster.

15:52.800 --> 16:02.800
That in general, you're still left with a couple of packages here and there actually benefit from having,

16:02.800 --> 16:05.800
uh, faster libraries.

16:05.800 --> 16:09.800
It's not going to keep people from saying, I want everything to be compiled faster.

16:09.800 --> 16:17.800
I'm going to go back to the fun role loops and, you know, you have to eke out that extra little bit of speed.

16:17.800 --> 16:23.800
But, you know, it's, you know, yes, it's a, you know, from the distro side,

16:23.800 --> 16:28.800
some of it becomes a how much time do I want to spend actually,

16:28.800 --> 16:33.800
I guess maybe not specifically supporting the different options because,

16:33.800 --> 16:36.800
you know, I just send it through and it gets built and it's done,

16:36.800 --> 16:40.800
but how much time do I want to spend building four copies of everything

16:40.800 --> 16:47.800
so that I can mush them all together and, you know, expand the size of the final library?

16:47.800 --> 16:59.800
Um, what did I have over here that I...

16:59.800 --> 17:08.800
No, I thought I had a thing right there.

17:09.800 --> 17:18.800
Uh, so I guess the other part that we had with this was that, you know, this one, you know,

17:18.800 --> 17:23.800
this assumes that, I mean, first of all, this works well for GSL.

17:23.800 --> 17:32.800
Uh, I could go and change it from, you know, GSL HWABI is the name of the function to make it more general

17:32.800 --> 17:39.800
and then start passing it other, you know, pass the name of the actual library to inherit from and all of that.

17:39.800 --> 17:46.800
But, you know, the other part of this is this assumes that passing just C flags and CXX flags

17:46.800 --> 17:54.800
are going to actually go and produce the binary, the optimized files that you're looking for.

17:54.800 --> 17:59.800
And, you know, not always the case.

17:59.800 --> 18:06.800
Sometimes you end up with ones that need extra CXX flags or you need to go and manually add them in anyway

18:06.800 --> 18:11.800
or they're hard-coded and they need to be substituted out.

18:11.800 --> 18:18.800
And, you know, going back to the, do I, you actually want to go and support every single package

18:18.800 --> 18:23.800
becomes a do you want to go through the entire archive of all of the packages

18:23.800 --> 18:29.800
for something that may or may not actually make a difference on all of the libraries?

18:29.800 --> 18:34.800
Oops, that was too far.

18:34.800 --> 18:39.800
So, yes, yeah, are there any questions?

18:39.800 --> 18:46.800
Any comments?

18:46.800 --> 18:51.800
Okay.

18:51.800 --> 18:56.800
Okay.

18:56.800 --> 19:01.800
Okay.

19:01.800 --> 19:07.800
Thanks.

19:07.800 --> 19:11.800
So how far have you gotten in implementing this?

19:11.800 --> 19:15.800
Is it just something you've been experimenting with or something that's actually working?

19:15.800 --> 19:18.800
I've mostly been experimenting with it.

19:18.800 --> 19:25.800
Some of it is, you know, I don't want to actually, don't actually want to build everything multiple times.

19:25.800 --> 19:32.800
But the size increase, that's the part that I thought I had, the size increase on GSL,

19:32.800 --> 19:41.800
it went from, I think it was 5.5 megabytes to about 18 megabytes by adding in basically the four different copies

19:41.800 --> 19:44.800
of all of the libraries.

19:44.800 --> 19:51.800
So it really becomes, you know, say for Vorbis or for Ag or for specific libraries that we know are going to make a difference.

19:51.800 --> 19:53.800
It really makes a difference.

19:53.800 --> 20:00.800
For other ones, you look at it and say, okay, you know, LibxUL runner for Firefox, that's 100 megabytes.

20:00.800 --> 20:03.800
And it's a long build process.

20:03.800 --> 20:08.800
Maybe we won't do that one.

20:08.800 --> 20:15.800
Okay.

20:15.800 --> 20:21.800
You said that there is support for PowerPC, Power9 and Power10.

20:21.800 --> 20:24.800
And what is this older variant?

20:24.800 --> 20:28.800
So PowerMicroVod or Power7?

20:28.800 --> 20:30.800
The...

20:30.800 --> 20:34.800
They are all 64-bit PowerPC variants.

20:34.800 --> 20:43.800
They are all PowerPC, they are all the 64-bit variants from the actual G-Lib C, where was it?

20:43.800 --> 20:51.800
From the actual G-Lib C source code, these are the only directories that are currently...

20:51.800 --> 20:54.800
I think this was accurate as of 2.38.

20:54.800 --> 21:02.800
These are all of the directories that are searched for additional libraries.

21:02.800 --> 21:08.800
So I think Geeks right now targets Power8 as the baseline.

21:08.800 --> 21:17.800
So a backboard would be needed for Power7 and for MicroVod.

21:17.800 --> 21:25.800
You have to get it into G-Lib C to have the...

21:25.800 --> 21:31.800
I mean, I guess if you compiled the distribution for Power7, then you would have support for Power7 there.

21:31.800 --> 21:42.800
But in terms of having the special directories, currently there's no support in G-Lib C, although I suppose it could be added.

21:42.800 --> 21:52.800
I might investigate later if I have hardware or buy hardware, because I'm interested in the PowerPC notebook project.

21:52.800 --> 22:16.800
And they have much more modern hardware compared to anything Apple used, but it's still older than Power8.

22:16.800 --> 22:25.800
I've tried some benchmarks yourself with some of the applications, because what you showed with the microscope,

22:25.800 --> 22:31.800
those were mostly SIMD instructions, which were optimized.

22:31.800 --> 22:45.800
So I think everything which uses those can profit from the knowing that there's like a different kind of vector extension.

22:46.800 --> 22:53.800
I ran a couple of benchmarks. Most of them were inconclusive.

22:53.800 --> 22:59.800
The one that I actually noticed the biggest change in was LZ4.

22:59.800 --> 23:08.800
I actually compiled one for X32 for the 64-bit, X8664 with 32-bit instructions.

23:09.800 --> 23:17.800
I think the claim in general is that it's supposed to be up to 40% faster, and I found that the LZ4 benchmarks were 5% slower.

23:17.800 --> 23:28.800
So other than actually being quite surprised by that, a lot of it really seemed to fall into the, is it just hot cash?

23:28.800 --> 23:35.800
Is there something else running in the background? Is it actually a big enough change to be worth it?

23:38.800 --> 23:42.800
I don't know if that's fine, but thank you very much for your time.

