WEBVTT

00:00.000 --> 00:13.200
All right, so the next talk is going to be about the Linux kernel key store and why you

00:13.200 --> 00:18.240
should be using it in your next application.

00:18.240 --> 00:19.240
Thank you.

00:19.240 --> 00:21.600
Hello, my name is Ignat.

00:21.600 --> 00:26.680
I work for Cloud for and today we're going to talk about Linux key store.

00:26.680 --> 00:31.480
By the way, how many people here know that Linux has a key store?

00:31.480 --> 00:34.760
Cool, many hands.

00:34.760 --> 00:40.840
Because like James earlier showed us that it has a key store but probably not everyone

00:40.840 --> 00:43.720
knows that Linux actually has a key store.

00:43.720 --> 00:46.480
So, yeah, a little bit about myself.

00:46.480 --> 00:48.560
I do Linux at Cloud for.

00:48.560 --> 00:52.040
I'm passionate about system security and performance.

00:52.040 --> 00:59.080
I'm like Lolo programming, Linux, but loaders, drivers and other stuff written in scary and

00:59.080 --> 01:02.240
safe languages.

01:02.240 --> 01:03.720
And I'm a hard Linux fan.

01:03.720 --> 01:09.600
That's why I'm presenting from a Mac.

01:09.600 --> 01:15.560
And probably like most of you here, I'm a fugitive programmer because NSA banned writing

01:15.560 --> 01:20.120
C and C++ languages and enterprises.

01:20.120 --> 01:21.320
And why is that?

01:21.320 --> 01:31.360
And there are many reasons but one of them is regarding application keys and memory.

01:31.360 --> 01:36.080
And by the way, here is the brand that NSA recommends that organization use memory safe

01:36.080 --> 01:39.800
languages whenever possible.

01:39.800 --> 01:43.240
So what is the problem with application key?

01:43.240 --> 01:46.080
Regarding keys, we're like talking about cryptographic keys, right?

01:46.080 --> 01:51.080
So to dig into that, let's review the Linux address namespace, isolation concept.

01:51.080 --> 01:58.160
So yeah, you have these many processes running on your systems because Linux is a multi-threaded,

01:58.160 --> 02:00.200
multi-process system.

02:00.200 --> 02:03.240
But what these processes have inside, right?

02:03.240 --> 02:10.320
So usually it's kind of like your code, like compiled code, your business logic.

02:10.320 --> 02:17.520
Some libraries, shared libraries, if your application uses shared libraries, some data, like global

02:17.520 --> 02:18.920
data stack.

02:19.920 --> 02:22.880
And yeah, I have the stack box separately.

02:22.880 --> 02:29.920
So it's like data heap and global variable with mStacks, right?

02:29.920 --> 02:32.440
And then you have the kernel, right?

02:32.440 --> 02:33.440
Everything runs in the kernel.

02:33.440 --> 02:36.440
In the kernel also you have the core code.

02:36.440 --> 02:39.520
You have static and dynamic data.

02:39.520 --> 02:43.200
You have the drivers which you load modules.

02:43.200 --> 02:47.720
And also you have stack or stacks if you have different threads, right?

02:47.720 --> 02:56.040
And the idea regarding the address spaces is within the process, each process, and even

02:56.040 --> 02:59.520
within the kernel, everything can access everything, right?

02:59.520 --> 03:08.280
So it's like one global space, whereas you can't access the memory of another process

03:08.280 --> 03:12.400
from one process and you also can't access the memory of the kernel.

03:12.400 --> 03:13.920
Like it's separated.

03:13.920 --> 03:16.720
This is Linux address space isolation.

03:17.720 --> 03:22.920
If we zoom in into the main process, into one of the processes, right?

03:22.920 --> 03:30.040
Like let's actually review what can be here and what can be in your data.

03:30.040 --> 03:32.560
And it can be like some internal state.

03:32.560 --> 03:38.120
So you have global variables, like applications can keep some internal state in the data.

03:38.120 --> 03:44.400
Yeah, your process can have user or customer data if it processes some external inputs

03:44.400 --> 03:45.800
and does stuff.

03:45.800 --> 03:46.800
Right?

03:46.800 --> 03:50.840
And the most important thing is cryptographic keys.

03:50.840 --> 03:55.800
If your application does some sort of level of encryption, it probably has some keys in

03:55.800 --> 03:58.880
the process address space.

03:58.880 --> 04:04.360
And what if like suddenly your application becomes compromised, so either through your

04:04.360 --> 04:09.760
main application logic or through a library, well, it means because it's all in the same

04:09.760 --> 04:15.080
address space, it means all your data section is compromised, right?

04:15.080 --> 04:17.480
But not all data is created equal.

04:17.480 --> 04:20.320
So, well, yeah.

04:20.320 --> 04:27.080
So yeah, well, like if your application internal state is compromised, well, it can be good

04:27.080 --> 04:28.080
or bad, right?

04:28.080 --> 04:29.080
It depends.

04:29.080 --> 04:30.200
Like depends on your logic.

04:30.200 --> 04:35.840
Of course, it can be bad if the attacker has control of some kind of data which can, for

04:35.840 --> 04:38.840
example, change the control flow of your application.

04:38.840 --> 04:44.520
If you're verifying a password, you can flip back like true or false or you can put some

04:44.520 --> 04:50.160
authenticated flag on and yeah, this can be bad, but sometimes it's not as bad depends

04:50.160 --> 04:55.680
on if your application is simple, but it can lead to further compromise.

04:55.680 --> 05:03.160
Well, if your user customer data is compromised, then like it's much, much more now.

05:03.160 --> 05:08.320
And yesterday also mentioned Equifox, my favorite company.

05:09.320 --> 05:16.440
Yeah, if you're a user customer data leak, it's a big problem because kind of it creates

05:16.440 --> 05:23.120
a lot of pressure on the company and you have to pay a lot of fines, but it's very, very

05:23.120 --> 05:25.640
bad but still more or less recoverably.

05:25.640 --> 05:30.760
Equifox is still in business to this day, unfortunately.

05:30.760 --> 05:35.280
But what about cryptographic key compromise?

05:35.280 --> 05:37.840
And this is like a total game over, right?

05:37.840 --> 05:43.160
So like if your identity key is leaked, that's what anyone can be as you.

05:43.160 --> 05:47.000
If you're like the main data encryption key is leaked, everyone knows your data.

05:47.000 --> 05:51.560
So it's a data integrity compromise, full security compromise and total identity take

05:51.560 --> 05:54.000
over.

05:54.000 --> 06:01.480
So what are the, well, 1000 feet view level of methods you can leak your application keys,

06:01.480 --> 06:02.480
right?

06:02.480 --> 06:07.680
Well, first of all, untrusted inputs and out of bound memory access.

06:07.680 --> 06:13.600
So imagine you have stuff in your memory written somewhere, right?

06:13.600 --> 06:19.120
And it may be that like near that stuff, you can have like a cryptographic key also in

06:19.120 --> 06:20.120
the same memory.

06:20.120 --> 06:25.840
And the normal application logic should allow you only to read stuff.

06:25.840 --> 06:31.840
But like what happened, for example, in hard bleed, if you can make the application read

06:31.840 --> 06:39.360
past the buffer boundary, you can also read the cryptographic key, right?

06:39.360 --> 06:41.760
And this is what happened to hard bleed.

06:41.760 --> 06:44.000
Everyone remembers hard bleed.

06:44.000 --> 06:51.320
Well, if your application have arbitrary remote code execution, like what else to discuss

06:51.320 --> 06:52.560
there is game over, right?

06:52.560 --> 06:57.200
So like attacker can control the execution of your binary and they can read, and due

06:57.200 --> 07:03.000
to say everything being in the same process space, so they can read everything and as

07:03.000 --> 07:05.280
to write everything.

07:05.280 --> 07:10.840
Not much to discuss there, but in the example was recent one, lock for shell.

07:10.840 --> 07:12.600
Everyone remembers lock for shell.

07:12.600 --> 07:15.200
Who patched lock for shell?

07:15.200 --> 07:21.880
Should have asked yesterday here, Java, right?

07:21.880 --> 07:27.360
Well, buffer use can be a sort of problem for leaking a key.

07:27.360 --> 07:32.440
So for example, this is a very, of course, this is a simplified program, but specifically

07:32.440 --> 07:36.840
tailored to leak the key, but like it illustrates the example.

07:36.840 --> 07:42.240
So for example, it has to function and crypt and log, right?

07:42.240 --> 07:48.840
And oh no, we forgot to initialize the logging message in the log function.

07:48.840 --> 07:53.360
And if you actually execute it, you will see that it kind of actually leaks the cryptographic

07:53.360 --> 07:55.120
key.

07:55.120 --> 08:00.400
So what happens is you have the process as thread stack, you have your main logic.

08:00.400 --> 08:05.480
For example, you call the decrypt or encrypt data function, which will get the key from

08:05.480 --> 08:09.480
somewhere and may put it on the stack depending on the implementation.

08:09.480 --> 08:15.000
But if you then the function exits, but if it doesn't clean it up the stack with the key,

08:15.000 --> 08:21.720
the next function can take it over and actually has an example, sorry, has an access to that

08:21.720 --> 08:24.160
cryptographic key, right?

08:24.160 --> 08:30.400
This is why all the compliance and security folks will tell you you always need to zero

08:30.400 --> 08:32.080
memory after key use.

08:32.080 --> 08:34.080
Like you have to clean up.

08:34.080 --> 08:39.760
Which is hard to do in many high level programming languages, especially if in garbage collected

08:39.760 --> 08:41.320
languages, right?

08:42.200 --> 08:45.040
Finally, you have the debugging tools.

08:45.040 --> 08:53.040
If you have a logging can accidentally leak your keys like core dumps, like GDB, Ptrace,

08:53.040 --> 08:58.760
everything that can access the memory of the application can leak a secret.

08:58.760 --> 09:05.800
Yeah, well let's make our applications don't crash and fix all the problems, right?

09:05.800 --> 09:09.960
We obviously can't fix all the bugs, so we have to do something about it.

09:09.960 --> 09:15.160
And probably we can't do a completely secure application, but what can we do specifically

09:15.160 --> 09:16.520
for cryptographic keys?

09:16.520 --> 09:22.880
Because they are the highest, most valuable data in our process address space.

09:22.880 --> 09:30.000
What some applications do, well, they try to leverage the operating system address space

09:30.000 --> 09:34.080
isolation, so they basically create another process, right?

09:34.080 --> 09:39.840
It will have a different data section and you can just move the cryptographic keys over

09:39.840 --> 09:47.920
to a different process and you write some very basic, very simple, which is unlikely

09:47.920 --> 09:53.880
to have bugs, a cryptographic logic to handle these keys on behalf of the main process.

09:53.880 --> 10:01.360
And then you create some kind of well-defined, tightened user interface between two processes,

10:01.360 --> 10:04.240
right?

10:04.240 --> 10:07.080
So we call it the key agent model.

10:07.080 --> 10:11.360
So you have two processes, one, the main process and the helper agent.

10:11.360 --> 10:18.000
The main process does not have the cryptographic material in the address space and the main

10:18.000 --> 10:22.680
communicates with the agent through a well-defined interface to perform cryptographic operation

10:22.680 --> 10:24.440
on its behalf.

10:24.440 --> 10:29.600
And agent is usually doesn't process untrusted input, like it's not connected to the network

10:29.600 --> 10:37.040
and is usually, and more scrutiny goes into that review.

10:37.040 --> 10:40.760
And some of the example of these we all use every day.

10:40.760 --> 10:42.960
So who here uses SSH?

10:42.960 --> 10:46.800
Who here doesn't use SSH agent?

10:46.800 --> 10:47.800
You don't?

10:47.800 --> 10:48.800
Yeah.

10:48.800 --> 10:54.600
Yeah, so SSH agent, GP agent, stuff like that.

10:54.600 --> 10:57.000
But there are drawbacks to this approach, right?

10:57.000 --> 11:00.080
So we need to develop and maintain two programs.

11:00.080 --> 11:03.320
We need to design this well-defined interface.

11:03.320 --> 11:05.160
We need to add communication.

11:05.160 --> 11:07.280
Like we need to think about how these processes communicate.

11:07.280 --> 11:13.880
Should we use Unix, talk, shared memory, something else, HTTP.

11:13.880 --> 11:20.880
And probably it's a good to somehow enforce and authenticate the main process from the

11:20.880 --> 11:21.880
agent.

11:21.880 --> 11:26.840
And not if the agent is kind of like this thing that performs cryptographic operations,

11:26.840 --> 11:31.760
we don't want anything in our system talking to it and being able to do signatures with

11:31.760 --> 11:35.120
our keys.

11:35.120 --> 11:38.440
This is where we go to Linux kernel key store.

11:38.440 --> 11:44.280
And the official name is Linux kernel key retention service.

11:44.280 --> 11:45.600
I call it the key store.

11:45.600 --> 11:50.800
Some people say it's a key ring, but actually, like key store has many key rings.

11:50.800 --> 11:55.920
So I think the key store is kind of the most applicable technology.

11:55.920 --> 12:00.760
And what it does is basically it takes this agent model and instead of process two, it

12:00.760 --> 12:03.120
replaces it with a kernel, right?

12:03.120 --> 12:08.160
And the well-defined interface is just system calls.

12:08.160 --> 12:09.440
Easy.

12:09.440 --> 12:15.480
So in a nutshell, Linux kernel key retention service stores cryptographic keys as kernel

12:15.480 --> 12:16.480
object.

12:16.480 --> 12:19.640
And this gives us some flexibility.

12:19.640 --> 12:25.000
So it was initially actually designed to share keys with the kernel services itself.

12:25.000 --> 12:28.640
So like for disk encryption, for example, you pass a key to the kernel and the kernel

12:28.640 --> 12:29.720
uses it.

12:29.720 --> 12:33.520
But eventually it was extended to user space.

12:33.520 --> 12:37.720
And the advantages that keys are now stored outside of the process address space, you

12:37.720 --> 12:42.840
have already have a well-defined system call interface to access and use the keys.

12:42.840 --> 12:47.920
And keys are becoming kernel objects so you can have associated access control lists,

12:47.920 --> 12:48.920
permission checks.

12:49.800 --> 12:52.720
Like you have on files or some other kernel objects itself.

12:52.720 --> 12:57.880
And the nice thing about it is like the key life cycle can be implicitly bound to the

12:57.880 --> 13:00.520
code life cycle.

13:00.520 --> 13:06.440
For example, security deleting a key even if the process terminates abruptly.

13:06.440 --> 13:13.840
And for a kernel feature, it surprisingly has a quite good documentation.

13:13.840 --> 13:15.840
So what does the key store look like?

13:15.840 --> 13:18.360
So it's a collection of key rings and keys.

13:18.360 --> 13:26.240
So a key ring can have links to other key rings and keys can contain other key rings

13:26.240 --> 13:27.240
or contain keys.

13:27.240 --> 13:31.000
So you can get this like a tree like structure.

13:31.000 --> 13:37.320
So keys are just objects that contain actual cryptographic material or a pointer treat.

13:37.320 --> 13:41.560
They can be read and written to and used to perform cryptographic operations.

13:41.560 --> 13:43.880
There are several key types which I go on later.

13:44.080 --> 13:48.040
You have user, logon, asymmetric encrypted and trusted keys.

13:48.040 --> 13:52.400
And they're kind of similar to a file system but unlike the file which can be on the in

13:52.400 --> 13:57.360
one directory, like if you don't take into account the weird bind mounts or some kind

13:57.360 --> 14:03.440
of hard links, keys can be part of many key rings at once.

14:03.440 --> 14:08.480
And key rings, they, it's a collection of links to the keys.

14:08.480 --> 14:10.800
And basically they enforce the life cycle of a key.

14:10.800 --> 14:17.280
If a particular key is not linked to a key ring, like it gets automatically destructed.

14:17.280 --> 14:24.840
And they can be explicitly created key rings or implicit special, a thread process, user

14:24.840 --> 14:26.760
and session.

14:26.760 --> 14:32.120
And they do enforce the key lifetime and they are kind of similar to a directory in the

14:32.120 --> 14:34.280
file system.

14:34.280 --> 14:35.760
So let's see an example.

14:35.760 --> 14:40.640
And by the way, all the examples I'm showing, I copied it from a real terminal.

14:40.640 --> 14:43.720
So it's a demo which doesn't fail.

14:43.720 --> 14:51.360
So in this example, here I'm creating a new key ring and linking it to my implicit user

14:51.360 --> 14:53.520
key ring.

14:53.520 --> 14:57.960
And each key or key ring is designated by a serial number which you can see.

14:57.960 --> 15:01.360
So it's kind of a unique number of the object inside the kernel.

15:01.360 --> 15:05.560
And once I created the key ring, I can add a key there with some secret contents Hunter

15:05.560 --> 15:07.840
2 to my key ring.

15:08.760 --> 15:17.920
Basically I can then show, kind of, KCTL show shows my key ring and key tree.

15:17.920 --> 15:24.040
So we have the session ring, the user ring, my ring and my key there.

15:24.040 --> 15:25.240
Yeah.

15:25.240 --> 15:31.640
And basically you can see that the serial numbers match so what we just created.

15:31.640 --> 15:35.920
And also like because I just created the key, I have access to it so I can read the cryptographic

15:35.920 --> 15:39.360
material back and get the secret.

15:39.360 --> 15:44.080
And I think one of the examples you can use is like secret sharing between two users.

15:44.080 --> 15:48.120
So you have Alice and Bob to users on the system and you may notice they don't have

15:48.120 --> 15:49.120
anything in common.

15:49.120 --> 15:51.920
So they have separate groups, separate IDs, everything is separate.

15:51.920 --> 15:56.600
No common groups or permissions.

15:56.600 --> 16:02.640
For example, and Alice can create a secret with Hunter 2 and put it in their user key

16:02.640 --> 16:03.800
ring.

16:03.800 --> 16:10.040
What Bob can do, for example, it can create a new key ring called from others, a recipient

16:10.040 --> 16:11.720
key ring.

16:11.720 --> 16:17.160
And Bob can actually set permissions on that key ring so it allows everyone to write there.

16:17.160 --> 16:20.240
Write means putting links to other keys.

16:20.240 --> 16:27.800
So then if Bob communicates the serial number to Alice, Alice can just move that key to

16:27.800 --> 16:32.760
the Bob's key ring and then we now see that Alice doesn't have the key anymore in their

16:32.760 --> 16:39.520
possession and Bob can actually now read the cryptographic material because Bob now possesses

16:39.520 --> 16:41.320
that key.

16:41.320 --> 16:43.400
Simple.

16:43.400 --> 16:48.600
There are special key ring types.

16:48.600 --> 16:52.880
And these special key ring times determine the life cycle of a key ring.

16:52.880 --> 16:59.680
So there are session key rings which are available to all the current process and all these children.

16:59.680 --> 17:04.520
So for example, if you are system D and you put a key in the session key ring, it will

17:04.520 --> 17:10.080
be available to every process on the system which is spawned by system D.

17:10.080 --> 17:14.400
The process key ring is private to a particular process.

17:14.400 --> 17:20.360
So like every process has their own implicit key ring which they can use to store process

17:20.360 --> 17:21.440
specific credentials.

17:21.440 --> 17:26.280
And there is also a sweat key ring which is specific to a particular thread.

17:26.280 --> 17:36.840
Then let's say you write a web server which serves several websites and each website has

17:36.840 --> 17:39.040
a different TLS key.

17:39.040 --> 17:47.400
And you can, if you serve a website per thread, for example, so you can kind of securely store

17:47.400 --> 17:52.680
a TLS key for that thread, for that website without other threads even having access to

17:52.680 --> 17:55.000
that key, which is really cool.

17:55.000 --> 17:59.320
There are also user key rings which are bound to the life cycle of a user.

17:59.320 --> 18:04.040
So it's a key ring which is shared between all the processes with the same user ID and

18:04.040 --> 18:09.960
there is a user session key ring which is similar to user but not important in this context.

18:09.960 --> 18:17.240
There is also a type called persistent key rings which the name is a little bit confusing

18:17.240 --> 18:21.240
because they are not actually persisting the keys on the desk.

18:21.240 --> 18:23.440
It has nothing to do with it.

18:23.440 --> 18:26.000
It's just the life cycle of these key rings are different.

18:26.000 --> 18:28.920
They're not bound to a process or a user.

18:28.920 --> 18:30.600
So it's kind of time bound.

18:30.600 --> 18:38.360
So if you basically don't access the key ring for a time out, it gets automatically destroyed.

18:38.360 --> 18:45.760
It's useful, for example, in Chrome jobs where you can't really bind, for example, a key ring

18:45.760 --> 18:50.720
to a user because that user appears and disappears from the system but you can put a time bound

18:50.720 --> 18:54.480
and while your Chrome job is running, your key ring will be available.

18:54.480 --> 19:01.840
If for some reason your Chrome job stops running, the key will be eventually destroyed.

19:01.840 --> 19:04.440
So let's see a session key ring example.

19:04.440 --> 19:09.160
So let me add my favorite Hunter 2 secret to my session key.

19:09.160 --> 19:15.240
And basically, I imagine I'm on a SSH session to this particular machine.

19:15.240 --> 19:22.880
I can see that my key exists, right, and I can see its ID and it's linked to the session key ring.

19:22.880 --> 19:31.120
What I can do now is, for example, in another terminal I can put a BPF probe on a user destroy function

19:31.120 --> 19:37.200
which is responsible for securely destroying keys from the kernel key store.

19:37.200 --> 19:44.240
And if now I just exit my SSH session, I log out, I can see that the probe works

19:44.240 --> 19:52.760
and my key was automatically destroyed because my session ended, so my session key ring got destroyed

19:52.760 --> 19:56.040
and all the keys are linked to it got automatically destroyed as well.

19:56.040 --> 20:02.160
And if I re-log in back, I can see that technically my session key ring changed.

20:02.160 --> 20:07.600
It was destroyed and recreated automatically and I don't have the key anymore.

20:07.600 --> 20:11.600
So what it helps is, like, if you select the appropriate key ring type,

20:11.600 --> 20:15.640
you can ensure that keys will be securely destroyed when not needed.

20:15.640 --> 20:19.200
And you don't have to explicitly clear the memory.

20:19.200 --> 20:20.880
It will happen if you're out.

20:20.880 --> 20:25.720
For example, if you bound to a process key ring, if the process dies, the key will get destroyed.

20:25.720 --> 20:32.040
And regardless how the process dies, if it's successful exit, if it crashed, if it cordoned, whatever,

20:32.040 --> 20:34.440
like the keys will be gone.

20:34.440 --> 20:41.800
Okay, so now let's consider, like, some different key types.

20:41.800 --> 20:48.160
So we check the key ring types, the key types, the simplest one is the user key, which we just saw.

20:48.160 --> 20:51.680
So you have the cryptographic material, you put it inside the kernel,

20:51.680 --> 20:57.680
and then eventually either this process or the other process, which has relevant permissions, can read that secret back.

20:58.680 --> 21:03.400
There is also, like, a special type called logon key, which you can put inside the kernel,

21:03.400 --> 21:05.120
but you can never read back.

21:05.120 --> 21:12.400
And this is where this type is primarily used to share secrets with the kernel for disk encryption or eCryptFS.

21:12.400 --> 21:20.320
So if you're in a relatively recent Linux distribution, if you dump your dmCrypt setup,

21:20.320 --> 21:30.680
you will see that some of your keys are actually coming from the kernel key ring instead of, like, you will see the bytes directly.

21:30.680 --> 21:35.440
There is also an asymmetric key type, which only supports RSA currently.

21:35.440 --> 21:39.720
So you put an RSA key inside the kernel, and technically you don't read it back,

21:39.720 --> 21:47.960
but you can perform some operations with this key, like you can instruct the kernel to sign data or decrypt something with the key.

21:48.000 --> 21:57.360
So for example, this is a simple example, it was open SSL, so we can generate an RSA private key.

21:57.360 --> 22:05.360
Kernel understands only pkcs8 format for unencrypted pkcs8 private keys,

22:05.360 --> 22:10.760
so we have to convert it to pkcs8 format, and then we can actually add it to the kernel,

22:10.760 --> 22:15.360
and then we can ask the kernel to sign something,

22:15.360 --> 22:21.960
and basically we can then verify that the signature is valid with OpenSSL.

22:21.960 --> 22:27.760
Which is very useful, so all the things I'm describing today, and more is describing Cloud for a blog post,

22:27.760 --> 22:34.760
and there we have an example where we completely replace SSL, it's like a proof-of-concept patch,

22:34.760 --> 22:40.560
but we patched OpenSSH and replaced the SSH agent with the kernel key store,

22:40.560 --> 22:48.960
so instead of SSH add, you do SSH add our bash script, which puts your private SSH key into the kernel key store,

22:48.960 --> 22:56.760
and if you run the patched SSH client, it will actually work the same as it would communicate with an agent,

22:56.760 --> 23:00.960
but you don't need any agents running on the assist.

23:00.960 --> 23:06.360
Cool, this is all well and good, this is how you can use it,

23:06.360 --> 23:16.160
but surprisingly key store can be very useful as a big corporate key management building model,

23:16.160 --> 23:22.160
but the question here remains, in all the previous examples you just saw,

23:22.160 --> 23:30.560
that we still need to put the keys into the kernel, so we don't want the secrets to be in the application address space,

23:30.560 --> 23:33.560
but we still need the application to put it inside the kernel,

23:33.560 --> 23:39.360
so even though if the application cleans up after itself, there is a small window of opportunity

23:39.360 --> 23:44.160
where application has the plain text secret in its address space,

23:44.160 --> 23:51.560
so how can we provision application keys without cryptographic material ever being exposed to the user space at all?

23:51.560 --> 23:57.160
So for this we have two other interesting key types, one is called encrypted key,

23:57.760 --> 24:06.760
and in this case the process has not the plain text key material, but encrypted key material with some other key,

24:06.760 --> 24:13.760
and the kernel has a wrapping key, so when the process inserts that key inside the kernel,

24:13.760 --> 24:20.760
the kernel automatically unwraps the key, and if we try to read it back, it gets automatically wrapped by the kernel again.

24:21.360 --> 24:26.360
But here we have the chicken and egg problem like how do you then provision the wrap key, right?

24:26.360 --> 24:36.360
So, still things, so what James showed earlier today in his demo is you can technically replace this with a TPM,

24:36.360 --> 24:42.360
and then you have a thing called a trusted key, so again you have the wrap key, but wrap to a particular TPM,

24:42.360 --> 24:49.360
you can insert in the kernel and TPM will automatically unwrap it, and again if you read it back, it gets wrapped.

24:51.360 --> 25:00.360
But this schema is not really great because as James mentioned TPMs are slow and there is as much as you can do with these operations,

25:00.360 --> 25:06.360
so like if you have thousands of keys you don't want to continuously poke the TPM to unwrap them,

25:06.360 --> 25:13.360
so you can do some kind of a combined approach where basically you have some kind of provision, right?

25:13.960 --> 25:20.960
So, and you have some kind of HSM in the cloud or on-prem, whatever which does your cryptographic keys,

25:20.960 --> 25:29.960
and then you provision a root key first, so you basically wrap the root key to a particular machine to its TPM,

25:29.960 --> 25:36.960
and then you insert it and the TPM unwraps it, but all the other thousand keys are encrypted with this root key,

25:37.560 --> 25:44.560
so the process received the wrap key and then it puts inside the kernel and then you don't go to TPM,

25:44.560 --> 25:50.560
you already have the root key which is a software implementation, can easily unwrap all the other thousand keys.

25:52.560 --> 26:02.560
But there are still problems with this approach, even though the application never sees the cryptographic material in this process address phase,

26:03.160 --> 26:13.160
but applications are still responsible for receiving this wrapped cryptographical material from this centralized KMS HSM service to wrap their keys,

26:13.160 --> 26:18.160
and so basically each application needs, who here uses Vault?

26:18.160 --> 26:27.160
Yeah, some people, right? So like it's, you kind of like know what, need to know what your Vault address endpoint is, right?

26:27.760 --> 26:38.760
You need to speak the Vault protocol or AWS KMS protocol, you need to basically integrate all this crap in your code,

26:38.760 --> 26:46.760
and there is little administrative control if like you're managing fleet of machines of the created kernel key object,

26:47.760 --> 26:52.760
so applications when inserting the key can set invalid permissions, so like anyone can, for example,

26:53.360 --> 26:59.360
if you set improper permissions on your RSA private key, any application, even malicious on your system,

26:59.360 --> 27:02.360
can use it to encrypt or sign data, right?

27:02.360 --> 27:09.360
And ideally like you also want authentication here, so KMS or HSM, that remote service,

27:10.360 --> 27:16.360
needs to somehow authenticate each requesting application if it can provide the wrapped cryptographic material.

27:16.960 --> 27:23.960
So how the kernel tries to solve that problem, it has two set of system calls.

27:24.960 --> 27:29.960
So far we've been using the at key system call with a key CTL utility,

27:29.960 --> 27:34.960
so it adds the key to the specified, key ring with the specified payload.

27:35.960 --> 27:39.960
So basically the application is responsible for the payload itself,

27:39.960 --> 27:44.960
so it's either plain text or in case of trusted or encrypted key, the encrypted payload,

27:44.960 --> 27:47.960
it gets it from somewhere and it sorts it into the kernel.

27:49.960 --> 27:55.960
And the payload is interpreted according to the key type, it's like no interpretation happens for user logon keys,

27:55.960 --> 27:59.960
because those are mostly symmetric keys which are random strings,

27:59.960 --> 28:05.960
it's a private public key for asymmetric cryptos or wrapped for encrypted and trusted.

28:05.960 --> 28:10.960
But there is another interesting API in the kernel called request key,

28:10.960 --> 28:15.960
so instead of applications inserting the payload directly what applications can do,

28:15.960 --> 28:22.960
they can ask the kernel, just give me my key, give me my key and give it an arbitrary string as an identifier.

28:23.960 --> 28:26.960
And it's on the kernel to actually satisfy that request,

28:26.960 --> 28:32.960
and obviously the kernel has no idea of everyone set up, like where should it take the key from,

28:32.960 --> 28:38.960
so it's one of the examples where the kernel can then make a user space callback

28:38.960 --> 28:48.960
and with a special helper program which you can then configure to actually deliver your keys, right?

28:48.960 --> 28:54.960
But it's a more centralized and transparent API to the kernel system, so how it works,

28:54.960 --> 29:00.960
so you have the process instead of adding key, so the process requests the key from the kernel

29:00.960 --> 29:04.960
and provides the identifier, so like give me my cloud app key one,

29:04.960 --> 29:10.960
so the kernel creates a placeholder, then it creates a special process,

29:10.960 --> 29:14.960
a callout process, helper process in user space called request key,

29:14.960 --> 29:20.960
and this one you can configure and you can specify different routes for different key types,

29:20.960 --> 29:26.960
for example if I requested the cloud app key one, it will go to the cloud sub-module

29:26.960 --> 29:31.960
and you can write these sub-modules in any programming language by the way, it doesn't have to be C,

29:31.960 --> 29:35.960
so you can write them in Go, it can be just simple batch scripts as well,

29:35.960 --> 29:42.960
which are basically responsible for if the path is cloud, it can contact your cloud HSM,

29:42.960 --> 29:47.960
get the wrapped cryptographic material, put it back inside the kernel,

29:47.960 --> 29:56.960
the kernel will then instantiate the keys and then the application will get its key back.

29:56.960 --> 30:01.960
So with request key advantages, you have a single centralized operating system API

30:01.960 --> 30:08.960
to request key from the application, so there are no KMS or HSM connection strings,

30:08.960 --> 30:13.960
you arise in your configuration form, just a freeform ID string,

30:13.960 --> 30:19.960
and it kind of fully decouples, your application is fully decoupled from key storage backend,

30:19.960 --> 30:23.960
so it doesn't care where the keys are stored and how they are distributed,

30:23.960 --> 30:31.960
and it's a more secure way to instantiate the keys in the kernel,

30:31.960 --> 30:37.960
so this special call-out process which is created by the kernel is very special in the sense that

30:37.960 --> 30:44.960
it has a special credential enforced by the kernel, so even if you launch the same helper process yourself as root,

30:44.960 --> 30:52.960
it will not be able to instantiate the requested key because it doesn't have a specific token from the kernel to do it.

30:52.960 --> 30:57.960
And this also call-out process is very useful, in fact it can be trustworthy,

30:57.960 --> 31:03.960
so you can perform additional security checks, you can implement arbitrary policies there,

31:03.960 --> 31:10.960
so you can check the requestor, user ID, group ID, executable pass, package name, whatever you suppose,

31:10.960 --> 31:14.960
is this application even allowed to request the key in the first place,

31:14.960 --> 31:17.960
and you can immediately deny that request.

31:17.960 --> 31:23.960
And you can support multiple key storage backends, you have local storage,

31:23.960 --> 31:30.960
you have a TPM backend, cloud HSM backend, whatever, and you can even swap these backends transparently,

31:30.960 --> 31:35.960
like if you, for example, migrated from on-prem HSM to a cloud HSM,

31:35.960 --> 31:44.960
all you have to do is just modify this helper process config file and applications will not notice.

31:44.960 --> 31:54.960
And then you have the nice thing that you need to only authenticate this single helper process on your backend.

31:54.960 --> 32:01.960
And yeah, as I mentioned, the backend connectors can be written in any language, so very easy to extend.

32:01.960 --> 32:09.960
But the nice thing about that with request key, the key management and distribution becomes a core service operating

32:09.960 --> 32:18.960
of the operating system itself as it should be, versus like every application has to deal with it on its own.

32:18.960 --> 32:25.960
That's basically it for today. Here are some links to some kernel documentation, to some key ring man pages,

32:25.960 --> 32:33.960
as well as the last link. Again, everything I told you today and even more is described in the cloud for our blog post,

32:33.960 --> 32:35.960
which is linked at the end.

32:35.960 --> 32:38.960
Thank you and I'm happy to talk to you.

32:46.960 --> 32:54.960
Thank you for the great talk. So I recall there was an API in the producer space to protect memory from kernel space.

32:54.960 --> 32:57.960
So the, like a given page was unmapped from the kernel.

32:57.960 --> 33:01.960
So if you had an out of bounds in the kernel, you couldn't access the memory,

33:01.960 --> 33:05.960
but of course the kernel could remap the page back again.

33:05.960 --> 33:09.960
My question is, are the keys protected in such a way in the kernel?

33:09.960 --> 33:17.960
And do you think it would make sense to do it? I mean, it would potentially minimize the exposure in theory at least.

33:17.960 --> 33:22.960
The default, I don't, I'm not sure about the implement, but I would say no.

33:22.960 --> 33:26.960
I think the keys are not like more protected.

33:26.960 --> 33:30.960
So the guy who wrote it is right there.

33:30.960 --> 33:41.960
And what was the question? If you put a key of the user space process into these areas, they will be more protected than otherwise.

33:41.960 --> 33:44.960
It still doesn't guarantee like 100%

33:44.960 --> 33:50.960
My point is the kernel could also do it so that it would protect those keys from itself as well.

33:50.960 --> 33:55.960
And it would only remap the page back again when it actually, when you do the request key for it.

33:55.960 --> 33:58.960
But what's the point then?

33:59.960 --> 34:07.960
If kernel needs the keys, it has to have access anyway and remapping and mapping is costly.

34:07.960 --> 34:13.960
The other thing is the key store API internally is also extendable.

34:13.960 --> 34:16.960
You can write other modules and this is what I asked for.

34:16.960 --> 34:21.960
James earlier, that you can technically write an asymmetric key implementation backed by the TPM.

34:21.960 --> 34:24.960
So the keys will not be even inside the kernel.

34:24.960 --> 34:29.960
It will be in the TPM, but then each operation will have to touch TPM in the first place.

34:29.960 --> 34:35.960
Or if you like design some kind of crypto chip or you can like design like an arm like a truss zone back here.

34:35.960 --> 34:37.960
So like whatever you want.

34:38.960 --> 34:48.960
There was some effort. I don't remember exactly which areas it touched to do this sort of separation between subsystems.

34:48.960 --> 34:53.960
But I only learned about it once. I don't know what they say this.

34:53.960 --> 34:59.960
No, no. Well in kernel it's still like the old, you mean in the kernel subsystems?

34:59.960 --> 35:03.960
I don't like it's still like a flat address space at this point.

35:03.960 --> 35:10.960
I don't, unless you're again using like arm trance zone or enclaves or whatever.

35:10.960 --> 35:14.960
My question is, so you mentioned that we can do RSA operations.

35:14.960 --> 35:17.960
Not everybody is using RSA.

35:17.960 --> 35:21.960
Are there any efforts to introduce other kinds of asymmetric keys?

35:21.960 --> 35:24.960
In particular, I'd like to see an explicated stuff.

35:24.960 --> 35:27.960
So, yes.

35:27.960 --> 35:33.960
So the kernel currently also supports ECDSA, but only for signature verification.

35:33.960 --> 35:35.960
It was added for kernel modules.

35:35.960 --> 35:42.960
I send like patches to actually support signatures through for the Q-Stone API twice.

35:42.960 --> 35:48.960
I didn't get any traction on them. I'll send it one more time maybe.

35:49.960 --> 35:53.960
Because I also know that the kernel has its own internal crypto API

35:53.960 --> 35:55.960
and has support for all of these operations.

35:55.960 --> 35:58.960
They're just not exposed through the key store.

35:58.960 --> 36:02.960
Well, specifically for RSA, for ECDSA, no.

36:02.960 --> 36:08.960
The kernel crypto API doesn't have crypto for ECDSA signatures for generating the signature.

36:08.960 --> 36:13.960
So my patch set included both the crypto subsystem and the key store subsystem.

36:13.960 --> 36:20.960
The kernel can do ECDSA signatures, but also this code is reachable through the key store API.

36:20.960 --> 36:22.960
Okay, thank you.

36:33.960 --> 36:36.960
Very interesting talk. Thank you.

36:36.960 --> 36:38.960
I have basically the same question.

36:38.960 --> 36:45.960
But also, wouldn't there be an urgency to get some PQ crypto in there?

36:45.960 --> 36:56.960
Maybe, but we have to fix ECDSA first before we have to learn to walk before the run, right?

36:57.960 --> 37:00.960
James, can you pass it to the next?

37:03.960 --> 37:08.960
So if we now add the trouson to the picture, does the kernel have any kind of API to interact?

37:08.960 --> 37:13.960
I mean, the key store itself, would it interact with the trouson to get the key

37:13.960 --> 37:16.960
or we need to still go to the user space to the helper

37:16.960 --> 37:20.960
and then the helper will just go through a normal way of communicating with the trouson

37:20.960 --> 37:24.960
and secure monitor call and get back the result and then the key back to the kernel.

37:24.960 --> 37:31.960
For the trouson, I think there is some code, because I never tested on an ARM system

37:31.960 --> 37:38.960
like similar to what we have, the trusted keys for the TPM back trusted keys.

37:38.960 --> 37:43.960
There is an implementation for trusted keys for the ARM trouson, the open source one.

37:43.960 --> 37:46.960
I saw the code, I never tried it, but it's there.

37:46.960 --> 37:49.960
So there is some reference of the application, right?

37:49.960 --> 37:50.960
Yes.

37:50.960 --> 37:53.960
The GNS and there is internal support for that.

37:53.960 --> 37:54.960
Yes.

37:54.960 --> 37:55.960
OPTE.

37:55.960 --> 37:57.960
Yes, OPTE.

38:05.960 --> 38:07.960
Alright, anything else?

38:07.960 --> 38:08.960
Oh, yeah.

38:08.960 --> 38:11.960
If you shout, I'll just repeat.

38:11.960 --> 38:15.960
It's just wondering which version I need to use this.

38:15.960 --> 38:16.960
Sorry?

38:16.960 --> 38:18.960
Which version is it available from?

38:18.960 --> 38:20.960
The kernel key store.

38:20.960 --> 38:22.960
I mean, it's quite all, I guess.

38:22.960 --> 38:29.960
What we did, I think from 6.1, again, we mentioned the crypto subsystem, the key store subsystem.

38:29.960 --> 38:38.960
It was really handy to insert the RSA key into operation with it, but you didn't have any ability to do the same with the symmetric key.

38:38.960 --> 38:46.960
So what we extended is like the crypto user space socket API to be initialized from the user or logon key.

38:46.960 --> 38:59.960
So now you can do it from 6.1, you can insert a symmetric key and then you can create a crypto socket based on that key to perform like AS encryption with that key without exposing the key to user space.

38:59.960 --> 39:06.960
Back to you, does this not want to...

39:06.960 --> 39:12.960
So if I recall correctly, you said that the persistent keys can expire after some time of being unused.

39:12.960 --> 39:16.960
Does listing the keys also count as using them?

39:16.960 --> 39:17.960
That's my first question.

39:17.960 --> 39:22.960
My second question is like, what's the time out time for it to expire?

39:22.960 --> 39:26.960
I haven't used them like so widely to have those specifics.

39:26.960 --> 39:35.960
I think the time out is configurable, definitely, but listing, I don't know if listing the keys actually reset the timer.

39:35.960 --> 39:38.960
I just want to answer the question from over here.

39:38.960 --> 39:46.960
It looks like the API has been available since 2.6.10, which feels old.

39:46.960 --> 39:48.960
Yeah.

39:48.960 --> 39:51.960
There is one person over there which...

39:51.960 --> 39:54.960
Maybe you shout, I repeat.

39:54.960 --> 40:07.960
As a certified micro-configuration enthusiast, is there a reason why this approach is taking rather than planning APIs for the value of duty and so on, that you need the space and have the same benefits?

40:07.960 --> 40:11.960
The question was why we didn't do it in user space, but...

40:11.960 --> 40:15.960
How do you add extra functionality to the kernel to give you the same benefits?

40:15.960 --> 40:18.960
I kind of don't quite understand the question.

40:18.960 --> 40:22.960
The whole point is not to expose cryptographic material to user space.

40:22.960 --> 40:29.960
You're saying the benefits are, for example, if a process dies, then you can immediately wipe the key from memory and that sort of thing.

40:29.960 --> 40:38.960
You could also add functionality to add consistals to the normal database processes that have that sort of benefits.

40:38.960 --> 40:41.960
Why didn't you do that rather than sticking extra things into the kernel?

40:41.960 --> 40:46.960
Because you can retrace the processing of user space, but you cannot retrace the kernel.

40:46.960 --> 40:49.960
Just saying.

40:49.960 --> 40:52.960
Anyway, we are out of time. Thank you very much.

40:52.960 --> 40:55.960
I'm sure you can get two infocations.

