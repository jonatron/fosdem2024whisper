WEBVTT

00:00.000 --> 00:10.520
Hello everyone and welcome to this session about ghosting the hardware.

00:10.520 --> 00:12.680
Maybe the title is a bit obscure to you.

00:12.680 --> 00:15.400
I will explain what it is a bit later on.

00:15.400 --> 00:17.520
So my name is RÃ©mi Durafort.

00:17.520 --> 00:21.520
I'm a principal tech lead at Linao and I've been working on different open source projects

00:21.520 --> 00:23.480
for many years now.

00:23.480 --> 00:30.200
I'm currently working on Lava which is a test automation system that I will present.

00:30.200 --> 00:35.600
So Lava stands for linear automated validation architecture.

00:35.600 --> 00:40.440
So it's a test execution system which means it allows for testing your software on real

00:40.440 --> 00:46.880
hardware, on real devices like Raspberry Pi, Dragon board, so physical devices.

00:46.880 --> 00:53.080
It allows to deploy your hardware, boot your software and test it on real devices.

00:53.080 --> 01:00.880
It's used by multiple projects like NLCI for example that use mainly multiple Lava instances.

01:00.880 --> 01:05.600
We use that a lot also in Linao for the LKFT project, Linux kernel functional testing project

01:05.600 --> 01:07.640
that we are driving.

01:07.640 --> 01:10.040
We also use it for doing bootloader testing.

01:10.040 --> 01:15.240
So for example you can test your UBoot version directly on your board and Lava will allow

01:15.240 --> 01:19.320
to interact with UBoot and test it.

01:19.320 --> 01:21.280
We also do firmware testing with it.

01:21.280 --> 01:28.960
So it currently supports 364 different device types which is a lot of different device types.

01:28.960 --> 01:36.480
So if you want to test your software without Lava, so you will have a kernel, DTB, RAM

01:36.480 --> 01:40.920
disk, root FS modules that you want to test.

01:40.920 --> 01:45.360
You will have Raspberry Pi, so this is a pretty old Raspberry Pi 3 anyway, doesn't really

01:45.360 --> 01:46.360
matter.

01:46.800 --> 01:52.040
You need a way to access the serial to interact with the board, so FTDI cable usually over

01:52.040 --> 01:53.040
USB.

01:53.040 --> 01:59.160
You need a way to power on and off the board, so you need some device that will allow to

01:59.160 --> 02:04.240
send a TCP request to a specific port with some commands and it will power on the board

02:04.240 --> 02:08.440
and another request will power off the board so it can be made automatic.

02:08.440 --> 02:15.240
And usually we use TFTP and NFS for sharing the kernel, DTB and root FS system with the

02:15.240 --> 02:19.560
board so you don't have to actually flash the board because after some time you will

02:19.560 --> 02:24.120
actually destroy the SD card if you do that a bit too often.

02:24.120 --> 02:28.680
So then when you have all of this, if you want to test the board you have to power on

02:28.680 --> 02:32.960
the board so you send the right command to your power manager.

02:32.960 --> 02:38.120
You then connect to the serial, you interrupt UBoot, you send some commands like DSCP,

02:38.120 --> 02:43.920
so the board get an IP address, you load the kernel over TFTP, you load the RAM disk over

02:43.920 --> 02:50.480
HTTP, you set the console argument for the kernel, you then send the right boot argument

02:50.480 --> 02:53.160
that are both specific.

02:53.160 --> 02:59.200
You watch the kernel booting, looking for some crashes maybe or warnings, then you have

02:59.200 --> 03:03.600
the prompt, you log in, you run your test, you collect the results and you shut down

03:03.600 --> 03:04.600
the board.

03:04.600 --> 03:08.640
That's dangerous, not really funny and you will have to do that for every release that

03:08.640 --> 03:10.960
you will have for your software.

03:10.960 --> 03:14.240
So that's where lava come into place.

03:14.240 --> 03:19.760
So instead of having to do that manually, we keep the board, we keep the power control,

03:19.760 --> 03:29.760
serial relay and TFTP and NFS server and replace yourself by a program which is a lava worker.

03:29.760 --> 03:35.160
So instead of typing commands manually one by one, you will explain in a YAML document

03:35.160 --> 03:38.160
to the lava worker what you expect him to do.

03:38.160 --> 03:44.800
So you will explain that you have a kernel, a DTB and a root FS that you want to deploy

03:44.800 --> 03:50.320
using TFTP and you want your root FS to be available over NFS.

03:50.320 --> 03:54.920
And lava will then know how to automatically interact with your board to send all the right

03:54.920 --> 04:00.240
commands that I explained in the previous slide, automatically in a reproducible fashion

04:00.240 --> 04:05.360
for you and it can do that days and nights, including weekends for you.

04:05.360 --> 04:12.600
And this document that you write is what we call a job definition or job configuration.

04:12.600 --> 04:20.640
So obviously you can have multiple DUTs, device under test, for example in this case, per worker

04:20.640 --> 04:25.080
and you can have multiple workers attached to your lava instance and they will all connect

04:25.080 --> 04:29.680
to the lava server, the classical server worker model.

04:29.680 --> 04:34.680
For example in Linao in Cambridge, we have a lab with hundreds of boards and I know Collabora

04:34.680 --> 04:38.200
also has some kind of board farm like that.

04:38.200 --> 04:44.000
It has been made for a large board farm if you want to.

04:44.000 --> 04:49.360
Regarding the roles, so the server, it's a web UI API, it's what is visible to the user

04:49.360 --> 04:52.240
and it usually does not have access to the boards.

04:52.240 --> 04:57.880
For example in Linao, all our lava servers are in the cloud somewhere while the boards

04:57.880 --> 05:01.840
are connected to the workers physically in a closed lab.

05:02.560 --> 05:07.880
So the workers, they have direct control of the DUTs, the boards, device under test

05:07.880 --> 05:10.280
and they are not accessible to the users.

05:10.280 --> 05:13.440
The user will not have access to the board directly, they will not have access to the

05:13.440 --> 05:16.720
worker directly, only to the server.

05:16.720 --> 05:22.880
So the server will be responsible for storing the logs, the jobs, the results, do the scheduling,

05:22.880 --> 05:27.080
send notifications, have an ICOI, things like that.

05:27.080 --> 05:30.000
And on the other side, the worker are more responsible for the hardware.

05:30.000 --> 05:34.240
So they have to deploy resources, they have to pour on and off the boards, they have to

05:34.240 --> 05:40.360
interact with the serials, look for crashes in the kernel under the board health, something

05:40.360 --> 05:41.360
like that.

05:41.360 --> 05:44.400
So this is the list of supported devices.

05:44.400 --> 05:48.720
Obviously you cannot see it, it's way too small because there are way too many devices.

05:48.720 --> 05:54.480
But just to explain that we support from really tiny devices, IoT devices, up to Raspberry

05:54.600 --> 06:03.600
Pi form factor and up to even large servers that you can test with Lava if you want to.

06:05.960 --> 06:10.120
And as we support multiple different kind of device types, we have to support different

06:10.120 --> 06:12.520
deploy methods, different boot methods.

06:12.520 --> 06:20.520
So for example you can deploy with TFTC, NBD, fastboots for all the Android boards, Vexpress,

06:20.520 --> 06:21.520
etc.

06:22.040 --> 06:25.480
For booting you can use DFU, Uboot, PyOCD, fastboot, etc.

06:25.480 --> 06:27.520
As a result of different ones.

06:27.520 --> 06:33.040
And for the tests you can have a POSIX shell interaction if it's available on the system

06:33.040 --> 06:34.040
that you have.

06:34.040 --> 06:35.640
You can have interactive tests.

06:35.640 --> 06:39.240
For example when you want to interact with a bootloader, it's not a POSIX shell, so

06:39.240 --> 06:41.800
you have to send commands and expect results.

06:41.800 --> 06:48.040
And we can also do multi-node tests which is a test in which you have multi, you have

06:48.080 --> 06:53.200
more than one device that will be booting at the same time and that will be able to interact.

06:53.200 --> 06:58.800
For example you can test your server on a physical hardware that will stream to multiple

06:58.800 --> 06:59.800
different clients.

06:59.800 --> 07:04.000
It's something that you can do in Lava.

07:04.000 --> 07:09.680
So today I will speak a bit more about also why we want to test Lava itself because why

07:09.680 --> 07:13.720
do we want to test the CI system?

07:13.720 --> 07:18.120
The obvious reason is that it's just a piece of software so it's buggy.

07:18.120 --> 07:21.880
So you have to test it to know what is working and what is not.

07:21.880 --> 07:27.800
And even more important is that when you're building a CI system you have to ensure that

07:27.800 --> 07:31.800
the CI system is rock solid for two main reasons.

07:31.800 --> 07:35.800
If you have bugs in your CI and if you have false positives which means that you're reporting

07:35.800 --> 07:40.280
something like a bug on the software while it's not buggy, then your developer will just

07:40.280 --> 07:42.720
say okay I'm done with it, it's not working.

07:42.720 --> 07:44.720
I will not look at your CI system anymore.

07:44.720 --> 07:46.360
That's the first reason.

07:46.360 --> 07:50.880
The second is false negative which is you're not reporting an error that happens in your

07:50.880 --> 07:51.880
CI.

07:51.880 --> 07:56.480
So you're running a test, it's failing, but the CI system says everything is okay which

07:56.480 --> 08:01.600
means that you will say to the developer I tested it, it's working while in fact it's

08:01.600 --> 08:03.000
buggy.

08:03.000 --> 08:08.840
So you will have a, you will release the software that has been tested but it's still buggy.

08:08.840 --> 08:16.840
So you have to prove that your CI is reliable over why it's just fully useless.

08:16.840 --> 08:20.520
So how are we going to test lava itself?

08:20.520 --> 08:24.120
So we do have a classical hierarchy of tests.

08:24.120 --> 08:28.600
We obviously have static analysis, we do have unit tests that are running on every GitLab

08:28.600 --> 08:31.520
CI merge request.

08:31.520 --> 08:35.920
We also do integration tests and that's why I will print today which is called meta lava

08:35.920 --> 08:40.440
and we also do federated testing and test on a staging instances.

08:40.440 --> 08:44.680
So we do have some instances that we upgrade every day where we run actual workload and

08:44.680 --> 08:51.480
we check that it's still working the same way as before.

08:51.480 --> 08:56.080
But the main problem when you want to test lava is that it's a combinatorial issue.

08:56.080 --> 09:01.440
As I said before we support 364 different device types, roughly 16 deploy methods, roughly

09:01.440 --> 09:04.600
26 boot methods and five test methods.

09:04.600 --> 09:08.400
So if you do the combination that's insane, the number of combinations that you have to

09:08.400 --> 09:09.400
test.

09:09.400 --> 09:13.480
Yes, I know that a lot of these combinations are just not going to work because not all

09:13.480 --> 09:19.360
devices support DFU or fast boot and things like that but still it's really good.

09:19.360 --> 09:23.600
So maybe you want to give me both and money, I will be out for it but obviously I don't

09:23.600 --> 09:25.920
think that's the case.

09:25.920 --> 09:30.440
So maybe we should consider faking the DUTs.

09:30.440 --> 09:32.960
So faking the hardware.

09:32.960 --> 09:36.120
So that's the goal of the MetaLava projects.

09:36.120 --> 09:38.360
So the goal is to be able to set the full system.

09:38.360 --> 09:41.600
I want to test from the user point of view back to the user.

09:41.600 --> 09:43.960
So the user should be able to send jobs.

09:43.960 --> 09:50.880
It has to be scheduled, run on a fake DUT, send back results and the user will pull the

09:50.880 --> 09:55.880
result from the user interaction.

09:55.880 --> 09:59.480
And I don't want to have any boards because I want that to be somewhere running in a CI

09:59.480 --> 10:00.480
CD system.

10:00.840 --> 10:03.920
And it has to be cheap obviously and fast.

10:03.920 --> 10:05.760
So you have two ways you can do that.

10:05.760 --> 10:10.360
If you want to fake devices, you can go for doing board emulation.

10:10.360 --> 10:17.040
You can use MVP or QMU devices for example to emulate devices.

10:17.040 --> 10:22.200
The main problem is that it's CPU intensive so it will be slow and expensive.

10:22.200 --> 10:25.760
The other way is to ghost the hardware.

10:25.760 --> 10:29.960
So if you go back at the lab architecture, I don't want to touch the user.

10:29.960 --> 10:32.080
That will be my testing system.

10:32.080 --> 10:36.440
I don't want to touch anything in the server and the worker because I want to keep my system

10:36.440 --> 10:39.440
intact.

10:39.440 --> 10:46.040
So the only thing I can change is what is on the left part, the board and the power control

10:46.040 --> 10:49.280
server and the TFTNFS servers.

10:49.280 --> 10:55.320
So what I have to do, I have to build a system that I have to build a fake DUT that will

10:55.400 --> 11:00.400
feel like a DUT, look like a DUT, smell like a DUT, sounds like a DUT and tastes like a

11:00.400 --> 11:05.720
DUT because lava should not see the difference between a real DUT and a fake DUT.

11:05.720 --> 11:10.600
But that's not enough because I also have to check that what lava will send, the interaction

11:10.600 --> 11:16.440
that lava will have with the fake DUT is still valid because if I have a fake DUT that accept

11:16.440 --> 11:22.520
anything then lava will do any stupid things and it will still work while it's just wrong.

11:22.600 --> 11:28.560
So it has to also check, the fake DUT also have to check that what lava send is legit.

11:28.560 --> 11:33.240
So it has to check that lava is still acting correctly.

11:33.240 --> 11:37.440
So we have to look at the interaction between lava and the DUT.

11:37.440 --> 11:40.640
So as I said there is free interaction, the power control.

11:40.640 --> 11:44.640
So by the way lava is designed, it's just a command that lava will run so it can be

11:44.640 --> 11:50.960
any shell command that has to return one or zero, one if it's failing or zero passing.

11:50.960 --> 11:55.120
But from the DUT point of view, from the fake DUT point of view, the DUT should be able

11:55.120 --> 12:00.040
to check that the command has been called at the right time, so before booting, that

12:00.040 --> 12:04.080
lava is still doing what is supposed to do.

12:04.080 --> 12:09.400
Yeah, the serial relay, again it's just a shell command that lava will run and that

12:09.400 --> 12:14.120
it will just interact with the input and output, STD and STD out.

12:14.120 --> 12:18.480
So I need to build something that will feel like a DUT when you interact with it with

12:18.480 --> 12:19.480
the serial.

12:20.000 --> 12:25.480
And the TFTP NFS servers, I will just use a normal and TFTP NFS server and I will just

12:25.480 --> 12:30.400
have to check from the fake DUT point of view that lava has deployed right binaries for

12:30.400 --> 12:31.400
me.

12:33.400 --> 12:36.720
So the question is where do I want to mark things?

12:36.720 --> 12:38.320
Let's take an example.

12:38.320 --> 12:43.600
I don't want to do this presentation but I want to be in my bed and I have something

12:43.600 --> 12:45.840
that will be in place of myself.

12:45.840 --> 12:47.400
So you don't see the difference.

12:47.400 --> 12:52.640
So I can build a robot that will be in my place and that will speak like me and explain

12:52.640 --> 12:55.480
the same things, interact with you the same way as I will do.

12:55.480 --> 12:56.720
That's one way to do it.

12:56.720 --> 13:03.400
I can also force you to have glasses that will inject in your vision an image of myself.

13:03.400 --> 13:07.520
That's two different ways to fake me but from your point of view, it will be the same.

13:07.520 --> 13:09.800
You won't be able to notice the difference.

13:09.800 --> 13:12.720
For mocking, it's all the same.

13:12.720 --> 13:14.840
I have different ways I can mock.

13:14.840 --> 13:20.320
I can create a hardware that will interact with lava the same way a real hardware will

13:20.320 --> 13:22.680
do but without actually booting a candle.

13:22.680 --> 13:27.400
I can do that if possible to just have to fake the serial and it will work.

13:27.400 --> 13:29.320
But as I said before, I don't want to have any hardware.

13:29.320 --> 13:30.840
I just want software.

13:30.840 --> 13:37.440
So what I will do is I will have only software that will fake all the interaction with lava.

13:37.440 --> 13:41.200
So it will fake the serial relay for example.

13:41.200 --> 13:44.120
So we're going for a full software implementation.

13:44.120 --> 13:46.600
It's a project called DEMISIS.

13:46.600 --> 13:49.760
So when you run it, it has the same output as a normal board.

13:49.760 --> 13:53.240
You can interact with it and you feel like you interact with a real board.

13:53.240 --> 13:55.560
I will show you in a right after that.

13:55.560 --> 14:00.360
So you can send it commands and it will react like a normal board will do.

14:00.360 --> 14:06.080
And when you do TFTP and NFS commands, it will actually load the TFTP and NFS command

14:06.080 --> 14:11.880
for you and check that the binary are present.

14:11.880 --> 14:15.400
I will just go for a really short demo.

14:15.400 --> 14:22.320
So I just have a run script, just a wrapper not to type everything because it's painful

14:22.320 --> 14:24.320
to type.

14:24.320 --> 14:31.520
For example, I want to, so my DEMISIS system, my program that will fake a duty, so it's

14:31.520 --> 14:36.600
a Python script and I give it some commands that are inside YAML file that I will explain

14:36.600 --> 14:37.800
right after.

14:37.800 --> 14:45.200
So if I start it, you will see for the one that are used to have a UBoot booting and

14:45.200 --> 14:51.280
acting to UBoot machine, it's what UBoot usually type enter and it's actually wait for you

14:51.280 --> 14:56.400
to do type enter and then you have a shell in which you can type some commands, for

14:56.400 --> 14:58.520
example, DSCP.

14:58.520 --> 15:00.120
It will get a DSCP.

15:00.120 --> 15:01.200
This is all fake.

15:01.200 --> 15:02.720
I don't have any board attached to it.

15:02.720 --> 15:03.720
You see that.

15:03.720 --> 15:09.160
It's just a program that is faking a UBoot interaction, a board interaction.

15:09.160 --> 15:11.720
And then I can just ask it to boot.

15:11.720 --> 15:13.760
I'm not doing it because I'm not booting anything.

15:13.760 --> 15:15.880
It's just faking it.

15:15.880 --> 15:20.120
For LavaPoint of view, it's actually booting something.

15:20.120 --> 15:24.440
You see that the screen is a bit too small.

15:24.440 --> 15:29.600
You see that it looks like a board is booting, but it's just printing text.

15:29.600 --> 15:33.760
But that's enough because that's filling all the requirements from the LavaPoint of

15:33.760 --> 15:36.200
view.

15:36.200 --> 15:39.400
And you see it's just a program running.

15:39.400 --> 15:42.880
I can just, for example, do a login interaction if I want to.

15:42.880 --> 15:47.960
I want to check that Lava is able to log in automatically to send or write login parameters

15:47.960 --> 15:49.280
and password.

15:49.280 --> 15:51.840
I can create a program that will do that.

15:51.840 --> 15:57.720
Again, just doing the basic thing, booting.

15:57.720 --> 16:01.000
You see it's a small delay when printing.

16:01.000 --> 16:04.960
It's on purpose to fake what a real board does because a real board does not send all

16:04.960 --> 16:10.000
the characters in one row because the cellular takes some time to process, to transfer.

16:10.000 --> 16:12.360
So we fake that also.

16:12.360 --> 16:15.720
Now I have to send.

16:15.720 --> 16:20.160
You see that if I not send in the right parameters, it would do a login incorrect.

16:20.160 --> 16:23.680
If I'm sending the right one, it will log in as normal.

16:23.680 --> 16:25.440
Again, this is not doing anything.

16:25.440 --> 16:30.120
It's just pretending to run up a system.

16:30.120 --> 16:34.120
And then this is what usually what Lava is expecting when it's run tests.

16:34.120 --> 16:36.320
It's expecting some signals to have.

16:36.320 --> 16:39.560
And I can fake that also.

16:39.560 --> 16:45.680
If you look at what's inside, it's a bit too small.

16:45.680 --> 16:52.640
So inside the argument for my program, it's just a set of commands that I'm asking.

16:52.640 --> 16:55.480
I'm asking my program to print the lines.

16:55.480 --> 16:58.280
That's the line that you've seen.

16:58.280 --> 17:04.880
Then it's printing the different lines and accept to be interrupted like what UBOOT does.

17:04.880 --> 17:06.800
Then it has a shell.

17:06.800 --> 17:09.520
This is a prompt with UBOOT prompt.

17:09.520 --> 17:16.720
And it will look forever waiting for exactly this command, USB start, and et cetera, et

17:16.720 --> 17:17.720
cetera, et cetera.

17:17.720 --> 17:23.000
And for the fake DUT to work and to go to the next stage, Lava has to exactly send the

17:23.000 --> 17:24.000
right commands.

17:24.000 --> 17:26.600
And if it's not sending it, it will fail.

17:26.600 --> 17:31.960
So thanks to this list of commands that I'm expecting, I'm able to check that Lava will

17:31.960 --> 17:36.520
send exactly the same command from one version to another, because that's what a real board

17:36.520 --> 17:37.680
will expect.

17:37.680 --> 17:43.560
And at the same time, from the Lava point of view, it will have the output that is expecting.

17:43.560 --> 17:56.680
And for example, here, Lava will, it's waiting for getting a TFTP instruction to load the

17:56.680 --> 17:58.920
VM Linux over TFTP.

17:58.920 --> 18:00.640
So I'm waiting for this exact command.

18:00.640 --> 18:04.360
And when I get it, I will actually download it.

18:04.360 --> 18:09.800
I have a small script that will download over TFTP, download the file, check that it's present.

18:09.800 --> 18:11.560
That's what I said.

18:11.560 --> 18:13.680
What it sends should be meaningful.

18:13.680 --> 18:20.360
So all the tools should be available, what it should be.

18:20.360 --> 18:23.800
That's for the shop demo.

18:23.800 --> 18:27.320
So that's what the MailTile Lava project is doing.

18:27.320 --> 18:30.320
So we have a server, we have the workers that are working together.

18:30.320 --> 18:33.880
And instead of having a real board, I just have the domicile system.

18:33.880 --> 18:39.440
So it's actually running 28 different device types, including both that I've never seen,

18:39.440 --> 18:41.800
because I just need the logs and the commands that it's expecting.

18:41.800 --> 18:44.960
I don't need the real board itself.

18:44.960 --> 18:48.000
And it also allows you to test bootloader failures, for example.

18:48.000 --> 18:51.000
So that's something that's difficult to reproduce in real life.

18:51.000 --> 18:54.480
You have to damage your board if you want to have some specific errors.

18:54.480 --> 18:58.000
The system, meta-lava and domicile, they can reproduce the same error all the time, because

18:58.000 --> 19:03.560
it's just a specific output that Lava will have to see.

19:03.560 --> 19:09.480
If you want to contribute to this, to have your boards tested by Lava, so a fake board

19:09.480 --> 19:11.800
tested by Lava, please come to see me.

19:11.800 --> 19:15.720
I will be happy to add that to the system, and that will ensure that your board will

19:15.720 --> 19:20.680
still remain valid in the next time I'm working.

19:20.680 --> 19:24.480
It's a fun thing to do, to do system mocking.

19:24.480 --> 19:29.640
And just have to look at the interaction between the different systems.

19:29.640 --> 19:30.640
That's all.

19:30.640 --> 19:34.840
Do you have some questions before we go to the next meeting, next presentation?

