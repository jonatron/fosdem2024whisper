WEBVTT

00:00.000 --> 00:11.000
Alright, let's get started. So I'd like to introduce Barry Pollard.

00:11.000 --> 00:20.440
Hi everyone, thanks for coming. My name is Barry. I'm a web performance developer advocate

00:20.440 --> 00:25.760
in the Google Chrome team. I work on the Core Web Vitals initiative. I look after the web

00:25.760 --> 00:33.000
Vitals.js library, crux, lighthouse, Chrome DevTools, all sorts of things that work about.

00:33.000 --> 00:38.000
Today I'm going to be talking about better than loading fast is loading instant. I'm

00:38.000 --> 00:45.120
going to talk about a new feature that we've added to Google Chrome very recently. So show

00:45.120 --> 00:53.120
of hands. I'd like to answer this question. So who here? No one? No one? No one? No one?

00:53.120 --> 00:58.560
Oh, oh, look what happened there. Like nobody likes that, do they? Nobody likes staring

00:58.560 --> 01:03.480
at a blank white screen for ages. It's even worse whenever it seems to have loaded but

01:03.480 --> 01:07.800
nothing works and then something else comes in. So hopefully you're all here at the web

01:07.800 --> 01:14.400
performance track because you actually want websites to be fast. And Google tried pushing

01:14.400 --> 01:19.400
this initiative quite hard a couple of years ago. So we launched this Core Web Vitals initiative.

01:19.400 --> 01:24.680
Show of hands of no tricks this time. Anyone heard of the Core Web Vitals initiative here?

01:24.680 --> 01:29.640
Okay, good. Sometimes I ask this question and nobody has. So we released these three metrics

01:29.640 --> 01:33.880
and we measure them in Chromium, which means they're available in Google Chrome and Edge

01:33.880 --> 01:40.040
and all the derivatives and that sort of thing. Recently Firefox launched LCP. Yay. So we're

01:40.040 --> 01:43.160
hopefully starting to get cross-browser support for them. But there are three metrics that

01:43.160 --> 01:48.160
are supposed to measure three different facets of the user experience. And we give recommended

01:48.200 --> 01:53.600
targets and say whether you're good, whether you're poor or somewhere in between needs improvements.

01:53.600 --> 01:58.680
There is a change happening, by the way. We're changing one of the metrics. FID is dying,

01:58.680 --> 02:03.280
resting peace. We're going to be using it with IMP. I'm not going to talk about that

02:03.280 --> 02:06.400
now. I would love to talk about that. So if you want to grab me afterwards, because there's

02:06.400 --> 02:10.920
a lot going on there, but that's the whole subject of a whole other talk. What we are

02:10.920 --> 02:16.080
going to be talking about mostly is the first metric, largest contentful paint. And it's

02:16.160 --> 02:22.520
a measure of when you click on a link until the largest content appears on the new page,

02:22.520 --> 02:25.600
which is supposed to be representative of the pages mostly loaded. Maybe there's some

02:25.600 --> 02:31.480
other little bits still coming in there, but it's generally the pages pretty much there

02:31.480 --> 02:37.920
and the user can start using it and stuff like that. In this, we said 2.5 seconds is

02:37.920 --> 02:42.160
seen as good. Anything above four seconds is seen as poor and as I say, somewhere in

02:42.200 --> 02:47.440
between that, it's like, eh, could do as I'm improving. And 2.5 seconds sounds like a lot.

02:47.440 --> 02:50.720
I see a lot of people in the forums never read the comments, but I occasionally read

02:50.720 --> 02:54.840
them and they're like, oh, 2.5 seconds. Google thinks that's fast. That's terrible. And you

02:54.840 --> 02:59.400
think computers measure things in microseconds or milliseconds, stuff like that. 2.5 seconds

02:59.400 --> 03:04.240
seems really poor. But the truth is that's actually quite a difficult metric. Meeting

03:04.240 --> 03:07.560
two-thirds of websites don't meet that, because there's a lot that happens whenever you click

03:07.640 --> 03:14.080
on the website. We'll talk about that in a minute. So getting 2.5 seconds is a tough enough

03:14.080 --> 03:21.080
target. But to me, I'm looking beyond that and I'm saying, can we do better than good?

03:21.840 --> 03:28.920
How can we do better than 2.5 seconds? How can we get instant? And that is very difficult

03:28.920 --> 03:33.760
on the web, because the website, it's got an inherent slowness to it. It's a distributed

03:33.800 --> 03:40.200
system. The internet is a network of computers and you sit on the browser at one end, you

03:40.200 --> 03:44.800
make a request, has to go to a server, and then this other request has to come back.

03:44.800 --> 03:48.440
This is different than traditional software before the web came along, where you download

03:48.440 --> 03:54.760
it or throw in 18 different floppy disks or get that free CD-ROM that you got in the magazine

03:54.760 --> 03:59.080
and actually install it locally and nearly everything's available locally. The web, nothing's

03:59.120 --> 04:04.160
available locally, not even the program. Okay, the browser is, but after that, everything

04:04.160 --> 04:08.520
that you want gets there. And this, by the way, is the best case scenario. The reality

04:08.520 --> 04:12.840
is more like this. You connect to something, maybe you're on a mobile and it's a mobile

04:12.840 --> 04:18.080
network or an ISP and it's going through a million different switches and stuff, not

04:18.080 --> 04:21.640
even the server gets to some load balancer which connects to a server which then has

04:21.640 --> 04:24.880
to connect to a database which then has to get some of the stuff. The last talk talked

04:24.920 --> 04:29.320
about connecting to a database and doing that and gathering information and sending it back.

04:29.320 --> 04:36.320
So websites cannot be fast, or so you think. The SBA is one attempt to work around this,

04:39.760 --> 04:43.760
so it tries to load a lot of stuff up front, maybe prefetch some stuff and get stuff and

04:43.760 --> 04:50.760
do that. But that often results in this guy. Anyone seen this sort of thing before in the

04:51.760 --> 04:57.760
web? Oh, sorry, by the way, do we all know what an SBA stands for? Yeah? That's right.

04:58.280 --> 05:03.400
Spinner page application. So this has become far too common on the web where you take that

05:03.400 --> 05:08.560
hit up front, but to a worse degree. Like it's kind of expected with app installs. You

05:08.560 --> 05:12.640
sit there and you wait and you see the loading bar going on the web. You don't expect that.

05:12.640 --> 05:16.440
You're not doing that. Particularly if you're going to look at one thing, I want to know

05:16.440 --> 05:20.080
what time Barry's fantastic talk is. And you go there and you get this, you don't when

05:20.120 --> 05:24.640
the first time website, they don't use an SBA, by the way. But still, this happens too often.

05:24.640 --> 05:29.400
And do you know what it reminds me of, actually? It reminds me of growing up in the 80s, where

05:29.400 --> 05:34.200
you used to get this whenever you load stuff from a set desk and usually some funky music.

05:34.200 --> 05:37.560
Some of them even gave you games while they were loading the main game, because it took

05:37.560 --> 05:44.560
a while. And like the 80s was 10 years, twi... All right, I just realised how old I am.

05:45.160 --> 05:48.680
The 80s was a long time ago. And the fact that we're still dealing with this is kind

05:48.680 --> 05:54.440
of depressing. And that's before you even get to the browser. So once stuff gets to

05:54.440 --> 05:58.840
the browser, then it has to run that JavaScript. And that's where you see the spinny sort of

05:58.840 --> 06:02.880
stuff. It has to do style and layout. It has to do paint. It has to do composite. These

06:02.880 --> 06:08.240
are all different parts of the browser just creating the website once you get the code.

06:08.240 --> 06:13.320
And that takes quite a long time. And again, this is usually measured in milliseconds, but

06:13.440 --> 06:17.440
paints and composite and stuff like that can take an awful lot of time to actually do that.

06:17.440 --> 06:21.960
And particularly with, again, sorry to dunk on SPAs, but they end up re-rendering the

06:21.960 --> 06:28.480
page multiple times at quite a high cost. And you quite often end up with this. You

06:28.480 --> 06:32.880
get a beautiful picture of your webpage, but do not touch it. You can't interact with

06:32.880 --> 06:36.160
it for another couple of seconds. You know, you sit there and you click on something,

06:36.160 --> 06:40.760
nothing happens. And then suddenly the menu opens and you lose a 16 time and you're like,

06:40.800 --> 06:47.480
what the hell is going on? So to deliver instant loading experience, we need to be less reliant

06:47.480 --> 06:52.280
on both the network and the client side processing. So just solving the network doesn't really

06:52.280 --> 06:57.520
fully answer the question because of all that stuff that has to happen once you have it.

06:57.520 --> 07:00.720
So you've been asking, how can the browser help with this? And there's a couple of things

07:00.720 --> 07:06.040
to do about it. They all basically fall into these two categories. You can prefetch stuff

07:06.120 --> 07:10.640
in advance. So get it before you need it rather than waiting for the user to ask for it. You

07:10.640 --> 07:15.120
sit there and say, I'm going to try and get it in advance. Or take it a step further and

07:15.120 --> 07:20.360
actually pre-render the whole thing. So not only do you get the resources, but you actually

07:20.360 --> 07:24.760
do a lot of that browser work and actually lay it out, actually sit there and render

07:24.760 --> 07:28.480
it almost like we do this ourselves sometimes. I don't know about you, but I right click

07:28.480 --> 07:32.840
on a link and say open in another tab because I know it's going to take a while. I've been

07:32.920 --> 07:38.520
at this website before. Let that load in the background and eventually go there.

07:38.520 --> 07:42.280
Prefetch, been there a while. Service workers are shown as great things. They can go ahead

07:42.280 --> 07:46.600
and prefetch stuff, which is great for next navigation. It's also good for offline stuff.

07:46.600 --> 07:50.400
SBAs, as I said, I gave them a bit of abuse earlier, but they're quite good. Sometimes

07:50.400 --> 07:55.280
some SBAs in the boot right is trying to get you next stuff whenever it goes there.

07:55.280 --> 08:00.760
The browser has an inbuilt, HTML is an inbuilt decorative API where you can just do link

08:00.760 --> 08:07.360
rel prefetch, say I want this JavaScript as script. There's a new speculation rules

08:07.360 --> 08:14.360
API that I'm going to perform the basis of this talk. Prefetch, basic concept, this is

08:14.360 --> 08:19.240
from a site I used to work at. We're on a login screen. I'm pretty sure I know where

08:19.240 --> 08:23.880
the next page is going to be. Most people that come to this login screen are going to

08:23.880 --> 08:28.880
log in, hopefully, and they're going to want the app loaded. We go ahead here and we load

08:28.960 --> 08:35.960
the actual area. It's a client-select rendered app, one of those spinny things because how

08:37.320 --> 08:42.720
everyone was doing it at the time. We load the app itself, the CSS, the JavaScript. We

08:42.720 --> 08:46.920
load a couple of static resources, a list of town and counties, some banner images and

08:46.920 --> 08:49.880
stuff like that. We can't load anything for the user because we don't know what the user

08:49.880 --> 08:56.200
is yet, but we can at least get some of the stuff up front. Go ahead there.

08:56.200 --> 09:03.200
Safari Sense has pretty good support. Firefox were the first support in 2006, which is coming

09:03.600 --> 09:08.960
up 20 years ago. Chrome Edge and all that, they've had it since about 2010. Safari have

09:08.960 --> 09:13.480
had it behind the flag for four years and I have no idea why and why they won't enable

09:13.480 --> 09:19.360
it, but anyway. Safari users don't benefit from this. I wish they would do it, but I'm

09:19.360 --> 09:25.120
okay using this anyway because Safari users, and I'm an iOS user myself, typically are

09:25.160 --> 09:29.880
using an higher end device, not often with better networks and stuff like that. I won't

09:29.880 --> 09:34.240
not use this because they don't support it. I still think it's a good API for that sort

09:34.240 --> 09:41.040
of thing. Prefects can help improve future web page performance, but it gets it slightly

09:41.040 --> 09:46.000
better. It's when we're talking about taking that 2.5 seconds down to 2.2 seconds or something

09:46.000 --> 09:52.120
like that. It doesn't give you that instant feel. The options for that are pre-render,

09:52.240 --> 09:55.920
some of you might be aware there was a very similar API to Prefects where you could do

09:55.920 --> 09:59.880
link rel pre-render and the speculation rules that I'm holding off, I still haven't told

09:59.880 --> 10:06.880
you about. Pre-render has less support. Chrome's had it for a while. Safari and Firefox basically

10:07.400 --> 10:12.120
never implemented it. To be honest, I don't blame them. There was a lot of problems with

10:12.120 --> 10:17.800
it whenever we put it in there, used a lot of memories, we didn't specify it entirely

10:17.800 --> 10:22.400
properly. We've actually taken it away in Chrome. If you do link rel pre-render, and

10:22.400 --> 10:26.000
you're like, oh great, this is going to pre-render, it doesn't actually do that anymore. Despite

10:26.000 --> 10:32.600
its name, what it does is we call it no state prefetch. It scans through it and gets all

10:32.600 --> 10:36.040
the links in the document that you know, CSS, JavaScript, stuff like that. It doesn't do

10:36.040 --> 10:41.280
anything with them. It doesn't actually pre-render anymore. That was kind of because we hadn't

10:41.280 --> 10:45.160
couldn't solve some of the things. We were like, there's a bit of a footgun, people were

10:45.200 --> 10:49.520
doing it wrong and that sort of thing, causing more performance problems than solving it.

10:49.520 --> 10:52.640
We don't recommend this anymore. It's still supported. I think we're going to remove it

10:52.640 --> 10:57.720
at some point. It's deprecated. Don't use it. Because we have replaced it with a new

10:57.720 --> 11:04.720
thing. This page, the slides, I'll give you a link afterwards. We have a new way of doing

11:07.080 --> 11:11.560
pre-render called the speculation rules API. There's documentation written by myself.

11:12.520 --> 11:16.960
I'm going to give you the gist of this talk. It's basically, again, you put something you

11:16.960 --> 11:22.400
put in HTML. It's a JSON-based format. You sit there and say, I want to pre-render the

11:22.400 --> 11:27.960
source here. Pre-render, you can also do prefetch, by the way. That can be a good way of starting

11:27.960 --> 11:33.200
into this. But getting pre-render at the end is really, to me, the ultimate goal. You have

11:33.200 --> 11:37.200
a source list. To be honest, we made this optional in the next version of Chrome because

11:37.200 --> 11:40.600
we've given you a list. It's kind of obvious a list. Why do you need to tell us it's a

11:40.640 --> 11:46.120
list? You say source list and you give it a couple of URLs. This will, in effect, load

11:46.120 --> 11:52.640
up next.html in a hidden background tab that the user doesn't see and next.html. If they

11:52.640 --> 11:57.120
click on that, then it will swap it in with the current tab seamlessly without using it

11:57.120 --> 12:04.120
and you get that instant page experience. But how can you know where the user is going

12:05.120 --> 12:11.000
to go next? That's the real difficulty problem. Baz gave a great talk to open this to talk

12:11.000 --> 12:17.480
about the cost of internet browsing, particularly in other parts of the world, where we can't

12:17.480 --> 12:22.880
guarantee and maybe users don't want us to use up their bandwidth and stuff like that.

12:22.880 --> 12:27.240
It can be very wasteful doing this. In certain scenarios, you've got a pretty good confidence

12:27.240 --> 12:31.800
level of where people are going or the costs are lower and you're happy to do it. In other

12:31.840 --> 12:37.840
scenarios, that might be less what you actually want to do. Chrome does put some certain things

12:37.840 --> 12:41.600
if you save data on, if you're in low bandwidth connection, it won't do this sort of stuff.

12:41.600 --> 12:45.840
Still, you don't really want to do that. Even for yourselves, you don't want to say that

12:45.840 --> 12:50.640
every web page load now costs 10 loads in your backend server. That can cost you quite a bit

12:50.640 --> 12:56.680
and so on. We've introduced a new thing called document rules. Source instead of being a

12:56.680 --> 13:01.200
list is a document. Again, we're going to make this option obvious because we've got

13:01.240 --> 13:05.960
a where object. In this case, we're saying any link with the href matches the slash star,

13:05.960 --> 13:09.640
i.e. any internal link, and that includes if you've fully qualified it because it will

13:09.640 --> 13:13.280
figure out that it's actually an internal, except certain things. You can put an exception

13:13.280 --> 13:17.000
in here and say log out. Log out. We don't want to pre-render for whatever reason that

13:17.000 --> 13:22.280
will log you out. Most links are actually safe to render. There's websites crawlers,

13:22.280 --> 13:26.160
Googlebot, some of you might have heard of and so on. Putting things where clicking on

13:26.160 --> 13:30.520
a link causes a problem is a very bad practice and shouldn't really be done anyway. But there

13:31.440 --> 13:35.680
are certain times we do things we know we're not supposed to do. There is a facility to

13:35.680 --> 13:41.600
say don't pre-render certain things. There's an eagerness field where you can sit there

13:41.600 --> 13:46.200
and say I want to pre-render it since the page loads, which is over where you go to

13:46.200 --> 13:50.280
me. This one is the one that I'm talking about here. This is moderate. This means if you hover

13:50.280 --> 13:54.240
over a link or you actually start clicking it, when you click a link, there's a lot of

13:54.240 --> 13:56.920
things that happens. There's a mouse down event, then there's a mouse up event, then

13:57.000 --> 14:00.880
there's a click event, then it runs some unload pages and then eventually it loads the page.

14:00.880 --> 14:05.320
Just by doing it on that mouse down or touch down on screens, you get a little bit of

14:05.320 --> 14:09.400
a head start, 50 milliseconds, 100 milliseconds, and that can do it. If you do it on hover,

14:09.400 --> 14:12.960
you get a lot of head start because quite a few people were hovering over and then

14:12.960 --> 14:17.800
they're like, yes, you can use that time to actually go ahead and get it. There's a lot

14:17.800 --> 14:21.960
of JavaScript libraries that have done this, but this is now built into the browser. It's

14:21.960 --> 14:26.600
available right now in Chrome 121. It's not behind a flag, it's not behind an origin

14:26.680 --> 14:30.760
trial. We've been through that process and it's actually available for people to use.

14:30.760 --> 14:35.920
Let's try and do a live demo. This is not going to go badly at all, is it?

14:35.920 --> 14:54.920
Okay. We have lots of DevTools built for this. My application. Okay.

14:55.240 --> 15:02.120
So when I run this, this is the original version. I have two links up here, Apple and Orange,

15:02.120 --> 15:07.000
and I have a third link Kiwi. By the way, I've misspelled in my rules. So you can see

15:07.000 --> 15:12.840
it has pre-rendered Apple, pre-rendered Orange, and then it's failed to pre-render Kawa because

15:12.840 --> 15:16.760
I misspelled it deliberately to show you what would happen here. So you can see two of these

15:16.760 --> 15:27.560
are ready. Now, if I click on this, now, I'm going to zoom in here. This is the magic thing.

15:29.080 --> 15:33.800
And I think an LCP of zero milliseconds deserves a round of applause, but obviously nobody else.

15:36.440 --> 15:40.600
So we're not talking about making it a little bit faster. We are talking about making it instant,

15:40.600 --> 15:45.880
where you literally get a zero millisecond. There's nothing better than that. That go negative LCP time.

15:47.000 --> 15:50.040
Though thinking about it, I'm sure there's something we can work with it. I just prove

15:50.040 --> 15:54.600
I'm not just doing it. Like, listen, it's not the most complicated app. It doesn't take a while to do it.

15:54.600 --> 16:01.320
But if I take Kiwi, which wasn't rendered, 120 milliseconds, I'd say it's a very simple app.

16:01.320 --> 16:04.840
And we've got very good Wi-Fi here, which is going to screw up my next demo with something shocking.

16:04.840 --> 16:10.200
But anyway, so if you think about that, this is instant. This is a very fascinating network

16:10.200 --> 16:14.840
and stuff like that. I haven't slowed it down. But multiply that up if you're on a mobile network

16:14.840 --> 16:19.480
and slower. Again, you might not get the zero milliseconds, but in most cases you will,

16:19.480 --> 16:23.720
depending on how much they hover over it and so on. Sorry, that was the immediate load.

16:23.720 --> 16:30.200
If I go back to the hover over version, again, let me zoom in here.

16:33.480 --> 16:38.680
So it finds all these URLs. None of them are triggered yet. So it's found all these URLs as

16:38.680 --> 16:47.640
potentially ones to pre-render. And if I hover over it, you see it changes. So Apple is now ready.

16:48.760 --> 16:54.360
Orange is now ready. Kiwi, I think, having this one. So what it does is it works in a FIFO,

16:54.360 --> 16:58.840
first in, first out thing. So it's got rid of Apple and said, I want to keep two in there.

16:58.840 --> 17:02.200
Because again, there's memory usage by this. Effectively, you've got two more tabs open.

17:02.280 --> 17:09.640
So as you do, move around. If I do Apple again, it will pre-render Apple and it will knock

17:09.640 --> 17:13.240
the next oldest down to the bottom. At this point, I've already fixed everything. Everything's in

17:13.240 --> 17:17.800
the HTTP cache. So I'm not causing any network costs here. There is a little bit more CPU costs,

17:17.800 --> 17:21.880
so there would. But again, we're not thinking, and some people do read like that, by the way,

17:21.880 --> 17:26.520
but most people only hover over a link whenever they're actually going for it. And again, I click

17:26.520 --> 17:37.800
on it and you get that zero milliseconds LCP. So the demo works. And I don't know what you

17:37.800 --> 17:42.840
might be thinking. Okay, that doesn't fix the first page load. That's great once you're in

17:43.400 --> 17:48.200
an application and moving around. But quite often, it's the first one that's actually most of the

17:48.200 --> 17:59.240
problem. Excuse me, dry mouth. And that's true. But there's not much you can do for that first

17:59.240 --> 18:04.600
page load because you haven't even gone there. We can't do anything like that. But the browser can.

18:05.400 --> 18:10.360
So Chrome can look at this. And if you look at Chrome colon slash that predictors,

18:10.920 --> 18:15.160
you can actually see what the user does, what the browser does based on your past history.

18:15.800 --> 18:20.120
So I cleared my history down to get rid of all the sites I didn't want you to see here.

18:20.120 --> 18:29.080
But if I type in d e d e v e, at this point, it's got 100% confidence that I'm going to developer

18:29.080 --> 18:34.680
dot chrome dot com because I visit that site a lot. So before that, it was amber. I have a little bit

18:34.680 --> 18:40.200
of confidence there. Once it gets a think above 60% it will pre fetch the document and go there.

18:40.200 --> 18:44.200
Once it gives above 80%, it will say, okay, Barry is definitely going there. And I'll actually

18:44.200 --> 18:48.760
pre render the document. And you may have noticed whenever you click on Chrome, it will actually

18:48.760 --> 18:53.400
then be an instant page load. So that's a nice way we can use this. You don't need to do anything

18:53.400 --> 18:58.440
about it. So if you're worried that preender not everyone's ready for it, the browser is actually

18:58.440 --> 19:02.600
doing this. So you better be ready for it. And look at it. And there's various things analytic

19:02.600 --> 19:07.640
fighters can do and Google Analytics does and Google to ads do that they don't actually register

19:07.640 --> 19:14.360
until the page becomes active. And I might ask why am I so obsessed about instant?

19:15.000 --> 19:20.600
Like surely fast is good enough. And I think it introduces new options for web developers.

19:22.360 --> 19:27.400
Like, has anyone heard of view transitions here? Okay, a couple of you. So view transitions is a

19:27.400 --> 19:32.200
new API where you can do things like this. This is shamelessly stolen from the call well ex-colleague

19:32.520 --> 19:37.800
Jake Archibald moved on dammit. He created this nice little demo. And what does you click on

19:37.800 --> 19:41.960
something and it does this nice transition effect as you move around your website. That's

19:42.600 --> 19:47.560
used to be possible with bucket loads of JavaScript. We've now made it a little bit of CSS. And it's

19:47.560 --> 19:52.280
a lot easier and a lot lighter. The browser does most of the work on it. That works in single page

19:52.280 --> 19:58.440
apps. But what we're really hoping to do is launch it for I hate the term multi page apps. I like

19:58.520 --> 20:07.480
to call them web pages. But anyway, and yeah, let's try that on this one. Let's say this works

20:07.480 --> 20:15.560
really well as long as the Wi-Fi isn't amazingly good as it is here. So this is a multi page app

20:15.560 --> 20:23.560
version of that same demo. And if I click on any of the sort of links, you might have noticed a

20:23.560 --> 20:27.720
little bit of a delay there. Not much because I say the Wi-Fi is really good, but it definitely

20:27.800 --> 20:34.360
takes away from the experience. And I also knocked the network down to 3G, which

20:36.440 --> 20:39.560
can't see. But anyway, yeah, there's definitely a little bit of a

20:40.280 --> 20:44.760
jarring effect there, which it's not the worst thing in the world, but it takes out that magical

20:45.320 --> 20:51.240
view transitions effect. If you go to the same demo with literally just that Jason block button,

20:51.240 --> 20:55.880
other than that, it's the exact same code. I can't code this stuff. Jake can. So I just stole his.

20:56.120 --> 21:01.080
And you can see again, we got the list of the potential links. And if I hover over this,

21:01.080 --> 21:05.080
you see it's running. It's now ready. I click on it. It does that nice effect there. There's not a

21:05.720 --> 21:11.400
one second, two second pause before it does that effect. So things like this,

21:12.600 --> 21:18.120
you might consider not using them on a multi page app or a non SPAR, or you might even consider

21:18.120 --> 21:23.080
using SPAR architecture because it doesn't, you can't get things like this. Well, now, hopefully,

21:23.160 --> 21:30.040
you can. That's available behind the flag at the minute. We're still working on that one.

21:30.040 --> 21:34.760
But that was a real life demo on the real life Chrome. You can test these links yourself afterwards.

21:36.040 --> 21:40.040
So finally, what's all it's got to do with open source? Very good Chrome. Look at you,

21:40.040 --> 21:44.200
done it. You're multi billion dollar company and you can do this. Congratulations. Your

21:44.200 --> 21:49.480
thoughts down here were a little bit lower key. If you've got an open source project,

21:50.200 --> 21:54.040
I would like to ask you to consider adding sport for this. I think it's a very easy thing that

21:54.040 --> 21:57.800
you can do. I say there's a lot of libraries that do that lover link over effect. And they do that

21:57.800 --> 22:02.280
if you run a framework, Astro is one framework that's done that they've added support for this.

22:02.280 --> 22:07.800
So you can go in there using some weird JavaScript Astro config and it'll do it word press. And

22:07.800 --> 22:13.560
I'm really excited about this. So on the Google Chrome team built a WordPress plugin. It's got two

22:13.560 --> 22:17.400
options. Do you want to prefetch? Do you want to pre render? And which of these options do you want

22:17.400 --> 22:24.520
to use? And we can suddenly give this to millions of WordPress sites. So WordPress is powers a third

22:24.520 --> 22:28.920
of websites at the minute. Just by installing this plugin, they can go ahead and just get instant

22:28.920 --> 22:32.040
navigation. And I think it's worked really well for the WordPress type thing, which is typically

22:32.040 --> 22:38.760
static websites, blog posts or articles or brochure sites and stuff like that. So yeah,

22:38.760 --> 22:45.160
let's make 2024 the year of instant navigations. And here is a link to slides, QR codes, stuff like

22:45.320 --> 22:48.200
or I'm around. I've got a couple of minutes for questions.

22:55.800 --> 22:56.360
Yes in the middle.

23:01.800 --> 23:05.960
Yeah. So on mobile, sorry, the question was if it renders and hover, how do you handle it on

23:05.960 --> 23:11.800
mobile? So moderate was render on hover or milestone. Conservative is measuring my style only

23:11.880 --> 23:16.120
mobile because there is no hover at the minute. It only falls back to effectively the conservative

23:16.840 --> 23:22.200
option there. Now there's an argument for and against in some ways, mobiles quite often the

23:22.200 --> 23:27.000
one that would benefit the most from this sort of thing. In other ways, mobiles often more constrained

23:27.000 --> 23:32.120
and you don't want to use it. So maybe not overly using this API until we're more sure

23:32.120 --> 23:36.040
isn't a bad thing on mobile. But yet trick of that is other things we can do. People can use the

23:36.040 --> 23:40.360
list URL if a library wants to build it. As you scroll and viewport. And if it stops scrolling,

23:40.360 --> 23:44.280
maybe that's an option. Maybe that's something we'll bring to Chrome and so on. But the minute

23:44.280 --> 23:48.680
it's a little bit slow in desktop. I think there's someone up back there, sure.

23:56.840 --> 24:00.680
So question is if they're a way to protect, if it's preloading, is there a way to deny it? Yes.

24:00.680 --> 24:05.640
So there's two ways. One, we send an extra HTTP header sec purpose, which is either prefetch or

24:05.640 --> 24:11.640
prefetch and pre-render. And your server, if you send back a non successful status code, so if you

24:11.640 --> 24:16.840
send back a 500 or a full award or whatever, Chrome will go, okay, they don't want me to pre-render

24:16.840 --> 24:21.960
this, I'll leave it alone. And similarly on the page, there's API you can check, am I in the middle

24:21.960 --> 24:26.840
of pre-rendering? Or have I been activated? In which case, maybe don't fire analytics, maybe don't

24:26.840 --> 24:32.520
load this, maybe don't load that, whatever, and you can choose to do that. So we're over here.

24:32.600 --> 24:33.160
Second rule.

24:41.080 --> 24:45.640
So if you open a pre-render page in a new tab, at the moment it won't use a pre-render, it will go

24:45.640 --> 24:49.880
and render it separately. So it's linked to the page. Similarly, if you go away from that page,

24:49.880 --> 24:54.600
it discards the old pre-renders. So it is linked to the current tab at the moment.

24:55.960 --> 24:56.440
At the front.

24:56.600 --> 25:01.400
Are there any attempts to put this in a common standard?

25:01.400 --> 25:05.400
There is. It's going through. It's part of WCAG at the moment. We've asked the other browsers for

25:05.400 --> 25:10.680
their feedback. I say none of them implemented pre-render first. We think we've done a better

25:10.680 --> 25:15.160
job with this. We've got a proper spec for it. We've got lots of things we consider. If the video

25:15.160 --> 25:19.560
is playing, should it play? If this API is used and so on. So yes, it's going through this under

25:19.560 --> 25:24.520
theization process. That's not to say other browsers will definitely like it. But we're

25:24.520 --> 25:27.240
definitely at least trying to do our part to push it out there.

25:29.560 --> 25:32.040
At the front. I'm probably running out of time, but go ahead.

25:44.680 --> 25:44.840
Sorry.

25:54.600 --> 25:58.120
The service, well, the speculation rules allows the rendering, which,

25:58.840 --> 26:03.480
oh, good point. The question is, if you use something like service worker to prefetch stuff,

26:03.480 --> 26:07.800
how does that compare with speculation rules? Service worker is pretty good about getting

26:07.800 --> 26:13.960
resources. Speculation rules is more about getting the actual document itself. As I said earlier,

26:13.960 --> 26:18.680
it sends headers. In certain scenarios, you can reject and say, hey, this is one that's live up

26:18.680 --> 26:23.400
to date. Must be live information. Don't do anything with it. There's more obvious to the

26:23.400 --> 26:27.960
server side. And it also offers the pre-render option there. Saying that, service workers are

26:27.960 --> 26:32.680
still very good for getting the sub resources. And even with pre-render, if you've got service

26:32.680 --> 26:36.280
worker back on, maybe the pre-render happens faster rather than only being half pre-rendered

26:36.280 --> 26:40.200
than it goes there. I'm not sure how the time is. No, I'm afraid we're out. I'm

26:40.200 --> 26:43.640
feel free to grab me. I have chrome stickers, little dinosaurs, by the way. Anyone want some?

26:44.520 --> 26:52.760
Sorry. Anyone else? Are you all ready for it? Thank you very much.

