WEBVTT

00:00.000 --> 00:12.000
Thank you everyone.

00:12.000 --> 00:14.000
I'm Cesar.

00:14.000 --> 00:17.000
Sorry, those that can stay.

00:17.000 --> 00:18.000
Sorry.

00:18.000 --> 00:19.000
Sorry.

00:19.000 --> 00:27.000
And I will talk about the introduction to formal verifications of digital circuits,

00:27.000 --> 00:31.000
which I like very much and I hope you too.

00:31.000 --> 00:37.000
So why do I, why do you need the formal verification or what,

00:37.000 --> 00:40.000
why would you want to use formal verification?

00:40.000 --> 00:47.000
So it's like a tool for finding bugs and finding bugs is what you want to do, right?

00:47.000 --> 00:53.000
And simulation is another way to do it, to find bugs.

00:53.000 --> 01:04.000
And it's complementary, but in truth, I find I'm using more and more formal verification and not so much simulation.

01:04.000 --> 01:19.000
And it does help finding corner cases, which normal simulation you need to put many, many test vectors,

01:19.000 --> 01:24.000
random test vectors to be able to even try to find these bugs.

01:24.000 --> 01:32.000
Like you have a sequence, a bug which is trigger, maybe you forgot to reset a finite state machine, maybe.

01:32.000 --> 01:38.000
And if you don't test in that sequence, you will miss the bug.

01:38.000 --> 01:40.000
And the formal verification will find the bug.

01:40.000 --> 01:43.000
It's really great.

01:43.000 --> 01:46.000
So here is a comparison.

01:47.000 --> 01:58.000
What does traditional simulation does and what does the formal verification equivalent or near approximation is?

01:58.000 --> 02:08.000
So in traditional debugging simulation, you want, maybe you make a simulation a few steps.

02:08.000 --> 02:13.000
When to look at the result, the traces to see if it's going all right.

02:13.000 --> 02:15.000
The equivalent is the cover.

02:15.000 --> 02:18.000
It's not like a software coverage.

02:18.000 --> 02:20.000
No, it's something different.

02:20.000 --> 02:23.000
You tell what you want to see.

02:23.000 --> 02:25.000
So you don't drive the inputs.

02:25.000 --> 02:29.000
You let the formal verification engine drive the inputs.

02:29.000 --> 02:33.000
And you say, I want to see three transactions.

02:33.000 --> 02:42.000
Every time there is a transaction, a write or a read, I count and I want that count to be three.

02:43.000 --> 02:50.000
And the engine will go and do everything it can to find these three.

02:50.000 --> 02:54.000
An input will give you these three transactions.

02:54.000 --> 02:59.000
If it can't, it will complain, not able, not possible.

02:59.000 --> 03:03.000
What is the equivalent to unit test?

03:03.000 --> 03:10.000
In unit test, you put some test factors.

03:10.000 --> 03:15.000
And you actually assert the result.

03:15.000 --> 03:17.000
So it's automated.

03:17.000 --> 03:19.000
It's not manually.

03:19.000 --> 03:24.000
In formal verification, you have bounded model check.

03:24.000 --> 03:29.000
You have your model in a bounded, in a limited number of steps.

03:29.000 --> 03:36.000
I want to drive this model and simulate it and see if it reaches a bad state, an assertion.

03:36.000 --> 03:39.000
But it's not like an assertion.

03:39.000 --> 03:44.000
If I put input two, it needs to return four.

03:44.000 --> 03:46.000
It's not like this.

03:49.000 --> 04:00.000
You have to assert that given the inputs which are driven by the formal engine, what the output should be.

04:00.000 --> 04:03.000
It's not a fixed number, not a fixed test.

04:04.000 --> 04:10.000
Test fixture is when you don't start from the beginning.

04:10.000 --> 04:16.000
Maybe you have several tests which share some common starting point.

04:16.000 --> 04:20.000
And you start from there.

04:20.000 --> 04:31.000
The closest equivalent will be K induction, where the engine will try from any state to reach the bad state.

04:31.000 --> 04:42.000
Or it will prove that from no starting point, it will reach a bad ending point, where the assertions doesn't hold.

04:42.000 --> 04:51.000
So equivalent for random test cases, maybe you want a coverage, yes, for your system.

04:51.000 --> 04:58.000
You try hand only because generated by hand is not feasible.

04:58.000 --> 05:06.000
You try to reach a corner case, but you cannot guarantee.

05:06.000 --> 05:17.000
You cannot actually see every random, will not cover every from zero to infinity or two.

05:17.000 --> 05:22.000
In the formal case, it does an exhaustive search of the inputs.

05:22.000 --> 05:25.000
So it's like random.

05:25.000 --> 05:28.000
If a random test will fail, it will find it.

05:28.000 --> 05:30.000
Yes.

05:30.000 --> 05:42.000
And the other difference is traditional tests can be procedure like you count, you do for loops, you call functions, maybe.

05:42.000 --> 05:46.000
In formal, everything has to be synthesizable.

05:46.000 --> 05:48.000
Everything needs to be logic.

05:48.000 --> 05:53.000
There is no software in formal.

05:53.000 --> 05:54.000
It's all hardware.

05:54.000 --> 06:06.000
So if you want to verify something, you have to make a test harness to catch it around it.

06:06.000 --> 06:13.000
In traditional simulation, you have a test vectors.

06:14.000 --> 06:20.000
Maybe a sequence of vectors, which you want to see.

06:20.000 --> 06:25.000
And then in formal verification, you assume.

06:25.000 --> 06:32.000
So it's not completely random, completely free.

06:32.000 --> 06:35.000
The engine has to follow your rules.

06:35.000 --> 06:44.000
So like if you have a valid signal, it has to stay stable while there is no ready from the next stage.

06:44.000 --> 06:59.000
Well, you have to tell it if it's, if valid is up, then ready, it will stay up while ready isn't false in the previous stage.

06:59.000 --> 07:02.000
So you assume inputs and you assert outputs.

07:02.000 --> 07:04.000
That's the rule.

07:04.000 --> 07:11.000
In traditional simulation, you also do assertions for automated testing, right?

07:11.000 --> 07:17.000
So the workflow in formal verification should be like this.

07:17.000 --> 07:25.000
In your high level definition, like harder definition language, you put the assertions.

07:25.000 --> 07:36.000
Then it can be a very long, a VHDL or any other language like Python-based language, harder languages.

07:36.000 --> 07:43.000
Then you make a work plan in the SSBI tool, which drives the process.

07:43.000 --> 07:45.000
What processes?

07:45.000 --> 07:54.000
First, you'll see, you may be remembered for the free FPGA and ASIC tooling.

07:54.000 --> 08:00.000
It will take your HDL to code that you can put into FPGA.

08:00.000 --> 08:07.000
Well, you also synthesize instead of an FPGA, it synthesizes to logic functions.

08:07.000 --> 08:09.000
Which logic functions?

08:09.000 --> 08:18.000
Well, there is a state, which is a state of all your design registers, all your memory.

08:18.000 --> 08:30.000
There is an initial predicate which says, this state is initial, like the registers are zero, the system is the reset state.

08:30.000 --> 08:46.000
Then is the transition relation, and it takes a state to the next state, like a finite state machine, for instance.

08:46.000 --> 08:48.000
And then you have your assertions.

08:48.000 --> 08:56.000
All these are Boolean functions, like AND or NOT and NAND.

08:56.000 --> 09:07.000
And then, these other two uses as MTBMC proves correctness or outputs a trace.

09:07.000 --> 09:17.000
It does exactly a search for an initial path to the bad state, an exhaustive search.

09:17.000 --> 09:22.000
If the path is not found, the design is correct.

09:22.000 --> 09:29.000
And if found, it outputs an error trace.

09:29.000 --> 09:33.000
This is an example of a bad trace.

09:33.000 --> 09:49.000
So, you have an initial state where the predicate holds, and there is a transition from S0 to S1, where the conditions hold on S1.

09:49.000 --> 09:56.000
All the way to the final, the case state, where there is a failure here in the assertions.

09:56.000 --> 10:05.000
So, the engine takes all of this logic here and try all the inputs, so this one is true.

10:05.000 --> 10:11.000
And then it tells you the trace, which hitches this.

10:11.000 --> 10:26.000
So, the algorithm is, from zero steps, you prove the base case, which is no path from the initial state will reach a bad state in K steps.

10:26.000 --> 10:29.000
Like mathematical proof. This is your base case.

10:29.000 --> 10:42.000
Then, the induction step. No path ending into a bad state can be reached in K plus 1 states.

10:42.000 --> 10:53.000
So, if the base case holds, and the induction steps holds, then you prove it for infinite time.

10:54.000 --> 11:01.000
You can hope to simulate for infinite time, but here you can. Yes.

11:01.000 --> 11:08.000
Like, this is why we call it unbounded inductive proof. No bounds.

11:08.000 --> 11:18.000
With our finite proof, I can prove it for all time for any input.

11:18.000 --> 11:29.000
Okay. Well, but maybe, inductive case, I cannot prove it in K. We try K plus 1, K plus 2, etc.

11:29.000 --> 11:41.000
Well, not for infinite, it's guaranteed to end, because you have a finite states, a number of states.

11:41.000 --> 11:51.000
Your number of registers is finite, is limited, so it can be extremely huge, the state space, but it's finite.

11:51.000 --> 11:59.000
It's true to the power of the number of flip-flops you have, right? But it's guaranteed to terminate.

11:59.000 --> 12:10.000
And there are very clever algorithms, so you don't have to try every single combination.

12:10.000 --> 12:23.000
So, let's try starting simple, right? This is a register with feedback. No inputs, no output, just internal state.

12:23.000 --> 12:36.000
What is the state diagram of this? If it's 0, it will be 0, it starts 0 here, and it will keep being 0 for all time.

12:36.000 --> 12:51.000
It can never reach the one state if it starts from 0. So, we tell the engine, the formal proof engine, please prove that it will ever be 0.

12:51.000 --> 13:03.000
What he will search for paths which end here at 1. But there is no path. I can tell you, try one step, K equals 1.

13:03.000 --> 13:12.000
It will work because there is no path in one step which will reach actually in any number of steps, right?

13:12.000 --> 13:24.000
So, the base case holds, and the inductive steps also holds.

13:24.000 --> 13:41.000
Complicated a bit. Now we have a registered output. So, here my notation is, the first number here is R, which starts 0, and S will be a copy of R after 1 clock.

13:41.000 --> 13:58.000
So, it's also 0. If R was 1, then it will move to a copy of it in the next state, okay? And stay there.

13:58.000 --> 14:12.000
But you see there is no path to here. And if it starts 0 and 1 here, it will go to 0 and 0. It will copy, lose the 1 in the next step.

14:12.000 --> 14:23.000
It will copy the R. So, you can simulate the base case holds here.

14:23.000 --> 14:40.000
And the inductive case, well, just one, just K equals 1 is not enough here. Because from here to here, you can reach a bad state if you start from here.

14:40.000 --> 14:58.000
Remember, the inductive, the inductive, only the base case will start from the initial state. The inductive state, the inductive algorithm, the inductive step will start from, from, actually will start from the bad states.

14:58.000 --> 15:16.000
It will start from here, trying to reach a good state. So, it starts from here, finds it's here and says one step is not enough. So, we try two steps. With two steps, yeah, it cannot be done.

15:17.000 --> 15:29.000
We have two good steps, two good states and one bad state. No way. So, we have proven this case with two steps. No.

15:30.000 --> 15:46.000
So, well, let's complicate a bit. We have an enable now. The output can be 0, will not copy R, and then I enable it and it can be, it will be copied.

15:47.000 --> 16:04.000
So, enable, I put it here. So, it can be here or here. You see, I not label the transitions and the input is actually inside the state. I treat it as a state also. Why?

16:04.000 --> 16:20.000
Because the transition relation is between two states and maybe it's from the states and inputs, I get the next state. Well, I put the two together, the input and the state is the state.

16:21.000 --> 16:43.000
Okay. Because the transition relation is a relation, it's not a function of the inputs. So, you see from, if enable is 0, it will keep 0, 0, 0. Likewise, if enable is 0, it will keep where it is.

16:44.000 --> 17:02.000
If enable goes to 1, then, well, it goes to here. If enable goes to 1, yes, it will copy. The input will be copied on the output.

17:03.000 --> 17:24.000
Yes, here. Here you have, for instance, R is 0 and S is 1. And enable now is 1. So, in the next state, that R, the S will copy R. But you see, I'm asserting only that S must be 0.

17:25.000 --> 17:44.000
So, R, I don't care. I don't know, actually. It's inside the design. So, only these states are where S is 1 are bad. And all the states where S is 0 are good.

17:45.000 --> 18:04.000
Independent of R. So, you see, the base case is good with two steps. It will never reach. The base case will never reach these bad states from here. Never, ever.

18:04.000 --> 18:33.000
And it will never reach. And, but now, what about if I have a, I'm in a bad state here. Okay. So, I try one, two steps. Okay, I, let's, I'm not proving induction, I cannot prove induction in only two steps.

18:34.000 --> 18:52.000
You see, there is a path here. What is the path? R is 1, R is 0. Not enabled. Then I enable. So, it is copied. Now, R, S is 1. It's a bad state. So, in two states, I can reach a bad state.

18:53.000 --> 19:12.000
So, let's try three. What happens in three? Well, I just repeat this. One, two, then three. One, two, then three, and four. Yes. So, you see, this loop here. So, I can try K equals four, K equals five.

19:13.000 --> 19:33.000
Induction will never prove it. Induction will never work. Why? Because I'm allowing this loop here. So, in induction, you, you can't have loops, actually. Yes. Some engines will remove the loop for you.

19:33.000 --> 19:52.000
Loops actually don't matter because you're only repeating yourself. Right? If there is a bad trace and you put a loop to repeat it, something in the middle, it only makes the trace longer. So, trace loops doesn't matter. No matter.

19:53.000 --> 20:11.000
So, two ways to solve this. I break the loop. I say, if enable is zero, then in the next step, enable must be one. I put a logic around this. This is the assumptions. Okay?

20:12.000 --> 20:36.000
The other way to solve this is to look inside and say R should be equal always to S. It will not make the proof wrong, wrong, because you are only strengthening the, the, the assertions.

20:36.000 --> 20:54.000
You're not allowing anything more that you already have. So, if you say R must be equal to S, you are not doing anything wrong. So, what will happen is these two will gain the X.

20:55.000 --> 21:12.000
By the way, the X, I said, are the bad states, right? The X, you, you, you know it. So, now I put X here and X here. So, the induction only has this, this X is up there too.

21:13.000 --> 21:32.000
To see about. And then in K steps, it works, because there is no arrow from here, from, from these bad states, you can go to here, but, but, but not from here. So, induction will work if these two are bad states.

21:33.000 --> 21:41.000
Okay. So, this is the kind of thing you have to worry about in formal verification. Yes.

21:42.000 --> 22:06.000
Well, this is a flip flop with input. So, R will equal D after one and eight, one step. So, it goes from zero. It can start from here to here. And in next step, S will be equal to, to D, R will be equal to that, to D.

22:07.000 --> 22:25.000
So, it will be one on one. Or if it's zero, next D is zero, it will stay zero. So, but you actually cannot verify this. You cannot verify, like this, you cannot verify that D equals R.

22:25.000 --> 22:52.000
Because D will, R will equal D in the next clock. So, with this, you cannot assert anything. So, what you do, you put a test harness around it. So, you capture D in S. Now, S is extra logic, which you need to prove that the flip flop works.

22:53.000 --> 23:17.000
So, I have here D, R, and S. So, R, S is supposed to be equal to R, equal to zero. So, it's supposed to, or if D is one, then eventually both will get one. So, the good states are zero, zero in the end, R, and S, zero, zero, zero, zero, or one, one, one, one.

23:18.000 --> 23:41.000
What are the bad states? Zero, one, one, zero. One, zero, zero, one. So, yes, the induction will work here, because this bad state can actually be reached. So, with zero, zero, or one, it will already work.

23:42.000 --> 24:02.000
So, this is an instance then where you need extra logic, external logic to prove things. And this is, well, I will not talk about this one, I just put it to scare you. Okay? Too many arrows, too many states, okay? Okay.

24:03.000 --> 24:22.000
Okay, so this is what will be, this will look in high level definition, much high language. This is very log. So, we like usual, the simple one which has the feedback. So, R equals R.

24:23.000 --> 24:46.000
And then, you have this extra thing here which, if formal is definition, is defined, then you assert that R is false. Okay? Not R, or you could write here R equal equal zero. It's the same thing. Okay?

24:47.000 --> 24:56.000
And this one won't be present if you target an FPGA, for instance, only on formal.

24:59.000 --> 25:13.000
So, you write the symbiosis write file, you prove, you put into the mode prove, you can do also BMC, only the base case here, or induction, you can choose.

25:13.000 --> 25:37.000
Here's the decay that I talked about. It is one or ten, what you need to put here. Then, the nice thing about UOSIS and formal verification, the engine which proves that statement, the long logic statement, this one, the engine is standardized.

25:37.000 --> 26:05.000
This output is a standard, so you can put, you can choose the engine you want. You drive it from UOSIS, but what proves is actually EISIS or Z3 or anything else that assets the output logic description that UOSIS outputs.

26:06.000 --> 26:31.000
Okay? So, this is instructions from for UOSIS here, and there's one missing here, which it is implicit, which is write SMT, write the logic here. But here you put the number of, name of the VADILOCK file and the top level of your design and the files here.

26:32.000 --> 26:51.000
And then you run it and it says induction, trying step one, trying step zero, and trying base case, summary, pass, it pass, so, proof, successfully proven by K induction.

26:52.000 --> 27:12.000
And it passes. And you put this into your test suite, GitHub, something, GitHub, or not GitHub, sorry, if you can. Continuous integration test suite, yes, CI.

27:13.000 --> 27:38.000
This is an example with a Python-based language, so you put imports here. This is an engine, by the way. I put here two registers instead of one because it will optimize away if I put only one with feedback, so I put two with feedback.

27:38.000 --> 28:00.000
Okay? And S will equal run and R2 in the next cycle. If the enable is true. This is one with enable. And then you assert that S is false, always, because in the initial state is false, is zero. So it will all be zero.

28:01.000 --> 28:22.000
And that is what happens, forget this about a moment. It will fail induction. You remember, you can stay with enable false for infinity. That was a loop. So it outputs the failing case here.

28:23.000 --> 28:37.000
It will start in the case where R is one and S is zero. And I don't only care about S being zero, but S will be one here. How?

28:37.000 --> 29:01.000
So enable was false for a long time. Then in the last possible time, it raises enable to one and you are cooked. Yes, you failed. So you go back and do the things I said.

29:01.000 --> 29:20.000
You assume that R either enable is true or in the past enable was true. So you don't have a choice if you're not enable now, you'll be enabled next. So this, only this one will solve your problem.

29:20.000 --> 29:39.000
And the other one is this. You assert that the R, the internal state is zero, which is true. You are not making any more mistakes. You are only making stronger conditions. Now R must be false.

29:40.000 --> 30:03.000
Then you can prove it in five steps. And now it will pass. Like either one of these. This one, that's why I said this one is equivalent to gray box, maybe your design is not a black box. You need to see inside.

30:03.000 --> 30:26.000
There is an internal state which is not reached maybe. So this is how one way to put memories in the team. So test memories. So this is a memory. One way to test memories. You can have gigabyte of memory.

30:26.000 --> 30:50.000
But what you do is you only test one address, but which address, any address. And then if the address is that what we tested, it will be captured here. And if you read from it, it will show the capture data and the data need to be equal.

30:50.000 --> 31:19.000
So that's a way to test a memory. If it works for any one address, it will work for any address at all. So you can have gigabytes of memory or megabytes. That's the same for you. You won't simulate gigabytes of memory. It only simulates these registers and the memory location. One memory location.

31:21.000 --> 31:40.000
And this one is if you have a pipeline with streams, you can count the number of transactions coming in, the number of transactions coming out. And then you say the counts need to be compatible.

31:40.000 --> 31:59.000
You cannot have more coming in that coming out. That will mean you drop it, packets. Or if you have more out that coming in, then you are duplicating packets. So that's a way to test.

32:00.000 --> 32:06.000
And that's one. I'll skip. Okay. So thank you.

32:10.000 --> 32:13.000
Thank you.

32:20.000 --> 32:29.000
Questions. You have questions. I haven't till when.

32:30.000 --> 32:34.000
My talk ends in five minutes. So you can. Yes, please.

32:34.000 --> 32:40.000
In the example you've shown, I saw that the depth was manually specified.

32:40.000 --> 32:46.000
Wait. If you can wait a bit before leaving, I still have five minutes, please.

32:46.000 --> 32:57.000
So in the Python code you showed, I saw that the depth was manually specified. If the proof changes over time or you adjust your circuit, you need to also adjust the depth.

32:57.000 --> 32:58.000
Yes.

32:58.000 --> 33:01.000
And if the depth is insufficient, will the proof fail?

33:01.000 --> 33:12.000
Indeed. Well, the question was if you adjust the circuit, will the, will need more steps in the proof? Yes, definitely.

33:12.000 --> 33:20.000
And more importantly, if I change the circuit and I forget to change the depth, will the proof still pass if it doesn't have sufficient depth?

33:20.000 --> 33:26.000
If it has insufficient depth, surely we'll have a failure. Yes.

33:27.000 --> 33:37.000
Next question, maybe. No questions. Well, if you think about a question, please.

33:38.000 --> 33:42.000
I have five, some minutes left. Thank you.

33:46.000 --> 33:48.000
Okay. One more.

33:49.000 --> 33:53.000
How does this scan to big circuits? Like how much time does it take?

33:53.000 --> 33:55.000
Okay. Good question. Good question.

33:57.000 --> 34:12.000
So I thought, please come down, people. The question was if, how much time it takes, what the complexity is.

34:12.000 --> 34:19.000
So one problem with a final verification, you can never be sure.

34:19.000 --> 34:31.000
You can have a simple design which takes tens of minutes. You don't know why. You made a modification. It, one second.

34:32.000 --> 34:41.000
You want, because, and the other thing is solvers. Like I said, you can change the solver. Okay.

34:41.000 --> 34:49.000
If you change it, one will be fast. The other will be slow. If you change the circuit, vice versa. Okay.

34:49.000 --> 34:52.000
So it's non-deterministic, really.

35:01.000 --> 35:04.000
Yes. Good. Thank you.

35:04.000 --> 35:32.000
Sorry. I, I was a bit nervous earlier. I am actually a dev room manager for this session.

35:32.000 --> 35:38.000
So I, I'm partially giving instructions to people here. Okay.

35:42.000 --> 35:46.000
Thank you. So the audience thinks I'm, it was good. Perfect.

35:51.000 --> 35:53.000
Well, if there is no much.

35:55.000 --> 35:56.000
Okay.

36:02.000 --> 36:11.000
Excellent. Thank you very much.

36:18.000 --> 36:21.000
Okay. I'll finish then. Thank you very much. You can.

