WEBVTT

00:00.000 --> 00:12.000
Okay, next lightning talk. So we don't have a lot of time to switch between speakers.

00:12.000 --> 00:18.520
Please take a seat. Next lightning talk as Christian, who's notorious for being very

00:18.520 --> 00:25.200
good on staying on time. I did once a very great job. I benefit from that still. Yeah.

00:25.200 --> 00:29.100
So if you see me, I talk about containers a lot. So this time I would like to give an

00:29.100 --> 00:33.660
update to the HPC container conformance project, which we started or I started last

00:33.660 --> 00:39.780
year and which got a little addition by being introduced to the OCI working or we created

00:39.780 --> 00:44.860
an OCI working group together with some other folks. So what is the problem? I mean, to

00:44.860 --> 00:49.500
just maybe call it challenges, everyone knows modules, right? If you're not, if you're new

00:49.500 --> 00:54.500
to containers and you use native code, you most likely use modules to figure out what's

00:54.500 --> 00:59.620
the best binary for your program on the current system you add. So you do module load

00:59.620 --> 01:05.140
grow max and the module system will pick the best binary for the current system you are

01:05.140 --> 01:08.980
on. So it's a runtime decision, right? So you have a bunch of software in a software

01:08.980 --> 01:13.980
share and it would just pick the best one problem or not problem. I think it's a good

01:13.980 --> 01:18.380
thing with containers. You don't want to have a lot of binaries or different variations

01:18.380 --> 01:23.420
of binaries within the container. You want one, right? So a single set of libraries and

01:23.420 --> 01:29.660
a single binary for a given problem. So what we end up doing was to create multiple containers

01:29.660 --> 01:36.140
for different systems. Let's say for the CPU like Graviton, Skylake, Zen 3, or maybe even

01:36.140 --> 01:41.820
we use a name to identify a cluster we are running on. That's fun, but problem is how

01:41.820 --> 01:46.500
do you pick the correct image? Within the container space, you have something that's

01:46.500 --> 01:52.420
called an image index, which is just a matching artifact that says, okay, you are on an arm

01:52.420 --> 01:57.580
system, you get this image. You're on an AMD system, you get this in or Intel or x86

01:57.580 --> 02:02.740
system, you get this image. And if you are a wasm guy, then you even get another system.

02:02.740 --> 02:07.180
But the thing is that's not, that's not fine enough, right? It's very, it's very gross

02:07.180 --> 02:13.140
grained. You cannot just put like your, your, all your x86 code in this. So what we actually

02:13.140 --> 02:20.420
want is an image index that is more specific. So they can say, um, this CPU, this accelerator

02:20.420 --> 02:25.460
gives me this image. If I have this CPU, I get another one, maybe even configured with

02:25.460 --> 02:31.420
MPI in, in, in mind so that you say, like, if I have MPH, this version, I get this image.

02:31.420 --> 02:35.100
If I have open MPI, I get a different image. So you get the idea. So have a very, maybe

02:35.100 --> 02:39.740
long image index with different variations and then you pick the best image. And another

02:39.740 --> 02:44.500
thing that I didn't mention in the first slide is, uh, run times will go through the, uh,

02:44.500 --> 02:48.660
image index, the normal image index and we'll just pick the best or the first match that

02:48.660 --> 02:54.420
they get. So even if you have an image index with five different x86 images in it, the

02:54.420 --> 02:58.020
runtime will just pick the first one. It matches and off you go. And with this, of course,

02:58.020 --> 03:03.220
we, we cannot do this. We need to go through all the versions that we have, all the different

03:03.220 --> 03:09.020
specific images and then the runtime ideally picks the best image for you. Okay. So I did

03:09.020 --> 03:14.540
some hacking back in the days, right? So I changed or used an unused feature in the image

03:14.620 --> 03:19.820
index to make some identification. So I saw it. Okay. This is a broad will this and media

03:19.820 --> 03:26.820
driver and I hacked, uh, the Docker runtime to also recognize what the best image matching

03:28.260 --> 03:33.540
is for this specific platform you're on. So with this ugly heck, you were able to identify,

03:33.540 --> 03:38.580
create an image index with a lot of different images for different, um, different systems.

03:38.580 --> 03:42.980
And then you configured your runtime to search for a specific tech list, if you will, that

03:43.020 --> 03:49.140
was like hacky. And, um, I didn't intend it to be, I created a pull request for Docker,

03:49.140 --> 03:54.420
of course, what turned down, but, uh, because it's, it's, it's ugly, right? And what's ugly

03:54.420 --> 03:58.100
about it is that you need to implement it in every runtime. You need to implement it in

03:58.100 --> 04:02.780
any scheduler to make sure that it works. And this was of course bogus. So what we did,

04:02.780 --> 04:07.780
uh, as I said last year or the year before, uh, we created an HBC container conformance

04:07.780 --> 04:12.780
project to establish best practices and provide some guidance on how to build images for the

04:13.220 --> 04:19.220
HBC and how to implement the use of those images. The first thing, which is very brief,

04:19.220 --> 04:24.340
uh, is what we expect an image to behave or how it should behave. So the first one is,

04:24.340 --> 04:28.980
uh, we want, there are two types of containers, application containers, I call them and login

04:28.980 --> 04:33.700
containers. Uh, application containers is just if you have, for instance, a binary and

04:33.700 --> 04:39.820
you put the entry point to be this application, you can create an alias that just runs some

04:39.860 --> 04:43.540
program within a container without you knowing about it. So for instance, let's go release

04:43.540 --> 04:48.580
a example. You just, instead of running a binary, you point to an alias and then you

04:48.580 --> 04:54.260
run, um, this problem here is if you want to debug things, uh, and if you, it's, it's

04:54.260 --> 04:58.500
hard because the entry point is always tricky to get rid of, or at least I need to look

04:58.500 --> 05:03.820
up the Docker command or every time. The other thing is multi or a lot of HBC applications

05:03.820 --> 05:07.020
have multiple binaries you want to run. Maybe you have a pre-processor or the application

05:07.060 --> 05:11.100
and a post-processor with this case, you would have like three different images for this

05:11.100 --> 05:16.500
because the entry point is different. So that's kind of ugly for HPC is not really usable.

05:16.500 --> 05:20.620
What we actually want is a login container. So you start the container and it drops you

05:20.620 --> 05:27.620
into a bash. That's that way you can just, um, augment your, your script and just say

05:27.620 --> 05:32.940
a Docker run or a singularity run or whatever to, um, execute the GMX command. For instance,

05:32.940 --> 05:37.940
you can just run it here, uh, within a container and it just works. Um, another aspect that's

05:37.940 --> 05:42.420
very important, but everyone hopefully does it anyways is, um, that the user within the

05:42.420 --> 05:48.020
container, if you use a shop, a shared file system needs to be agnostic, right? So you

05:48.020 --> 05:53.460
cannot rely on a certain user within the container. So you might, or you should, um, make sure

05:53.460 --> 05:58.780
that the, that the container is able to run with nobody because the username will be dropped

05:58.780 --> 06:03.340
from external, uh, the user ID and group ID to have access to share file systems so

06:03.340 --> 06:06.660
that the process is owned by the user outside of the container and the container itself

06:06.660 --> 06:13.420
has no knowledge about the actual user. Um, okay. And then that's how we expect the container

06:13.420 --> 06:17.860
to behave. And I think that's common and already understood. I think I talked about, yeah,

06:17.860 --> 06:24.660
last time was annotations that was an idea of us HPC guys and girls, a simmering in our

06:24.700 --> 06:29.820
own soup and tried to come up with something to put forward. Um, that was kind of a nice

06:29.820 --> 06:35.900
exercise, but at the end, um, we jumped on the train of the image compatibility working

06:35.900 --> 06:42.660
group at the old OCI initiative. And you might ask, and hopefully a lot of you know it already,

06:42.660 --> 06:48.180
but what is the OCI? It's the open container initiative. It maintains the more the, the

06:48.180 --> 06:52.980
relevant specifications about containers. So what's the, what's the image like? How

06:53.020 --> 06:57.660
do, uh, run times interact with images and distributions and registries and so on. What

06:57.660 --> 07:03.300
is the distribution specifications or how do, uh, registry work and security stuff? So

07:03.300 --> 07:08.140
it's kind of like a body that maintains the specifications and we formed a working group

07:08.140 --> 07:14.500
together with others. Um, that's called image compatibility. So we want, as I discussed

07:14.500 --> 07:19.700
in the, in the beginning, we want to extend the manifest list or the image index to not

07:19.740 --> 07:26.740
only be able to, um, pick by platform by architecture, but extended so that you can make what I,

07:26.740 --> 07:31.700
what I said as a, as a desired state for the image index so that we can pick the right

07:31.700 --> 07:38.700
image and an optimized image for, uh, a certain application. And of course we want to express

07:39.220 --> 07:43.740
like what the image was built for, what we expect from the host, what runtime we might

07:43.740 --> 07:48.220
want to use and so on. All this cool stuff we want to incorporate in this. And why is

07:48.340 --> 07:53.580
it a better way? I mean we HPC folks, we like to, to do our own thing, right? And we are kind

07:53.580 --> 07:57.980
special and snowflakey, but this is of course a better way because we interact with the OCI

07:57.980 --> 08:02.700
community and we put it in front of them so that we can take into account other things

08:02.700 --> 08:07.420
like for instance, wasm is a thing, uh, haven't used it, but seems to be a thing and it's

08:07.420 --> 08:12.460
a runtime was in, was in the, was in the container ecosystem. And of course we also have different

08:12.500 --> 08:18.500
run times, right? We have like singularity, obtainers, saros, what have you. And, um, picking

08:18.500 --> 08:22.620
a runtime over the other is something that we are interested in. The wasm folks are

08:22.620 --> 08:27.980
interested in. Say you have a Kubernetes cluster and you have an x86 image for an application

08:27.980 --> 08:32.220
and a wasm image for an application. Maybe you want to pick one or the other like different,

08:32.220 --> 08:37.100
depending on the condition. So they want this, we want this as well. Uh, scheduling a registry,

08:37.100 --> 08:42.940
of course HPC is great, uh, but the container tech is much wider than HPC, say the least.

08:42.940 --> 08:46.380
And, uh, we want to make sure that we align with Kubernetes. We want to make sure that

08:46.380 --> 08:51.380
the registries are aligned with us and the OCI working groups have like, they have an

08:51.380 --> 08:56.940
oil machine of sanitization. So that's also very cool to do. Okay. Where are we now? Uh,

08:56.940 --> 09:01.580
we discuss around use cases and while discussing the use cases, we already brainstormed some

09:01.660 --> 09:07.820
implementation ideas and we came up with a couple of use cases or, uh, stand in, um,

09:07.820 --> 09:11.900
stand in stakeholders, let's say, um, for instance, like the first one, of course, and

09:11.900 --> 09:17.300
we are all building images. So the first one is image author. If you build a container

09:17.300 --> 09:22.260
image, you want to define this compatibility definition that we propose that we want to

09:22.260 --> 09:29.740
propose. Uh, easy. I, ideally it's implemented with an easy build of spec or geeks that, um,

09:29.740 --> 09:34.740
you don't need to do it yourself. So all the stuff you can put there and, uh, Vanessa

09:34.740 --> 09:40.220
already wrote a little tool for that. The other is of course a system admin that wants

09:40.220 --> 09:45.740
to make sure that the system that he's maybe pursuing, procuring, uh, is able to run the

09:45.740 --> 09:49.100
container. So you just go through all the competibilities and then you, you figure out

09:49.100 --> 09:54.500
what's, uh, what, what works and what not work. So that's all, uh, this good stuff.

09:54.500 --> 09:59.300
And, um, you also want to make sure that the configuration of your system is actually able

09:59.300 --> 10:03.740
to run this image. The end user just wanted to work, right? So we need to make sure that

10:03.740 --> 10:09.500
the system admin and the image author and the other stakeholders just hum together and,

10:09.500 --> 10:13.700
and conclude on a certain configuration. And that's what it wants to do. There are other

10:13.700 --> 10:19.180
use cases. I don't have time to go all of them, but, uh, we have a list of, of, of this

10:19.180 --> 10:24.020
use cases we are going through currently. Our meeting is every Monday. Uh, and if you

10:24.020 --> 10:29.740
want to join, please do. Um, I have some links. There are resources. The, the slides are

10:29.740 --> 10:34.660
available online. If you want to get in touch, we have an HPC container slack. We have an

10:34.660 --> 10:41.380
OCI slack channel. There is a HPC social slack channel as well. So if you want to have a

10:41.380 --> 10:47.620
more general overview and if you're at ISE, make sure to, uh, join our high performance

10:47.620 --> 10:51.040
container workshop. It's a tense edition. So we do it for 10 years now, which pretty

10:51.040 --> 10:57.040
cool. And we have a friends of container boat trip. So if you like to, to, um, meet

10:57.040 --> 11:01.720
container guys and girls, uh, make sure that you point your mark, your calendar at the

11:01.720 --> 11:10.720
13th of May. Yeah. That's it. Thanks. And now the famous and I think I'm good on time.

11:10.720 --> 11:17.480
Awesome. Maybe do, do I get a sticker if I do it three times in a row on time? You,

11:17.480 --> 11:21.600
you get a beer. Oh, even better. Right. We have time for one question.

