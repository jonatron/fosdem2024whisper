WEBVTT

00:00.000 --> 00:07.000
Thank you.

00:07.000 --> 00:29.620
My pleasure to introduce the next speakers, Jordy and Tillman, who are going to be speaking

00:29.620 --> 00:36.620
about SCION, the next generation internet. Can we get a round of applause please? Thank you.

00:36.620 --> 00:47.620
Hello everyone. Thanks for attending the talk. Thanks to the host for having us here.

00:47.620 --> 01:00.620
I'm a little bit of a rockstar right now. We are Till and Jordy. We both come from ETH Zurich.

01:00.620 --> 01:10.620
We are part of the network security group at ETH Zurich. We are also part of the SCION open source implementation team.

01:10.620 --> 01:26.620
First question, who has heard before about SCION? Okay, some people. You can skip the introduction and the overview.

01:26.620 --> 01:46.620
Okay, so for the rest, I will start introducing what SCION is. SCION is a clean design of an inter-domain architecture that considers security from design to achieve security properties,

01:46.620 --> 01:59.620
mainly availability, also transparency and control, reliability and scalability. So I want to make here clear that SCION has to do with an inter-domain network,

01:59.620 --> 02:15.620
so it doesn't have anything to do with inter-domain protocols or higher level protocols in that sense. And the other thing I want to highlight on this slide is that SCION is an open source project.

02:15.620 --> 02:28.620
So here you have the GitHub repo in which you can find the reference implementation of SCION. So in here you have also, well, Till will give more details afterwards.

02:28.620 --> 02:36.620
Here you can find also references to documentation and related stuff.

02:37.620 --> 02:49.620
So the second question is why does even SCION exist? So SCION comes as an alternative to our old friend, BGP IP Internet.

02:50.620 --> 02:58.620
So yes, this was created even before I was born, so imagine how things have changed so far.

02:58.620 --> 03:09.620
So SCION has the distinct aspect that incorporates those security aspects I mentioned before from the very inception.

03:10.620 --> 03:27.620
Why do we need this? Because we need a network that provides availability even under the presence of malicious actors because there are people interested in harming the inter-domain routing.

03:28.620 --> 03:41.620
So we can find some examples, current recent examples, so for example an outage caused to a Spanish ISP due to a BGP attack.

03:42.620 --> 04:05.620
And we have several malicious actors in Internet unfortunately from nation state actors to cyber criminal groups that are interested in harming and due to different reasons.

04:05.620 --> 04:13.620
They can be from political reasons to economic incentive, you can name it.

04:13.620 --> 04:29.620
And yes, sometimes the trust boundaries, so trust nature of the current routing architecture sometimes doesn't make it clear enough where the trust boundaries are.

04:29.620 --> 04:37.620
So probably some of you are hungry, maybe not enough for just running away and grabbing lunch.

04:37.620 --> 04:47.620
So I cannot offer you food like actual food but I can offer you some yummy desserts.

04:47.620 --> 04:53.620
In this case towards the end of the presentation we will give or we will present a couple of demos.

04:53.620 --> 05:19.620
One is a browsing demo using Scion, second one is a Scion word first person shooter, and finally we will walk you through steps and guidelines for developers that hopefully find this interesting and want to contribute or just use what's there so far.

05:20.620 --> 05:24.620
But first some overview of Scion.

05:24.620 --> 05:39.620
So the whole Scion ecosystem includes different entities from different domains or from research institutions to ISPs, to vendors and integrators and users of the system.

05:39.620 --> 05:51.620
All these ecosystems is nurtured by the Scion Association which is a non-profit organization responsible for the standardization of the Scion protocols.

05:51.620 --> 06:02.620
They are currently pushing and they have published three or four ITF drafts and they are pushing it to RFCs.

06:03.620 --> 06:11.620
So they are also responsible for managing the open source implementation.

06:14.620 --> 06:20.620
So here I try to summarize Scion in five distinct aspects.

06:21.620 --> 06:37.620
The first one is that Scion is a pathway where internet architecture meaning that end hosts are presented with path information in the network and they can make a choice of what path they use to send their traffic through.

06:37.620 --> 06:45.620
The second aspect is that Scion designs and implements a scalable trust infrastructure.

06:45.620 --> 06:49.620
I will go into a little bit more detail just in the next slide.

06:49.620 --> 07:03.620
It also designs and implements scalable path discovery basically in the control plane for trying to achieve rapid global connectivity.

07:04.620 --> 07:08.620
Then another aspect is that it has like multi-path nature.

07:08.620 --> 07:16.620
So as I said before end hosts are presented with several paths that they can use even simultaneously.

07:16.620 --> 07:24.620
And finally another aspect I would like to highlight in here is that there is already real world deployment of Scion.

07:24.620 --> 07:30.620
So these I will show you towards the end or the middle of the presentation.

07:31.620 --> 07:34.620
So first just some terminologies.

07:34.620 --> 07:41.620
My idea here is that you kind of get the idea or the gist of it so you are not completely abstract in this.

07:43.620 --> 07:51.620
So first term is that Scion organizes itself in trust in so called trust isolation domains or ISDs for sure.

07:52.620 --> 08:07.620
These trust domains as the name indicates are isolated trust so are nothing else that group of ASSs of autonomous systems that share a common trust route configuration.

08:07.620 --> 08:16.620
So they basically agree on a set of routing policies that they want to use.

08:17.620 --> 08:27.620
And the other term here is the core ASSs which are the ones in charge of managing meaning updating those TRCs and so on.

08:27.620 --> 08:32.620
And they also provide peering with other ISDs.

08:32.620 --> 08:34.620
So basically they isolate trust.

08:34.620 --> 08:36.620
This is an important point I want to emphasize.

08:36.620 --> 08:40.620
This isolate trust it's not another kind of isolation.

08:41.620 --> 08:47.620
Then the other part of the overview is the control plane.

08:47.620 --> 08:52.620
So here I will explain briefly how the control plane and the path dissemination looks like.

08:52.620 --> 08:54.620
So again this is an overview of code.

08:54.620 --> 09:02.620
This is full of details and you will find them in the documentation and references to the books and several papers that we have about this.

09:03.620 --> 09:12.620
So the routing information is disseminated to the network in these so called beacons which are these squads, these corals and squads in here.

09:12.620 --> 09:27.620
Those beacons are initiated from these core ASSs that I mentioned before and they are either propagated farther down the network in the local ISD and they are also propagated between these core ASSs.

09:28.620 --> 09:42.620
These beacons are authenticated and extended at every hop and every hop meaning every ASS on path decide how they extend these beacons.

09:42.620 --> 09:47.620
So they do it based on only their local policies.

09:48.620 --> 10:03.620
So yeah basically on the slide you see that they are disseminated and finally you have found some path information.

10:03.620 --> 10:14.620
You have already those segments, sorry those beacons have been disseminated and at the very moment they reach an ASS and here we can focus on the green ones.

10:14.620 --> 10:23.620
For example those are already usable so there is no need for convergence in that sense so this piece of information is already directly usable.

10:26.620 --> 10:31.620
This helps to achieve rapid path exploration and scalability.

10:31.620 --> 10:47.620
As I said before this is just a quick overview because I don't want to overrun with details but there is exhaustive evaluation on this scalability aspect of the control plane system.

10:47.620 --> 10:56.620
One other aspect I mentioned before is the multi-path nature of SIAM.

10:56.620 --> 11:09.620
So from the N-host perspective N-host retrieve path information from their local ASSs.

11:10.620 --> 11:19.620
So basically they request this path information and they retrieve several paths they can use simultaneously.

11:19.620 --> 11:27.620
So the path server, so called the servers in the local ASS that provides this information will provide to the N-host this information.

11:27.620 --> 11:35.620
So this is different from source routing so here N-host directly retrieves the path from their local ASS.

11:36.620 --> 11:52.620
This many paths or several paths allows applications for optimizing on different metrics so they might find some of those paths better in terms of latency than others.

11:52.620 --> 12:04.620
Others better in terms of bandwidth and they may hopefully find a point that better suits their needs, the application or N-host needs.

12:05.620 --> 12:27.620
So just for putting some numbers in here in the current production network, so the real fabric we are building, if you take two ASSs you will find from dozens to even hundreds of paths that can be used to reach the other endpoint.

12:28.620 --> 12:36.620
And last slide on this overview is this control plane and data plane slides.

12:36.620 --> 12:44.620
So the control plane is what I have just explained in the previous slides and the data plane is what I will try to explain right now.

12:44.620 --> 12:54.620
So as I said before N-host retrieve those path segments from local service and they combine them to create a path.

12:54.620 --> 12:57.620
So you can find here two examples of paths.

12:57.620 --> 13:05.620
So segments are combined in one path for packet one and in another different path for packet two.

13:05.620 --> 13:16.620
So once the N-host has encapsulated this information into the packet they send it out to the network.

13:16.620 --> 13:33.620
And routers forward packet based on the path information, so they inspect this path information which contains information of which one is the next hop and then routers can simply forward to this next hop.

13:33.620 --> 13:39.620
So this allows for simple routers and stateless operations.

13:40.620 --> 13:46.620
So as you can see here, so for example those packets may belong to the same application.

13:46.620 --> 13:57.620
For example, you send the packets or the N-host in this case send the packets using two different paths that in this case are even disjoint.

13:57.620 --> 14:12.620
So for example this can be useful if you have an application, it has a control channel, it can use low latency path for control channel and higher bandwidth path for the real application data.

14:12.620 --> 14:38.620
Okay, now, so I want to also convey the idea that there is already some tangible stuff so it's not, as I said before, it's not only a research project, of course there is a lot of research in it, but there is real deployment and engineering right now already in Cyan.

14:38.620 --> 14:45.620
So for that I will basically explain these two networks.

14:45.620 --> 14:51.620
So first one is the actual, the global Cyan internet, so the real production network in that sense, so the real fabric.

14:51.620 --> 15:02.620
And I will just introduce briefly some concrete ISDs in this case, those color bubbles that I showed at the beginning.

15:02.620 --> 15:16.620
And then I will also talk briefly about side lab test with network which is a completely separated network, in this case this is an overlay network that anyone can use and I will give more details afterwards.

15:16.620 --> 15:25.620
So in general this production network again is, this is not an overlay network, it's the real fabric, it's BGP-free.

15:25.620 --> 15:33.620
And it's currently deployed by several international ISPs, so here you have some logos, you don't have to look at them.

15:33.620 --> 15:45.620
Currently there are over 100 ASS and they are distributed in Switzerland, you find a few of them, also in the EU, in North America or in Asia.

15:45.620 --> 15:56.620
And the other thing about the production network is that recently also has been enabled Cyan-Claus-Bates access, in this case this is a commercial offering.

15:56.620 --> 16:13.620
But so just for you to know that if anyone happens to have like cloud deployments, they can also access the production network.

16:13.620 --> 16:24.620
Okay this is one of the examples, this is one ISD again, one of the, this color bubbles that I showed you at the beginning.

16:24.620 --> 16:30.620
This is the Education and Research ISD, Sierra is the fancy name.

16:30.620 --> 16:40.620
And here you find universities, in this case here you have some of those.

16:41.620 --> 16:51.620
This is a growing ISD so it's not closed, so more universities may come and some are interested in coming in.

16:51.620 --> 17:05.620
There are also other research institutions and research and education networks that also provide connectivity between those research entities.

17:05.620 --> 17:15.620
So here is a world map picture of how they are distributed roughly around the world.

17:17.620 --> 17:29.620
And then very shortly there are also industry use cases right now, so there is this secure, in Switzerland are those two that I'm going to introduce.

17:29.620 --> 17:39.620
The first one is the Secure Swiss Finance Network, so they are basically using Cyan and they are going to phase out the finance IP net that they are using.

17:39.620 --> 17:50.620
And by June this year, and by then they will have, or the network will have around 120 participants.

17:51.620 --> 18:05.620
And the other example similar to the Secure Swiss Finance Network is the Secure Swiss Healthcare Network that provides similar service for health professionals.

18:08.620 --> 18:16.620
So yeah, that was the real production network and this is Cyan Lab, which is the research network.

18:16.620 --> 18:23.620
In this case Cyan Lab is a globally distributed testbed to conduct experiments and test deployments.

18:23.620 --> 18:33.620
So anyone can join, so anyone in the audience can join this network just by downloading a virtual machine.

18:33.620 --> 18:41.620
So with background file you run background app and then you have your node attached to one of these transit nodes.

18:41.620 --> 18:45.620
So all of those are transit nodes, leaf nodes are not in here.

18:45.620 --> 18:57.620
And yeah, basically I'm not that interested in the names, so they may be a little bit unreadable, but different boxes are located in different parts of the world.

18:57.620 --> 19:01.620
So for example you have Korea, you have North American, also you.

19:02.620 --> 19:12.620
So yeah, Tillman will also give some pointers afterwards where you can find the information for joining Cyan Lab.

19:15.620 --> 19:27.620
So now we also have awesome Cyan project, so basically this is a compilation of projects that are related with Cyan.

19:28.620 --> 19:36.620
So we have from infrastructure projects, so we have people implementing Cyan into Fino routers, also express routers.

19:36.620 --> 19:46.620
We also have firewalls using Cyan and other kind of infrastructure related projects.

19:46.620 --> 19:55.620
We also have application projects, so we have the Cyan Naval Browser extension for example in Chromium.

19:55.620 --> 20:05.620
And we also have, so far as Cyan were, Quake 3 video game, video game client distance.

20:05.620 --> 20:10.620
And of course we also have the libraries.

20:10.620 --> 20:19.620
We have pointers to reference implementation again to network APIs and client and host stack in different languages.

20:20.620 --> 20:33.620
So we have in Go, then we have this client libraries for Java that Till will give some more information and explanation just right now.

20:33.620 --> 20:42.620
We also have client and host in Rust and bindings to other languages like C++ and Python.

20:43.620 --> 20:57.620
Then also this list includes useful tools, so Cyan is integrated in the CIT emulator, so if you are using CIT emulator you can also bring up your Cyan network.

20:57.620 --> 21:05.620
Then there is also escape libraries for package generation and YSAR plugins for packet capturing.

21:06.620 --> 21:13.620
So here is the first demo I want to show to you. I will just switch to the video.

21:13.620 --> 21:15.620
Okay.

21:18.620 --> 21:20.620
Yeah, I guess.

21:21.620 --> 21:34.620
So this is the Cyan browser demo and basically here you will see, so first of all this uses the production network.

21:34.620 --> 21:40.620
So you will see this basically browsing in the production network.

21:40.620 --> 21:50.620
This is part already, I just said, of these awesome projects in which we have projects of, so different projects using Cyan.

21:50.620 --> 21:54.620
So in here you can find this extension.

21:54.620 --> 22:01.620
You load one Cyan-enabled website, in this case for example the ETH website.

22:01.620 --> 22:09.620
And the extension provides some information about the resources and where they were loaded from.

22:09.620 --> 22:20.620
So here you see that the resources from the ETH domain were loaded via Cyan, so the green indicates Cyan and red indicates that they fall back to the GPIP.

22:20.620 --> 22:26.620
Of course this is configurable and you could choose not to fall back to anything if they are not available.

22:26.620 --> 22:38.620
Here you have some path information. You see that we stay within the Swiss ISD, so my client in this case is in the Swiss ISD, so we stay in there.

22:38.620 --> 22:44.620
Because the server happens to be located in the same ISD.

22:44.620 --> 22:47.620
Then an example of navigating to another ISD.

22:47.620 --> 23:00.620
In this case we navigate to the MacW University server and in here we see that resources are loaded, all of them via Cyan and we have also some path information.

23:00.620 --> 23:08.620
So here we see that we go from the Swiss ISD where my client is through this CERA education network that I presented before.

23:08.620 --> 23:16.620
So here you find the exact AS numbers that the traffic traverses.

23:17.620 --> 23:25.620
So here I type yet another example.

23:28.620 --> 23:34.620
And basically also we have more path information.

23:34.620 --> 23:40.620
This resource also happens to be located in the same ISD.

23:40.620 --> 23:47.620
If you really do find different ISS but this is not important information.

23:47.620 --> 23:50.620
So basically that will be it.

23:50.620 --> 23:57.620
Now this is just again for just showing that we fall back to the GPIP but this I already explained.

24:00.620 --> 24:05.620
The second demo I wanted to show is this Quake 3 demo.

24:05.620 --> 24:16.620
So here this demo is using the CYLAB testbed network so it's not using the production network.

24:16.620 --> 24:26.620
And here our client is located in note at ETH in Zurich and we connect to the server which is located in Magdeburg, Germany.

24:26.620 --> 24:31.620
We connect it to the server and okay.

24:31.620 --> 24:38.620
So basically here what you will see commands being typed.

24:38.620 --> 24:50.620
The piece of information I want to convey is that so different things that we have is this showpaths command that's CYM specific.

24:50.620 --> 24:55.620
And this showpaths command show all available paths from the client to the server.

24:55.620 --> 25:04.620
So you get a bunch of paths and well we see a little bit more of them.

25:04.620 --> 25:13.620
And the other thing is that for demonstration purposes what we do is we bind to the key to command next path.

25:13.620 --> 25:19.620
So then we can iterate basically and see how different paths provide different latencies.

25:19.620 --> 25:30.620
So we have this key shortcut and while we are playing you will see on the top left of the screen not right now but while we are playing.

25:30.620 --> 25:39.620
So this path for example, so if you saw before this path had 100 milliseconds latency, we start playing.

25:39.620 --> 25:48.620
And then what I was saying before is that now for example you see in the top left corner we have switched the path.

25:48.620 --> 25:57.620
So we just press this key shortcut and we iterate over the set of available paths.

25:57.620 --> 26:03.620
So this is for demonstration purposes for show that we can find paths with different latencies.

26:03.620 --> 26:20.620
We keep iterating, we see changes in latency, we see we keep iterating on the top left part of the screen and yes basically we see these different latencies.

26:20.620 --> 26:28.620
So hopefully this will stop now in the last frame and here for this specific path we receive this latency.

26:28.620 --> 26:41.620
So this interactive of course you can program this and adapt your application to have path selection algorithm that does it automatically and always takes the path with best latency.

26:41.620 --> 26:53.620
And yes that was it. I will now let the floor to Till for explaining the rest of the presentation.

26:53.620 --> 27:03.620
Okay thank you Jody. So now let's imagine you found all the science stuff very interesting and you tried to implement your own project.

27:03.620 --> 27:20.620
How would you go about that? Yeah the first step would be to go through this awesome science list that Jody presented earlier where you can find existing projects but also libraries, language libraries to connect to the science network.

27:20.620 --> 27:31.620
So these are probably most important ones for a new project. The first one here is the Go API that's like the reference implementation, the original implementation of science.

27:31.620 --> 27:41.620
It's the most comprehensive implementation. It contains everything including border routers, control servers and everything you need to completely run science.

27:41.620 --> 27:47.620
It also comes with language bindings for C, C++ and Python.

27:47.620 --> 28:06.620
More recently we have a Rust API 100% written in Rust and just released a few days ago we have an alpha version of the Java API and that's actually what I'm going to talk about in the next few slides because that's kind of the project I'm involved in the Java API.

28:06.620 --> 28:18.620
So yeah it's written in 100% pure Java. It is very similar to the Datagram channel that people may know from Java with a few exceptions.

28:18.620 --> 28:31.620
Datagram socket is currently not implemented but that's very pretty much the next thing to do in our list especially since I realized that a lot of existing older projects rely on Datagram socket instead of Datagram channel.

28:31.620 --> 28:43.620
The library also has an API for path inspection. This is pretty much all what science is about. You kind of get a lot of paths from your AS and you select the best path for your purpose.

28:43.620 --> 28:48.620
So yeah path inspection and selection is very essential.

28:48.620 --> 29:01.620
It also supports the SCMP protocol. SCMP is like ICMP for science. So again you have echo or ping and trace root commands available.

29:01.620 --> 29:14.620
So let's look at a very basic Java client. So this is a Datagram channel example and basically there's nothing to see here because it looks exactly like you would use a normal Datagram channel.

29:14.620 --> 29:30.620
The one thing to just bear in mind is for example the host name eth.ch that needs to be in sign and able to host otherwise you can't run that example and also your local machine needs to be somehow connected to the sign network.

29:30.620 --> 29:40.620
Let's look at a bit more interesting example. So there's an additional method. There are several ones but this is one that may be interesting. It's called set path policy.

29:40.620 --> 29:50.620
So what you can do of course is just go through all the paths that you get from your local ISP, your local AS and then pick the one that you want to use.

29:50.620 --> 30:05.620
But it's much easier if you can just define a path policy. In that case maximum bandwidth. You set that path policy on your channel and the channel will always try to find a path that suits this path policy.

30:06.620 --> 30:19.620
Now we're going to look at the server side. It's a little bit different from the native Java implementation in the sense that the receive doesn't return an Ionet socket address but a path object.

30:19.620 --> 30:25.620
And the path object does contain the Ionet socket address from the client that connected to the server.

30:26.620 --> 30:32.620
But it also contains the whole path that the packet actually took through the internet.

30:32.620 --> 30:37.620
And you can just use this path and to send a response back to the client.

30:37.620 --> 30:45.620
The idea here in sign is that usually if you send a packet to a server you would send it back the exactly same route.

30:45.620 --> 30:55.620
Technically you don't have to do that but it makes it a lot easier for the server because the server doesn't have to look up paths how to connect to the client.

30:55.620 --> 30:58.620
It's just much faster.

30:59.620 --> 31:07.620
So I mentioned path policies before. The Java library comes with some predefined path policies.

31:07.620 --> 31:22.620
Somewhat self explanatory probably but one path policy is called first. That just picks the first path that your AS gives you back when you ask it for a path to a certain destination.

31:23.620 --> 31:31.620
That's kind of a cheap way for the AS to actually recommend you a path. They think this is a path you should use.

31:31.620 --> 31:35.620
The next one is min hop that just tries to find the shortest path.

31:35.620 --> 31:44.620
So with the least hops in the path on hop being like a border router or other ASs you have to go through.

31:44.620 --> 31:56.620
Then there is min latency and max bandwidth which also pretty much do what you would expect them to do except that these implementations are non parameterized aesthetic.

31:56.620 --> 32:10.620
So they just rely on metadata. So you ask your AS for a path to get metadata back that kind of estimates the latency and give you like the allocated bandwidth for the short for the links in the path.

32:10.620 --> 32:18.620
If you want to have like really the best latency you would need to implement a new filter or I may also provide that in the future.

32:18.620 --> 32:28.620
A new filter that looks at all the paths, pings all the paths and then just selects the one that has a lowest latency.

32:28.620 --> 32:33.620
At the bottom of the list we have the ISD allow and ISD disallow filters.

32:33.620 --> 32:43.620
ISD being the isolation domain numbers that we previously saw, although this whole set of ASs.

32:43.620 --> 32:52.620
So basically isolation domains can map to countries for example or to something like the university network that we saw earlier.

32:52.620 --> 32:57.620
So these ISD allow and disallow can be used to implement something like geo fencing.

32:57.620 --> 33:06.620
And since the ISDs represent countries for example you can decide that you don't want your packets to go through a certain country.

33:06.620 --> 33:20.620
So imagine you're on the bottom left ISD in one of those ASs in that ISD and you want in your ISD is 110 and you want to send to ISD 130 and there are a lot of paths, some direct path.

33:20.620 --> 33:35.620
Some go out by 99 and one some path by 125 and 120 and for some reason you don't like ISD 99 which could be a country, could be just some other organization.

33:35.620 --> 33:39.620
And then you can just define your path policy like that.

33:39.620 --> 33:42.620
The exact syntax is a little bit different.

33:42.620 --> 33:45.620
So I simplified it here but it's pretty much that.

33:45.620 --> 33:58.620
So you can just exclude 99 so the filter will pick any path that is not and that doesn't go by a 99.

33:58.620 --> 34:06.620
So once you wrote your application, your first step, well not the first step but yeah, the next step is testing.

34:06.620 --> 34:13.620
And the common way to test sign is just to run a local network on your computer on your machine.

34:13.620 --> 34:20.620
And you can do that using the reference implementation that was mentioned earlier, the sign proto reference implementation.

34:20.620 --> 34:27.620
So what you do is first you define a topology in a file, topology file, then you run this command.

34:27.620 --> 34:38.620
This will create a lot of configuration files for all the border routers and control servers, demons and whatever needs to be started in your machine.

34:38.620 --> 34:42.620
Then you can view the topology if you like.

34:42.620 --> 34:53.620
So we have a very simple topology here with three ASs like the three ellipses, one core AS that's a button on the top and they all reside in the same ISD.

34:53.620 --> 34:55.620
That's just a simple example.

34:55.620 --> 35:04.620
There are also a number of topologies that are already in the repository so you don't really need to write your own if you don't want to.

35:04.620 --> 35:13.620
Then you just run the topology that will start up all the different processes for the different border routers, control services.

35:13.620 --> 35:19.620
They're all connected by loopback devices and then you can just connect with your local application to the network.

35:19.620 --> 35:30.620
In this case I just run a ping to the core ISD and that's the result.

35:30.620 --> 35:33.620
So there are other methods for testing.

35:33.620 --> 35:40.620
So there's for example the seed emulator that Jordy already mentioned that does support Sion.

35:40.620 --> 35:42.620
Then there's the Sion lab.

35:42.620 --> 35:45.620
This is a worldwide network of Sion nodes.

35:45.620 --> 35:52.620
If you want to use it you can go to the website, register, you can allocate your own ASs if you want.

35:52.620 --> 36:02.620
Then you can, as mentioned previously, download an image for a virtual machine and the virtual machine is like an AS that you run locally.

36:02.620 --> 36:07.620
You can even create several of those and then create a network.

36:07.620 --> 36:13.620
Then you can test in the production network but that requires you to actually have access to the production network.

36:13.620 --> 36:18.620
So if you're lucky your ISP supports that but there are currently not that many.

36:18.620 --> 36:26.620
AWS offers nodes that have Sion access so you can rent an AWS cloud center or something.

36:26.620 --> 36:31.620
Or maybe your university has access to the Sierra network.

36:31.620 --> 36:36.620
And finally for debugging there's a lot of command line tools.

36:36.620 --> 36:41.620
I think I mentioned ping and trace route before, show path and several others.

36:41.620 --> 36:45.620
And there's also a very neat wire shark plugin.

36:45.620 --> 36:57.620
So you can just look at Sion packets, inspect the header, look at the path that is associated with the header.

36:57.620 --> 37:06.620
So and if you want to contribute there are several tons of projects that could be done.

37:06.620 --> 37:13.620
You could carry your own project so we are still missing native libraries for C and C++ for example.

37:13.620 --> 37:17.620
There are no libraries at the moment for C sharp or swift.

37:17.620 --> 37:22.620
You could think about embedded or mobile devices.

37:22.620 --> 37:25.620
Also network protocols.

37:25.620 --> 37:29.620
For example Java implementation currently only supports UDP.

37:29.620 --> 37:42.620
We aim to use support quick and probably TCP very soon but there are many other protocols that would need support.

37:42.620 --> 37:47.620
Or you can just use one of the big existing projects for web proxies,

37:47.620 --> 37:52.620
HTTP servers or video conferencing clients like JITC or something.

37:52.620 --> 38:05.620
Or gaming libraries and try to make them sign a way so you can select path or automatically select good path in these projects.

38:05.620 --> 38:15.620
So yeah finally if you want help or support there's a Sion Slack channel, there's a Matrix channel.

38:15.620 --> 38:27.620
And since last week we also have a Sion tag on Slack overflow so you can tag your question with Sion and we have some developers subscribe to the tag and they will try to answer your questions.

38:27.620 --> 38:31.620
Yeah that's already from my side everything.

38:31.620 --> 38:36.620
Thank you and looking forward to some questions.

38:45.620 --> 38:48.620
Thank you for a great presentation.

38:48.620 --> 38:55.620
I have my question is regards security and protection against the DOS attack.

38:55.620 --> 39:04.620
So you allow everybody to select a path for packets and how do you protect against someone doing it maliciously.

39:04.620 --> 39:12.620
For example sending packets back and forth between ASS to overload the network.

39:15.620 --> 39:28.620
Yeah so the question was I think how do you prevent DOS attacks or how to prevent people abusing paths to send traffic for creating loops for example.

39:28.620 --> 39:32.620
So these paths that you can see here they all signed.

39:32.620 --> 39:37.620
So that makes it kind of impossible to create your own path.

39:37.620 --> 39:41.620
The paths are all signed by all the ASS on the way.

39:41.620 --> 39:47.620
And that also makes it a bit easier to prevent DOS attacks because you know where a packet came from.

39:47.620 --> 39:53.620
And if you don't like that region you can quite simply block everything that comes from that region.

39:53.620 --> 39:55.620
Thanks.

39:55.620 --> 40:00.620
Yes.

40:00.620 --> 40:08.620
I think a question is someone in the similar vein how do you deal with resiliency of the network which with.

40:08.620 --> 40:10.620
How do you deal with.

40:10.620 --> 40:12.620
Oh yeah the speakers.

40:12.620 --> 40:14.620
How do you deal with the resilience.

40:14.620 --> 40:22.620
Like the internet is very resilient because the routers can take independent decisions but if you select a path as a user and like a link goes down then like.

40:22.620 --> 40:28.620
Like information that information has to disseminate all the way back to the user so they can select a new route and then.

40:28.620 --> 40:33.620
Have their link up again instead of that just happening transparently to the user.

40:34.620 --> 40:35.620
So.

40:35.620 --> 40:46.620
Okay the point here is that normally you send the packet out to the network right and just pick routers to send it to the next hop just based on the destination information right.

40:46.620 --> 40:59.620
So when you have for example some link failing in the middle you need to converge to a stable state in which okay what's now the after the failure what's the next router I have to send the package to.

40:59.620 --> 41:15.620
So this is this takes some time and by that time your packet may be time out already so you need to still send the packet so with Sion you can already detect that when you see that the packet it's taking long or you don't get feedback and you can already take for example.

41:15.620 --> 41:22.620
Completely disjoint path and in that sense this failover mechanism is quite effective.

41:22.620 --> 41:44.620
So normally when link is busy you also get network feedback right so you see that packets are thinking longer latency is increasing so what you do is you as a user you are interested in taking a more.

41:45.620 --> 41:50.620
Healthy path in that sense if I can say that so you will automatically switch to that path.

41:53.620 --> 42:00.620
I have I have a question you showed in your API example that when you create a connection you specify the route.

42:00.620 --> 42:09.620
But supposedly a country changes you don't want to go your want your packet to go through a certain country then you have to change your software.

42:09.620 --> 42:15.620
Currently when I make a connection I only specify the destination and I don't care how it gets there.

42:15.620 --> 42:20.620
Now the information of how it gets there is mixed with where it should go.

42:20.620 --> 42:24.620
So when the route changes I need to change my client software.

42:25.620 --> 42:27.620
If I understand correctly.

42:30.620 --> 42:32.620
I hope I understood the question.

42:32.620 --> 42:38.620
So the routers become very simple because I don't need to do any decisions anymore.

42:38.620 --> 42:43.620
The only thing is they could verify whether the path is assigned past.

42:43.620 --> 42:46.620
So yes you do have to update your clients.

42:46.620 --> 42:49.620
The clients all need new libraries that could be.

42:49.620 --> 42:53.620
I mean I have a quite high level library with a Java but it could be an operating system.

42:53.620 --> 43:00.620
Just another driver that sits underneath UDP or TCP and adds like the sign path transparently.

43:00.620 --> 43:05.620
But yeah that's kind of the big work we have to provide updates for the clients.

43:05.620 --> 43:07.620
Let me add five cents.

43:07.620 --> 43:11.620
So there are also transition mechanisms right.

43:11.620 --> 43:16.620
So we have for example a thing so called Sion IP Gateway.

43:16.620 --> 43:22.620
So there for example traditional IP applications so you have your applications in a certain subnet

43:22.620 --> 43:25.620
and this traffic gets to this Sion IP Gateway.

43:25.620 --> 43:29.620
And this Sion IP Gateway encapsulates traffic to the Sion network.

43:29.620 --> 43:32.620
So in that sense you don't need to change for example with this transition mechanism.

43:32.620 --> 43:35.620
You don't need to change your application.

43:35.620 --> 43:41.620
Of course the application is not taking like the best properties in that sense.

43:41.620 --> 43:49.620
For example then you would not be as application choosing your path and optimizing for all of those or for some of those metrics.

43:49.620 --> 43:58.620
But you can still let this traffic go to this specific gateway and then this gateway will decide for you depending maybe on policies

43:58.620 --> 44:01.620
and local policies where do I send this traffic to.

44:01.620 --> 44:08.620
I don't mean the one time conversion of course if you switch to a new network protocol you have to change your software.

44:08.620 --> 44:17.620
But it's more the dynamic stuff when now my provider decides if some AS is out of the loop.

44:17.620 --> 44:21.620
But now I have to decide that as a client.

44:21.620 --> 44:27.620
Yes but you can easily default to whatever paths your provider provides to you.

44:27.620 --> 44:31.620
So you can always pick your default and just don't care about the rest.

44:31.620 --> 44:39.620
But on top of that you have the choice as an host to decide where you want to send your traffic to.

44:39.620 --> 44:47.620
If your for your use case is not important whether your traffic goes through I don't know any country you name it.

44:47.620 --> 44:55.620
Then you can just fall back to the default paths and then you don't have to make this decision if so.

45:01.620 --> 45:12.620
Is path selection always from the client side or can the server make a decision of what paths are acceptable.

45:12.620 --> 45:22.620
So the password is usually the client would connect the path server in his AS in its AS to get a selection of paths and we would use those paths.

45:22.620 --> 45:30.620
And those paths are sent to the server and the server could look up a different path to the client in theory but that feels a bit ineffective.

45:30.620 --> 45:37.620
So they can just reverse the path what's automatically reversed in this API to you send the packet back.

45:37.620 --> 45:49.620
Yes but just adding something else. There are some projects for example that try to make some negotiations so the server can signal or indicate the client.

45:49.620 --> 45:57.620
What's the best path to choose in their opinion but this is also like separate from the vanilla side I don't think.

45:57.620 --> 46:02.620
This is something you could put in place.

46:02.620 --> 46:05.620
I have a few questions but they should be quick to answer.

46:05.620 --> 46:12.620
So I've read about this thing called secure backbone autonomous system which is where you advertise better routes to existing BGP infrastructure.

46:12.620 --> 46:18.620
Is this in wide deployment is this popular is it being used.

46:18.620 --> 46:24.620
Also have there been any experiments with Wi-Fi does Zion work well in wireless context.

46:24.620 --> 46:29.620
Also in the quake example I didn't see an IP address in the quake demo I saw some other sort of address.

46:29.620 --> 46:34.620
What is that address. It's like the ISD or something.

46:34.620 --> 46:42.620
So I got the first and the last questions I will try to answer those first.

46:42.620 --> 46:45.620
So the first was talking about as much right.

46:45.620 --> 46:58.620
So as much is also an incremental deployment model architecture which basically is a hybrid between BGP and and so in that sense.

46:58.620 --> 47:12.620
The idea very basic idea and I'm not the one like involving the project but very basic ideas that you combine BGP so that BGP are announced closer to this backbone.

47:12.620 --> 47:22.620
And then you use this backbone as secure backbone and then you go out to the Internet again hopefully close to the to the to the destination.

47:22.620 --> 47:27.620
So the specific question was about the current deployment so it's under deployment.

47:27.620 --> 47:38.620
So some members in our team are making efforts and this I would say should be soonish already to be used in production.

47:38.620 --> 47:42.620
It's not yet there but it's there.

47:42.620 --> 47:46.620
The last question was about the address format right.

47:46.620 --> 47:58.620
So yes the address format that you saw is composed of the ISD so this color bubble and a yes the individual is of the of this ISD.

47:58.620 --> 48:05.620
So these two numbers plus the end host the end host address.

48:05.620 --> 48:10.620
This end host address has a scope within the autonomous system.

48:10.620 --> 48:28.620
So you could use basically any address you want but the scope of this end host address is specific to this specific autonomous system which is indicated by the ISD plus AS numbers.

48:28.620 --> 48:36.620
There was just one more question about wireless. Is there any experiments with wireless? Has anyone done anything?

48:36.620 --> 48:47.620
So now we will be starting projects for supporting Sion in Android and there we are going to go deeper on that.

48:47.620 --> 48:59.620
But of course I mean for example if you are interested in providing wireless support and optimize for wireless this Sion use case I mean you are more than welcome.

48:59.620 --> 49:08.620
But yeah.

49:08.620 --> 49:23.620
Thank you for the talk. My question is you mentioned earlier at the presentation that there is a way to update ASS which nodes which which nodes can be trusted with the further routing.

49:23.620 --> 49:38.620
So my question is how does that work? Who decides which nodes can act as ASS which ones cannot and how those bigger bubbles ISP or something else whatever it's called.

49:38.620 --> 49:49.620
How do you decide which nodes act as ASS and can you dynamically update it?

49:49.620 --> 49:57.620
So if I understood the question correctly it's about who decides what ASS is trustable or not trustable right?

49:57.620 --> 50:07.620
So what Sion brings is this possibility to the sender in this case the end host within the ASS as I said before.

50:07.620 --> 50:28.620
So your ASS will provide you with a set of paths and then you will based on your local policies as end host you will apply these policies to these set of paths and then you will end up having a subset of path that you consider that good for your use cases.

50:28.620 --> 50:42.620
So this of course brings so this delegates some responsibility but this is good. I mean at the end as I answered before you can fall back to any default path right?

50:42.620 --> 50:51.620
And just be kind of agnostic to okay where my packet is going to but I mean the main benefit is just having a choice on that.

50:51.620 --> 50:57.620
So ISDs basically represent jurisdictions right? So you can think about them for example we have the Swiss ISD.

50:57.620 --> 51:04.620
We will have other countries ISDs or regions or in this case for example this group of university institutions.

51:04.620 --> 51:18.620
So you may think so in there is pretty much for my use case for example I would want my traffic only go through research institutions because I'm deploying this thing from maybe my home country.

51:18.620 --> 51:28.620
And then I could basically steer that policy or implement that policy in there and then of all the sets of available paths I will be doing that.

51:28.620 --> 51:34.620
Of course this will depend maybe on your application for doing certain things you are good with other paths.

51:34.620 --> 51:36.620
So I don't know if I...

51:43.620 --> 51:47.620
The initial trans routes so they are agreed upon so basically...

51:47.620 --> 51:53.620
Can we take this offline so we can get the next speaker please?

51:53.620 --> 51:57.620
Yeah I mean I can answer you offline because they need to...

51:57.620 --> 52:02.620
Hallway track it's a thing. Okay thank you for the talk thank you.

52:04.620 --> 52:06.620
Thank you.

