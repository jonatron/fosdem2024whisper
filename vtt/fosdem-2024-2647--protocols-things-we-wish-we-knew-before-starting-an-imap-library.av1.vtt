WEBVTT

00:00.000 --> 00:12.360
Hi, thank you for being here so early to hear about such an old protocol.

00:12.360 --> 00:15.240
So we're going to talk about IMAP.

00:15.240 --> 00:21.360
We've both started writing some IMAP libraries and we want to share experience in that.

00:21.360 --> 00:26.240
We've hit a few issues along the way, a few surprising things.

00:26.240 --> 00:31.240
Hopefully this can help you if you want to deal with IMAP as well.

00:31.240 --> 00:36.240
So, I'm Simon.

00:36.240 --> 00:41.240
I'm working on the Go libraries and he is Damien.

00:41.240 --> 00:44.240
Hi, I'm the main head of IWF-Code.

00:44.240 --> 00:48.240
Yeah.

00:48.240 --> 00:54.240
So the first thing you might wonder is what is IMAP useful for?

00:54.240 --> 00:58.240
So maybe some of you know that IMAP is used to fetch messages from a mail server.

00:58.240 --> 01:05.240
So if you have a mail client and a list of messages shows up, this is fetched via the IMAP protocol.

01:05.240 --> 01:09.240
IMAP lets you organize messages into mailboxes.

01:09.240 --> 01:15.240
So mailboxes is what regular people call folders.

01:15.240 --> 01:21.240
So inbox, archive, spam, drafts, all of these are mailboxes for IMAP.

01:21.240 --> 01:32.240
The main advantage on the upside of using IMAP compared to older protocols is that it's possible to synchronize from multiple clients and devices.

01:32.240 --> 01:46.240
So for instance, if I want to start writing a draft on my laptop and then continue later on my mobile phone and sending my mobile phone, that's possible with IMAP.

01:46.240 --> 01:50.240
What's the basic way you interact with IMAP?

01:50.240 --> 01:52.240
So it sounds pretty simple at first.

01:52.240 --> 01:58.240
You open a TCP connection, ideally with TLS and without start TLS.

01:58.240 --> 02:02.240
And then you write a command and then you get back some responses from the server.

02:02.240 --> 02:04.240
So it sounds simple.

02:04.240 --> 02:08.240
Here's a very simple example.

02:08.240 --> 02:15.240
Here's an example of a login command where you specify your username and your password.

02:15.240 --> 02:27.240
And then after that you get an OK response from the server if the password is correct and the login is correct.

02:27.240 --> 02:33.240
So something interesting to note before going to the next slide is that...

02:33.240 --> 02:34.240
I'm sorry.

02:34.240 --> 02:36.240
I'm going to do this, no problem.

02:36.240 --> 02:42.240
So something interesting to note is that there's a CMD1 right before the login command here.

02:42.240 --> 02:45.240
So this is what we call a tag and it's used...

02:45.240 --> 02:54.240
It's an arbitrary string, a sendizer client, and it's used to match up the server responses with the client's requests.

02:54.240 --> 02:57.240
So it's just a string echoed back by the server.

02:57.240 --> 03:05.240
So the client knows that the OK response is for the command, this particular login command it sent before.

03:05.240 --> 03:06.240
OK.

03:06.240 --> 03:13.240
Here's a more complicated example with a fetch command which is used to fetch messages from the server.

03:13.240 --> 03:19.240
So here the client sends a fetch command and asks for the message flags and message envelop.

03:19.240 --> 03:25.240
The envelope typically contains a subject and the recipients and stuff like this.

03:25.240 --> 03:33.240
And then the server sends back some replies here with responses with the first message as the flag is seen.

03:33.240 --> 03:36.240
So it's not unread.

03:36.240 --> 03:38.240
It has been marked as important.

03:38.240 --> 03:42.240
And then the envelope is very big, so it omitted it here.

03:42.240 --> 03:45.240
And the second message has no flags.

03:45.240 --> 03:52.240
And when the server is done sending all data, it ends with an OK response.

03:52.240 --> 03:59.240
Something worth noting is that here in the middle,

03:59.240 --> 04:03.240
you might notice that the command tag is not included here.

04:03.240 --> 04:06.240
There's a wild card instead.

04:06.240 --> 04:09.240
So this will have consequences later.

04:09.240 --> 04:20.240
If you ask for data, it's complicated to know if you get replies for which command it was and if it was for command at all.

04:20.240 --> 04:24.240
We'll see you more on this later.

04:24.240 --> 04:30.240
In the fetch command here at the start, you might notice the one column wild card.

04:30.240 --> 04:34.240
This is the way you specify which messages you want to fetch.

04:34.240 --> 04:39.240
And we'll see how we do this in the next slide.

04:39.240 --> 04:41.240
So how do we refer to a particular message?

04:41.240 --> 04:42.240
There are two ways.

04:42.240 --> 04:45.240
Both ways use a 42-bit inside integer.

04:45.240 --> 04:50.240
So the first way is with something called UIDs.

04:50.240 --> 04:57.240
UIDs are a unique ID which doesn't ever change except when it does.

04:57.240 --> 05:00.240
It increases when a new message is added to a mailbox.

05:00.240 --> 05:10.240
So if the last message in the inbox has UID 42 and you receive a new one, then it will get UID 43.

05:10.240 --> 05:14.240
So the second way is with message sequence numbers.

05:14.240 --> 05:16.240
It's an ordinal number.

05:16.240 --> 05:21.240
So if you use sequence number one, it means the first message in the mailbox,

05:21.240 --> 05:25.240
sequence number two, second email in the mailbox, and so on.

05:25.240 --> 05:32.240
And it goes the same way as ICOIDs, like the oldest message added to the mailbox is the first one.

05:32.240 --> 05:42.240
So something interesting is that the sequence number, they get reassigned by some operations.

05:42.240 --> 05:49.240
For instance, if a message is deleted from a mailbox, then the sequence number shifts a bit.

05:49.240 --> 05:58.240
So here's an example of a mailbox with three messages, one with UID 4, one with UID 6, one with UID 12.

05:58.240 --> 06:06.240
And if the UID 6 is removed from the mailbox, then the first message stays with UID 4.

06:06.240 --> 06:10.240
And the second message is none of the UID 6. It's now UID 12.

06:10.240 --> 06:15.240
So the meaning changes depending on the state.

06:15.240 --> 06:19.240
Another detail is that message data is immutable.

06:19.240 --> 06:23.240
So if you fetch message contents, it will never change.

06:23.240 --> 06:29.240
If you want to edit a message, you need to re-upload it and then delete the old one.

06:29.240 --> 06:39.240
So this was to refer to a single message and we can also refer to multiple messages with something called SET.

06:39.240 --> 06:46.240
The simplest set is just one message. So here's just sequence number one.

06:46.240 --> 06:53.240
Here's another example with a column. You can say messages 2 to 4 inclusive.

06:53.240 --> 06:58.240
You can specify multiple ranges like this, like 2 to 4 and then 6 to 10.

06:58.240 --> 07:07.240
And the last one is 1 to wildcard. It means 1 until the end, until the last message.

07:07.240 --> 07:13.240
That's it for the IMAP introduction. Now we can go into the meat of the presentation.

07:13.240 --> 07:17.240
Do you want the microphone?

07:17.240 --> 07:21.240
Is it on?

07:21.240 --> 07:24.240
Okay, so let's go through all these layers.

07:24.240 --> 07:28.240
The first layer is types.

07:28.240 --> 07:32.240
So what's there to tell about types? A few things.

07:32.240 --> 07:37.240
Probably your journey as an IMAP developer will start as either a client or a server developer.

07:37.240 --> 07:44.240
So it's kind of tempting to try to implement only half of the standard and to a certain amount.

07:44.240 --> 07:52.240
This is possible because as a client developer you can implement command serialization and response parsing only.

07:52.240 --> 07:57.240
And as a server developer you can implement command parsing and response serialization only.

07:57.240 --> 08:02.240
You can kind of pick only half of the routines that you would need.

08:02.240 --> 08:08.240
But the IMAP standard has quite a few of overlap between commands and responses.

08:08.240 --> 08:13.240
So there are many types that you need to define and many parsers that you need to define and serialize.

08:13.240 --> 08:21.240
So you won't end up anyway with implementing 50% of the standard but more like 70, so to say.

08:21.240 --> 08:29.240
So my suggestion would be to structure your code so that you can easily extend it to the other side afterwards.

08:29.240 --> 08:35.240
For example using a shared module.

08:35.240 --> 08:42.240
And if you are lucky and someone will provide the missing side to you and you have parsing and serialization handy,

08:42.240 --> 08:47.240
you can do kind of cool stuff because you can first generate a random message

08:47.240 --> 08:52.240
and then ensure that parsing and serialization is inverse to each other by doing randomized tests.

08:52.240 --> 08:55.240
So there's a pretty powerful kind of unit test for it.

08:55.240 --> 09:00.240
At least for me it helped a lot as you can see at the bottom.

09:00.240 --> 09:05.240
Complicated stuff. Complicated bugs.

09:05.240 --> 09:08.240
Yeah, perfect.

09:08.240 --> 09:11.240
Okay regarding syntax, oh my.

09:11.240 --> 09:16.240
I will quote Mark Crispin from the IMAP protocol mailing list because I think

09:16.240 --> 09:21.240
it's not that bad but you need to be in a certain state of mind when doing it.

09:21.240 --> 09:24.240
Alright, let me think now I'm a bit tired today.

09:24.240 --> 09:31.240
But first and foremost the formal syntax should be your holy book.

09:31.240 --> 09:40.240
If any part of the syntax distracts you from the formal syntax, you should ignore it in favor of the formal syntax.

09:40.240 --> 09:43.240
Your eyes will glaze over and your jaw will drop.

09:43.240 --> 09:46.240
You can start saying no, no, no.

09:46.240 --> 09:48.240
Just work through that stage.

09:48.240 --> 09:55.240
It's a steep hill to climb but once you make it to the top you will see everything with crystal clarity.

09:55.240 --> 10:05.240
And remember, no matter what you do, do not try to implement any command or response by looking at the examples.

10:05.240 --> 10:08.240
And he's what Mark said, so he's right.

10:08.240 --> 10:15.240
I would add that before reading the formal syntax you need to learn ABNF and I mean you need to learn it by heart

10:15.240 --> 10:19.240
because there are some subtle things you need to be aware of.

10:19.240 --> 10:27.240
And regarding lexas and parsas, I think we agreed when talking about this things.

10:27.240 --> 10:34.240
IMAP makes in some places the impression that there are things like tokens saying arguments invalid

10:34.240 --> 10:37.240
meaning that there could be some generic argument.

10:37.240 --> 10:41.240
I had a very hard time to figure out what should a token be.

10:41.240 --> 10:50.240
So there are no words on what constitutes a token and I think Simon in version one tried it and got away from this approach

10:50.240 --> 10:53.240
or used a different approach in version two.

10:53.240 --> 11:00.240
So I don't know, maybe someone has a better idea but for me you cannot lex the IMAP syntax.

11:00.240 --> 11:04.240
And another recommendation, even the syntax has layers.

11:04.240 --> 11:10.240
So first of all you have the ABNF corals that are described in the ABNF standard and referred in almost any rule.

11:10.240 --> 11:15.240
And then you have these IMAP strings which make everything kind of messy.

11:15.240 --> 11:20.240
As an example, you see this is the lock-in command, looks kind of simple.

11:20.240 --> 11:27.240
And then you have this innocent looking A string thingy in there which is for example here the username and the password.

11:27.240 --> 11:33.240
And an A string is in fact one of three types and one of two protocol flows.

11:33.240 --> 11:39.240
So you have A string means either an atom or a string, more or less or some IMAP quirks.

11:39.240 --> 11:43.240
And if it is a string it can be a quoted string or a literal.

11:43.240 --> 11:48.240
And literals do require special care when implemented.

11:48.240 --> 11:52.240
So as a simple example we will start with password.

11:52.240 --> 11:58.240
It uses only a very simple character set so you can just write exactly these eight bytes as an atom.

11:58.240 --> 12:05.240
If you have a white space in it you need to put quotes around and if you have a quote inside quotes you need to escape the quote.

12:05.240 --> 12:09.240
So it is similar to programming, most programming languages.

12:09.240 --> 12:15.240
And if you have a literal, obviously if you have a new line in there, this would be the obvious case,

12:15.240 --> 12:22.240
you need to use these prefix here in curled braces and then you just send exactly the bytes that made up your string after a new line.

12:22.240 --> 12:25.240
With a twist as we will see.

12:26.240 --> 12:32.240
What we will glaze over today are ambiguities and defects and I had a few discussions already about this one.

12:32.240 --> 12:37.240
So I would very much ask everyone if you find some defect in IMAP please report it to us.

12:37.240 --> 12:41.240
We really want to start a collection on all of these things.

12:43.240 --> 12:49.240
And one thing I finally wanted to say, I quoted Mark Crispin from this thread,

12:49.240 --> 12:53.240
but if you now will go to the internet you won't find it.

12:53.240 --> 12:59.240
So the IMAP protocol, at some point it's not available anymore due to reasons.

12:59.240 --> 13:07.240
So and for me the only lucky thing that happened was that someone I know, it's the maintainer of the Mealy email client,

13:07.240 --> 13:13.240
he had this super cool online interactive WebAssembly demo and he used the dump as test data.

13:13.240 --> 13:16.240
So that was the only reason I could read it.

13:16.240 --> 13:21.240
I guess the thing I want to say here is let's try to be aware that knowledge is disappearing

13:21.240 --> 13:26.240
and maybe try to resurrect the IMAP protocol mailing list because it's awesome,

13:26.240 --> 13:29.240
it's like a travel trove of information.

13:29.240 --> 13:33.240
Okay, then let's go back to framing.

13:34.240 --> 13:36.240
So...

13:38.240 --> 13:41.240
Oh, everything tanked up.

13:41.240 --> 13:42.240
Yeah, I'm back again.

13:42.240 --> 13:50.240
So we're going to continue to talk about some higher level layer.

13:50.240 --> 13:59.240
So flow and framing, but by flow and framing we mean how does one split the IMAP stream into separate commands and responses.

13:59.240 --> 14:03.240
So this is pretty simple. This seems pretty simple at first.

14:03.240 --> 14:06.240
Here's a simple example, similar to what we've seen.

14:06.240 --> 14:12.240
Log in command at first and then the server replies okay and then the client sends a select command

14:12.240 --> 14:15.240
and then the server replies some data and then replies okay.

14:15.240 --> 14:18.240
So one may think, yeah, it's pretty simple.

14:18.240 --> 14:25.240
You just need to split a new line and each line is a message basically.

14:25.240 --> 14:28.240
And then literals happened.

14:28.240 --> 14:36.240
So here's a slightly more complicated example where the client sends a login command, the username,

14:36.240 --> 14:40.240
and then the password is passed as a literal.

14:40.240 --> 14:46.240
So first there's a number of bytes and then the next line there's contents.

14:46.240 --> 14:53.240
So here what's interesting is that these two lines are a single logical message.

14:53.240 --> 15:02.240
The second line here sent by the client is still part of the login command.

15:02.240 --> 15:07.240
Another interesting thing is that in between here there's a plus sent by the server.

15:07.240 --> 15:11.240
This is because the server needs to acknowledge literals.

15:11.240 --> 15:18.240
So when the client sends the first line here, it says, hey, I want to send a literal with six bytes

15:18.240 --> 15:25.240
and then later the server has to reply, yeah, you can go on with this plus and then option and comment after that.

15:25.240 --> 15:38.240
The client needs to wait for the acknowledgement before sending the literal data.

15:38.240 --> 15:40.240
Okay, so that's interesting.

15:40.240 --> 15:44.240
Let's try to look at only one side of the connection.

15:44.240 --> 15:49.240
So here let's try to look at only the client side and see what happens.

15:49.240 --> 15:58.240
So we can still make sense of everything here, like login with the literal and the next line and no op.

15:58.240 --> 16:01.240
Is this valid by the way?

16:01.240 --> 16:04.240
This sounds a bit weird, right?

16:04.240 --> 16:11.240
The client sends the username and then announces the literal and then the next line here,

16:11.240 --> 16:13.240
it sends a completely different command.

16:13.240 --> 16:15.240
It's not the password or anything.

16:15.240 --> 16:17.240
Is this valid IMAP even?

16:17.240 --> 16:26.240
It turns out that yes, it's completely valid IMAP because if the server replies no to the first line the client sends,

16:26.240 --> 16:29.240
then it can send the literal.

16:29.240 --> 16:31.240
It says, I don't want your literal.

16:31.240 --> 16:41.240
So basically what I'm trying to say here is that it's not possible to pass IMAP just looking at one side

16:41.240 --> 16:49.240
because you can't make the difference between this case and this case here, whereas the server rejects the literal.

16:49.240 --> 16:59.240
So you need in your IMAP password to have some kind of feedback from the other side of a connection to know what happened.

16:59.240 --> 17:07.240
And so one may think that we don't really need to wait for the server to acknowledge the literal.

17:07.240 --> 17:13.240
We can just send the command and the literal in one go and forget about it.

17:13.240 --> 17:19.240
The server will probably reply, okay, we'll probably acknowledge the literal in any case.

17:19.240 --> 17:26.240
So here's an example of what could go wrong if you don't wait for the server acknowledgement.

17:27.240 --> 17:37.240
Maybe you have a web form on a page which lets the user save a draft in their mailbox.

17:37.240 --> 17:46.240
And maybe the literal contains like, may contain some text like this which are valid IMAP commands.

17:46.240 --> 17:55.240
So if the server happens to reject the literal, then these lines are interpreted just as regular IMAP commands by the server.

17:55.240 --> 17:59.240
And these lines delete everything from your mailbox.

17:59.240 --> 18:00.240
So that's not great.

18:00.240 --> 18:07.240
And this can be potentially inserted into HTML email hidden and HTML on a single line.

18:07.240 --> 18:11.240
And yeah, if you reply to the email, you just use everything.

18:11.240 --> 18:13.240
So yeah, it's pretty scary.

18:15.240 --> 18:21.240
So to recap everything, something I haven't mentioned is that literal can appear basically anywhere.

18:21.240 --> 18:25.240
We've seen in the login command, but it can happen in the search command.

18:25.240 --> 18:29.240
There can be many literals for a single command.

18:29.240 --> 18:31.240
It's limited to one.

18:31.240 --> 18:35.240
So literals interrupt completely the regular syntax.

18:35.240 --> 18:41.240
You have to pause the parser from the server side or the client side if you receive a literal.

18:41.240 --> 18:46.240
And then wait for the other side to reply, yeah, go on.

18:46.240 --> 18:49.240
And then you have to resume the parser.

18:49.240 --> 18:53.240
And the literal can be nested into a list or nested into something else.

18:53.240 --> 19:00.240
So it's kind of complicated to do, especially if you're using, for instance, a parser generator or something.

19:00.240 --> 19:05.240
So we can pass IMAP just by looking at the single side of the connection as we've seen.

19:05.240 --> 19:11.240
And it's important to wait for the server to accept literals before going on or security within.

19:12.240 --> 19:20.240
So another aspect of the flows we want to talk about is commands such as authenticate.

19:20.240 --> 19:28.240
So authenticate is a command that lets the client use Sassel authentication.

19:28.240 --> 19:31.240
Sassel is a binary protocol.

19:31.240 --> 19:37.240
And to authenticate in a modular way, you have several mechanisms.

19:37.240 --> 19:45.240
So here's an example of a plain mechanism, which is a simple one with username and password, but there are those as well.

19:45.240 --> 19:53.240
So basically the idea is that you get a binary message and code it to base64 and then send it over.

19:53.240 --> 20:00.240
And the interesting thing here is that, so the client says authenticate command, the server says go on,

20:00.240 --> 20:03.240
you can continue the authenticate command.

20:03.240 --> 20:08.240
And then the client sends just base64, like the, what?

20:08.240 --> 20:10.240
This is not a regular IMAP command.

20:10.240 --> 20:11.240
This is just base64.

20:11.240 --> 20:12.240
There's no tag.

20:12.240 --> 20:13.240
There's no command name.

20:13.240 --> 20:16.240
It's just like the base64 data as is.

20:16.240 --> 20:20.240
It just interrupts regular IMAP syntax with completely something else.

20:20.240 --> 20:28.240
And IDOL does something as well similar to this, where client sends IDOL, server says go on,

20:28.240 --> 20:34.240
and then client can just send the ASCII string down like the four bytes down.

20:34.240 --> 20:36.240
And it's not an IMAP command or anything.

20:36.240 --> 20:38.240
It's just like an ASCII string.

20:46.240 --> 20:54.240
Start CLS and compress are kind of similar in the way that when you start these commands,

20:54.240 --> 21:01.240
it interrupts a regular IMAP stream and wraps it up with CLS or compression mechanism.

21:01.240 --> 21:05.240
So these are fun to implement as well.

21:05.240 --> 21:15.240
So in summary, for the flow section, IMAP demands you to conflate your passing with business logic

21:15.240 --> 21:17.240
with higher level details.

21:17.240 --> 21:23.240
So you cannot have a pure password in its own little module isolated from everything else.

21:23.240 --> 21:28.240
You need to wire it up with the rest of the IMAP library.

21:28.240 --> 21:34.240
It's kind of special in this regard compared to other processes.

21:34.240 --> 21:41.240
Okay, now on to operations and semantics.

21:41.240 --> 21:45.240
So let's talk about fetching messages again.

21:45.240 --> 21:49.240
There are multiple things you can request from the server to fetch messages.

21:49.240 --> 21:54.240
So basic example, the envelope we've already seen.

21:54.240 --> 22:03.240
Body structure is if you request the MIME structure of a message with a tree of nested parts.

22:03.240 --> 22:05.240
If you have attachments for example.

22:05.240 --> 22:10.240
And then to fetch the message body, you can use body square brackets.

22:10.240 --> 22:17.240
If you just request body square brackets like this example, you get a full message body.

22:18.240 --> 22:25.240
So here's an example, very simple message with two header lines and then a simple text.

22:25.240 --> 22:30.240
So yeah, if you fetch the body square bracket, you get everything.

22:30.240 --> 22:36.240
If you want to fetch only the header, you can use body square brackets header.

22:36.240 --> 22:39.240
And then you get only the first two lines.

22:39.240 --> 22:42.240
And you can request only the text of the message.

22:42.240 --> 22:47.240
So the howdy part here with the text modifier.

22:47.240 --> 22:51.240
But you can do more complicated stuff as well.

22:51.240 --> 22:53.240
Oh my.

22:53.240 --> 22:57.240
Yeah, maybe I'll go very fast on this one.

22:57.240 --> 22:59.240
You can fetch particular header fields.

22:59.240 --> 23:05.240
You can fetch sections, bytes, substrings of the results.

23:05.240 --> 23:10.240
You can fetch, if you have a multi-part message, we have an example with two parts.

23:10.240 --> 23:16.240
So the main part, the first sub part, the second sub part with an attachment.

23:16.240 --> 23:22.240
Then you can fetch only the first part here.

23:22.240 --> 23:25.240
So the counter disposition in line one.

23:25.240 --> 23:30.240
Or you can, here this one is interesting because it returns nothing.

23:30.240 --> 23:33.240
A header actually doesn't work in nested parts.

23:33.240 --> 23:38.240
You have to use a special keyword called mine for some reason.

23:38.240 --> 23:43.240
And then if you have a message attached to a message, then you have a section of the RFC

23:43.240 --> 23:46.240
dedicated to this particular use case.

23:46.240 --> 23:48.240
Like something everybody does every day, I think.

23:48.240 --> 23:52.240
Messages into messages, like Russian dolls.

23:52.240 --> 23:58.240
The last thing I want to talk about is unilateral server data.

23:59.240 --> 24:05.240
That's another simple example of a fetch command where you want to fetch the body of message one.

24:05.240 --> 24:09.240
And then the server replies, yeah, here's the body of message one.

24:09.240 --> 24:10.240
So everything's fine.

24:10.240 --> 24:18.240
Let's say another client happens to mark the first message as important.

24:18.240 --> 24:24.240
So the way this works in IMAAP is that the next time you execute a command,

24:24.240 --> 24:27.240
then the server replies here in the middle.

24:27.240 --> 24:32.240
Hey, by the way, the flags of the message one have changed.

24:32.240 --> 24:38.240
Even if you didn't ask for it, just before completing the command, it sends this data.

24:38.240 --> 24:44.240
So what happens if another client changes the flags of message one

24:44.240 --> 24:50.240
and you happen to send a fetch command right after this happened?

24:50.240 --> 24:58.240
Then you get something like this where the server replies first the body of the first message.

24:58.240 --> 25:00.240
Like hello world, like before.

25:00.240 --> 25:05.240
And then you get something interesting where you get another fetch item for the same message,

25:05.240 --> 25:08.240
but something you didn't ask for at all.

25:08.240 --> 25:09.240
So...

25:09.240 --> 25:14.240
Yep.

25:14.240 --> 25:21.240
So it's not possible to think of IMAAP as you request some data and you get back some data.

25:21.240 --> 25:23.240
It doesn't really work like this.

25:23.240 --> 25:29.240
You can think of it as you request some data and then the server pushes some data into you

25:29.240 --> 25:32.240
whether you want it or not, and you have to deal with it.

25:32.240 --> 25:37.240
And as a client, if you ignore all but the last reply from the server

25:37.240 --> 25:42.240
for the fetch message you asked for, then you won't get the body here.

25:42.240 --> 25:46.240
So it's something to look out for.

25:46.240 --> 25:48.240
Okay, last topic, extensions.

25:48.240 --> 25:50.240
These are a bit interesting.

25:50.240 --> 25:57.240
In GoaMAV1, I tried to implement extensions as a very modular thing, which you can plug.

25:57.240 --> 26:02.240
But extensions turn out to be more like amendments.

26:02.240 --> 26:09.240
Like fundamentally alters IMAAP syntax, flows, operations, everything we've talked about.

26:09.240 --> 26:13.240
Idle and compress are examples that add completely new flows.

26:13.240 --> 26:20.240
So Idle switches to a completely different mode than you need to send a downed SQL string to switch back.

26:20.240 --> 26:24.240
And compress, yeah, just wraps the connection with something else.

26:24.240 --> 26:28.240
And then you have another kind of extension like extended list,

26:28.240 --> 26:33.240
which modifies an existing list command and adds some arguments in the middle

26:33.240 --> 26:38.240
to add more options for the clients.

26:38.240 --> 26:46.240
The search extension for extended search, it changes how the reply looks like.

26:46.240 --> 26:51.240
So you send a regular search command and then you get some completely different kind of reply.

26:51.240 --> 26:55.240
And then the literal plus extension completely changes how literals work.

26:55.240 --> 26:59.240
You get a new syntax that you need to pass.

26:59.240 --> 27:05.240
So yeah, this doesn't work at all if you try to implement it as a modular thing.

27:05.240 --> 27:13.240
IMAAP is completely mononit, if you want to implement extensions that implement everything in the same repository.

27:13.240 --> 27:16.240
It will help a lot.

27:16.240 --> 27:21.240
All right, that's about it. Unfortunately, we don't have time to talk about everything we wanted,

27:21.240 --> 27:26.240
but it should be a good start, I hope at least. Any questions?

27:26.240 --> 27:28.240
Thank you very much first.

27:33.240 --> 27:36.240
I see a first arm.

27:36.240 --> 27:40.240
Yeah, quite immune. It really helps you at the time.

27:40.240 --> 27:44.240
Hello. Thanks for the talk and thanks for the library too.

27:44.240 --> 27:48.240
I think we're using it quite a lot.

27:48.240 --> 27:50.240
Thanks for the talk and thanks for the library.

27:50.240 --> 27:51.240
Oh, okay.

27:51.240 --> 27:57.240
Yeah, yeah. My question is like, you said like, sometimes you get responses from the server.

27:57.240 --> 28:03.240
You're not even asked for, does the server also send without asking?

28:03.240 --> 28:08.240
Does the server also send data without asking?

28:08.240 --> 28:13.240
So it kind of.

28:13.240 --> 28:24.240
I mean, if you, it will only send data right before it, right after it, sorry, let's go from the start again.

28:24.240 --> 28:30.240
It will not send data on its own if you don't send any command.

28:30.240 --> 28:38.240
You have to send a command and then you reply to the command and then add its own unilateral responses to it,

28:38.240 --> 28:42.240
which can be a bit arbitrary. Like it can be anything, really.

28:42.240 --> 28:51.240
It's usually at the end of the, just before the okay response, you get some extra data and you have to somehow maybe distinguish it from the regular data.

28:51.240 --> 28:55.240
But yeah, it doesn't really work in practice.

28:55.240 --> 28:56.240
I was glad to have you.

28:56.240 --> 28:59.240
Yep. Oh, yeah, yeah, yeah.

28:59.240 --> 29:04.240
I just added that on a little bit.

29:04.240 --> 29:11.240
So the IMAP standard is quite specific regarding and it says you need to be able to receive any response at any time.

29:11.240 --> 29:18.240
So it's quite, it has in the standard, but us doing practical things.

29:18.240 --> 29:25.240
The thing we learned is that you should not trust anything that's in the standard and to the best of my knowledge, most servers don't.

29:25.240 --> 29:33.240
So you have, there are exceptions, for example, by, by respond, by untact, like when the server do a shutdown.

29:33.240 --> 29:43.240
Yeah, as answered, maybe if you can explain a bit more, but to the best of our knowledge, most people doesn't do it because at least when we tested some clients, many clients,

29:43.240 --> 29:47.240
and I mean, I mean, like the most of the clients, they crashed when we sent this.

29:47.240 --> 29:51.240
So I think there's a reason why it's not so common in the real world.

29:51.240 --> 29:56.240
Okay.

29:56.240 --> 30:10.240
Okay. Just wanted to say that if you consider the client server interaction more like that the client told the view about the server and then the server updates the view whenever you send a command, then it starts to make a bit more sense.

30:10.240 --> 30:17.240
Yep. But it can be hard to architecture a client with, yeah, against this IMAP concept.

30:17.240 --> 30:20.240
Like sometimes you don't want this kind of thing.

30:20.240 --> 30:21.240
But it's good.

30:21.240 --> 30:24.240
But yeah, it's a good mindset for sure. Yeah.

30:24.240 --> 30:27.240
All right. Any, any.

30:27.240 --> 30:45.240
Is the only, having regarding IMAP as a cash fill protocol where the client has a view and the server fills in the client's view is the only way to write an IMAP client that will preserve your sanity over years.

30:45.240 --> 30:55.240
If you try to, if you try to act as though this were a web server, you will have and this works over the years.

30:55.240 --> 31:02.240
Each new server will surprise you in some way. Painful. Don't ask me.

31:02.240 --> 31:09.240
Well, your code is.

31:09.240 --> 31:16.240
All right. Thank you very much. And thanks again to the two presenters and we come to the next talk.

