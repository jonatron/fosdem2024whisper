WEBVTT

00:00.000 --> 00:15.120
Good morning everybody. Thank you for being so patient. I don't think I've ever had a

00:15.120 --> 00:20.440
full room with 24 minutes to go before the start of my talk before. So that is a very

00:20.440 --> 00:27.800
special experience. Thank you for sharing it with me. I unmuted, but thank you for checking.

00:27.800 --> 00:34.240
So I am going to talk to you today about OpenAPI. I'm going to try to give you something

00:34.240 --> 00:39.520
new that you could maybe take back and try, whether you haven't seen this before or whether

00:39.520 --> 00:46.360
you're just looking to level up your game a little bit. My name is Lorna. I work for

00:46.360 --> 00:54.600
Redockly. I'm VP Developer Experience there. I love APIs. My background is in software engineering.

00:54.600 --> 01:01.720
I've been a developer for most of my career. I've built APIs, integrated with APIs, worked

01:01.720 --> 01:08.440
for API producers, done API consultancy. Now I build the API tooling. It's, yeah, look,

01:08.440 --> 01:14.440
it's a thing that I enjoy and I'm happy that you are all here to share it with me. So let's

01:14.440 --> 01:21.800
start by talking about OpenAPI. OpenAPI, I know a lot of people raised their hands, but

01:21.800 --> 01:28.200
maybe it's new to some people. OpenAPI is an open standard. It's a way of describing

01:28.200 --> 01:39.720
your HTTP APIs in a format that aims to be both human and machine readable. What's nice

01:39.720 --> 01:46.280
about that is when we use a standard format, everybody uses the same format. And when that's

01:46.360 --> 01:52.960
an open format, it's developed in the open. You can be part of that development process

01:52.960 --> 01:58.680
and I'll talk a little bit more about the OpenAPI community at the end. You can see

01:58.680 --> 02:03.200
what's coming. You can join the meetings. You can follow the issues on GitHub. If you

02:03.200 --> 02:10.600
are using OpenAPI as a producer, as a consumer, if you make tooling for OpenAPI, there are

02:10.600 --> 02:16.200
no surprises. You know what's coming and you can be part of that. So it really improves

02:16.200 --> 02:23.960
our confidence on working with it. I think the most difficult thing about working with

02:23.960 --> 02:34.120
OpenAPI is it's just very verbose. It takes a lot of lines to describe what can be quite

02:34.120 --> 02:42.800
a simple thing. So I'm going to start by talking a bit about the structure of OpenAPI because

02:42.840 --> 02:47.160
I think when you can find your way around, you understand the map, it's much easier to

02:47.160 --> 02:54.080
work with it. So this is a representation of the things that you will find at the top

02:54.080 --> 03:05.080
level of an OpenAPI description. OpenAPI, which version of OpenAPI is this? Info, a

03:05.080 --> 03:12.560
bit of metadata about the API that this description describes. So here you'll find the title,

03:12.600 --> 03:17.920
probably some license information, some contact information, the version that we're on. All

03:17.920 --> 03:25.720
of that is in the info block. External docs. It's very easy. You publish an IAS developer

03:25.720 --> 03:30.640
website, you link to your API reference docs. If the user arrives on the reference docs,

03:30.640 --> 03:35.760
maybe from a search engine, is there a link back to that nice developer website that you

03:35.800 --> 03:42.240
made them? Check, because I feel like I've put this right on everything I've ever worked

03:42.240 --> 03:49.920
on. There is a security section and that will describe the authorization and authentication

03:49.920 --> 03:55.640
needs for the different that are used by the different endpoints in your API. We've got

03:55.640 --> 04:04.240
a service section, where is this API published? Tags allow you to attach metadata to individual

04:04.280 --> 04:10.040
endpoints. They're listed at the top level and then you can just use them where you need

04:10.040 --> 04:19.640
them. The paths section is where the real API documentation actually happens. This is

04:19.640 --> 04:26.560
what we think of as API docs. We have an entry for each endpoint describing what it does,

04:26.560 --> 04:32.880
the parameters that it accepts or how to shape the request and the response or responses

04:32.920 --> 04:39.880
that you can expect back. You'll also find web hooks here, so where you have an API that

04:41.960 --> 04:48.080
as well as receiving requests and returning responses, something happens and it sends

04:48.080 --> 04:52.760
you a response. You can describe those with web hooks. They're a little bit different to

04:52.760 --> 05:00.880
the request response feature. Those were added in 3.1, which, although it is the newest version

05:00.880 --> 05:08.680
of OpenAPI, is 3 years old, so wouldn't describe it as cutting edge. We also have here the

05:08.680 --> 05:13.880
components section. The components section allows us to describe things that we're going

05:13.880 --> 05:22.200
to use multiple times. If you use the same filtering, pagination, date format, if those

05:22.200 --> 05:30.200
are common patterns across your API, I mean, if they're not, we need to talk. But if you

05:30.240 --> 05:36.280
reuse those things, you can define them in the components section and reuse them.

05:36.280 --> 05:40.520
So knowing kind of, they can go in any order, but knowing where you are and where the other

05:40.520 --> 05:49.520
things are that you might need can make these very long documents navigable. OpenAPI descriptions

05:49.520 --> 05:57.600
are often thousands or tens of thousands of lines of code. My favorite test API description

05:57.600 --> 06:04.600
to use is the GitHub one. It's quarter of a million lines of YAML. Like, yeah, you need

06:05.400 --> 06:09.840
to know where you're going. Your tools can help you. But it's like carrying something

06:09.840 --> 06:14.440
that's not exactly heavy, but it's just a bit unwieldy.

06:14.440 --> 06:21.440
So let's drill into some of the detail. Here is just basically the top part of your OpenAPI

06:21.440 --> 06:28.440
description. We have a version. It's not very exciting. We have an info section. We've

06:30.240 --> 06:37.240
got a title. Give your API a unique and meaningful title. We have summary and description. A

06:38.120 --> 06:45.120
lot of OpenAPI elements have these two texty fields, the summary and the description. The

06:45.280 --> 06:52.280
difference, the summary is just text. It's short format. It's usually shown in a listing.

06:53.400 --> 06:59.400
The description supports markdown, specifically common mark. It's usually shown when we're

06:59.400 --> 07:05.400
looking at the detail. So if your API is shown in a catalog or in a list, it'll use the

07:05.400 --> 07:11.400
summary. And if you are viewing the API reference documentation, you'll probably see the whole

07:11.560 --> 07:18.560
description. And don't be afraid to use the markdown features for links and to really

07:20.080 --> 07:25.080
enrich what you do within your OpenAPI file.

07:25.080 --> 07:32.080
There's an info version field. And I think this is one thing that I see people getting

07:32.920 --> 07:39.920
confused with frequently. Info version is the version of the API description. So if you

07:40.920 --> 07:47.920
change this definition document, you're going to change the description field. Does your

07:49.480 --> 07:56.480
API info version need to match your API version? I don't really care. But if you change your

07:57.440 --> 08:02.240
description a lot, can you please bump the info version so that I know I don't have the

08:02.240 --> 08:09.240
latest version of this document? You lock it to your API version if that helps or don't.

08:09.520 --> 08:15.320
Maybe you haven't made any API changes, but you did add great descriptions, better examples

08:15.320 --> 08:21.320
or something else that changes the OpenAPI description of your API. Bump the version

08:21.320 --> 08:28.320
so I know I need to get the new one. Please add a license. Yeah. So this is like some

08:29.240 --> 08:35.000
nice fluffy rendering. I made this with Blockly. I hope that you like it. And I think it's

08:35.040 --> 08:41.240
just easier to look at than the real thing. This is the YAML version. And I can do 10

08:41.240 --> 08:45.600
screens of YAML and I will be having a nice time, but I don't know if you will be having

08:45.600 --> 08:51.600
a nice time. So I brought you some pictures. But this is kind of the equivalent of seeing

08:51.600 --> 08:57.400
it in YAML. Like now imagine another 20,000 lines and you're starting to visualize how

08:57.400 --> 09:04.400
this thing looks. Okay, let's look a little bit at the paths. We have within the YAML

09:05.040 --> 09:12.040
path section, we have one block for each combination of URL and verb or method. So like I have

09:15.640 --> 09:21.120
one that is item endpoint, it's got a get operation. Got another one. I'm really good

09:21.120 --> 09:28.120
at naming things. Called things another URL which has both get and post. Those are different

09:28.640 --> 09:35.640
operations. They get their own description. If we drill into one, how's an operation ID?

09:37.320 --> 09:44.320
Fun fact, operation ID is optional in open API. It's technically optional. Honestly,

09:46.480 --> 09:51.840
you need it. It needs to be unique. Just get your linting to put that in. There's very

09:51.840 --> 09:57.240
few APIs where this isn't a useful thing to have and it's not like it's painful to do.

09:57.800 --> 10:04.800
We've got a description. You probably would have a summary as well. Won't all fit. I have

10:04.880 --> 10:10.600
added some tags to my endpoint. This is related to user and accounts. We might have user and

10:10.600 --> 10:17.600
orders or some other combination of tags here. You can have multiple tags. If there were

10:18.440 --> 10:25.440
request body requirements or parameters, those will be described here as well. And then we've

10:26.440 --> 10:33.440
got the responses. I've only got the 200 response here. It's very bad. You should always describe

10:33.440 --> 10:40.440
your 400 response errors. I got 200 response here. It's application JSON and it's just

10:41.720 --> 10:46.920
got a couple of fields in it. I'm going to drill into that in more detail. It's the same

10:46.920 --> 10:53.920
endpoint. More detail. Shuffled down a little bit. In my response, you can see I have a

10:54.520 --> 10:59.840
maybe you can't see actually because the font is quite small. This schema has a message

10:59.840 --> 11:06.840
and an event ID. I've got data types. I've got descriptions. And I've crucially got

11:07.880 --> 11:14.880
examples here. The examples are the magic because it lets the user know what kind of

11:16.480 --> 11:22.960
data will this be. You can tell me it's a string. But if your example is, I don't know,

11:23.040 --> 11:29.540
are you UID? I'm like, oh yeah, I know what that is. If you show me it's my username or

11:29.540 --> 11:36.540
you show me it's an ID, okay, I am just instinctively going to put the right thing in when I'm using

11:36.540 --> 11:43.540
those tools. If you use the same fields in other places and it's becoming increasingly

11:43.860 --> 11:50.860
standard that even if you're not reusing them, you'll often use the open API reference syntax

11:53.940 --> 12:00.940
to refer to them being stored somewhere else. So instead of defining each of the objects

12:02.540 --> 12:09.540
or elements of the response payload, you just refer to use a reference, dollar ref, to refer

12:09.980 --> 12:14.900
to that description and put the description in the components. So your path entry looks

12:14.900 --> 12:21.180
like this and then we have that detail down in the components section under schemers.

12:21.180 --> 12:28.180
So this gives you a very powerful reuse. The key to API experience is consistency. And

12:31.220 --> 12:38.220
so the reuse helps us to just, without thinking, get it right, get it the same, get it consistent

12:38.220 --> 12:44.180
and avoid having similar named fields that might take different timestamp formats or

12:44.180 --> 12:49.980
look identical but validate differently because our back end application didn't understand

12:49.980 --> 12:56.180
that they were the same thing. So that's the structure of open API but I really felt when

12:56.180 --> 13:02.380
I created those slides that I was missing the magic. The thing that brings me to this

13:02.380 --> 13:09.380
and makes me believe in open API as the powerhouse of our modern application development. And

13:10.420 --> 13:17.180
when I think about open API, I think about the things that I do with it and the things

13:17.180 --> 13:24.180
that it enables. You think about the way that you design your API, giving meaningful operation

13:25.180 --> 13:32.180
IDs for each endpoint and these can be used by the tools that consume your API description.

13:32.180 --> 13:39.180
Having great descriptions, naming things in such a way that developers don't need to come

13:39.180 --> 13:43.900
and read your documentation because they will know from the operation ID what it's going

13:43.900 --> 13:50.900
to do and it's very consistent. They feel at home. You describe your error responses

13:51.620 --> 13:57.660
even if I never publish my open API description. The fact that I wrote down the error responses

13:57.660 --> 14:04.100
makes my API better because I thought about what I wanted to do if something went wrong.

14:04.100 --> 14:10.140
I can validate my API and make sure that my open API is valid, is at the standard that

14:10.140 --> 14:17.140
I want and I can have my own linting rules as well. Operation ID is optional. Why? Not

14:17.900 --> 14:24.900
in my APIs. So I write my own rules. I say we use kebab case here. We use plurals here.

14:25.540 --> 14:32.540
We always define an error response. We make sure that our examples match our media types.

14:32.540 --> 14:39.540
These are the things that you can add with the additional linting rules. We can create

14:40.180 --> 14:46.580
documentation. That's great. You have an API. You should probably have some docs for it.

14:46.820 --> 14:53.580
We can also allow other people to pull the open API description and generate their own

14:53.580 --> 14:59.060
docs, keep it locally for reference. I have some accessibility needs. If you have an accessible

14:59.060 --> 15:04.340
API web-based documentation, I can just generate with something that works for me with my

15:04.340 --> 15:11.340
open API locally. It's ideal. Beyond this sort of entry level, there's

15:11.340 --> 15:18.100
some more things that I think we are not doing enough of in open API. You have an API. You

15:18.100 --> 15:22.660
describe it with open API. You lint it. You generate some docs. This is great. Please

15:22.660 --> 15:29.660
do these things. You are all awesome. The next level is how you deal with very complex

15:31.980 --> 15:38.980
API setups. If you work in a large organization with many microservices, how does that pipeline

15:39.540 --> 15:45.420
look? How do you keep them all meeting the same standards? How do you bring them together

15:45.420 --> 15:50.700
to publish as if you knew what you were doing to the user? Don't mind if you do or not,

15:50.700 --> 15:56.260
but you need to look like you do. How do you bundle those things together? If you have

15:56.260 --> 16:02.460
one enormous open API description, how do you collaborate on that when you are making

16:02.460 --> 16:07.460
changes, whether you are an API experience specialist, product owner, engineer, tech

16:07.500 --> 16:13.420
writer? How do we give you a clue that GitHub file is not maintained as a single quarter

16:13.420 --> 16:20.420
of a million line YAML file? Looking at how do you manage your files? What do you do with

16:20.420 --> 16:27.420
references? How do you split across manageable file chunks? Then how do you bring that together

16:27.420 --> 16:34.420
to ship downstream? Finally, what do those downstream tools look like? A lot of organizations,

16:38.020 --> 16:43.940
organizations come into open API because they want documentation. This is the beginning.

16:43.940 --> 16:50.940
We don't want to write a whole load of words. We just want to describe once with open API

16:53.220 --> 16:57.620
and then we can generate some documentation and we can generate it in different ways.

16:57.620 --> 17:03.980
Then for free, you start being able to get all these other benefits. You can generate

17:04.020 --> 17:10.700
some client SDKs. You can even generate your service stubs if you want. Lots of tools will

17:10.700 --> 17:17.460
automatically integrate with your API if you have a good standard open API description.

17:17.460 --> 17:24.460
So your API gateways and other integration platforms will just take it. But you can also

17:24.660 --> 17:31.660
start to automatically look at how do you describe sequences of API calls? How do you

17:31.660 --> 17:37.220
test your API? What does a mock server look like? Because you've described this API in

17:37.220 --> 17:44.220
so much detail that a tool can pretend to be it very easily. So there's a lot of pieces

17:44.860 --> 17:51.860
here that make up the ecosystem. Open API is kind of the seed from which the rest of

17:53.620 --> 18:00.500
the tree grows. For me, this is the magic. It's the interoperability. It's the way that

18:00.500 --> 18:06.660
we come back to maybe we generate some open API. It's terrible. So then we use overlays

18:06.660 --> 18:12.700
or decorators to add all the descriptions and examples. And maybe not all of these end

18:12.700 --> 18:18.220
points are public yet. So we just filter out the public ones to make the final open API

18:18.220 --> 18:23.420
and generate some docs. Maybe only some of them are available in the SDK. So we filter

18:23.420 --> 18:29.260
differently, make a new open API file, pass that down to the SDK's endpoint. Maybe the

18:29.260 --> 18:35.180
next generation of your client SDK has some new functionality. Well, that you start with

18:35.180 --> 18:42.180
the same source file or files and bring that together. So it's all about how do you not

18:43.060 --> 18:49.660
code, generate docs, but how do you create your open API? Don't have time for my design

18:49.660 --> 18:54.580
first rant. So I'm going to try and hold that in. However, your open API comes into

18:54.620 --> 19:01.300
the picture. How do you maintain and manage it successfully? How do you ensure the quality

19:01.300 --> 19:08.300
on it? How do you transform it and get it ready for all the outputs that you choose?

19:09.100 --> 19:16.100
There's just so much in this picture. Let's talk about some tools. Now, I've just linked

19:16.300 --> 19:23.300
open API.tools here. I'm not making any specific tools recommendations. That's for two reasons.

19:24.660 --> 19:31.060
One, this is a really hot area. There's new tools every week. There are different tools

19:31.060 --> 19:36.060
for different text acts. When you are ready for a new tool on that day and no sooner,

19:36.060 --> 19:41.460
you should go and look at the list and pick something. The second reason is I work for

19:41.500 --> 19:48.500
a tools vendor. I work there because I use their tools. I cannot possibly give you an

19:49.140 --> 19:55.640
impartial recommendation. I went to ReadDocley because they know me and I know them. I really

19:55.640 --> 20:00.380
don't know the other tools that well as a result. So don't listen to me for specific

20:00.380 --> 20:07.380
tools. I work on the ReadDocley stuff and I love it. You need an editor. There's basically

20:08.380 --> 20:15.380
two ways to go. You can use a programmer's editor, something like VS Code. Please add

20:15.460 --> 20:20.460
some plugins to help yourself. ReadDocley makes an open API plugin. Even if you just

20:20.460 --> 20:26.660
have some syntax highlight for YAML, the one that makes the indentations a different color

20:26.660 --> 20:33.660
helps me a lot in YAML. Find something that works for you. There are some graphical editors

20:34.460 --> 20:39.340
and if that's your thing, then go find one of those. You don't need to pick the same

20:39.340 --> 20:45.260
as your team because it's an interrupt format. You use whatever you want to collaborate. Try

20:45.260 --> 20:51.340
really hard not to lock your team into tools. Again, accessibility needs. I need to do it

20:51.340 --> 20:58.340
in Vim and of course I can. That's part of the magic. Open API governance, which is clearly

20:59.340 --> 21:06.340
not a tool, but let's skate over that. When you write, your API standards do not exist

21:06.940 --> 21:13.540
until you write them down. They are not standards until they exist somewhere that somebody else

21:13.540 --> 21:20.540
can look at them and they are consistently enforced. We have a lot of really good linting

21:20.900 --> 21:27.140
that can really help you, but the humans are always going to be in this review process.

21:27.140 --> 21:34.140
Find your most wise and thoughtful humans and invite them to be part of the review process.

21:36.460 --> 21:42.900
Naming is the thing that the machines genuinely cannot do for us and just the joined up thinking

21:42.900 --> 21:49.900
of being able to see things next to each other. As you introduce API standards, start small.

21:50.900 --> 21:57.380
Do not be tempted by other people's recommended rule sets, not even ours. Pick what works

21:57.380 --> 22:03.420
for you. Look at the recommended rule set, but then pick the things that you aspire to

22:03.420 --> 22:09.380
and can adhere to today and commit to reviewing every six months and building up the quality

22:09.380 --> 22:14.980
on your API. If you're retrofitting standards to an existing API, there will be things you

22:14.980 --> 22:21.660
cannot change now and that's okay, but you can set those rules for the new versions.

22:21.660 --> 22:25.820
If you don't know where to start on this, I am going to recommend Zalando. Have some

22:25.820 --> 22:32.820
brilliant public API standards and you could do worse than, okay, they have a lot. Start

22:33.260 --> 22:38.380
small, just pick your favourites out of theirs. It's a great place to start and your organisation

22:38.380 --> 22:45.380
will evolve as it goes along. Please put some linting in. The machines are genuinely good

22:47.140 --> 22:53.340
at this. They can help keep you straight. Is your open API valid? Does it have descriptions?

22:53.340 --> 23:00.340
Does it have examples? I've got one team that I work with where we have a whole API where

23:00.860 --> 23:07.500
the description for the access response is okay with a full stop and it turns out we

23:07.540 --> 23:14.540
enforced sentences. So it has to be at least one word and at least one full stop. Yeah,

23:16.300 --> 23:22.780
we did some work with them on that. Get some case conventions, some naming conventions

23:22.780 --> 23:29.880
and be really picky about what you include. I do this with Redockly CLI, so if you are

23:29.880 --> 23:33.740
using that, feel free to send me questions. If you use something else, I can't answer

23:33.740 --> 23:40.740
your questions, but good luck. Open API documentation. Read the docs for your docs tools. I see a

23:45.100 --> 23:52.100
lot of implementations where those functionalities exist in the tooling that you've used, but

23:53.100 --> 23:58.860
you haven't really dug into what it can do or looked at how you can extend or configure

23:58.860 --> 24:05.460
it. API reference documentation is evolving very quickly in a good way. There's a lot

24:05.460 --> 24:09.780
of new entrants in this market. I'm not sure if I'm supposed to be saying that we have

24:09.780 --> 24:15.000
a new product coming out later in the year that does this. It's beautiful, but you have

24:15.000 --> 24:19.580
lots and lots of options. Whatever you've picked, make sure you're making the most

24:19.580 --> 24:26.580
of it. And if you have something that's, oh, our, I don't want to malign any other tool

24:26.700 --> 24:31.260
families, but something which isn't specialist docs and it can render documentation is a

24:31.260 --> 24:37.700
great way to start. But because you have the open API format, you can use all of one tool

24:37.700 --> 24:44.020
set for one thing, something else for docs, something else for your SDK gen, like lots

24:44.020 --> 24:51.020
and lots of options. Open API, when you publish documentation, your documentation is part

24:52.020 --> 24:59.020
of the product. You should be deploying it often. It should be easy to deploy and redeploy.

24:59.020 --> 25:03.660
And make sure that you're treating it like a web product. Get some metrics, have a look

25:03.660 --> 25:09.260
at what's happening, see what people run into. If you have interactive docs, what are people

25:09.260 --> 25:14.460
calling the same endpoint all the time? Is it super popular or is it super confusing?

25:14.460 --> 25:19.500
Why is everyone here testing this thing? Have a look at those metrics because they can really

25:19.500 --> 25:26.500
help you understand your product. I want to talk a little bit about the open API community.

25:26.780 --> 25:31.340
This is something that I don't always include in my technical open API talks, but as far

25:31.340 --> 25:38.340
as them, it feels appropriate. It's an open standard. It's part of the Linux foundation.

25:39.220 --> 25:46.220
You can get, you can learn more about it on openapis.org. The GitHub repository is public.

25:46.300 --> 25:51.620
Everything happens there. We have a Slack group. It's very active. Also, public to sign

25:51.620 --> 25:56.340
up. And there's a weekly technical meeting. I will confess, it's not super friendly for

25:56.340 --> 26:03.340
Europe. I think it's 6 p.m. Central European time, 5 p.m. for me in the UK. Yeah. I'm trying

26:04.460 --> 26:09.420
to get to a critical mass of EU-based maintainers, and then we need to start mixing that up.

26:09.420 --> 26:13.860
But yeah. If it's unfriendly for Europe, it's sort of dinnertime. There's no hope at all

26:13.980 --> 26:20.980
for anyone east of here. So yeah, we need to fix that. But the open API community is

26:20.980 --> 26:25.460
currently growing its maintainer set. It's working on some new stuff. Like, this is a

26:25.460 --> 26:31.960
good time to get involved. We've also spun up some special interest groups. So just to

26:31.960 --> 26:38.560
kind of tease some of the headline activities within the open API project. The Workflows

26:38.560 --> 26:45.040
special interest group describes a sequence of API calls. So if you have, this has come

26:45.040 --> 26:50.440
from the travel industry. So where you need to find the flights, find the seats, ask the

26:50.440 --> 26:56.560
user, book a seat. None of those make sense by themselves. Workflows aims to give an extra

26:56.560 --> 27:03.560
level of description for that. Overlays is a special interest group that describes repeatable

27:04.560 --> 27:11.560
modifications to an open API. So if you have a generated open API that is just thin, you

27:12.560 --> 27:18.560
don't maintain good examples and good descriptions when you're generating from code, and lots

27:18.560 --> 27:24.560
of organizations struggle to get away from that Java doc workflow. Overlays can help for

27:25.560 --> 27:30.560
now, where you can get your open API and make the same changes every time to make the descriptions

27:30.560 --> 27:40.560
better and add examples, hide things, whatever. Open API 4.0. Code name, Moonwalk, why? Don't

27:40.560 --> 27:48.560
ask. Don't let engineers name things. Open API, Project Moonwalk, is committed to doing

27:48.560 --> 27:55.560
some sort of release this calendar year. So that is just starting. The high level goals

27:55.560 --> 28:02.560
are to give you a really simple upgrade from 3.1 upwards, so 3.0 you might want to go to

28:02.560 --> 28:12.560
3.1, and to include a wider range of HTTP APIs. Open API is amazing for RESTful APIs. Okay

28:12.560 --> 28:20.560
for some other HTTP-ish, RESTful-ish ones. Moonwalk will include the RPCs and a wider

28:20.560 --> 28:27.560
family. So if you've struggled with open API, have another look in about a year. Yeah, open

28:27.560 --> 28:34.560
API, an open standard for API descriptions. If you're not using it, I hope you will now

28:34.560 --> 28:39.560
or feel like it's a thing that you can approach. If you are, maybe I've given you some ideas

28:39.560 --> 28:45.560
to go back and look at what you might change in your current workflow. I'm going to leave you

28:45.560 --> 28:57.560
with some resources and say thank you very much for your time. Okay, I'm allowed to take

28:57.560 --> 29:09.560
two questions. Would anyone like to take a question? Yes. This is a really good question. How do I

29:09.560 --> 29:19.560
feel about generating open API from code or code from open API both ways? Let's start at the

29:19.560 --> 29:28.560
beginning. A lot of organizations generate open API from their back-end server-side code. I don't

29:28.560 --> 29:41.560
like it. And the reason I don't like it is I think when you go code first, you're missing a design

29:41.560 --> 29:50.560
step. When you design first, you're thinking about it in the context of the rest of the API. You're

29:50.560 --> 29:56.560
more likely to get the naming right the first time because that implementation is not done by an

29:56.560 --> 30:03.560
engineer by themselves. So you ideally design first APIs. You propose the change to your open

30:03.560 --> 30:09.560
API with a pull request. You're wise people and you're amazing linting. Go a few iterations to get it

30:09.560 --> 30:16.560
perfect. Then we build it. And that's my ideal and that's why I prefer it. The other question,

30:16.560 --> 30:25.560
generating code from open API? Yes, go for it. I think we have this machine description and there's

30:25.560 --> 30:35.560
a lot of boilerplate. So we can go quite a long way to things like client SDKs from open API. When I

30:35.560 --> 30:41.560
talk about the transform step where you have an open API and you make it better, for docs, you're

30:41.560 --> 30:48.560
going to add examples and descriptions. For API gateways, SDK code gen, that sort of thing, you're

30:48.560 --> 30:54.560
going to add metadata here. You're going to give the type hints that the specific programming languages

30:54.560 --> 31:01.560
and text stacks need. And you're going to give extra information. You might not have that at design

31:01.560 --> 31:08.560
time, but if you think of it as a pipeline that splits off, you might want to add some extra magic from

31:08.560 --> 31:17.560
your standard open API to enhance it before you generate code from it. But generating code is typically

31:17.560 --> 31:24.560
fine. It will only be as good as your description is. And lots of those fields are optional. So cool. I am

31:24.560 --> 31:29.560
out of time. Thank you so much, everyone. I hope to see you during the event.

