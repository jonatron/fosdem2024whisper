WEBVTT

00:00.000 --> 00:12.000
Thank you.

00:12.000 --> 00:22.000
Let's see.

00:22.000 --> 00:30.000
Thank you.

00:30.000 --> 00:31.000
Come on.

00:31.000 --> 00:33.000
Oh, you got a shiny surface here.

00:33.000 --> 00:38.000
I'm old fashioned. I like to use a mouse.

00:38.000 --> 00:42.000
I'd like to thank Marcus for having me here.

00:42.000 --> 00:44.000
I just wanted to see what that looked like.

00:44.000 --> 00:46.000
Okay.

00:46.000 --> 00:53.000
And I'm going to run a bash grip right now.

00:53.000 --> 00:54.000
Okay.

00:54.000 --> 00:59.000
So this should be fairly automated.

00:59.000 --> 01:01.000
Oh, well.

01:01.000 --> 01:02.000
Okay.

01:02.000 --> 01:04.000
Hi, I'm Lance.

01:04.000 --> 01:10.000
And I like to build stuff and quick streams, software I've built.

01:10.000 --> 01:14.000
It's a new flow graph framework.

01:14.000 --> 01:18.000
Okay.

01:18.000 --> 01:19.000
Okay.

01:19.000 --> 01:22.000
What is quick stream?

01:22.000 --> 01:28.000
The biggest part of it is it's an application programming library,

01:28.000 --> 01:32.000
application programming interface library.

01:32.000 --> 01:35.000
Okay, not like the APIs you hear about on the web, I get,

01:35.000 --> 01:41.000
but they seem to change the word API to have a different meaning than what I'm used to.

01:41.000 --> 01:44.000
So that's the core runtime library.

01:44.000 --> 01:46.000
It's the biggest part of it.

01:46.000 --> 01:47.000
Okay.

01:47.000 --> 01:51.000
And with that library, we built, oh, this isn't going to work so good on that,

01:51.000 --> 01:52.000
is it?

01:52.000 --> 01:54.000
I'll come over here.

01:54.000 --> 02:00.000
We built blocks, similar to new radio blocks.

02:00.000 --> 02:03.000
Okay.

02:03.000 --> 02:06.000
There are simple blocks that do computation.

02:06.000 --> 02:10.000
You connect the simple blocks together and then you're going to get flow graph.

02:10.000 --> 02:14.000
And also hierarchical blocks, I call them super blocks.

02:14.000 --> 02:16.000
New radio calls them here blocks.

02:16.000 --> 02:18.000
I like the word super.

02:18.000 --> 02:19.000
Okay.

02:19.000 --> 02:23.000
There are two programs that come with it.

02:23.000 --> 02:30.000
A command line program and a graphical user program.

02:30.000 --> 02:33.000
Both these programs do the same thing.

02:33.000 --> 02:40.000
I'm going to write the command line program options first and then I integrate them into the GUI

02:40.000 --> 02:44.000
because I need tests to make sure my code works.

02:44.000 --> 02:51.000
And so the command line interface is really nice for doing the tests that checks that my code is correct.

02:51.000 --> 02:52.000
Okay.

02:52.000 --> 02:57.000
And it's all written in C with very few required dependencies.

02:57.000 --> 02:58.000
Okay.

02:58.000 --> 03:02.000
Oh, I'll just jump right into it here.

03:02.000 --> 03:03.000
Okay.

03:03.000 --> 03:10.000
So I click on that guy there and I didn't click right so I got to go back.

03:10.000 --> 03:12.000
Click this.

03:12.000 --> 03:13.000
Okay.

03:13.000 --> 03:14.000
Okay.

03:14.000 --> 03:16.000
How does that look?

03:16.000 --> 03:17.000
Okay.

03:17.000 --> 03:21.000
It's a bash shell and this is the demo for the command line program.

03:21.000 --> 03:22.000
Okay.

03:22.000 --> 03:26.000
I type in QUI.

03:26.000 --> 03:31.000
How many people here have done command line programming?

03:31.000 --> 03:32.000
Good.

03:32.000 --> 03:33.000
Okay.

03:33.000 --> 03:43.000
So this is, it has a complete, well not as complete as I could think of if you have more things you want in bash completion,

03:43.000 --> 03:45.000
I'll code them in.

03:45.000 --> 03:52.000
So I can hit tab a few times and I see there are four programs installed from the quickstream installation.

03:52.000 --> 03:58.000
Two of them I'm going to go over and demo and then the others came about from necessity

03:58.000 --> 04:00.000
and I want to have time to go into those.

04:00.000 --> 04:09.000
So I'm going to hit space and hit tab a few more times and we can see what the options are for this command line program.

04:09.000 --> 04:13.000
There are, let me hit another dash there.

04:13.000 --> 04:16.000
Okay.

04:16.000 --> 04:19.000
And hit tab again.

04:19.000 --> 04:21.000
I like that long options better.

04:21.000 --> 04:29.000
I always use the long options in my test programs too because the shorter options do the same thing but

04:29.000 --> 04:36.000
they're limited to one character so if I change an interface then it breaks all my tests and so on.

04:36.000 --> 04:47.000
But the long option names are probably not going to change their name given they'll have the ability to stay unique because they're a long character set.

04:47.000 --> 04:48.000
Okay.

04:48.000 --> 04:52.000
So I want to run this program then with some kind of option.

04:52.000 --> 04:53.000
Okay.

04:53.000 --> 05:08.000
So it has a semi decent help in it and it's a long help dash dash help option and I'm going to pipe it to the pager.

05:08.000 --> 05:10.000
Bless.

05:10.000 --> 05:13.000
And so it looks something like a man page.

05:13.000 --> 05:15.000
Let's see how that came out pretty good.

05:15.000 --> 05:16.000
All right.

05:16.000 --> 05:20.000
So we can scroll through the man page and there you have it.

05:20.000 --> 05:23.000
You're used to looking at this kind of stuff but so it's there.

05:23.000 --> 05:27.000
It's documented this much at this point.

05:27.000 --> 05:37.000
That'll turn into a man page of course and it will be auto generated when you build the software and install it from this text which is actually in a separate program.

05:37.000 --> 05:42.000
It launches a separate program because there's too much too many characters in this program.

05:42.000 --> 05:43.000
I thought it would get bigger.

05:43.000 --> 05:50.000
I wanted to keep it small so it launches the help separately from another program which you don't have to worry about.

05:50.000 --> 05:51.000
Okay.

05:51.000 --> 05:52.000
As you're using it.

05:52.000 --> 05:53.000
Okay.

05:53.000 --> 05:54.000
Let me quit this.

05:54.000 --> 05:58.000
So this is bash bash has this wonderful thing called history.

05:58.000 --> 06:08.000
We all know about and I've preloaded a history in here because I would spend at least half an hour trying to type in one command line to get a flow graph running.

06:08.000 --> 06:15.000
So instead of sitting here for dittling on my keyboard.

06:15.000 --> 06:20.000
Yeah, maybe wouldn't take a half an hour to type in that command.

06:20.000 --> 06:28.000
With the bash completion you can find the blocks in a list of blocks that come up when you hit the tab.

06:28.000 --> 06:33.000
So it has tab file completion on the block files themselves.

06:33.000 --> 06:34.000
Okay.

06:34.000 --> 06:38.000
And I was going to show that but I skipped it because I want to make sure I got enough time here.

06:38.000 --> 06:40.000
So I've got to run this thing, right?

06:40.000 --> 06:41.000
Okay.

06:41.000 --> 06:43.000
So there is running.

06:43.000 --> 06:44.000
Okay.

06:44.000 --> 06:47.000
So what did I just do?

06:47.000 --> 06:52.000
So this was the display command that was in the command line.

06:52.000 --> 06:55.000
You can run the display command as many times as you want.

06:55.000 --> 06:59.000
You could load a block, display it, then load another block, display it again.

06:59.000 --> 07:02.000
Then you see two blocks then on the second display that you show.

07:02.000 --> 07:04.000
And then you keep on adding to it.

07:04.000 --> 07:08.000
This is really too much to look at in a presentation like this.

07:08.000 --> 07:10.000
But it shows the flow graph.

07:10.000 --> 07:15.000
The blue lines are what I call control parameters.

07:15.000 --> 07:19.000
And the red lines, there's only two red lines.

07:19.000 --> 07:25.000
They are stream data, similar to GNU radios stream data.

07:25.000 --> 07:26.000
Okay.

07:26.000 --> 07:28.000
Let me just cue that thing.

07:28.000 --> 07:31.000
Everybody is familiar with image magic?

07:31.000 --> 07:32.000
Okay.

07:32.000 --> 07:40.000
And this is from the graph viz program that uses this dot file format.

07:40.000 --> 07:45.000
That's really easy to print out a graph.

07:45.000 --> 07:48.000
And it displays it for you magically.

07:48.000 --> 07:50.000
And my formatting kind of stinks there.

07:50.000 --> 07:52.000
I've got to get better at dot programming.

07:52.000 --> 07:54.000
You get a better display than that.

07:54.000 --> 08:01.000
It gives you all the things you can configure and connect in the block in that mess there.

08:01.000 --> 08:02.000
Okay.

08:02.000 --> 08:05.000
So we don't need to be concerned with that right now.

08:05.000 --> 08:06.000
Okay.

08:06.000 --> 08:12.000
So this is this one program I'm running from that command line.

08:12.000 --> 08:22.000
And we can see it's using the GNU radio QT GUI sync, which has this nice thing.

08:22.000 --> 08:24.000
I like the constellation plot.

08:24.000 --> 08:26.000
Let's see if I can pick this up.

08:26.000 --> 08:29.000
Yeah, I can saturate it.

08:29.000 --> 08:32.000
Yeah.

08:32.000 --> 08:36.000
Quickstream writing house has some GUIs there.

08:36.000 --> 08:40.000
One GUI per block where a GUI would be a slider here.

08:40.000 --> 08:45.000
Like I can change the frequency and the gain of this thing.

08:45.000 --> 08:47.000
I can maybe desaturate that.

08:47.000 --> 08:48.000
Yeah, there you go.

08:48.000 --> 08:50.000
I just smudged it.

08:50.000 --> 08:55.000
I can also kill that and then run it again with the GUI.

08:55.000 --> 08:56.000
Okay.

08:56.000 --> 09:02.000
So what that's doing is I have a block that is a Unix pipe block.

09:02.000 --> 09:07.000
And then Unix has an option to say what program to run to pipe to.

09:07.000 --> 09:15.000
And so it pipes to a radio, a Python script in this case, which I pre-constructed obviously.

09:15.000 --> 09:16.000
Okay.

09:16.000 --> 09:21.000
Let me kill this and move on to another slide.

09:21.000 --> 09:31.000
Okay, so ctrl-C again, ctrl-D, and back to the slides.

09:31.000 --> 09:34.000
All right, so that was okay.

09:34.000 --> 09:42.000
So why on earth would I do such a thing?

09:42.000 --> 09:47.000
I wanted to write blocks with one source file, one C file.

09:47.000 --> 09:48.000
Okay.

09:48.000 --> 09:53.000
And well, of course, you may have to make a make file or just at least having the top of the file,

09:53.000 --> 09:58.000
a compiler line, how to make the damn thing when you get there.

09:58.000 --> 10:00.000
That would be good for simple blocks.

10:00.000 --> 10:04.000
Of course, you can use many files to make these linked to other libraries.

10:04.000 --> 10:07.000
It doesn't care.

10:07.000 --> 10:11.000
Or I can make the blocks in C plus plus if I like.

10:11.000 --> 10:13.000
Kind of partial to C for some reason.

10:13.000 --> 10:17.000
Or for that matter, I could probably write blocks in Fortran.

10:17.000 --> 10:20.000
Fortran and C get along very well.

10:20.000 --> 10:23.000
Okay, like the linear algebra libraries, nobody wants to rewrite those.

10:23.000 --> 10:26.000
Those things are amazing.

10:26.000 --> 10:32.000
They'll agglise the matrix and you try to get all ones and it's like one point, you know,

10:32.000 --> 10:40.000
whoever wrote that code is, you know, oh, you wrote it?

10:40.000 --> 10:50.000
So, oh, so another feature is that workflow, when you're building whatever it is you're

10:50.000 --> 10:57.000
building through your end user application, Quickstream GUI and Quickstream command line

10:57.000 --> 10:59.000
both output a block.

10:59.000 --> 11:02.000
The block is itself your end user application.

11:02.000 --> 11:08.000
That block can be reloaded back into Quickstream GUI or Quickstream command line.

11:08.000 --> 11:09.000
They both do the same thing.

11:09.000 --> 11:12.000
And so we have a cyclic workflow then.

11:12.000 --> 11:19.000
So we output stuff, use stuff, that same stuff we can reload back in, even if you edit it.

11:19.000 --> 11:25.000
Because the runtime library knows about what that stuff is and when it loads it up it's

11:25.000 --> 11:30.000
just loading up a dynamic shared object and it looks for the symbols that are in it.

11:30.000 --> 11:34.000
As long as you didn't like change the names of all your functions and stuff, it's still

11:34.000 --> 11:38.000
going to be able to find all those functions and be able to call them when it reloads it.

11:38.000 --> 11:49.000
OK, so workflow being cyclic, typical use case GNU radio is you output a Python script

11:49.000 --> 11:58.000
from GNU radio companion or you output C++ code that you compile.

11:58.000 --> 12:04.000
Once those files are output, they don't go back in.

12:04.000 --> 12:06.000
So that workflow is not cycled.

12:06.000 --> 12:10.000
In the typical use case of GNU radio companion.

12:10.000 --> 12:17.000
But if you were to output the hierarchical block, then you could have a cyclic workflow.

12:17.000 --> 12:24.000
And I think that could probably bleed back some benefit into the whole thing if you get

12:24.000 --> 12:26.000
that cyclic workflow in there.

12:26.000 --> 12:33.000
OK, so next feature we can assign threads to blocks on the fly.

12:33.000 --> 12:38.000
Well the flow graph is running while all the code is running, what have you.

12:38.000 --> 12:43.000
So and we can give it arbitrary thread numbers of thread pools and threads in those thread pools

12:43.000 --> 12:48.000
and say here I assign you to this block, I assign you to this block and so on.

12:48.000 --> 12:52.000
And I'll illustrate that in the next GUI demo.

12:52.000 --> 12:59.000
It also has a pass through buffers where your input and your output are the same size

12:59.000 --> 13:03.000
then you don't have to do a memory copy for them with the input to the output.

13:03.000 --> 13:09.000
And so you can get an optimization where you're eliminating all the memory copy in the block

13:09.000 --> 13:11.000
by using the pass through buffer.

13:11.000 --> 13:16.000
And that can go through the next block and the next block if they have the same amount

13:16.000 --> 13:17.000
of input as output.

13:17.000 --> 13:20.000
So it's not a decimator or what's the other thing?

13:20.000 --> 13:26.000
Yeah, it can't get bigger or smaller as it comes in and out.

13:26.000 --> 13:31.000
OK, and the flow graphs can have loops.

13:31.000 --> 13:38.000
OK, both the pass through buffers and flow graphs with loops, both of those things I think

13:38.000 --> 13:44.000
will be in GNU Radio 4.0, my guess.

13:44.000 --> 13:50.000
All right, assignment of threads on the fly, I don't know about that.

13:50.000 --> 13:55.000
Workflow being cyclic, I want to push that one too.

13:56.000 --> 14:02.000
So you'd have to take the hierarchy of blocks and be careful how you construct them such

14:02.000 --> 14:06.000
that it's easy for the user to then make their app from that.

14:06.000 --> 14:07.000
Yeah, I don't know.

14:07.000 --> 14:10.000
So there's a little work to be done on that too.

14:10.000 --> 14:15.000
But that was one of my biggest incentives is to get that cyclic workflow.

14:15.000 --> 14:21.000
All right, so let me move on to the next demo here.

14:22.000 --> 14:27.000
OK, so I just click on this thing here and now it launches the next demo.

14:27.000 --> 14:30.000
So this is QuickStream GUI.

14:30.000 --> 14:32.000
So you see I named it QuickStream.

14:32.000 --> 14:34.000
I should have named it QuickStream GUI, I don't know.

14:34.000 --> 14:36.000
I can have a vote here later.

14:36.000 --> 14:38.000
What should I call this program?

14:38.000 --> 14:44.000
OK, so on the side here, it looks something like GNU Radio Companion.

14:44.000 --> 14:50.000
And we have core blocks that are installed from in the package.

14:50.000 --> 14:53.000
And this is two actually, but these are test blocks.

14:53.000 --> 15:04.000
You wouldn't want to use test blocks in your end user application because what these test blocks do is nasty things like testing to see if a block can fail by, you know,

15:04.000 --> 15:06.000
you know, committing suicide and what have you.

15:06.000 --> 15:12.000
So you want to test all the different failure modes that are in your software in these test blocks.

15:12.000 --> 15:18.000
But it so happens that I'm going to use a test block to demonstrate today.

15:18.000 --> 15:28.000
So I can load, so we see I just did a right click on the block in this little directory tree here with files in it.

15:28.000 --> 15:30.000
These files are blocks.

15:30.000 --> 15:31.000
I can load it into the graph.

15:31.000 --> 15:32.000
Here, let me load it into the graph.

15:32.000 --> 15:33.000
There it is.

15:33.000 --> 15:39.000
Oh, yeah, so I named this one Fostum 2024.

15:39.000 --> 15:43.000
Now, that's not as interesting to look at as when I loaded it differently.

15:43.000 --> 15:45.000
OK, so let me make another tab.

15:45.000 --> 15:49.000
So that right now that's a flow graph that's running in that tab.

15:49.000 --> 15:56.000
All right, so let me load it again though, but I'm going to load it as a flattened super block.

15:56.000 --> 15:58.000
So boom, there it is.

15:58.000 --> 16:02.000
OK, this one's kind of a mess.

16:02.000 --> 16:05.000
I don't think you want to, I don't know.

16:05.000 --> 16:12.000
These blocks are translucent so you can see the connections easily in them.

16:12.000 --> 16:17.000
Because when you start making connections that loop around the blocks,

16:17.000 --> 16:23.000
like this one here has a connection going from its input to its output.

16:23.000 --> 16:26.000
OK, now what does this block do?

16:26.000 --> 16:28.000
OK, so it's got a sequence generator.

16:28.000 --> 16:32.000
That's generating just random bits.

16:32.000 --> 16:41.000
And I encode them as hex characters because I like to program on units where you always use ASCII text for everything, right?

16:41.000 --> 16:44.000
And then I put them through sequence checkers.

16:44.000 --> 16:47.000
And that's just testing out that the stream works.

16:47.000 --> 16:53.000
OK, and so I've tested this thing out by running this thing for days.

16:53.000 --> 16:55.000
I come back, yep, still running, yep.

16:55.000 --> 17:00.000
And it's checking every single bit that goes through these blocks to make sure that they're working.

17:00.000 --> 17:02.000
Then I can also check out the speed and what have you.

17:02.000 --> 17:04.000
See how it's doing the performance.

17:04.000 --> 17:08.000
Now, the button bar in this thing is pretty unusual, I guess,

17:08.000 --> 17:11.000
but it's got a translucent button bar here.

17:11.000 --> 17:14.000
It's got a run buttons here, I'll run it.

17:14.000 --> 17:17.000
So now you are in the matrix.

17:17.000 --> 17:20.000
OK, that's a little matrix converter block.

17:20.000 --> 17:26.000
It was just ASCII text before, but then I say, hey, this is going to be cool for this demo.

17:26.000 --> 17:29.000
There's also a halt button.

17:29.000 --> 17:31.000
OK, there's a difference between halt and run.

17:31.000 --> 17:34.000
A very, very good difference.

17:34.000 --> 17:41.000
So halt, right there, I just hit it, will stop all the threads from working.

17:41.000 --> 17:44.000
And the blocks don't know anything about it.

17:44.000 --> 17:49.000
As far as they're concerned, when you unhalt, it never halted.

17:49.000 --> 17:51.000
The blocks just don't know.

17:51.000 --> 17:57.000
All right, so run though will run the stream, the stream's in the photograph.

17:57.000 --> 18:01.000
The other inner block communication methods are already running.

18:01.000 --> 18:04.000
They never stop, like the control parameters.

18:04.000 --> 18:08.000
A control parameter, for example, so the stream lines are the red lines.

18:08.000 --> 18:10.000
A control parameter is like this purple line here.

18:10.000 --> 18:14.000
See, I'm jiggling this block up here.

18:14.000 --> 18:17.000
It's got a button on it that will hit a run,

18:17.000 --> 18:21.000
and I've got blocks that will run the flow graph for you in the flow graph.

18:21.000 --> 18:25.000
That's a little tricky because then it has to be very asynchronous,

18:25.000 --> 18:29.000
and it's got a sort of, hey, I request to run later sometime

18:29.000 --> 18:33.000
because I don't want to crap on myself because all these threads,

18:33.000 --> 18:38.000
others threads are running and I can't modify the data structures to get it to do that yet.

18:38.000 --> 18:40.000
But I'm going to have you do this later.

18:40.000 --> 18:44.000
So it has to be an asynchronous form of a program.

18:44.000 --> 18:47.000
It's kind of like if you've done JavaScript quite a bit,

18:47.000 --> 18:53.000
I was influenced quite a bit by JavaScript in the way they run things asynchronously all the time.

18:53.000 --> 18:57.000
Any blocking call is asynchronous usually unless you take,

18:57.000 --> 19:03.000
unless you do the synchronous one, which is probably not a great design.

19:03.000 --> 19:07.000
So let's see, there it is running.

19:07.000 --> 19:12.000
Now, I wanted to show Htop here, and Htop is nice.

19:12.000 --> 19:14.000
It's not so nice right now.

19:14.000 --> 19:21.000
Let me do a F4, and I'll type in bin, what do I type in so far?

19:21.000 --> 19:23.000
Bin slash QUI.

19:23.000 --> 19:28.000
Okay, now I have it searching for the quickstream GUI process,

19:28.000 --> 19:34.000
and we can see there are two threads working hard.

19:34.000 --> 19:37.000
Okay, this is unthrottled, so that's what you get.

19:37.000 --> 19:40.000
That's what I want in my case because I'm testing this thing,

19:40.000 --> 19:45.000
and I want to put it through as hard as I can because this is a test.

19:45.000 --> 19:50.000
Now, oops, why did I do that?

19:50.000 --> 19:59.000
Okay, what I have in the GUI here is I just clicked on the layout window.

19:59.000 --> 20:02.000
That's the top level window there where all the blocks are,

20:02.000 --> 20:06.000
and I've got a lot of options in there I can do.

20:06.000 --> 20:11.000
So it's a matter of right click mostly to find stuff in this quickstream GUI program.

20:11.000 --> 20:13.000
So right click.

20:13.000 --> 20:16.000
So I want to manage the thread pools.

20:16.000 --> 20:20.000
And so right now you see it says two,

20:20.000 --> 20:24.000
and there are two threads in this thread pool that are running this flow graph.

20:24.000 --> 20:29.000
And what I want to do is mess around with the number of threads that are running this thing.

20:29.000 --> 20:34.000
An easy way to do that is to create a new thread pool by clicking that button there,

20:34.000 --> 20:38.000
and then I want to tell it, I want to eight threads because I've got,

20:38.000 --> 20:41.000
supposedly, eight cores on this computer.

20:41.000 --> 20:49.000
And, you know, I'm not trying to do a performance test.

20:49.000 --> 20:53.000
And now, let's see, did I get the eight clicked in yet?

20:53.000 --> 20:55.000
No, I got to hit enter or something.

20:55.000 --> 20:58.000
There you go.

20:58.000 --> 21:01.000
No.

21:01.000 --> 21:04.000
Oh, so what's going on here?

21:04.000 --> 21:05.000
Why didn't it go?

21:05.000 --> 21:07.000
This is probably good that I screwed that up.

21:08.000 --> 21:12.000
I still have that thread pool there, and I haven't assigned blocks to it yet.

21:12.000 --> 21:13.000
Duh.

21:13.000 --> 21:17.000
Okay, so these kinds of duhs happen all the time.

21:17.000 --> 21:19.000
So let me just remove that thread pool,

21:19.000 --> 21:23.000
and now they have to migrate to the other thread pool.

21:23.000 --> 21:27.000
Oh, thank you.

21:27.000 --> 21:36.000
Okay, so now I have eight CPUs being used freely well, except not very well.

21:36.000 --> 21:43.000
The punchline here is that this has what's it called hyperthreading.

21:43.000 --> 21:46.000
So I can only expect 50% on each one.

21:46.000 --> 21:54.000
Okay, so let me go get to the next part of this demo, which is real quick.

21:54.000 --> 21:59.000
It's in the examples here, and I'm going to run, oops, not that one there.

21:59.000 --> 22:01.000
I need a new tab.

22:01.000 --> 22:05.000
Okay.

22:05.000 --> 22:06.000
Load as graph.

22:06.000 --> 22:09.000
This is the same example that I ran before from the command line.

22:09.000 --> 22:12.000
It's exactly the same, and I can run it here.

22:12.000 --> 22:15.000
And ta-da.

22:15.000 --> 22:17.000
Okay, and this has a GUI too.

22:17.000 --> 22:23.000
I could go to this control parameter here and set its value as it's running here

22:23.000 --> 22:28.000
and tell it it's true, and then it'll show up with the same widgets that we're showing before.

22:28.000 --> 22:31.000
And yeah, that's it.

22:31.000 --> 22:34.000
Let's see.

22:35.000 --> 22:45.000
So, I thought I'd leave two minutes for questions.

22:45.000 --> 22:58.000
Okay.

22:58.000 --> 23:01.000
So, you have a thread pool.

23:01.000 --> 23:06.000
That means your blocks are, you're choosing to run blocks on pools,

23:06.000 --> 23:12.000
and they're not like in radio 3 where they all have the same thread basically running on its own,

23:12.000 --> 23:15.000
deciding when to do the stuff on its own.

23:15.000 --> 23:17.000
Yes.

23:17.000 --> 23:22.000
If I want to set CPU affinity, then I need to make thread pools with one thread.

23:22.000 --> 23:25.000
And then I can control that CPU affinity.

23:25.000 --> 23:26.000
Yeah.

23:26.000 --> 23:30.000
So, the thread pool picks the next block to start the next slow project.

23:30.000 --> 23:34.000
They just end up in the same queues and shared in that thread queue,

23:34.000 --> 23:37.000
and then all the blocks are just going through that queue and saying,

23:37.000 --> 23:41.000
here's your job, I call them jobs, Micah.

23:41.000 --> 23:52.000
I mean, your terminology in GNU radio is different than mine in Quistream, sure.

23:52.000 --> 23:54.000
Any more questions?

23:54.000 --> 23:55.000
Oh, okay.

23:55.000 --> 24:00.000
And you can assign thread pools for different blocks, or it's always for the whole...

24:00.000 --> 24:01.000
Whatever you like.

24:01.000 --> 24:02.000
Whatever.

24:02.000 --> 24:03.000
Yeah.

24:03.000 --> 24:08.000
The GUI had another menu that would go through, and you'd have a list of all the simple blocks,

24:08.000 --> 24:10.000
which is the ones that actually compute stuff.

24:10.000 --> 24:14.000
And you can select the thread pool and the little thing beside it.

24:14.000 --> 24:18.000
Or you can do it on the command line with a command line interface, yeah.

24:18.000 --> 24:23.000
You'd have to name the thread pools, though, so that you could refer to it in the command line,

24:23.000 --> 24:25.000
or the GUI, too.

24:25.000 --> 24:26.000
Yeah.

24:26.000 --> 24:27.000
I did it.

24:34.000 --> 24:36.000
Any more questions?

24:36.000 --> 24:39.000
So, Lance, thanks again.

24:39.000 --> 24:40.000
Thank you.

