WEBVTT

00:00.000 --> 00:07.000
Yeah, thank you.

00:07.000 --> 00:14.000
Yeah, just to introduce myself, my name is Falka Lendeker.

00:14.000 --> 00:22.000
As you can all see, I work for Samba since the mid-90s, last century actually, so for

00:22.000 --> 00:23.000
quite a while.

00:23.000 --> 00:28.000
And I think I don't have to introduce what Samba and SMB really are.

00:28.000 --> 00:31.000
They are file-serving protocols.

00:31.000 --> 00:36.000
And what I would like to do eventually is kill NFS.

00:36.000 --> 00:44.000
And I know this doesn't go down well in some communities, but this is what I'm working on

00:44.000 --> 00:46.000
in my spare time, when I have spare time.

00:46.000 --> 00:51.000
In the last few months, unfortunately, it was a bit limited, but still, some of you already

00:51.000 --> 00:55.000
have seen this talk at Samba XP or other conferences.

00:55.000 --> 01:00.000
There's a little bit of new stuff, but I think it's still interesting to see that you can

01:00.000 --> 01:06.000
actually serve SMB clients or Linux clients with SMB.

01:06.000 --> 01:09.000
So what is it all about?

01:09.000 --> 01:15.000
You want to share file systems, directory and files across a network.

01:15.000 --> 01:19.000
So you have one server where you have a directory, where you have a file system.

01:19.000 --> 01:25.000
And you want this to be shared across a network to possibly many, many clients.

01:25.000 --> 01:31.000
If you go Linux to Linux, you typically use NFS.

01:31.000 --> 01:37.000
And one of the reasons is it's so simple.

01:37.000 --> 01:41.000
What you do is you just add a line to your ETC exports.

01:41.000 --> 01:44.000
Maybe you have to kill or restart a demon or whatever.

01:44.000 --> 01:49.000
Then you issue just amount command on your client and you're done.

01:49.000 --> 01:51.000
That's about it.

01:51.000 --> 01:56.000
However, it comes with some downsides.

01:56.000 --> 02:05.000
First, there is essentially no real metadata or data caching in NFS.

02:05.000 --> 02:13.000
This means that it can regularly happen that you create a file somewhere and it doesn't really show up

02:13.000 --> 02:19.000
until a bit later, some on other clients.

02:19.000 --> 02:26.000
If you just write to directories, if you just write to files, other clients don't really see the M time

02:26.000 --> 02:31.000
or size updates really precisely and so on.

02:31.000 --> 02:34.000
So this is kind of problematic.

02:34.000 --> 02:40.000
Why does the mail format actually exist?

02:40.000 --> 02:42.000
Because locking doesn't work over NFS.

02:42.000 --> 02:49.000
And yes, NFSv4 has locking, NFSv3 has external protocols to do locking,

02:49.000 --> 02:52.000
but you can't really rely on those.

02:52.000 --> 03:00.000
And it's really, really complex to set up locking properly and to get failover done and so on.

03:00.000 --> 03:08.000
This initial very simple setup, and I love this acronym of NFS, it's just no file security.

03:08.000 --> 03:16.000
Because essentially what you do is you trust your clients to assign the UIDs and GIDs

03:16.000 --> 03:21.000
and essentially the group permissions and whatever you assign them correctly on the client.

03:21.000 --> 03:23.000
And there's nobody in between who actually checks.

03:23.000 --> 03:30.000
I know there are these days there are protocol extensions to do NFS over TLS,

03:30.000 --> 03:36.000
so at least transport is in a standard way protected.

03:36.000 --> 03:44.000
You can of course go and enable Kerberos for NFS, but this is also pretty complicated

03:44.000 --> 03:47.000
and we have done it in customer scenarios.

03:47.000 --> 03:50.000
The client at least is buggy like hell.

03:50.000 --> 03:54.000
And you get incompatibilities all over the place.

03:54.000 --> 03:57.000
You lose keys, you would, you lose anything.

03:57.000 --> 04:01.000
So it's really, really difficult to set up.

04:01.000 --> 04:08.000
As I said, clients have a very bad day when you Kerberize them.

04:08.000 --> 04:12.000
SMB however, it really comes from the Windows world.

04:12.000 --> 04:19.000
And if you look at the, there was one talk by the original SMB implementer, Barry Feigenbaum.

04:19.000 --> 04:23.000
Is it online available, GÃ¼nther, do you know?

04:23.000 --> 04:26.000
So at one of the conferences that we regularly go to,

04:26.000 --> 04:33.000
there was actually a talk by the original inventor or developer of the SMB protocol.

04:33.000 --> 04:42.000
And essentially what they did is they took the MS-DOS interrupt in 21

04:42.000 --> 04:46.000
and put the arguments on disk and let the server take care of it.

04:46.000 --> 04:54.000
And this means that they have to be compatible with a lot of applications on DOS.

04:54.000 --> 05:02.000
And DOS means that applications like Word 5.5 or whatever believes it's alone on the machine.

05:02.000 --> 05:05.000
So this means you have to get locking right.

05:05.000 --> 05:09.000
If Word opens a file and it believes it's the only one editing that file,

05:09.000 --> 05:13.000
you better make sure that nobody else also edits that file simultaneously.

05:13.000 --> 05:18.000
So they had to get locking right from day one.

05:18.000 --> 05:22.000
The other one is cache coherency.

05:22.000 --> 05:28.000
We have protocol for this and this between Windows and Linux, this actually works.

05:28.000 --> 05:37.000
So if you open a file over SMB, typically what you get is a permission to cache stuff,

05:37.000 --> 05:39.000
to cache your updates, to cache reads and so on.

05:39.000 --> 05:42.000
This leads to much, much better performance.

05:42.000 --> 05:49.000
And if somebody else also wants to open the file, you get notified that,

05:49.000 --> 05:51.000
oh, no, you're not alone on the file anymore.

05:51.000 --> 05:52.000
Please drop all your caches.

05:52.000 --> 05:54.000
Please write back your caches.

05:54.000 --> 05:57.000
And you tell the server, hey, I'm done writing back.

05:57.000 --> 05:59.000
Now please let the other one in.

05:59.000 --> 06:06.000
And then they have to agree that they all have to write back their changes and so on,

06:06.000 --> 06:10.000
read new data from the server.

06:10.000 --> 06:17.000
And the other advantage is, one of the advantages is that SMB servers, they are everywhere.

06:17.000 --> 06:22.000
Every home router in Germany, the Fritz box has an SMB server in there.

06:22.000 --> 06:26.000
All NAS appliances have SMB, so it is everywhere.

06:26.000 --> 06:30.000
And you can access it from almost any place.

06:30.000 --> 06:35.000
Whether all the features that we are talking about here are correctly implemented everywhere,

06:35.000 --> 06:36.000
that's a different story.

06:36.000 --> 06:43.000
For example, Fritz boxes don't talk to my mobile phone properly, but that's a different story.

06:43.000 --> 06:49.000
But essentially, it's everywhere.

06:49.000 --> 06:54.000
The SMB protocol is very flexible.

06:54.000 --> 07:00.000
There were very, very early extensions of the SMB1 protocol.

07:00.000 --> 07:04.000
So like every protocol, you have a lot of requests going back and forth,

07:04.000 --> 07:07.000
and there is unused protocol space.

07:07.000 --> 07:12.000
You have whatever, a create request, a read request, and so on.

07:12.000 --> 07:16.000
They are numbered, and there's number space that you can take and so on.

07:16.000 --> 07:23.000
And this is what we did early in the, whatever, 2000s or so for the SMB1 protocol.

07:23.000 --> 07:29.000
There are UNIX extensions that match all the UNIX semantics in the SMB1 protocol.

07:29.000 --> 07:38.000
This was never transferred properly yet to the newer and now only SMB3 protocol.

07:38.000 --> 07:50.000
And what we are working on actually is we want to extend the SMB protocol with all the behavior that a POSIX client expects.

07:50.000 --> 07:52.000
How is that done?

07:52.000 --> 07:58.000
The first packet that is sent between client and server is called Negotiate Protocol.

07:58.000 --> 08:01.000
And it exactly does what it says.

08:01.000 --> 08:05.000
It negotiates different flavors of the protocol.

08:05.000 --> 08:12.000
For example, it tells, hey, I'm SMB1, I'm SMB2, I'm SMB3, and I have this and this subfeature and so on.

08:12.000 --> 08:17.000
I can do these capabilities and those capabilities I can't and so on.

08:17.000 --> 08:24.000
And essentially what Microsoft has done with the SMB3 protocol,

08:24.000 --> 08:30.000
they did the smart thing and made this request extensible.

08:30.000 --> 08:39.000
Essentially what you can do is you have this Negotiate Protocol request and you can add what I would call extended attributes to this request over the wire.

08:39.000 --> 08:50.000
I mean it's not an exact file system, but you can just extend the request in a standard way with a new Negotiate context.

08:50.000 --> 08:55.000
So you have a ton of Negotiate context that say, okay, I can do encryption this way, I can do whatever.

08:55.000 --> 09:04.000
And we just have an additional extended Negotiate context that says I can do POSIX in this version.

09:04.000 --> 09:09.000
So the client tells the server, I can do POSIX, server tells client I can't.

09:09.000 --> 09:15.000
The default behavior is for unknown extensions is that the server just ignores it and doesn't send a reply.

09:15.000 --> 09:23.000
If the server sends a reply, I know I'm talking to a Samba who is able to do all this stuff that I'm talking about here.

09:23.000 --> 09:35.000
File name handling. This is really painful in our case because Unix file systems are case sensitive.

09:35.000 --> 09:41.000
Windows file systems in particular NTFS is not case sensitive. What does it mean?

09:41.000 --> 09:48.000
Under Unix you can have two files, Make file and Make file, one with capital M, one with lowercase M,

09:48.000 --> 09:52.000
and under Windows you can't, under NTFS you can't.

09:52.000 --> 09:59.000
When now a Windows client comes in and says I want to create Make file,

09:59.000 --> 10:09.000
what you have to prove at creation time is that no other uppercase, lowercase combination of Make file exists in the file system

10:09.000 --> 10:14.000
to fulfill this promise that this is case insensitive.

10:14.000 --> 10:18.000
What do you do by default? You scan the whole directory.

10:18.000 --> 10:23.000
And this leads to an O to the order of N square performance behavior.

10:23.000 --> 10:32.000
If you just drop a million files into a directory, file number 900,000 takes a lot longer than file number 1

10:32.000 --> 10:39.000
because I have to scan the whole directory to prove that no other uppercase, lowercase combination exists.

10:39.000 --> 10:45.000
And what we can do is we can add a new create context, not only the negotiate context,

10:45.000 --> 10:51.000
but also the open file and create file request has these extended attributes.

10:51.000 --> 10:58.000
I can say that I want to open a file POSIX style by adding one of these create contexts.

10:58.000 --> 11:06.000
And we have defined a create context so that clients on a per request basis can say I want POSIX behavior,

11:06.000 --> 11:10.000
I want case sensitive behavior, I don't want file name restrictions,

11:10.000 --> 11:14.000
I want double quotes in a file name which Windows wouldn't allow.

11:14.000 --> 11:18.000
I want them. I know what I'm doing. I'm POSIX.

11:20.000 --> 11:25.000
So what we also need is POSIX metadata.

11:25.000 --> 11:32.000
If you look at the properties of Windows client on a Windows file, sorry.

11:33.000 --> 11:37.000
So we are here, Windows Server, I say properties.

11:37.000 --> 11:43.000
There's a lot of stuff. In particular, there's timestamps created.

11:43.000 --> 11:50.000
We have four timestamps in Windows that are roughly similar to what we have in Linux.

11:50.000 --> 11:54.000
We have attributes and so on. There's a lot of stuff that Windows has as metadata.

11:54.000 --> 11:58.000
However, the semantics are a bit different.

11:59.000 --> 12:06.000
In particular, they don't have a good notion of UID and GID.

12:06.000 --> 12:12.000
And they don't really have a good match right now for POSIX permissions.

12:12.000 --> 12:19.000
So some of the ones that we have in struct stat, like file size and so on,

12:19.000 --> 12:26.000
they are the same in Windows but in particular UID and GID, they are not.

12:27.000 --> 12:29.000
They are not the same at least.

12:29.000 --> 12:33.000
So we did. We extended the protocol.

12:33.000 --> 12:38.000
And if you, for example, do a stat on a file, if you ask for get file information,

12:38.000 --> 12:44.000
you can say I want this info level and there's a 16-bit field for info levels.

12:44.000 --> 12:46.000
And we just added one. We talked to Microsoft.

12:46.000 --> 12:48.000
Hey, get us this additional...

12:48.000 --> 12:54.000
Don't use this additional number that we use for POSIX information level.

12:54.000 --> 12:58.000
They agreed and so we have an additional field that we can use

12:58.000 --> 13:02.000
to fill in all this information that a client might want to use.

13:02.000 --> 13:06.000
However, second-last line.

13:06.000 --> 13:10.000
None of this is really the topic of this talk.

13:10.000 --> 13:13.000
It's about file types.

13:13.000 --> 13:19.000
If you look at the Unix file system, you have seven types of files.

13:19.000 --> 13:21.000
You have a normal file. You have a directory.

13:21.000 --> 13:23.000
What else do we have?

13:23.000 --> 13:26.000
We have block and character devices. We have named pipes.

13:26.000 --> 13:30.000
We have swim links. Oh, shock and horror.

13:30.000 --> 13:34.000
And we have sockets. Unix domain sockets.

13:36.000 --> 13:41.000
Samba can handle regular and directory files extremely well.

13:41.000 --> 13:45.000
Oh, there's a typo here as you find out.

13:45.000 --> 13:48.000
So we can handle directories and file. I mean, that's what we are made for.

13:48.000 --> 13:52.000
We have file servers so we better handle directories and files well.

13:52.000 --> 13:56.000
What do we do about the other ones?

14:00.000 --> 14:07.000
If you go and share ETC in Samba, sorry, share slash dev in Samba,

14:07.000 --> 14:11.000
something you probably shouldn't do, but if you do,

14:11.000 --> 14:15.000
Samba will find a lot of stuff that it can't really properly present to Windows,

14:15.000 --> 14:18.000
to any client.

14:18.000 --> 14:23.000
It will find character, block devices. It will find all sorts of stuff in slash dev.

14:23.000 --> 14:28.000
Or it will, if you just share a home directory, you will find sockets for

14:28.000 --> 14:32.000
GPG agent, SSH agent and so on.

14:32.000 --> 14:39.000
You will find all sorts of stuff that doesn't really fit into the file and directory schema.

14:39.000 --> 14:44.000
In particular, for example, you find files.

14:45.000 --> 14:51.000
And in previous Samba version, this used to work, that from a client you came in,

14:51.000 --> 14:59.000
it could open a file for writing, hoping that the server side on the Unix machine still exists,

14:59.000 --> 15:02.000
the server side process on the Unix machine still exists,

15:02.000 --> 15:07.000
and you could write into that and the server would get the data that you write into this.

15:07.000 --> 15:11.000
This can't be very popular because, I mean, many versions ago,

15:11.000 --> 15:14.000
we broke it and nobody noticed.

15:14.000 --> 15:17.000
Alexander is confirming.

15:17.000 --> 15:20.000
You're using it, Alexander?

15:29.000 --> 15:34.000
We have a lot of tests, but Alexander's comment was that we don't cover this,

15:34.000 --> 15:37.000
which means we didn't notice.

15:37.000 --> 15:40.000
Why didn't we know, or why did we break it?

15:40.000 --> 15:48.000
If you open a file for under Unix, all you can do is issue read and write syscalls.

15:48.000 --> 15:53.000
We don't do that in Samba anymore because whenever we get a read and write request from Windows,

15:53.000 --> 15:57.000
there's an offset attached to that read and write request, like in NFS.

15:57.000 --> 16:00.000
And we do the natural thing.

16:00.000 --> 16:06.000
We p-read and p-write, like what you do normally in the process where you have an offset.

16:07.000 --> 16:11.000
This is all from times when you couldn't really expect p-read to exist,

16:11.000 --> 16:14.000
but these times are long gone.

16:17.000 --> 16:22.000
We have some very special support for sockets.

16:22.000 --> 16:24.000
What's a socket?

16:24.000 --> 16:26.000
That's essentially a...

16:26.000 --> 16:29.000
It's a 5.0 on steroids.

16:30.000 --> 16:38.000
And what we do with sockets is we implement the Microsoft notion of RPCs.

16:38.000 --> 16:40.000
What is it?

16:40.000 --> 16:49.000
A Microsoft Windows client over SMB can open a file and transfer data over this file,

16:49.000 --> 16:55.000
special file, on the share IPC dollar, slash pipe, slash semr.

16:55.000 --> 16:58.000
What you do is you're win-redge.

16:58.000 --> 17:04.000
You open a file on the IPC dollar share, win-redge, Windows registry.

17:04.000 --> 17:08.000
You talk to the server side registry over RPC calls.

17:08.000 --> 17:15.000
And we implemented these days since 4.16 that our Windows registry server

17:15.000 --> 17:21.000
actually listens on a Unix domain socket and the SMB server connects to that Unix domain socket

17:21.000 --> 17:24.000
and just passes on back and forth requests.

17:24.000 --> 17:26.000
And so this is what I mean.

17:26.000 --> 17:31.000
We have limited support for sockets, but this is not what somebody would expect

17:31.000 --> 17:37.000
if on the client we would run a SSH8, for example, that clients connect to

17:37.000 --> 17:40.000
because this all needs to be done on the client side then.

17:40.000 --> 17:44.000
Block and character devices, I mean, we find them server side,

17:44.000 --> 17:47.000
but they don't make sense at all over the network.

17:47.000 --> 17:53.000
You don't want to whatever read and write to DevSDA over the network.

17:53.000 --> 17:55.000
You just don't want this.

17:55.000 --> 17:59.000
You could, but why?

17:59.000 --> 18:02.000
Enter NTFS repass points.

18:02.000 --> 18:06.000
There's a Wikipedia article actually on NTFS repass points.

18:06.000 --> 18:11.000
Repass points provide a way to extend the NTFS file system.

18:11.000 --> 18:15.000
A repass point contains a repass tag and data that is,

18:15.000 --> 18:20.000
and data that are interpreted by a file system filter driver identified by the tag.

18:20.000 --> 18:24.000
What does this mean?

18:24.000 --> 18:31.000
One use case is HSM systems, hierarchical storage management,

18:31.000 --> 18:39.000
where you have a huge file on NTFS that some software just pushes to tape

18:39.000 --> 18:46.000
and leaves a stab inside the NTFS file system that is just visible to the client as normal.

18:46.000 --> 18:53.000
And now when the client opens the file, the open code sees, okay,

18:53.000 --> 19:01.000
this stab is a repass point and the extended data that the repass point carries

19:01.000 --> 19:04.000
points at the place somewhere on tape.

19:04.000 --> 19:07.000
It's on this tape at that offset.

19:07.000 --> 19:12.000
And what you can do then in Windows is install a driver

19:12.000 --> 19:17.000
that when a client opens this file, the Windows kernel goes to the tape library

19:17.000 --> 19:20.000
and says, get me that file back.

19:20.000 --> 19:27.000
So this is software that you can install in the Windows kernel to extend NTFS semantics.

19:27.000 --> 19:33.000
And this is what, by the way, the NFS server uses.

19:33.000 --> 19:36.000
And we will see in an example of this.

19:36.000 --> 19:40.000
So applications can use this for arbitrary blobs.

19:40.000 --> 19:46.000
It's a special marker for a file, for a normal file that says, oh, I am a repass point

19:46.000 --> 19:52.000
and you can store stuff in there and essentially it's an extended attribute.

19:52.000 --> 19:56.000
When opening a file, NTFS filters can interpret the contents.

19:56.000 --> 19:59.000
This is what Microsoft also actually uses for sim links.

19:59.000 --> 20:01.000
Windows has symbolic links.

20:01.000 --> 20:06.000
They are stored as repass points.

20:06.000 --> 20:12.000
If you double click on that repass point, and I can demonstrate this here,

20:12.000 --> 20:15.000
I know demos never work.

20:15.000 --> 20:19.000
I have a file for and I will show you how I created this.

20:19.000 --> 20:21.000
I double click on the file for.

20:21.000 --> 20:24.000
Oh, okay.

20:24.000 --> 20:35.000
Wait, oh, I have a, as I said, I should never do.

20:35.000 --> 20:37.000
Ah, file for .text.

20:37.000 --> 20:42.000
Here it says text document, which is just a description of this is a .text file.

20:42.000 --> 20:50.000
I double click on this and what it says is the file cannot be accessed by the system

20:50.000 --> 20:57.000
because this is a repass point that happens to be named test.text or something.

20:57.000 --> 21:04.000
And they believe, oh, we have to open notepad, but it can't access that file.

21:05.000 --> 21:11.000
So the error message that you get if you double click on that file is,

21:11.000 --> 21:13.000
status I owe repass tag not handled.

21:13.000 --> 21:23.000
You have to tell the server that, oh, I want to open this special file in a special way.

21:23.000 --> 21:25.000
You have to set a flag.

21:25.000 --> 21:31.000
So a repass point, as I said above, has a so-called repass tag,

21:31.000 --> 21:35.000
which is a 32-bit integer.

21:35.000 --> 21:37.000
And if you look at the Microsoft documentation,

21:37.000 --> 21:44.000
Microsoft uses these repass tags and documents the use to a certain extent.

21:44.000 --> 21:47.000
And there's a lot of those.

21:47.000 --> 21:55.000
If you go here to that website, there's a ton of repass tags, reserve 0, reserve 1.

21:55.000 --> 21:59.000
What you see here is, I hope you can read that.

22:00.000 --> 22:02.000
No, you should be able to read that.

22:02.000 --> 22:03.000
That's HSM.

22:03.000 --> 22:05.000
That's HSM 2.

22:05.000 --> 22:08.000
And so on and so forth.

22:08.000 --> 22:11.000
Filter manager, repass tag, swim link.

22:11.000 --> 22:15.000
So this is what Microsoft defines in their spec,

22:15.000 --> 22:19.000
that they are using these sets of swim links.

22:19.000 --> 22:24.000
These sets of repass tags, and you get the integer there.

22:24.000 --> 22:30.000
Swim link is 0xA and then a C at the end.

22:30.000 --> 22:31.000
And we're using this.

22:31.000 --> 22:35.000
We are about to use that.

22:35.000 --> 22:43.000
So now we have two kinds of users of these repass tags.

22:43.000 --> 22:48.000
Do you remember WSL1, the version one of the Windows subsystem?

22:48.000 --> 22:53.000
They try to run Linux applications on Windows, and they face the same problem.

22:53.000 --> 22:59.000
Windows applications expect sockets and fee force and swim links to work.

22:59.000 --> 23:07.000
And in version one, they used NTFS actually for your home directory, for your local files.

23:07.000 --> 23:13.000
And what they did is, they have this repass tag address family unix.

23:13.000 --> 23:14.000
They use that.

23:14.000 --> 23:18.000
And what you will see here is, it must be somewhere.

23:18.000 --> 23:31.000
But if you dig a bit deeper, what they tell you is, the contents of these repass tags are not meaningful over the while.

23:31.000 --> 23:41.000
They were intended just for the WSL subsystem, Windows subsystem for Linux, server side.

23:41.000 --> 23:47.000
So they define as part of the data that is stored in this repass tag,

23:47.000 --> 23:52.000
hey, we have a block device, a character, a FIFO, and so on, with the obvious counterparts on Linux.

23:52.000 --> 23:59.000
So what they did in WSL1 is, when somebody didn't make FIFO, they created a file with a repass tag.

23:59.000 --> 24:06.000
And they, in the content of the repass tag, said, hey, this is a FIFO.

24:06.000 --> 24:08.000
None of them are actually documented.

24:08.000 --> 24:17.000
And because that costs so much trouble, the version two of the WSL, which I actually, is anybody using WSL?

24:17.000 --> 24:18.000
Some are.

24:18.000 --> 24:19.000
It's actually usable.

24:19.000 --> 24:21.000
I would say it's actually usable.

24:21.000 --> 24:26.000
You can't really tell the difference from a real Linux.

24:26.000 --> 24:27.000
At least I can't.

24:27.000 --> 24:30.000
I mean, if you look at Pock, of course, you will find differences.

24:30.000 --> 24:34.000
But for the normal day-to-day use, it actually works pretty well.

24:34.000 --> 24:42.000
Because what they are using, they are using a real X4 these days.

24:42.000 --> 24:46.000
Then there is a Windows NFS server.

24:46.000 --> 24:47.000
Pardon?

24:47.000 --> 24:48.000
Why?

24:48.000 --> 24:50.000
The question is why.

24:50.000 --> 24:53.000
I don't know.

24:53.000 --> 24:59.000
The Windows NFS server, this is what I'm going to present here, hopefully in demo.

24:59.000 --> 25:01.000
They also have the same problem.

25:01.000 --> 25:06.000
A client does a make link or a sim link or whatever.

25:06.000 --> 25:10.000
It doesn't make FIFO, and they have to store the data somewhere.

25:10.000 --> 25:18.000
And they define yet another set of repass points.

25:18.000 --> 25:27.000
And if you look here, they actually have a definition of what goes into the data, into the data field.

25:28.000 --> 25:33.000
Repass tag, repass length, and so on, in general.

25:33.000 --> 25:38.000
So they define sim link, character device, block device, and so on.

25:38.000 --> 25:43.000
And they actually specify what goes into the data field.

25:43.000 --> 25:45.000
For a sim link, the target goes in there and so on.

25:45.000 --> 25:53.000
And for the character device, you have two UIN32s for major and minor and so on.

25:53.000 --> 25:55.000
So they define what goes in there.

25:56.000 --> 26:04.000
I mean, you would have thought that these guys, talk to these guys, to share an implementation, but no.

26:04.000 --> 26:06.000
Why?

26:06.000 --> 26:14.000
The interesting thing is, if you look at, and I created a FIFO server side,

26:14.000 --> 26:21.000
and if you look at the properties of this FIFO, and you have to trust me, the one in the first row,

26:22.000 --> 26:27.000
can confirm that you have an L here.

26:27.000 --> 26:31.000
It says archive and L, L for sim link, if you look up the documentation.

26:31.000 --> 26:33.000
No, it's not a sim link, it's a FIFO.

26:33.000 --> 26:37.000
So their GUI is not really prepared for this.

26:37.000 --> 26:44.000
They believe, okay, all the GUI believes, all files that are repass points are sim links.

26:44.000 --> 26:46.000
Alexander?

26:47.000 --> 26:50.000
Is this client side?

26:50.000 --> 26:52.000
Client side? I can demonstrate that I see it.

26:52.000 --> 26:54.000
Because this is a local file, right?

26:54.000 --> 26:57.000
That's a local file that I created over NFS.

26:57.000 --> 27:06.000
Okay, so the NFS server created on a local file system something with this associated repass.

27:06.000 --> 27:07.000
Yes.

27:07.000 --> 27:11.000
So this directory here is local disk share.

27:11.000 --> 27:13.000
This is a local NTFS file.

27:13.000 --> 27:17.000
And what I did is I exported this via the NFS server.

27:17.000 --> 27:19.000
I mounted this from the client.

27:19.000 --> 27:22.000
And why don't I show it directly?

27:22.000 --> 27:26.000
I mounted it from the client, which is here.

27:26.000 --> 27:29.000
That's my client with a mount.

27:29.000 --> 27:32.000
If you look up at the top, NFS.

27:32.000 --> 27:39.000
And you can see in the left column here, I have sim links, I have block devices and so on.

27:39.000 --> 27:42.000
And I created them with normal UNIX commands over NFS.

27:42.000 --> 27:49.000
And this is what ended up on the NFS, on the NFS file system server side.

27:49.000 --> 27:51.000
Repass points.

27:51.000 --> 27:56.000
And so this is not too popular with Windows applications.

27:56.000 --> 28:08.000
So the Windows Explorer believes all files with repass points must be sim links because that's the most popular use of repass points in the Windows world.

28:08.000 --> 28:10.000
OK.

28:10.000 --> 28:15.000
So they don't look at the repass tag.

28:15.000 --> 28:21.000
They just see that this is repass point and it must be just one type of question.

28:21.000 --> 28:22.000
Yes.

28:22.000 --> 28:29.000
Alexander's comment was, and I will show you that in the Wireshark trace in a minute.

28:29.000 --> 28:34.000
There is a special flag in the metadata of the file that says I am a repass point.

28:34.000 --> 28:39.000
And you can of course get into the details of that repass point if you wanted to.

28:39.000 --> 28:41.000
But if you're an explorer, you don't care.

28:41.000 --> 28:47.000
You say it's a sim link.

28:47.000 --> 28:48.000
OK.

28:48.000 --> 28:50.000
Now this is a discussion.

28:50.000 --> 28:58.000
Do we use these guys or do we use these guys to represent or to present to the client when Samba finds a sim link?

28:58.000 --> 29:00.000
Samba site.

29:00.000 --> 29:04.000
Or for sim links, we even have three options.

29:04.000 --> 29:12.000
And so WSL version one has reserved repass tags.

29:12.000 --> 29:21.000
And if you look at one of these lists that I've shown you, you have repass tags for the individual subtypes, but they are not documented.

29:21.000 --> 29:23.000
They are not used anymore at all.

29:23.000 --> 29:26.000
You don't have any interoperability with anything else.

29:26.000 --> 29:28.000
We could of course use them.

29:28.000 --> 29:36.000
So in the case when Samba on disk finds a sim link or a block device, how do we present that?

29:36.000 --> 29:39.000
We have to make a choice.

29:39.000 --> 29:45.000
And WSL defines repass tags with undocumented comment.

29:45.000 --> 29:48.000
NFS only uses one repass tag.

29:48.000 --> 29:54.000
Pro NFS would be we have documentation available.

29:55.000 --> 29:56.000
And so on.

29:56.000 --> 30:03.000
And what we can do is we can write protocol level tests against the benchmark, which is the Windows NFS server.

30:03.000 --> 30:10.000
So we have ways to create these things on Windows and write just tests, which is very good.

30:13.000 --> 30:23.000
Also, if you now say, OK, I want to create a FIFO from my Windows client.

30:24.000 --> 30:29.000
That has mounted the home directory of a user on a Windows server.

30:30.000 --> 30:45.000
If I do that, the Windows client will create a repass tag that an NFS client talking to that same file system on the Windows server will also see as a sim link.

30:45.000 --> 30:47.000
Or as a FIFO, whatever.

30:47.000 --> 30:49.000
The same thing.

30:49.000 --> 30:54.000
And so this is why I would say, OK, I would like to use NFS repass tags.

30:54.000 --> 30:57.000
I have to talk to the CIFS kernel developers.

30:57.000 --> 31:02.000
I think with Linux 6.8, they went to different route.

31:02.000 --> 31:04.000
Andreas, do you know?

31:04.000 --> 31:05.000
No.

31:05.000 --> 31:09.000
So I think they went a different route, but we need to talk.

31:12.000 --> 31:14.000
Coming to sim links.

31:15.000 --> 31:32.000
Symbolic links in the BSD, UNIX, depending on how you look at it, are the best ideas since sliced bread, or the worst nightmare that everybody falls over security-wise.

31:32.000 --> 31:35.000
Even the Rust infrastructure.

31:35.000 --> 31:43.000
I mean, Rust being a language very security sensitive, they had their sim link race security bug.

31:44.000 --> 31:46.000
But we have to deal with it.

31:46.000 --> 31:47.000
We have to live with them.

31:47.000 --> 31:48.000
They are there.

31:48.000 --> 31:53.000
And so what do we now do when we see a sim link on the summer server side?

31:53.000 --> 31:57.000
Yeah, we can do that with the two ways that I presented.

31:57.000 --> 32:02.000
But as I said, Windows even has its own notion of sim links.

32:02.000 --> 32:14.000
So if you create a sim link, depending on where you come from, you get one out of three versions, three ways to represent them on an NTFS.

32:16.000 --> 32:28.000
And if you look at it, this Windows way of sim links, they actually work pretty well over SMB in the pure Windows world.

32:28.000 --> 32:40.000
For example, what you can do is you can have a sim link on a directory on an NTFS that is shared over SMB.

32:40.000 --> 32:49.000
And the sim link target can be backslash backslash IP address backslash share name backslash directory.

32:50.000 --> 33:00.000
And if you want to cut that file, or if you want to CD into that file from a Windows client, it will redirect to that server.

33:01.000 --> 33:11.000
So you can have cross server sim links with the Windows NTFS notion of sim links, with the pure Windows notion of sim links.

33:12.000 --> 33:28.000
Even better, if you try to open a sim link the Windows way, you double click on that file and under POSIX, you typically follow that sim link directory.

33:28.000 --> 33:37.000
If you mount that over NFS, the NFS client will have to take care of those and follow client side.

33:37.000 --> 33:40.000
But Windows does it a bit differently.

33:40.000 --> 33:47.000
When you double click on that or when you open that sim link file, they tell you, hey, you hit a sim link.

33:49.000 --> 33:56.000
And they will even in the error response, they will tell you, and by the way, the sim link points there.

33:57.000 --> 34:08.000
That saves at least one round trip, or several round tips, that if I hit a sim link, then I know where to go directly on the client side in the response.

34:08.000 --> 34:18.000
And Windows typically is completely path based, so if I open a Windows file, slash A slash B slash C slash D, and somewhere in the middle there's a sim link.

34:19.000 --> 34:29.000
They don't follow that server side, but they tell me, hey, go there, and by the way, I have passed slash A slash B already, and C was the sim link.

34:29.000 --> 34:36.000
So if I have a long path with many components, they tell me, okay, the third component is a sim link.

34:38.000 --> 34:41.000
Okay, how do we create these special files?

34:42.000 --> 34:49.000
Protocol-wise, there's a special flag to the open call, and we just set the contents.

34:50.000 --> 35:04.000
And yeah, what we can do is with Samba, what we don't want to do and what we will never do, if a Windows client comes in and creates a sim link the Windows way, we will not create a sim link server side.

35:05.000 --> 35:19.000
What we will do is because Windows sim links are also represented by normal files, 10 minutes left, they are represented by normal files with some special contents, with some special whatever extended data.

35:19.000 --> 35:20.000
We will do the same.

35:20.000 --> 35:33.000
So if you do a make link from Windows, then we will create such a file telling the client, hey, this is a sim link file, and the Windows client will just work as it will.

35:34.000 --> 35:37.000
And we will just open GIFs to the NDI interface and we will create Web notEP Things like R!!

35:37.000 --> 35:40.000
Or maybe Mint Speedusu advert.

35:43.000 --> 35:52.000
Okay, you know how much space here, I ran over the interlocking Mobile T share line for this.

35:52.000 --> 35:53.000
Okay, a shell.

35:54.000 --> 35:59.000
So what we will do for that Fashionbt is, I will use the three space walk way, and just kind of Diellow,

35:59.000 --> 36:10.600
And what you can see is ln minus s foo bar.

36:10.600 --> 36:15.320
This means I do a sim link from bar to foo, I believe.

36:15.320 --> 36:16.760
I always get that wrong.

36:19.320 --> 36:21.000
Yeah.

36:21.000 --> 36:24.960
So what I did is, and this is a file that actually

36:24.960 --> 36:31.680
lives on ntfs shared via nfs.

36:31.680 --> 36:37.320
And what we should see here now is that this is file bar.

36:37.320 --> 36:38.160
I created that.

36:41.920 --> 36:47.400
Now what I'm doing is I have my little user space tool,

36:47.400 --> 36:54.440
test start, that, and you know my password now, that I use

36:54.440 --> 36:58.640
always for Windows boxes.

36:58.640 --> 37:00.920
OK, what does this do?

37:00.920 --> 37:06.360
It creates a connection to that Windows server over SMB.

37:06.360 --> 37:11.320
And I just get all the metadata over SMB.

37:11.320 --> 37:14.200
And let me just TCP dump that.

37:14.200 --> 37:17.680
Oh, this is the wrong.

37:25.440 --> 37:28.480
TCP dump cannot override its own files.

37:28.480 --> 37:29.480
That's very strange.

37:32.080 --> 37:34.080
I know.

37:34.080 --> 37:37.360
OK, let me wire shark this.

37:37.360 --> 37:39.280
And what I see is a sim link.

37:39.280 --> 37:40.120
It's a sim link.

37:40.120 --> 37:43.960
What I could have done actually is to extend this command

37:43.960 --> 37:47.960
output with the sim link points there.

37:47.960 --> 37:49.920
Haven't done that yet.

37:49.920 --> 37:51.520
Maybe on the train back home.

37:51.960 --> 37:55.480
Let's look at that wire shark trace.

38:04.040 --> 38:06.880
Oh, TLsR.

38:06.880 --> 38:14.720
In the background, I have my connection for RDP running.

38:14.720 --> 38:16.040
SMB2.

38:16.040 --> 38:17.720
So here you go.

38:17.720 --> 38:19.040
It's a bit verbose.

38:19.600 --> 38:27.320
But what I want to point you at is I try to open the file

38:27.320 --> 38:30.760
bar, which is the sim link.

38:30.760 --> 38:33.920
And it says, repass tag not handled.

38:33.920 --> 38:36.960
Then I open the file again.

38:36.960 --> 38:39.480
And don't be confused by the create request.

38:39.480 --> 38:42.120
Create request is all catch all open file thing.

38:44.600 --> 38:47.520
And there I tell you, I tell the server, hey.

38:49.720 --> 38:51.480
I want to open this file.

38:51.480 --> 38:54.440
And I don't want you to interpret it.

38:54.440 --> 38:57.720
I don't want the HSM engine to go running.

38:57.720 --> 38:59.520
I just want to open the file.

38:59.520 --> 39:03.520
I want to open the HSM stub or the sim link as such.

39:03.520 --> 39:05.520
I want to see the metadata.

39:05.520 --> 39:09.320
I want to see the metadata.

39:09.320 --> 39:10.880
And it gives, OK, here you are.

39:13.880 --> 39:18.080
And a bit further down, what I can say is, OK,

39:18.440 --> 39:23.640
what I can say is, I can get the repass point data out

39:23.640 --> 39:24.280
of this file.

39:24.280 --> 39:31.040
And what I can see here is, I have, oh, this is a repass

39:31.040 --> 39:33.360
tag NFS.

39:33.360 --> 39:36.520
And by the way, this is a sim link with a target foo.

39:36.520 --> 39:43.320
So this is data that the NFS server gave me.

39:43.320 --> 39:48.480
This blob here, which is somewhere here, that was

39:48.480 --> 39:50.640
created by the NFS server.

39:50.640 --> 39:53.760
And so we can just utilize it.

39:53.760 --> 39:56.640
And we will utilize this.

39:56.640 --> 39:59.320
Before I take questions, I have one more slide that I want

39:59.320 --> 40:02.000
to talk about.

40:02.000 --> 40:03.520
Long running compute jobs.

40:03.520 --> 40:05.760
Very quick overview.

40:05.760 --> 40:13.040
If you have your HPC job farm, the one thing that gets in

40:13.040 --> 40:16.000
your way is all this file security.

40:16.000 --> 40:19.160
You want NFS, no file security, on long running compute

40:19.160 --> 40:22.200
jobs, because if a machine dies, it just, yeah, you

40:22.200 --> 40:26.520
don't want really, this is a trusted environment, and you

40:26.520 --> 40:28.680
just want your jobs to continue existing.

40:31.200 --> 40:35.400
SMB actually has secure provisions for this.

40:35.400 --> 40:39.000
What you can do with SMB is, you can create a machine

40:39.000 --> 40:41.960
account, you can give the machines a password,

40:42.000 --> 40:46.240
essentially something like key tab for Kerberos.

40:46.240 --> 40:51.240
And you can, this is standard Windows protocol.

40:51.240 --> 40:58.280
You can extend the connection to a share with yet another T

40:58.280 --> 41:04.160
con context saying, OK, dear server, I know what I'm doing.

41:04.160 --> 41:07.720
You trust me by my machine account.

41:07.720 --> 41:12.720
For this connection, please use this UID and GID to this

41:12.720 --> 41:13.720
share.

41:13.720 --> 41:17.040
This is a standard SMB protocol extension, and this is what

41:17.040 --> 41:19.680
needs doing before we actually can claim success and say,

41:19.680 --> 41:25.920
OK, we can also cover this long running compute jobs

41:25.920 --> 41:29.280
properly like you can with NFS or any other file sharing

41:29.280 --> 41:30.600
protocol.

41:30.600 --> 41:33.040
Not implemented yet, another server side, no client side,

41:33.040 --> 41:36.040
but it's there.

41:36.040 --> 41:36.880
Yeah.

41:36.880 --> 41:37.880
Mark.

41:37.880 --> 41:40.320
The machine account to the machine accounts

41:40.320 --> 41:44.240
authorized to protect any of the IDs.

41:44.240 --> 41:45.360
Correct.

41:45.360 --> 41:51.520
The comment was that SMB has a provision that you can trust a

41:51.520 --> 41:56.200
machine notified by the machine account database,

41:56.200 --> 41:57.840
whatever, you know what I mean?

41:57.840 --> 42:01.200
You have server side, this machine is trusted for doing

42:01.200 --> 42:02.400
the no file security thing.

42:03.400 --> 42:07.400
Send a protocol extension.

42:07.400 --> 42:12.400
OK, this is not really, thanks for your attention.

42:12.400 --> 42:13.400
Any questions?

42:13.400 --> 42:25.400
No questions.

42:25.400 --> 42:27.400
This is not good.

42:27.400 --> 42:28.400
Fun?

42:28.400 --> 42:39.400
Just an observation, the WSWSL version 1, are you really

42:39.400 --> 42:45.400
wanting to implement that more obscure data remaining on

42:45.400 --> 42:47.400
some obscure machines?

42:47.400 --> 42:52.400
I would suggest forget about it completely just because it's

42:52.400 --> 42:54.400
that.

42:55.400 --> 43:01.400
The comment was questioning whether we want to go the WSL1

43:01.400 --> 43:04.400
way with these repass.

43:04.400 --> 43:05.400
Talk to Steve.

43:05.400 --> 43:09.400
Talk to Steve, French author, main author of the ZIF client.

43:09.400 --> 43:11.400
I mean, it basically is him.

43:11.400 --> 43:17.400
Steve French and Paul Alcantara, those are the ones who I

43:17.400 --> 43:22.400
believe for Linux 6.8 have implemented the WSL1, here,

43:22.400 --> 43:23.400
this one here.

43:23.400 --> 43:28.400
If you look at LWN, they can now create block and character

43:28.400 --> 43:32.400
devices and I think they went the way with WSL1.

43:32.400 --> 43:34.400
But I mean, talk to Steve.

43:34.400 --> 43:52.400
The comment was WSL1 is the only one under Windows Server

43:52.400 --> 43:53.400
2019.

44:04.400 --> 44:09.400
There you go.

44:09.400 --> 44:16.400
Any other questions?

44:16.400 --> 44:17.400
Good job.

44:17.400 --> 44:18.400
You also, what?

44:18.400 --> 44:23.400
The question was how the current ZIFS client deals with

44:23.400 --> 44:24.400
these repass points.

44:24.400 --> 44:26.400
That's actually what is covered here.

44:26.400 --> 44:29.400
They start to properly implement that.

44:30.400 --> 44:33.400
So they already have some links.

44:33.400 --> 44:36.400
They have support for some links, the Windows way,

44:36.400 --> 44:38.400
because I mean, they are there.

44:38.400 --> 44:43.400
But they start to, they start working on all the other ones

44:43.400 --> 44:45.400
that we were talking about.

44:45.400 --> 44:46.400
Mark.

44:46.400 --> 44:48.400
It's work in progress.

44:48.400 --> 44:53.400
So I mean, parts already exist.

44:53.400 --> 44:55.400
Can you repeat the question?

44:55.400 --> 44:57.400
I was pointed out.

44:57.400 --> 45:02.400
Mark was asking about the, the, the new data, the

45:02.400 --> 45:07.400
data that is used in the system, and the data that is

45:07.400 --> 45:10.400
used in the system, and the data that is used in the

45:10.400 --> 45:11.400
system.

45:11.400 --> 45:12.400
Can you repeat the question?

45:12.400 --> 45:14.400
I was pointed out.

45:14.400 --> 45:19.400
Mark was asking about the status, what's currently

45:19.400 --> 45:21.400
implemented.

45:21.400 --> 45:25.400
It's a slow progress.

45:25.400 --> 45:29.400
And parts already exist.

45:29.400 --> 45:31.400
Other parts don't yet exist.

45:31.400 --> 45:35.400
So I don't know when we can actually claim that we do

45:35.400 --> 45:37.400
full SMB3 Unix extensions.

45:37.400 --> 45:40.400
I can't promise anything.

45:40.400 --> 45:42.400
One more, there's time up.

45:42.400 --> 45:44.400
I think we are pretty strict here.

45:44.400 --> 45:46.400
Just come to me later.

