WEBVTT

00:00.000 --> 00:22.640
Our next talk is about reproducible builds the first 10 years and I'll let Holger explain

00:22.640 --> 00:36.520
Hello everybody. So I'm not a lunar I'm Holger but that was the interest light of

00:36.520 --> 00:45.640
lunar's talk 10 years and two days ago. I'm based in Hamburg I work on Debian

00:45.640 --> 00:52.000
since many years and I've also been to foster many years. Ten years ago we did

00:52.000 --> 00:57.520
the first setup with all videos and all rooms and then I gave up with video and

00:57.520 --> 01:03.360
cut and voile for reproducible builds. We're working mostly on Debian but I try

01:03.360 --> 01:08.800
to make or try to contribute help make all software all free software reproducible

01:08.800 --> 01:15.840
and it's pretty complex topic ask me anything anytime during the next two

01:15.840 --> 01:26.280
days because there's a lot of information in this talk. So reproducible builds. This is not my

01:26.280 --> 01:32.240
talk but the talk of the people working on this these are over 150 people and it's not my

01:32.240 --> 01:37.920
knowledge we have them in Git so if you are missing there then you can add yourself to this

01:38.000 --> 01:47.640
repository and be here. So about you who knows about reproducible builds why and how a bit.

01:50.640 --> 02:00.520
Yay that is awesome I can go home now thank you. Who has contributed to reproducible builds?

02:01.520 --> 02:04.520
Wee thank you.

02:08.520 --> 02:14.520
Who knows that reproducible builds have been around for more than 30 years? Ten years.

02:16.520 --> 02:25.520
Because 30 years really old not as old as net BST or maybe it is. Who knows about S-Bomb?

02:26.520 --> 02:34.520
The industry. So S-Bomb is software build of materials and basically our build info files

02:34.520 --> 02:40.520
from 2014 also already have this contain all the build environment describe what's in there.

02:40.520 --> 02:49.520
It's the same concept more or less. And we need you it's not going reproducible builds

02:49.520 --> 02:54.520
nothing five or ten or even fifty people can do it needs to be done in every software project

02:54.520 --> 03:02.520
needs continuous testing that software is reproducible. But I think we can do it and there's still a lot of work to do.

03:05.520 --> 03:11.520
So I give a short introduction the problem source code is freely available which is not a problem

03:11.520 --> 03:20.520
but most people use binaries and that is a problem. And no one really knows if this binary really comes from the source code.

03:21.520 --> 03:28.520
I'll get to that in a moment. And as a result there are various supply chain attacks.

03:30.520 --> 03:38.520
So long time ago more than ten years ago there was a threat on devil mailing list in 2007

03:38.520 --> 03:48.520
and it was known but it seemed undoable. This email would be really cool if deviant policy required that packages could be rebuilt

03:48.520 --> 03:54.520
bit identical from source and then somebody replied I see no benefit.

03:57.520 --> 04:04.520
Someone else replied I for one think this is technically infeasible but hey I'm happy to be proved wrong.

04:05.520 --> 04:13.520
I'm happy to prove them wrong. So that was ten years ago but the idea also appeared in the year 2000 already in another threat.

04:14.520 --> 04:25.520
And then in 2017 we learned that GCC was reproducible in the early 90s on several architectures and not only GCC but also binutils and the whole new tool chain.

04:26.520 --> 04:29.520
But that got lost that got bit rotten and people forgot.

04:30.520 --> 04:41.520
So fast forward to last year. There was a mail on the wire guard mailing list of VPN up for Android said that the bills are now reproducible.

04:41.520 --> 04:50.520
The release is identical on their website Google Play store on an asteroid. And that was well and they didn't even tell us.

04:51.520 --> 04:55.520
Yay so great. We're super happy.

05:00.520 --> 05:11.520
This logo by the way we developed in 2016. So it's also 80 years old was a logo by design committee and in the end I think it turned out nice anyhow.

05:12.520 --> 05:20.520
So our definition when is it reproducible. It built is reproducible given the same source code built environment and built instructions.

05:20.520 --> 05:26.520
Any party can recreate it by bit identical copies of all specified artifact. Pretty simple.

05:28.520 --> 05:34.520
Yeah it gets more complicated because you need to have everything. What is source code. What is the environment and so on.

05:35.520 --> 05:43.520
So our mission is to enable anyone to independently verify that a given source produces bit by bit identical results.

05:45.520 --> 05:54.520
And by that we are an important building block in making supply chains more secure. Nothing more nothing less reproducible builds are not more secure than others.

05:54.520 --> 06:00.520
They're just built more securely and unsecure software still remains unsecure.

06:01.520 --> 06:06.520
But with reproducible builds you cannot be sure that you run this insecure software.

06:08.520 --> 06:14.520
And this again is from Luna's talk from 10 years ago. It's pretty much the same definition that we have now.

06:15.520 --> 06:24.520
And by 2024 reproducible builds have been widely understood. We have resources documentation. We have public scientific publication.

06:24.520 --> 06:39.520
There's lots of material online. And even the White House has said about us. They made a release which in 2021 government statement which requires software bill of materials for governmental software.

06:39.520 --> 06:46.520
And at the moment only recommends reproducible builds. But hey the White House recommends our work. Yay.

06:47.520 --> 06:51.520
How did we get there. Money.

06:52.520 --> 06:53.520
Snowden.

06:55.520 --> 06:58.520
Why money. Bitcoin.

07:02.520 --> 07:13.520
10 years ago actually 12 years ago in 2012 or 11 the software was made reproducible because Bitcoin all bitcoins were worth four billion.

07:13.520 --> 07:20.520
I think there was very much more now. But they were still afraid if there was a compromised Bitcoin client would steal the Bitcoin.

07:20.520 --> 07:26.520
The developers would be accused of having a back door and they didn't want this. So they basically made reproducible builds.

07:27.520 --> 07:34.520
And Snowden is kind of obvious. And so the tour people made tour browser reproducible in 2013.

07:34.520 --> 07:41.520
Because they were afraid that they would get back door. And tour browser is Firefox. One of the biggest software projects in the world.

07:42.520 --> 07:48.520
50 or 70 or whatever megabyte binary at the time. Every bit was the same. And there was. Wow.

07:50.520 --> 07:52.520
So how did we really get there.

07:53.520 --> 07:56.520
Lot of work by many people over many years.

07:56.520 --> 08:00.520
And.

08:01.520 --> 08:10.520
Debcom 13 in 2013 there was a box of small workshop last minute 30 attendees and that kicked off the Debbie in a thought for reproducible builds.

08:12.520 --> 08:16.520
And then Luna had this another box at that conference team.

08:17.520 --> 08:18.520
And the stock here.

08:18.520 --> 08:22.520
And we had the first package that patches for the package to Debbie and package maintainer.

08:23.520 --> 08:31.520
We sorted the files and created built info files built info files is where we store the environment and the sources and the product.

08:32.520 --> 08:33.520
The output the binaries.

08:34.520 --> 08:37.520
And with that we can reproduce them. And that was all done in 2014 already.

08:39.520 --> 08:44.520
And in September 2014 I started systematic builds of Debbie and packages twice.

08:44.520 --> 08:49.520
First does handle packages and then all 25,000 at that time.

08:51.520 --> 08:54.520
And Mike Perry and said she gave a presentation at Congress.

08:55.520 --> 08:57.520
See Congress in December of 2014 showing my graphs.

08:58.520 --> 09:01.520
It was really nice sitting in the audience and suddenly seeing this graph I made.

09:02.520 --> 09:04.520
And I have some from the slides.

09:05.520 --> 09:06.520
So this is the presentation.

09:07.520 --> 09:08.520
2014 again.

09:09.520 --> 09:16.520
And I want to believe that is really the problem with trusting somebody that this binary comes from.

09:17.520 --> 09:27.520
Whether it's needs to need to believe me or Microsoft or your government or Debbie and you need to believe somebody saying that's not believing is not scientific at all.

09:29.520 --> 09:30.520
And I am the developer.

09:31.520 --> 09:36.520
It's I know it's on my machine and I'm upstanding careful and yeah.

09:36.520 --> 09:40.520
But we develop us are also excellent targets.

09:41.520 --> 09:49.520
I just spoke with somebody who's producing the GPG binaries for Windows who would have interest to compromise that several nation states.

09:50.520 --> 09:51.520
So.

09:54.520 --> 09:57.520
And they had that to very nice proof of concept.

09:57.520 --> 10:04.520
So the most secure computer in the world is that network most computers on network USB access.

10:05.520 --> 10:17.520
24 seven you can compromise computers and especially if one computer gives you access to 100 millions of other computers or lots of money or whatever the state secrets.

10:17.520 --> 10:21.520
Where whatever you terrorist or war taxi want to make.

10:22.520 --> 10:23.520
So they made a small back door.

10:24.520 --> 10:27.520
They use the CDE against SS eight where the the.

10:28.520 --> 10:32.520
It's greater and it should be greater equal.

10:33.520 --> 10:34.520
That's the difference and gives you who to exploit.

10:35.520 --> 10:37.520
And in the binary the difference is one bit.

10:37.520 --> 10:39.520
So they are seven e.

10:40.520 --> 10:43.520
Seven C is the difference whether somebody can get root on your computer.

10:44.520 --> 10:46.520
And it's very hard to detect.

10:47.520 --> 10:49.520
And then they made another thing.

10:50.520 --> 10:52.520
They made a Linux kernel module which modifies.

10:54.520 --> 10:57.520
That if the compiler looks at the source code and it's not a good thing.

10:57.520 --> 11:02.520
And then they made another thing and they made a Linux kernel module which modifies.

11:04.520 --> 11:10.520
That if the compiler looks at the source code it will take different compile different code than if you look at it with an editor.

11:12.520 --> 11:14.520
And then they made a proof of concept for that.

11:15.520 --> 11:18.520
So these attacks are not only feasible they are possible and probably be done.

11:20.520 --> 11:22.520
And this was the graph they showed.

11:22.520 --> 11:26.520
No they must have showed an earlier graph because it was from 2014.

11:27.520 --> 11:31.520
But anyway the green pack is the percentage of Debian packages reproducible.

11:32.520 --> 11:35.520
The orange one are unreproducible and the red ones are failing to build.

11:36.520 --> 11:41.520
But it was still more than half the packages were quite early reproducible.

11:43.520 --> 11:45.520
So 2015.

11:46.520 --> 11:48.520
Luna and myself gave a talk here.

11:48.520 --> 11:54.520
And this was the first talk where we were spread from Debian to going to all free software projects.

11:56.520 --> 11:58.520
I think it was quite nicely perceived.

11:59.520 --> 12:01.520
Because since then we have lots of collaboration.

12:02.520 --> 12:06.520
And Luna gave her presentation at CCCCAM presenting many problems.

12:07.520 --> 12:11.520
We found many many problems and come on ways to work against them.

12:12.520 --> 12:15.520
And we had the first reproducible build summit in Athens.

12:15.520 --> 12:20.520
We had the time I think we were 25 people from 15 projects or something.

12:21.520 --> 12:25.520
And we wrote source date epoch spec which I explained in a second.

12:26.520 --> 12:27.520
And divorce code.

12:28.520 --> 12:32.520
So first the common reason for unreproducibility is time stamps.

12:33.520 --> 12:34.520
People leave time stamps everywhere.

12:35.520 --> 12:36.520
And they leave more time stamps.

12:37.520 --> 12:40.520
Really every documentation tool has time stamps.

12:41.520 --> 12:42.520
Compilers have time stamps.

12:42.520 --> 12:44.520
And there's build parses.

12:45.520 --> 12:46.520
Also very annoying.

12:47.520 --> 12:48.520
And the rest.

12:49.520 --> 12:51.520
And the rest is about 400 different kind of issues or something.

12:52.520 --> 12:54.520
But it's mostly time stamps and build parses.

12:56.520 --> 12:58.520
And for build parses to get that is very easy.

12:59.520 --> 13:01.520
You just rebuild in the same build parses.

13:02.520 --> 13:05.520
And nowadays with name spaces it's also trivial to do.

13:07.520 --> 13:09.520
And for time stamps we came up with source date epoch.

13:09.520 --> 13:11.520
Who knows about source date epoch?

13:12.520 --> 13:13.520
Yoo hoo hoo.

13:17.520 --> 13:19.520
Build time stamps are largely meaningless.

13:20.520 --> 13:23.520
Source date epoch describes the time of the last modification of the source.

13:24.520 --> 13:25.520
In seconds since the unique epoch.

13:26.520 --> 13:28.520
Because that is consistent.

13:29.520 --> 13:30.520
This is deterministic.

13:31.520 --> 13:32.520
It doesn't change.

13:33.520 --> 13:34.520
And this means that was when the software last changed.

13:35.520 --> 13:37.520
And when you know the build environment you also know all the libraries you're using.

13:37.520 --> 13:39.520
So there's no use to record a time stamp.

13:40.520 --> 13:43.520
And that's supported by a lot of software today.

13:44.520 --> 13:45.520
If this build environment variable is set.

13:46.520 --> 13:47.520
Then it's used and there's 100 tools.

13:48.520 --> 13:49.520
DCC is using it.

13:50.520 --> 13:51.520
Pundock is using it.

13:52.520 --> 13:53.520
Whatever is using it.

13:54.520 --> 13:55.520
And the specification is also really stable.

13:56.520 --> 13:58.520
We modified it once in 2017 and that's it.

13:59.520 --> 14:00.520
So it's been working.

14:02.520 --> 14:03.520
And it's available on the internet.

14:03.520 --> 14:04.520
Difascope.

14:05.520 --> 14:06.520
Who knows about Difascope?

14:07.520 --> 14:09.520
You should all know about Difascope.

14:10.520 --> 14:12.520
I met lawyers who know Difascope.

14:13.520 --> 14:14.520
Who uses Difascope?

14:16.520 --> 14:17.520
Nothing against lawyers.

14:18.520 --> 14:19.520
I explained it.

14:20.520 --> 14:22.520
Difascope tries to get to the bottom of what makes files or directories different.

14:23.520 --> 14:27.520
It will recursively unpack archives into many kinds and transforms various binary formats

14:28.520 --> 14:29.520
into more human readable form to compare them.

14:30.520 --> 14:31.520
So you have a tar archive.

14:31.520 --> 14:32.520
And in the tar archive is a PDF.

14:33.520 --> 14:34.520
And in the PDF is an image.

14:35.520 --> 14:36.520
And the image has a varying time stamp.

14:37.520 --> 14:38.520
Difascope will show this.

14:39.520 --> 14:41.520
And it has large file system formats.

14:42.520 --> 14:43.520
So basically for anything.

14:44.520 --> 14:45.520
APK files, DEX files, all file systems,

14:46.520 --> 14:47.520
GBG, keybox databases, HTML, anything.

14:48.520 --> 14:49.520
There's more JPEG, whatever.

14:50.520 --> 14:51.520
It compares two objects.

14:52.520 --> 14:53.520
And this is also why there's a lot of different types of files.

14:54.520 --> 14:55.520
And it's not just a file.

14:56.520 --> 14:57.520
It's a file.

14:58.520 --> 14:59.520
It's a file.

15:00.520 --> 15:01.520
And it compares objects.

15:02.520 --> 15:03.520
And this is also why lawyers like to use it,

15:04.520 --> 15:05.520
because they compare two PDFs,

15:06.520 --> 15:07.520
and then they see which text changes.

15:08.520 --> 15:09.520
And there's other use cases,

15:10.520 --> 15:11.520
but we don't also use it to find out why something is unreproducible.

15:12.520 --> 15:13.520
Not if it's unreproducible.

15:14.520 --> 15:15.520
If it's unreproducible, it's easy because the hash doesn't match.

15:16.520 --> 15:17.520
But really why?

15:19.520 --> 15:20.520
And it falls back on HexStump.

15:22.520 --> 15:23.520
It does fuzzy matching

15:24.520 --> 15:25.520
and many things.

15:26.520 --> 15:27.520
It does disassembling.

15:27.520 --> 15:34.520
Here you can also go to try Diffrescope Org and upload two objects and it will show you the difference.

15:34.520 --> 15:42.520
Not sure if you can read this, but basically the colors are.

15:42.520 --> 15:48.520
There's an archive, there's at the top, there's the bits are different,

15:48.520 --> 15:53.520
and then here you see really the diff between the two versions.

15:53.520 --> 16:06.520
And because I compared two different versions, 5.06 and 5.07, the version numbers of course change.

16:06.520 --> 16:10.520
But you can look at many differences with Diffrescope.

16:10.520 --> 16:15.520
If you haven't taken a look at Diffrescope, do.

16:15.520 --> 16:27.520
So in the last 10 years we filed almost 4,000 bucks with patches and 3,500 of them have already been merged.

16:27.520 --> 16:32.520
So there's only 300 left and there's still some more coming.

16:32.520 --> 16:37.520
And in general in Debian we found over 32,000 bucks.

16:37.520 --> 16:43.520
Most are failing to build from source because we constantly rebuild Debian, but there's also many other things.

16:43.520 --> 16:47.520
The Reproducer Builds is also a huge QA effort.

16:47.520 --> 16:55.520
And yeah, we have a Git repository very categorized the issues and put, okay, this package is also affected by this.

16:55.520 --> 16:58.520
And Luna's talk is also a good reference for this.

16:58.520 --> 17:03.520
And it's because it's much easier to describe what makes a problem a package unreproducible,

17:03.520 --> 17:10.520
we have created the unreproducible packages package which shows many, many problems and how to fix them,

17:10.520 --> 17:15.520
because a reproducible package is very, it's hard to show why it's reproducible.

17:15.520 --> 17:18.520
It's very easy to show what's unreproducible.

17:18.520 --> 17:28.520
And some of the unexpected benefits we had is lower development costs and increased development speeds through less developer time.

17:28.520 --> 17:37.520
Google is one of the main users of this benefit because the builds are way faster, of course you can cash way more.

17:37.520 --> 17:45.520
And it's also good for software development to see if this change really just affects this part you thought it would be effect.

17:45.520 --> 17:52.520
And for license compliance, you can only be sure it's free software if you know the binary is coming from the source.

17:52.520 --> 17:58.520
As you're running some binary, maybe it matches the license, maybe it doesn't, who knows.

17:58.520 --> 18:02.520
Yeah, and you have reproducible verified S-bombs.

18:02.520 --> 18:11.520
S-bombs are just a statement with reproducible builds you have verified S-bombs.

18:11.520 --> 18:19.520
So we made these summits over the years, mostly in Europe.

18:19.520 --> 18:22.520
And we're going to have a summit this year as well.

18:22.520 --> 18:26.520
There were always like 50 people around something.

18:26.520 --> 18:32.520
But there were many, many projects there.

18:32.520 --> 18:41.520
Like all the BSD, FDROID, Github, Microsoft, RATAT, Apache, Maven, whatever, many, many, many.

18:41.520 --> 18:46.520
And there was another benefit, bootstrapable org.

18:46.520 --> 18:50.520
It began as a breakout session at the Reproducible Build Summit in Berlin.

18:50.520 --> 18:52.520
Who knows about bootstrapable org?

18:52.520 --> 18:54.520
Some people.

18:54.520 --> 19:01.520
So my understanding is you have 500 byte block which can build in this very small assembler,

19:01.520 --> 19:06.520
which builds another small assembler, which builds a tiny C-C, which builds an old GCC,

19:06.520 --> 19:09.520
which builds an old GCC, which builds modern GCC.

19:09.520 --> 19:12.520
So you bootstrap from sources only.

19:12.520 --> 19:18.520
And they bootstrap Dix, which is another Linux distribution.

19:18.520 --> 19:20.520
It's pretty amazing.

19:20.520 --> 19:23.520
They have their own talk here.

19:23.520 --> 19:30.520
And that is just because there was an idea to do this and people really tried this.

19:30.520 --> 19:36.520
And bootstrapping, completely bootstrapping from source has not been done since the 60s or 70s.

19:36.520 --> 19:41.520
We all just use binaries, building binaries, building binaries.

19:41.520 --> 19:46.520
For the summit this year, we don't know where, we don't know when.

19:46.520 --> 19:49.520
We need a location for 50 people.

19:49.520 --> 19:52.520
We need some sponsors to cover the costs.

19:52.520 --> 19:54.520
And we need you to make it happen.

19:54.520 --> 20:01.520
Please talk to me after the event if you have an idea where to hold this.

20:01.520 --> 20:03.520
In general, we have some funding.

20:03.520 --> 20:07.520
We are a Software Freedom Conservancy project since 2018.

20:07.520 --> 20:13.520
Funding is for Chris Lam, Mati Aritzolo, Vagrant Cascadian and myself.

20:13.520 --> 20:19.520
We support our continuous work, the development, community work,

20:19.520 --> 20:23.520
developing software, designing processes, the summit.

20:23.520 --> 20:28.520
Thanks to all our sponsors.

20:28.520 --> 20:33.520
So short overview of various projects, which is mostly about Debian.

20:33.520 --> 20:38.520
So these are the CI results for Debian Trixie.

20:38.520 --> 20:42.520
We are now in the 95% range and it's pretty boring.

20:42.520 --> 20:45.520
The graph has become very boring.

20:45.520 --> 20:46.520
This is a bit nicer.

20:46.520 --> 20:48.520
So these are the past Debian releases.

20:48.520 --> 20:50.520
Bookworm is the current release.

20:50.520 --> 20:51.520
Bullseye is two years ago.

20:51.520 --> 20:53.520
Buster is four years ago.

20:53.520 --> 20:58.520
And you can see the unreproducible packages have gone constantly down,

20:58.520 --> 21:05.520
but there are still over 600 unreproducible packages.

21:05.520 --> 21:08.520
And these I really want to get to zero.

21:08.520 --> 21:10.520
This is still the goal.

21:10.520 --> 21:15.520
So these are the CI results for Debian Unstable for the last 10 years.

21:15.520 --> 21:21.520
And you can see in the right here in the end in 2023,

21:21.520 --> 21:24.520
we stopped varying the build pass.

21:24.520 --> 21:27.520
That's why we went from 85 to 95%.

21:27.520 --> 21:34.520
But Debian is constantly growing and we are getting constantly getting more reproducible.

21:34.520 --> 21:42.520
So in 2017, we changed or Debian changed policy and now says packages should build reproducible.

21:42.520 --> 21:43.520
It's not a must.

21:43.520 --> 21:46.520
It's just that would be really nice.

21:46.520 --> 21:50.520
And of course I want to get to the must, but that is not so easy.

21:50.520 --> 21:57.520
So I want to have reproducible packages must not regress as a next step.

21:57.520 --> 22:03.520
And in 2025, because that will be after the next Debian release.

22:03.520 --> 22:06.520
And also new packages must build reproducible.

22:06.520 --> 22:09.520
I don't want any new packages which are not reproducible.

22:09.520 --> 22:13.520
It's been 10 years, it's over.

22:20.520 --> 22:25.520
And finally in whatever 2027, one, two more releases.

22:25.520 --> 22:31.520
I think all packages must build reproducible to be allowed into testing unstable.

22:31.520 --> 22:34.520
That can be an unstable experimental.

22:34.520 --> 22:37.520
You can experiment with that.

22:37.520 --> 22:40.520
And really 100% is the goal.

22:40.520 --> 22:45.520
And 100% reproducible is a political decision and nothing technical.

22:45.520 --> 22:47.520
Because we can always say, okay, you're out.

22:47.520 --> 22:50.520
And that is political, not technical.

22:50.520 --> 22:54.520
So we need to change policy.

22:54.520 --> 22:58.520
And we can work around must have offenders using whitelist in the beginning.

22:58.520 --> 23:01.520
Like at the moment Grubb and Linux kernel are not reproducible.

23:01.520 --> 23:04.520
And I guess most people want to use them.

23:08.520 --> 23:10.520
And goal is still 100%.

23:10.520 --> 23:13.520
Whitelist are just a way to achieve that goal eventually.

23:13.520 --> 23:17.520
Because with that we can kick the others out.

23:17.520 --> 23:20.520
And then Debian testing migration.

23:20.520 --> 23:23.520
I'm not sure how many know Debian workflow.

23:23.520 --> 23:27.520
So there's packages get uploaded to unstable, then they move to testing.

23:27.520 --> 23:30.520
And eventually testing is declared stable.

23:30.520 --> 23:35.520
So this moving to testing, this migration, there's various penalties or can be introduced.

23:35.520 --> 23:40.520
And since three months or something, it now shows if the package is unreproducible,

23:40.520 --> 23:43.520
there's no penalty or nothing yet.

23:43.520 --> 23:47.520
But I think for the next release, there should be penalties for violating,

23:47.520 --> 23:51.520
not regressing, and new packages must be reproducible.

23:51.520 --> 23:53.520
And the framework is now there.

23:53.520 --> 23:55.520
It's just not activated yet.

23:56.520 --> 24:00.520
And the whitelisting part I already said.

24:00.520 --> 24:06.520
So, and this, this is a bit stepped for the next part.

24:06.520 --> 24:10.520
Because what I showed you before these other graphs,

24:12.520 --> 24:18.520
this graph is just about continuous integration where we build the package twice

24:18.520 --> 24:24.520
in maximum variation to see why a package is not reproducible.

24:24.520 --> 24:28.520
But what we really want to do is Debian builds a package once,

24:28.520 --> 24:33.520
and we want to rebuild it to see if we can reproduce it.

24:33.520 --> 24:37.520
And we don't want to find differences, we want to find the same thing.

24:37.520 --> 24:43.520
So for this, this, we have made this other rebuilder,

24:43.520 --> 24:47.520
and this was already working two years ago, and it also showed good results,

24:47.520 --> 24:49.520
but then it stopped working.

24:50.520 --> 24:54.520
Because we need the working snapshot Debian org service.

24:54.520 --> 24:57.520
Snapshot has all the Debian binaries ever released.

24:57.520 --> 25:01.520
And without snapshot, we cannot recreate the same environment.

25:01.520 --> 25:03.520
But snapshot is buggy.

25:06.520 --> 25:09.520
And this has been buggy for five years.

25:09.520 --> 25:11.520
And so this is broken.

25:11.520 --> 25:13.520
Sad.

25:13.520 --> 25:18.520
And Snaps fixing snapshot, it's 150 terabytes of data.

25:18.520 --> 25:23.520
It has four pushes per day, gaining 70 gigabytes of data every day.

25:23.520 --> 25:27.520
One project to fix, so I got access to fix it.

25:27.520 --> 25:29.520
Yay.

25:31.520 --> 25:33.520
We need something soon.

25:33.520 --> 25:36.520
We still need to fix snapshot, so if somebody wants big data,

25:36.520 --> 25:39.520
we need this, please talk to me.

25:39.520 --> 25:44.520
But at the summit last year, we also did, we don't need the whole snapshot.

25:44.520 --> 25:47.520
We only want to reproduce 70,000 binary packages,

25:47.520 --> 25:50.520
and they will depend on 30,000 packages.

25:50.520 --> 25:54.520
So 40,000 packages are never used as built-in pens.

25:54.520 --> 25:57.520
And then it looks at the build info files,

25:57.520 --> 26:00.520
because the build info file describes the environment,

26:00.520 --> 26:04.520
and those 30,000 packages are only used on 100,000 variations.

26:04.520 --> 26:07.520
So we only need 100,000 packages.

26:07.520 --> 26:11.520
That's just 100 gigabytes per arch and suit, so that's nothing.

26:11.520 --> 26:13.520
It's just two terabytes or something.

26:13.520 --> 26:15.520
It fits on my laptop.

26:15.520 --> 26:19.520
So we rebuild our snapshot, it was born.

26:19.520 --> 26:23.520
And that's a cache for Snapshot WNORG,

26:23.520 --> 26:27.520
which only stores the packages used as built-in pens today.

26:27.520 --> 26:32.520
And if new version is, then the old built-in pens are not needed anymore.

26:32.520 --> 26:36.520
Because Snapshot has this problem, seeding this still takes a week,

26:36.520 --> 26:42.520
but we've done this, and then each arch only takes hours to seed from another instance.

26:42.520 --> 26:46.520
And we already run two instances of rebuild a snapshot,

26:46.520 --> 26:48.520
and our goal is to allow many instances,

26:48.520 --> 26:53.520
so you can just have your snapshot cache in your institution and use it.

26:53.520 --> 26:58.520
And this is needed because DAP rebuild,

26:58.520 --> 27:00.520
which is used for rebuilding DAP packages,

27:00.520 --> 27:04.520
then uses the boot snap together with meta-snap.

27:05.520 --> 27:09.520
Because the packages don't have the trust information,

27:09.520 --> 27:13.520
and the meta-snap has the metadata from Snapshot WNORG,

27:13.520 --> 27:15.520
so you have a trust pass there.

27:15.520 --> 27:19.520
But because there's only five minutes left, I will skip those details.

27:19.520 --> 27:23.520
And rebuild a snapshot only has one issue at the moment,

27:23.520 --> 27:26.520
because we only started it in early December,

27:26.520 --> 27:29.520
and then there was Christmas and Congress and whatever,

27:29.520 --> 27:31.520
so we didn't fix this issue.

27:31.520 --> 27:34.520
And this is, Lynx and Yosh have really helped with that.

27:34.520 --> 27:37.520
I've done some work, but the coding part is mostly them.

27:37.520 --> 27:39.520
I've done the design work.

27:39.520 --> 27:42.520
I hope to have this working in a month or at least two.

27:42.520 --> 27:46.520
I don't really care when. We've waited five years, so yay.

27:46.520 --> 27:55.520
And so Outlook testing migration can use and force policy,

27:55.520 --> 27:57.520
but we need real rebuilders,

27:57.520 --> 28:01.520
because we don't want to test immigration just on CI results.

28:01.520 --> 28:05.520
And therefore the rebuilders, we need a working snapshot,

28:05.520 --> 28:10.520
and we will keep the CI builds to really still find the issues.

28:10.520 --> 28:14.520
I can give a very short overview now in the last three minutes

28:14.520 --> 28:16.520
about other projects.

28:16.520 --> 28:19.520
Tails is easy. Tails was the first project which is reproducible.

28:19.520 --> 28:24.520
You can rebuild the Tails ISO, and be sure that's the same ISO.

28:24.520 --> 28:29.520
ArchDinox has rebuilt us in Snapshot Binary and Active Community.

28:29.520 --> 28:33.520
They really rock. They know more about this than I do.

28:33.520 --> 28:40.520
Zouza is one person, but maybe that person will be allowed to do a reproducible Zouza fork

28:40.520 --> 28:42.520
on company time this year.

28:42.520 --> 28:45.520
So Zouza, I'm looking forward to Zouza in this regard.

28:45.520 --> 28:49.520
MixoS and GeekZoS are by design reproducible,

28:49.520 --> 28:53.520
but they also have still the unreproducible Linux software.

28:53.520 --> 28:56.520
Yachto has support for reproducible images,

28:56.520 --> 29:01.520
and FDroid also has reproducible packages in the repository.

29:01.520 --> 29:04.520
Alpine has basic support.

29:04.520 --> 29:07.520
FreeBSD, the base system is reproducible for all BSDs.

29:07.520 --> 29:11.520
We never tested OpenBSD, and we never tested the ports.

29:11.520 --> 29:15.520
Fedora Red Hat Ubuntu is not interested, it seems,

29:15.520 --> 29:17.520
but that is not really true anymore.

29:17.520 --> 29:20.520
Fedora has enabled in Macro, so that source state epoch is now used

29:20.520 --> 29:24.520
when building packages, so Fedora could have this easily.

29:24.520 --> 29:29.520
Ubuntu, I would really love a Debian fork, which is reproducible.

29:29.520 --> 29:33.520
Take the Debian sources, throw away the Debian build processes,

29:33.520 --> 29:38.520
do them new, and make a Debian binary fork, which is reproducible.

29:38.520 --> 29:45.520
So many projects support reproducible builds in a way or another,

29:45.520 --> 29:49.520
but it's mostly in theory, so it's unclear what it does,

29:49.520 --> 29:51.520
how users benefit.

29:51.520 --> 29:55.520
Tales is easy. Tales has one ISO, one checks them, you can recreate it

29:55.520 --> 29:58.520
with Debian with 60,000 packages.

29:58.520 --> 30:01.520
How do you verify them? It's still open.

30:01.520 --> 30:05.520
And this is massive success.

30:05.520 --> 30:08.520
This was thought impossible 10 years ago.

30:08.520 --> 30:13.520
This is, again, a 10-year-old slide.

30:13.520 --> 30:15.520
In theory, we are done.

30:15.520 --> 30:22.520
In practice, we have shown that reproducible builds can be done in theory.

30:22.520 --> 30:25.520
We need rebuilders, we need to store the results,

30:25.520 --> 30:29.520
we need defined criteria, how tools should treat the data,

30:29.520 --> 30:32.520
and then we need to use these tools.

30:32.520 --> 30:35.520
Because if you have several rebuilders, which you basically want,

30:35.520 --> 30:39.520
what you do with the results are not matching.

30:39.520 --> 30:42.520
And yeah, those last 5% or it's maybe 2% now,

30:42.520 --> 30:45.520
we still need to fix the software.

30:51.520 --> 30:54.520
And we need project-level consensus and commitment

30:54.520 --> 30:57.520
to keep reproducible builds working in practice.

31:01.520 --> 31:03.520
Thank you.

31:12.520 --> 31:15.520
Thank you for the talk. I learned a lot actually.

31:15.520 --> 31:18.520
I had vaguely heard about it, but very good introduction.

31:18.520 --> 31:21.520
Anyone have any questions?

31:25.520 --> 31:27.520
Hello, Agarhe.

31:27.520 --> 31:31.520
Most of the graphs you were showing were for AMD64, I think.

31:31.520 --> 31:34.520
Do you have any information about the other architectures?

31:34.520 --> 31:39.520
Is there any difference between AMD64 and ARM64, for example?

31:39.520 --> 31:43.520
We also have graph for ARM64, I-386 and ARMHF,

31:43.520 --> 31:47.520
and I just got an offer for RISC64 hardware.

31:47.520 --> 31:51.520
So when we do this rebuilders, we want to have every WN architecture.

31:51.520 --> 31:54.520
But it's, yeah, get there.

31:57.520 --> 31:59.520
Any more questions?

32:01.520 --> 32:05.520
How about, I actually have several questions.

32:05.520 --> 32:08.520
How about source releases?

32:08.520 --> 32:11.520
Because this is a problem with many projects

32:11.520 --> 32:14.520
that they don't have reproducible sources.

32:14.520 --> 32:18.520
If you want to get an expulsion or something,

32:18.520 --> 32:24.520
unless the original tower is around,

32:24.520 --> 32:29.520
you cannot remake it easily from a weapon.

32:32.520 --> 32:34.520
It's getting out of the...

32:34.520 --> 32:38.520
The releases of the source code or the source release?

32:38.520 --> 32:40.520
The releases of the source code.

32:40.520 --> 32:43.520
For many projects, it's still hard.

32:43.520 --> 32:46.520
Is there any effort around that?

32:46.520 --> 32:49.520
It depends mostly on the tools,

32:49.520 --> 32:53.520
like whether G-SIP or GitHub, when it creates an archive, is reproducible.

32:53.520 --> 32:56.520
We have basically decided not to look at this,

32:56.520 --> 32:59.520
because if you do a release once, you have version X,

32:59.520 --> 33:01.520
and that version X stays.

33:01.520 --> 33:04.520
Being able to reproduce will recreate the same version.

33:04.520 --> 33:07.520
We've just decided to be out of scope.

33:07.520 --> 33:10.520
But it's worthwhile, do it.

33:12.520 --> 33:15.520
Another thing is variants.

33:15.520 --> 33:19.520
For some distributions,

33:19.520 --> 33:22.520
they support a lot of variants of packages,

33:22.520 --> 33:29.520
and these distributions are more interested in causal analysis.

33:29.520 --> 33:32.520
How we arrive at certain versions

33:32.520 --> 33:35.520
and why we didn't arrive at it.

33:35.520 --> 33:38.520
Because this is what enables us to fix

33:38.520 --> 33:42.520
the things that didn't allow us to have a reproducible build.

33:42.520 --> 33:47.520
And if you have 100 variants multiplied by 1000 packages,

33:47.520 --> 33:50.520
that's a problem.

33:51.520 --> 33:55.520
I would not say that the number of packages matters.

33:55.520 --> 33:59.520
Of course, if they are reproducible, you can have 100,000 of packages.

33:59.520 --> 34:03.520
Is there any effort in causal analysis

34:03.520 --> 34:07.520
of why a package is not reproducible?

34:09.520 --> 34:12.520
Can you very hardly understand you, because it's so loud.

34:12.520 --> 34:19.520
Is there any effort to build tools to do causal analysis?

34:19.520 --> 34:22.520
Why the packages are?

34:22.520 --> 34:26.520
Yes, we've built this. This is the framework to analyze this.

34:26.520 --> 34:31.520
But first you check whether the packages are reproducible,

34:31.520 --> 34:33.520
but just comparing the hash.

34:33.520 --> 34:36.520
Build it twice, and if the hash is the same, it is the same.

34:36.520 --> 34:39.520
And if not, you can use Difloscope to analyze why.

34:39.520 --> 34:43.520
We've also had Bernhard Wiedemann from ZUSA

34:43.520 --> 34:46.520
also made some scripts to analyze the build logs

34:46.520 --> 34:49.520
to make a statistically analyze on this.

34:49.520 --> 34:52.520
So there is work on this as well.

34:52.520 --> 34:55.520
There is endless work on this area.

35:06.520 --> 35:09.520
We should talk about Snapchat, the Levian, and Thare.

35:09.520 --> 35:11.520
We should, Julian.

35:19.520 --> 35:25.520
Definition, I assume, that we have given the same build environment.

35:25.520 --> 35:29.520
What are the best practices to deliver the same build environment

35:29.520 --> 35:32.520
in long term?

35:32.520 --> 35:35.520
Are there any best practices for that?

35:35.520 --> 35:39.520
Well, just recreating the build environment is different from distribution to distribution,

35:39.520 --> 35:42.520
and it's often a challenge.

35:42.520 --> 35:49.520
Could you repeat it?

35:49.520 --> 35:53.520
Recreating the build environment is often difficult,

35:53.520 --> 35:57.520
and it depends very much on the distribution how to do this.

35:57.520 --> 36:00.520
But it can be done.

36:00.520 --> 36:03.520
So what are the best practices?

36:03.520 --> 36:07.520
What about containerization or something like that,

36:07.520 --> 36:09.520
or VMs or whatever?

36:09.520 --> 36:12.520
VMs help with that, yes,

36:12.520 --> 36:16.520
but it's also you need to record the build environment while you build,

36:16.520 --> 36:19.520
and then have some tools to recreate it.

36:19.520 --> 36:23.520
Okay, so are there any tools right now for kind of defining build environment?

36:23.520 --> 36:25.520
There are several tools, yes.

36:25.520 --> 36:28.520
Any keywords for that?

36:28.520 --> 36:33.520
There's DepriBuild for Debian, there's Reprobild for Arch Linux,

36:33.520 --> 36:36.520
there's, I don't know how OpenWRT does it,

36:36.520 --> 36:50.520
but depending on the distro there's different ones.

36:50.520 --> 36:52.520
Great talk.

36:52.520 --> 36:56.520
I was really fascinated by you describing how we can now potentially

36:56.520 --> 37:00.520
build from source code, bootstrap from, you know, 500 bytes,

37:00.520 --> 37:03.520
and then ancient versions of GCC and upwards.

37:03.520 --> 37:07.520
I think one of the reasons that is fascinating is because it addresses,

37:07.520 --> 37:11.520
Ken Thompson's attacks that he described in On Trusting Trust,

37:11.520 --> 37:15.520
which has been a major weakness in the security of the whole industry.

37:15.520 --> 37:18.520
When can I do this with Debian?

37:18.520 --> 37:25.520
When can I build Debian from source completely like back in the 60s?

37:25.520 --> 37:32.520
There you would need to talk to the bootstrap over people to bootstrap Debian really.

37:32.520 --> 37:36.520
I think you can do it probably today if you do the work.

37:36.520 --> 37:38.520
The sources are there.

37:38.520 --> 37:40.520
Somebody just needs to do it.

37:40.520 --> 37:44.520
And about this trusting trust from, can Richie what you mentioned,

37:44.520 --> 37:48.520
there's now from David Wheeler, there's reverse double compilation,

37:48.520 --> 37:53.520
where you rebuild both compilers, two compilers twice with each other,

37:53.520 --> 37:56.520
and if they produce the same results then you can be more or really sure

37:56.520 --> 38:00.520
that this trusting trust issue is resolved.

38:00.520 --> 38:04.520
There was a nice paper through the last year, October,

38:04.520 --> 38:08.520
for this 30s or 40s anniversary of Trusting Trust.

38:12.520 --> 38:14.520
Any more questions?

38:20.520 --> 38:23.520
It's not really a question, it's more a comment.

38:23.520 --> 38:28.520
For people who come from TPMs and attestation, attestation always works on binaries,

38:28.520 --> 38:32.520
and the question you always have is, what is the source code corresponding to the binary?

38:32.520 --> 38:36.520
And the only process we know forgetting that is actually reproducible builds.

38:36.520 --> 38:42.520
And so there's a lot of people in the security community actually trying to advocate for reproducible builds,

38:42.520 --> 38:47.520
just so we can prove to our customers that this binary hash corresponds to this source code.

38:47.520 --> 38:51.520
And the comment is just that this is actually a very important use case

38:51.520 --> 38:55.520
that is rising enormously in importance with the attestation requirements

38:55.520 --> 38:59.520
of confidential computing and the like, that you can actually use to plead for funding

38:59.520 --> 39:05.520
for guys like the NSA or other people, because this is suddenly becoming really, really important.

39:10.520 --> 39:13.520
I just have a total beginner question.

39:13.520 --> 39:18.520
So I have source code checked out somewhere, and I want to have a reproducible build.

39:18.520 --> 39:21.520
So how do I go there?

39:21.520 --> 39:28.520
I can set source stage epoch, but that doesn't really match because each of those files have a different date.

39:28.520 --> 39:35.520
So is there an easy just to make this way, and then it will analyze the source states,

39:35.520 --> 39:39.520
set the right source epoch and things like that, or how do I get there?

39:39.520 --> 39:46.520
It depends. But first you set source state epoch just to the last modification of the whole source.

39:46.520 --> 39:50.520
So if you have 10 source files, just the latest timestamp.

39:50.520 --> 39:55.520
And then you just build it, and you build it twice, and you compare it.

39:55.520 --> 40:00.520
And with that, if you just build it now twice, you already have some variations,

40:00.520 --> 40:07.520
like randomization, hashes are not sorting the same, but maybe you don't catch the issue with the timestamp.

40:07.520 --> 40:10.520
So you build it once today and once tomorrow.

40:10.520 --> 40:18.520
And then you compare it, either they are the same, or if not, then you compare them with DIFFERSCOPE to see where is the difference.

40:18.520 --> 40:22.520
And according to this, you do whatever is needed to remove the difference.

40:22.520 --> 40:28.520
Okay, then is there an easy tool to give me the right timestamp to set for source stage epoch?

40:28.520 --> 40:32.520
Or when I have a make file, I may be even able to say,

40:32.520 --> 40:36.520
Analyze the date and give me the highest one as source state epoch.

40:36.520 --> 40:43.520
There is not the right timestamp. Often the right timestamp is no timestamp.

40:44.520 --> 40:50.520
And some people just set it to January 1st, 1970, or just drop it.

40:50.520 --> 40:55.520
Because if the timestamp is just there to be a timestamp, if it's really meaningless, you can just drop it.

40:55.520 --> 41:01.520
The other thing is you replace the build timestamp with the timestamp of source state epoch.

41:01.520 --> 41:06.520
Then you still have a timestamp, but what's the timestamp worse?

41:07.520 --> 41:17.520
Just kind of saying that one thing I have done several times in projects is to add,

41:17.520 --> 41:24.520
for the reason of getting the same source table each time,

41:24.520 --> 41:35.520
added a make target or something like that to basically touch all files with a timestamp derived from a file.

41:35.520 --> 41:39.520
And this file will be some sort of manifest.

41:39.520 --> 41:46.520
So you can check that against the files and also use it as a source for all the timestamps.

41:46.520 --> 41:51.520
It's not perfect because sometimes there's timestamps inside files,

41:51.520 --> 41:59.520
and you need to manually add something to edit that, but it's a good starting point to do that.

42:05.520 --> 42:12.520
Thank you for the talk.

42:12.520 --> 42:18.520
What are the main challenges to make the Linux kernel representative?

42:18.520 --> 42:25.520
At the moment, the main challenges are signatures on kernel modules.

42:26.520 --> 42:35.520
Then we came up with the solution that if you rebuild something and you get the same bits,

42:35.520 --> 42:40.520
then you can just reapply the signature again because the signature will match again,

42:40.520 --> 42:43.520
but for that you still need to have the signature.

42:43.520 --> 42:47.520
So it's mostly, it's not impossible, but it's busy work.

42:47.520 --> 42:52.520
And because the signing process is also a secure boot change and there's time requirements

42:52.520 --> 43:01.520
to get the signing in, that is more problematic than the technical challenges.

43:01.520 --> 43:04.520
Okay, and that's time. Thank you very much for the talk.

