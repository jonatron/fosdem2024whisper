WEBVTT

00:00.000 --> 00:14.960
So, in the previous talk, we heard about how you can add lots of commands to, well, like

00:14.960 --> 00:22.560
to fix the shortcomings of an interesting or dated model of version control.

00:22.560 --> 00:28.320
In this talk, I want to convince you that you can actually...

00:28.320 --> 00:31.680
Oh, this isn't working?

00:31.680 --> 00:32.680
Yeah.

00:32.680 --> 00:35.240
I didn't do anything.

00:35.240 --> 00:36.240
So, I don't...

00:36.240 --> 00:38.240
Oh, yeah, right, right, right.

00:38.240 --> 00:43.400
So, as I was saying in the previous talk, we heard about how you can add commands to

00:43.400 --> 00:48.840
all sorts of things and improve on the state of the art in version control.

00:48.840 --> 00:52.760
In this talk, I want to convince you that we can actually get all, like most of the

00:52.760 --> 00:54.640
stuff for free if we do...

00:54.640 --> 00:56.960
If we start by doing some mathematics.

00:56.960 --> 01:06.200
So, my entire life so far has been about doing really far stretches between deep PRE

01:06.200 --> 01:10.880
or deep practice or between one domain and another.

01:10.880 --> 01:15.920
I've been working on DNA nanotechnology as a theoretical computer scientist for a while.

01:15.920 --> 01:23.200
Today, I'm working on a game theory and economics algorithms for electricity markets.

01:23.200 --> 01:26.200
I'm also working...

01:26.200 --> 01:29.440
Well, in general, I'm interested in distributed computing.

01:29.440 --> 01:33.480
So, PIRUL is a byproduct of that interest.

01:33.480 --> 01:40.280
So, in this talk, I'll first start with defining things.

01:40.280 --> 01:44.520
There'll be some mathematics involved and also some practical stuff.

01:44.520 --> 01:50.760
So, if you're not interested in mathematical parts, like bear with me, they won't be too

01:50.760 --> 01:51.760
long hopefully.

01:51.760 --> 01:52.760
All right.

01:52.760 --> 01:58.840
So, I'll first start with defining what version control is for me, then talk about our solution

01:58.840 --> 02:05.720
and what we've been working on, and then some cool implementation details or things that

02:05.720 --> 02:08.000
I find cool at least.

02:08.000 --> 02:14.320
And then, well, my talk title was a little bit of a bit of a bit of a bit of a bit of

02:15.200 --> 02:21.820
So, I'll try to come back to that and comment on that choice by asking the question again.

02:21.820 --> 02:23.820
Is this really post-get?

02:23.820 --> 02:24.820
Okay.

02:24.820 --> 02:27.200
So, version control.

02:27.200 --> 02:30.600
Probably many people here use it and know exactly what it is.

02:30.600 --> 02:33.000
Let's do it anyway.

02:33.000 --> 02:35.600
It's one or more cool out there.

02:35.600 --> 02:38.240
Is it a tree of documents concurrently?

02:38.240 --> 02:43.440
And one thing that's super important is the asynchronous nature of the thing.

02:43.560 --> 02:47.640
The co-authors can choose when they want to sync or merge.

02:47.640 --> 02:55.640
And like reminding these definitions sounds like it's a little bit trivial, but it actually

02:55.640 --> 03:00.920
matters a lot when you're deep down in mathematics and you're trying to understand what you're

03:00.920 --> 03:02.920
doing and why you're doing it.

03:02.920 --> 03:09.120
So, for example, how does version control differ from Google Docs, for example?

03:09.120 --> 03:10.560
It is made conflicts.

03:10.680 --> 03:18.680
So, that's a feature that's been often overlooked in current systems like Git, Mercurial, SVN,

03:18.680 --> 03:21.960
CVS, RCS before it.

03:21.960 --> 03:26.040
And finally, also, version control allows you to review a project's history.

03:26.040 --> 03:29.720
So, that's a very important feature as well.

03:29.720 --> 03:36.160
Many people consider, well, apparently not everybody, but many people consider version

03:36.160 --> 03:37.960
control a solved problem.

03:37.960 --> 03:39.760
Git is here to stay.

03:39.760 --> 03:44.640
It's sold version control 15 years ago, and that's the end of the story.

03:44.640 --> 03:49.040
Unfortunately, well, I personally don't think this is true.

03:49.040 --> 03:54.320
Some symptoms indicating this might not be true are, for example, that's R-tools, no

03:54.320 --> 03:56.920
matter how good we think they are.

03:56.920 --> 03:59.800
They still aren't used by non-coders despite their maturity.

03:59.800 --> 04:05.240
We've been working on this for 30 years, and the thing we're most proud of in this industry

04:05.240 --> 04:07.840
cannot even be used by outsiders.

04:08.280 --> 04:15.480
So, nowadays we have, like, Silverware designed by NASA, and everybody at NASA is proud of

04:15.480 --> 04:19.040
that, and everybody buying Silverware designed by NASA is proud of that.

04:19.040 --> 04:25.840
But R-tools for version control, they aren't used by outsiders or just marginally.

04:25.840 --> 04:28.120
R-tools are distributed.

04:28.120 --> 04:33.120
Yes, most of the time we use them with a global central server.

04:33.120 --> 04:39.760
So I've seen a poster in this conference saying, not all paths lead to Chrome, but apparently

04:39.760 --> 04:42.400
many paths lead to GitHub.

04:42.400 --> 04:46.960
R-tools also require strong work discipline in planning.

04:46.960 --> 04:53.880
You need to plan ahead of time, to plan your branches, to follow really strict workflows,

04:53.880 --> 04:55.200
to rebase versus merge.

04:55.200 --> 05:01.560
We even had a slide on that in previous talk, like how we merge shop or rebase shop.

05:01.560 --> 05:05.600
In this talk, I'll try to convince you that this doesn't matter at all.

05:05.600 --> 05:12.600
And all this results in a significant waste of human work time at a global scale.

05:12.600 --> 05:17.640
Improvements have been proposed, for example, DAX, but they don't really scale and nobody

05:17.640 --> 05:19.200
uses them.

05:19.200 --> 05:22.520
So, is there, can we get a quick fix?

05:22.520 --> 05:27.280
Can we get that next Git command that will fix everything?

05:27.280 --> 05:30.360
Well, unfortunately, I don't think so.

05:30.360 --> 05:35.520
First of all, because abstractions leak terribly in Git.

05:35.520 --> 05:41.360
And the reason isn't the UI, isn't the bad naming of some commands or arguments.

05:41.360 --> 05:46.800
The reason is that if we consider miracle trees and DAX as the core mechanism, they

05:46.800 --> 05:49.200
can't really be hidden from the user.

05:49.200 --> 05:52.880
Because if that's the core thing you want, and if all the properties you want come from

05:52.880 --> 05:56.040
that, there's absolutely no reason to hide it from the user.

05:56.040 --> 05:59.360
And there's no hope you can even succeed in doing that.

05:59.360 --> 06:08.640
Also, similarly, if strict ordering of snapshots is the main feature, the most used Git commands

06:08.640 --> 06:15.080
like rebase, we heard about rarararar in previous talk, cherpic, they're fixes around that best

06:15.080 --> 06:16.760
feature we have.

06:16.760 --> 06:20.360
So why do you need to fix your main feature?

06:20.360 --> 06:22.360
That's strange.

06:22.360 --> 06:25.480
Anyway, some more same terms.

06:25.480 --> 06:29.960
There is an inflation of commands and options in Git.

06:29.960 --> 06:33.640
Like I'll try to show you an example here.

06:33.640 --> 06:37.840
This is God and comicals, it's the point that someone made a Git's man page generator that

06:37.840 --> 06:39.760
actually looks credible.

06:39.760 --> 06:49.400
If you reload the page here, you get a different one every time.

06:49.400 --> 06:53.920
Give environment grabs non-reset downstream environments using past local garbage collectors

06:53.920 --> 06:56.760
while overriding fitting shells survey the given environments.

06:56.760 --> 07:01.160
Boo doesn't use this command here.

07:01.160 --> 07:05.760
Anyway, there is also an inflation of UIs.

07:05.760 --> 07:08.640
Even Big Tech is now investing in Git in mercurial UIs.

07:08.640 --> 07:10.960
I won't cite names here.

07:10.960 --> 07:12.920
But there's also inflation of forges.

07:12.920 --> 07:16.360
How many forges have started last year alone?

07:16.360 --> 07:22.400
I know a bunch of forges because they sometimes contact me to help them do something with

07:22.400 --> 07:25.680
people.

07:25.680 --> 07:32.040
My claim here is that we all consider text editing a solved problem.

07:32.040 --> 07:36.280
There's no new text editor popping up every now and then and convincing the VC that this

07:36.280 --> 07:38.520
is a really cool idea.

07:38.520 --> 07:41.000
Window managers, same thing.

07:41.000 --> 07:45.840
And forges, you keep seeing forges popping up every now and then.

07:46.320 --> 07:47.480
I'm not saying this is bad.

07:47.480 --> 07:49.120
This is actually really good.

07:49.120 --> 07:53.640
It's fantastic that the ecosystem is thriving and there's a lot of diversity.

07:53.640 --> 07:58.560
But my claim is that maybe this inflation comes from some more fundamental thing that

07:58.560 --> 08:00.360
we don't understand.

08:00.360 --> 08:04.600
Now, on to our demands.

08:04.600 --> 08:09.680
First, we demand associative merges.

08:09.680 --> 08:14.680
It may not matter much to use, but I'll show you in the next slide that you actually want

08:14.680 --> 08:16.680
associative merges.

08:16.680 --> 08:23.040
Associative merges means that when you have two changes, A and B, and you merge them together,

08:23.040 --> 08:28.840
it should do the same as merging A followed by merging B.

08:28.840 --> 08:32.720
And the reason you want that is because you want to be able to review your patches or

08:32.720 --> 08:37.720
your comments one by one and then merge them and trust that the merge does exactly what

08:37.720 --> 08:41.280
you think it does, except in get it doesn't.

08:41.320 --> 08:48.360
Associative merges, if A and B can be produced independently, they all should not matter.

08:48.360 --> 08:52.320
That's what I mean by are we a rebase shop or a merge shop.

08:52.320 --> 08:53.320
It doesn't matter.

08:53.320 --> 08:54.840
We don't want to ask this question.

08:54.840 --> 08:57.960
We want to get back to work.

08:57.960 --> 08:59.480
Branches, we do want branches.

08:59.480 --> 09:04.320
Everybody loves branches, but not too many branches.

09:04.320 --> 09:06.400
Branches are good until they aren't.

09:06.400 --> 09:09.040
I'll tell you more on that later.

09:09.800 --> 09:13.200
We also want that's something I personally really want.

09:13.200 --> 09:15.480
I want low algorithmic complexity.

09:15.480 --> 09:22.800
And also ideally, fast implementations was in my way of seeing things that come second.

09:22.800 --> 09:27.560
But I also give you an example of a very fast implementation of something with Darm.

09:27.560 --> 09:32.280
All right, associative merges, the first of our demands.

09:32.280 --> 09:36.400
This is exactly what I described, but this is a graphic view of it.

09:36.400 --> 09:39.840
So you have two co-authors, Alice and Bob.

09:39.840 --> 09:46.040
Alice produces one, commits A, and Bob produces two, commits B and C.

09:46.040 --> 09:53.160
And then in the first scenario, Alice merges Bob's first, commits, and then Bob's second, commits.

09:53.160 --> 09:57.760
The second scenario, she merges both commits at once.

09:57.760 --> 10:04.640
And while the commit identifiers, nobody would expect that they're the same.

10:04.720 --> 10:06.600
They will necessarily be different.

10:06.600 --> 10:15.360
But the contents of the, if there's no conflict at all, the contents should absolutely be the same.

10:15.360 --> 10:18.000
And this is actually false.

10:18.000 --> 10:25.320
So this is an example, a counter example of where Giz is not associated, and this might be a problem.

10:25.320 --> 10:28.000
This is actually terrifying to me.

10:28.000 --> 10:33.920
We start on the left here with a simplified two lines, A and B.

10:34.000 --> 10:35.720
Alice follows that path.

10:35.720 --> 10:41.080
She adds the first commits with a G at the very beginning of the file.

10:41.080 --> 10:48.920
And then she goes on and adds another commit with another copy of A and B before that G, right?

10:48.920 --> 10:55.320
And concurrently to that, Bob inserts an X between the initial A and B.

10:55.320 --> 11:01.640
And when you can try that, if you have a laptop here, you can try to simulate that in Git today.

11:01.640 --> 11:04.600
And this is actually not a bug, it's a feature of Git.

11:04.600 --> 11:11.560
And what happens if you do that is that Bob's new lines get merged into Alice's new lines.

11:11.560 --> 11:17.040
And if I were working in a high security project, this would absolutely terrify me.

11:17.040 --> 11:24.760
This means that Git can randomly shuffle your lines around and do it silently.

11:24.760 --> 11:27.560
Without telling you that there's no conflict, nothing.

11:27.560 --> 11:29.360
It just works.

11:29.360 --> 11:31.040
And yet it doesn't really work.

11:31.040 --> 11:33.240
It doesn't do what you think it does.

11:33.240 --> 11:34.080
So we don't want that.

11:34.080 --> 11:36.920
We want to fix the problem.

11:36.920 --> 11:38.640
We also want commutative mergers.

11:38.640 --> 11:41.800
So that's a more controversial one.

11:41.800 --> 11:49.800
We want the property that if Alice and Bob work together, well, Alice can pull Bob's changes

11:49.800 --> 11:52.440
and Bob can pull Alice's changes.

11:52.440 --> 11:58.560
Without having to worry too much about the resulting hashes or the contents of the file.

11:58.600 --> 12:02.520
If the patches are independent, you should be able to apply them in any order without

12:02.520 --> 12:04.120
changing the results.

12:04.120 --> 12:06.240
So we do that.

12:06.240 --> 12:07.600
Git and SBN are never commutative.

12:07.600 --> 12:11.360
So why would we want this?

12:11.360 --> 12:13.720
Actually there's very good reasons to want this.

12:13.720 --> 12:19.520
For example, you might want to unapply and unapply an old change, an old patch that you

12:19.520 --> 12:22.680
just made a few patches ago that was wrong.

12:22.680 --> 12:26.400
And you want to undo it without having to change your entire identities.

12:26.400 --> 12:30.680
Of course, we also want state identities and I'll come back to that later.

12:30.680 --> 12:31.920
We want cherry picking.

12:31.920 --> 12:37.760
We want to be able to just take that one patch from a different branch, maybe a bug fix.

12:37.760 --> 12:42.880
I want to pull this into our branch without having to rebase everything and change every

12:42.880 --> 12:44.960
commit's identity.

12:44.960 --> 12:50.320
And yet keep strong, unfortable state identifiers.

12:50.320 --> 12:51.800
And we want partial clones.

12:51.840 --> 12:59.080
So partial clones means that you want to just pull the patches related to subprojects and

12:59.080 --> 13:03.360
possibly also in the other direction merge repos transparently.

13:03.360 --> 13:09.720
Scott was talking before about mono repos and how Microsoft devoted probably millions

13:09.720 --> 13:13.440
of man hours to have their mono repos work.

13:13.440 --> 13:19.480
But actually if you first try to model your things properly and try to understand commutativity,

13:19.480 --> 13:21.600
actually you don't need all that.

13:21.600 --> 13:26.000
You can get mono repos for free.

13:26.000 --> 13:34.040
And so that brings us to one of the crucial slides in this presentation about states versus

13:34.040 --> 13:35.040
changes.

13:35.040 --> 13:40.080
So the way we see things in order to think about version control.

13:40.080 --> 13:46.280
So I understand I'm not giving you many new commands or cool line hacks, but before getting

13:46.280 --> 13:52.280
to that we had to think about what it means to do version control.

13:52.280 --> 13:54.640
So states versus changes.

13:54.640 --> 13:59.800
There's actually two fundamentally different ways to model what version control is.

13:59.800 --> 14:05.680
One is by seeing it as a series of versions, a series of snapshots of your repos, which

14:05.680 --> 14:10.000
is what Git does, and Mercurial, SVN, CVS do that.

14:10.000 --> 14:16.120
And only compute changes as a byproduct of these.

14:16.600 --> 14:18.800
The question we can ask is what if we did the opposite?

14:18.800 --> 14:25.240
What is if instead of considering that working in a project means creating a new version,

14:25.240 --> 14:31.280
we consider that working in a project means changing it, creating a change.

14:31.280 --> 14:35.520
And another question we can ask is what if we did both at the same time?

14:35.520 --> 14:37.520
And that's what we do.

14:37.520 --> 14:39.560
All right.

14:39.560 --> 14:41.840
So a little bit of bibliography first.

14:41.840 --> 14:48.280
And this is getting a little bit mathematically.

14:48.280 --> 14:52.880
So bear with me if you don't understand everything, I'll get back to cool implementation stuff

14:52.880 --> 14:54.400
later.

14:54.400 --> 14:59.480
So a change-based idea, and this is from the 80s, it's called operational transforms.

14:59.480 --> 15:04.000
It is what Google Docs, for example, uses, or Docs uses that as well.

15:04.000 --> 15:09.880
So in operational transforms, for example, we start with a file with only three lines,

15:10.520 --> 15:16.200
T1 on the left inserts, so this is Alice, let's say, inserts X at the beginning of the

15:16.200 --> 15:26.200
file, and T2 deletes the character C. So to get into two divergent states, and then

15:26.200 --> 15:30.800
what operational transforms mean is that now that we've inserted an X at the beginning

15:30.800 --> 15:35.760
of the file, this changes, we have to rewrite the other concurrent changes.

15:35.800 --> 15:39.880
So for example, here, instead of saying delete the second character, it was a C, now you

15:39.880 --> 15:45.200
have to say delete the third character, it was a C. And so that's how you can merge things.

15:45.200 --> 15:49.320
Docs does this and uses this to detect conflicts.

15:49.320 --> 15:56.320
One issue is that if you only have insertions and deletions, it's okay, but there are still

15:56.320 --> 15:58.000
performance problems.

15:58.000 --> 16:03.000
But as soon as you start handling more than insertions and deletions, you get into a quadratic

16:03.040 --> 16:10.200
explosion of cases because you have to handle all pairs of types of operations.

16:10.200 --> 16:14.920
And this is according to Google engineers who worked in the Google Docs project, this

16:14.920 --> 16:16.440
is an absolute nightmare to implement.

16:16.440 --> 16:20.760
And I've never heard anyone implement an operational transform, we said, yeah, they're cool, they're

16:20.760 --> 16:24.360
really easy.

16:24.360 --> 16:28.720
So a hybrid in more recent state approach is CRDTs.

16:28.800 --> 16:31.800
So how many here know about CRDTs?

16:31.800 --> 16:37.200
Okay, okay, reasonable number.

16:37.200 --> 16:40.520
So the general principle is very simple.

16:40.520 --> 16:44.680
The idea is to design a structure where all operations have the properties we want.

16:44.680 --> 16:50.560
Instead of having your structure and say, okay, now how do we merge changes?

16:50.560 --> 16:55.200
Instead of doing that, you take the problem in the opposite direction saying, how can

16:55.200 --> 17:00.280
we design a data structure from scratch so that all operations on that data structure

17:00.280 --> 17:06.480
have the right properties, meaning they are commutative, associative, they have a neutral

17:06.480 --> 17:10.640
element and all that algebraic things.

17:10.640 --> 17:16.400
Natural examples of CRDTs are like, for example, a very simple one, increments only counters,

17:16.400 --> 17:19.840
counters where you can only add one to the counter.

17:19.840 --> 17:26.560
This is a very easy and natural example of a CRDT because if Alice and Bob both increment

17:26.560 --> 17:31.360
the counter, you just have to add two to the result to merge their change.

17:31.360 --> 17:38.480
Insert only sets, for the exact same reason, insert only sets, there are natural CRDTs.

17:38.480 --> 17:44.160
And if you want to do things like deletions or more subtle data structure, more subtle,

17:44.160 --> 17:49.920
more interesting operations, you have to use more trickier techniques like Tom Stones

17:49.920 --> 17:51.640
and Landport clocks.

17:51.640 --> 17:56.760
I won't get into these details and if you're interested, we can talk later.

17:56.760 --> 18:02.320
A useless example of a CRDT that's often invoked is a full git repository.

18:02.320 --> 18:04.960
Well this is just an append only set of commits.

18:04.960 --> 18:09.800
So yeah, sure, it's a CRDT.

18:09.800 --> 18:11.080
It's commutative and all that.

18:11.080 --> 18:15.600
But also, it's not super useful to see a git repository as a CRDT.

18:15.600 --> 18:17.120
Just means you can clone this.

18:17.120 --> 18:21.560
Saying this is a CRDT means basically it's okay, you can clone a git repository and then

18:21.560 --> 18:24.240
keep pulling into it.

18:24.240 --> 18:27.920
But it doesn't mean it handles merges properly.

18:27.920 --> 18:32.800
What we want is the heads of the git repository to be a CRDT.

18:32.800 --> 18:36.480
All right, so how do we do that?

18:37.480 --> 18:44.360
Well, merges, when everything goes right, we're not really interested.

18:44.360 --> 18:47.720
So we'll start by modeling conflicts because they're the hardest case.

18:47.720 --> 18:52.880
And if we cannot model conflicts properly, then there's little hope of doing anything

18:52.880 --> 18:53.880
interesting.

18:53.880 --> 18:57.080
So conflicts are where we need a good tool the most.

18:57.080 --> 18:59.160
The exact definition depends on the tool.

18:59.160 --> 19:04.120
DAX for example has really cool and exotic definitions of conflicts.

19:04.760 --> 19:09.240
For example, if Alice and Bob are writing to the same file at the same place, I'd say

19:09.240 --> 19:13.080
most tools consider that a conflict, but not all.

19:13.080 --> 19:18.920
When Alice renames a file from F to G, while Bob renames it to H, I'd say most tools also

19:18.920 --> 19:20.040
consider that a conflict.

19:20.040 --> 19:22.880
Some will just pick a name randomly.

19:22.880 --> 19:27.800
Alice renames a function F while Bob adds a call to F. So that's a trickier one.

19:27.800 --> 19:32.120
And very few tools that I know of can handle that conflict properly.

19:32.120 --> 19:34.880
If a conflict can do it, my tool cannot do it.

19:34.880 --> 19:37.240
And Git can certainly not do it.

19:37.240 --> 19:39.920
So how do we do that?

19:39.920 --> 19:45.960
How do we solve all these problems at once and get all the nice properties for free?

19:45.960 --> 19:48.720
We do that by using category theory.

19:48.720 --> 19:56.760
So this is a mathematical framework that gives you really nice tools to model, to work in

19:56.760 --> 20:00.240
abstractions of things in general.

20:00.240 --> 20:07.920
So our modeling in category theory of this problem is if you have any two patches, F and

20:07.920 --> 20:14.320
G, what we want is a unique state P, which is the sort of the minimal merge of F and

20:14.320 --> 20:21.680
G, such that for anything that Alice and Bob could do after F and G to reach a common state,

20:21.680 --> 20:26.040
that common state, or common state Q, that common state can also be reached from P. So

20:26.040 --> 20:32.440
instead of doing some work to get to common points, you can always first get to a common

20:32.440 --> 20:35.280
point and then do the work.

20:35.280 --> 20:43.840
So if P exists, category theorist call it the push out of F and G. So the reason we're

20:43.840 --> 20:49.480
interested in that is because category theory has a lot of tools to start from this simple

20:49.480 --> 20:56.520
modeling and give us lots of cool stuff like free data structures and while do our job

20:56.520 --> 20:58.080
for us basically.

20:58.080 --> 21:04.640
So in this case, category theorist would notice that the push out of two patches doesn't always

21:04.640 --> 21:09.600
exist and this is absolutely equivalent saying that sometimes there are conflicts.

21:09.600 --> 21:13.880
And now the question becomes how to generalize representation of states, states are like

21:13.880 --> 21:19.480
X, Y and Z, so that all pairs of changes F and G have a push out.

21:19.480 --> 21:25.760
The solution is to just generalize states to directed graphs instead of just sequences

21:25.760 --> 21:29.600
of bytes where vertices of these graphs are bytes.

21:29.600 --> 21:32.160
I'll give you an example in the next slide.

21:32.160 --> 21:36.040
Verses are bytes and edges represent the union of all known order between bytes.

21:36.040 --> 21:41.840
So that sounds a little far fetch, but actually it's very clear in the example.

21:41.840 --> 21:46.480
So the way we model these things in Pichl is as fellow.

21:46.480 --> 21:52.400
So the first example of a simple patch is how do we add some bytes to our data structures.

21:52.400 --> 21:55.040
So we have a file.

21:55.040 --> 22:00.600
So well first in our graph, all vertices are labeled by a change number.

22:00.600 --> 22:07.440
Here for example C0 is change number zero and an interval such as zero and presenting

22:07.440 --> 22:11.360
bytes inside that change, inside that patch.

22:11.360 --> 22:15.360
And edges or our graph are labeled by the change that introduced them.

22:15.360 --> 22:21.400
So for example, here's a starting from an initial file C0, zero, n.

22:21.400 --> 22:23.440
How do we add some bytes in the middle?

22:23.440 --> 22:32.120
Well, we'll first split the initial file and then add some bytes, add a new vertex inside

22:32.120 --> 22:35.680
the middle of that vertex and then reconnect everything so that we can get the order of

22:35.680 --> 22:36.680
rights.

22:36.680 --> 22:43.880
And now that the bytes introduced by C0 between zero and i come before the bytes in C1 between

22:43.880 --> 22:50.200
zero and m and these in turn come before the bytes introduced by C0 between i and n.

22:50.200 --> 22:53.760
So this is how we do insertions.

22:53.760 --> 22:58.880
The implementation now, the rest is a question of, is a matter of implementation like how

22:58.880 --> 23:05.400
do we store these giants graphs efficiently on disk and so on.

23:06.200 --> 23:12.400
Deleting works more or less in the same way except we now introduce a new thing which

23:12.400 --> 23:13.960
is the edge label.

23:13.960 --> 23:21.800
So deleting a vertex in our system means turning an edge, like turning an edge from a continuous

23:21.800 --> 23:25.600
line into a dashed line.

23:25.600 --> 23:28.480
And so we do more or less the same thing.

23:28.480 --> 23:33.000
In this example we're deleting bytes J2i from C0 and zero to K from C1.

23:33.040 --> 23:36.600
So some bytes that were introduced by previous patches.

23:36.600 --> 23:38.960
And so this is what we guess in the end.

23:38.960 --> 23:45.120
So we get a bunch of vertices and dashed lines to indicate which bytes should be deleted

23:45.120 --> 23:48.120
and which are still alive.

23:48.120 --> 23:49.600
All right.

23:49.600 --> 23:53.680
And that's actually the good news is that we don't need more than that to build an entire

23:53.680 --> 23:55.560
version control system.

23:55.560 --> 23:59.200
So this is rebuilding foundations first, right?

23:59.200 --> 24:03.920
This is actually really cool because it's a very minimalistic system and we like that

24:03.920 --> 24:06.680
because it makes everything else easy.

24:06.680 --> 24:08.240
So two kinds of changes.

24:08.240 --> 24:14.040
One is adding a vertex to our graph in a context, meaning parents and children of that new vertex,

24:14.040 --> 24:16.760
and change an edge's label.

24:16.760 --> 24:18.040
And this is all we need actually.

24:18.040 --> 24:22.760
We get, like, from these things we get a ton of cool properties for free.

24:22.760 --> 24:28.760
First we get free conflict handling because we were just, like, there's no notion of

24:28.760 --> 24:29.760
conflict in this.

24:29.760 --> 24:32.920
We're just adding vertices, changing edges' labels.

24:32.920 --> 24:37.960
And there's no, like, the graph naturally models conflicts.

24:37.960 --> 24:39.120
So conflicts are possible.

24:39.120 --> 24:44.600
They're properly modeled inside the graph and they can be talked about and manipulated

24:44.600 --> 24:48.120
without any specific treatments.

24:48.120 --> 24:53.200
So our definition of conflict here is we could first call the live vertices whose incoming

24:53.200 --> 24:56.480
edges are all alive, meaning they're all full lines.

24:56.480 --> 25:02.000
Live vertices or vertices whose incoming edges are all dead, and vertices in the middle that

25:02.000 --> 25:06.640
have both alive and dead edges, we call them zombies.

25:06.640 --> 25:10.800
We say now that the graph has no conflicts if and only if it has no zombie, and all its

25:10.800 --> 25:16.480
live vertices are totally ordered, meaning we can actually compute a full ordering of

25:16.480 --> 25:17.480
all the bytes.

25:17.480 --> 25:22.360
We know exactly what order the bytes come in the file, and if we have that, then we

25:22.360 --> 25:27.160
can output the file to the user, and it actually makes sense.

25:27.160 --> 25:32.040
So some notes on this system.

25:32.040 --> 25:36.720
So this gives a system where we have changes that are not exactly or diffs that are not

25:36.720 --> 25:38.160
exactly Unix diffs.

25:38.160 --> 25:42.560
They are Unix diffs plus tons of metadata to make it work.

25:42.560 --> 25:47.600
And now they are partially ordered by their dependencies on other changes.

25:47.600 --> 25:52.520
This means that you cannot possibly work inside a file that has not been introduced

25:52.520 --> 25:56.960
in the repository yet, or you cannot edit a paragraph that doesn't exist yet.

25:56.960 --> 26:03.240
So not all changes are commutative, but changes that could be made independently are commutative.

26:03.240 --> 26:06.080
Chera picking, now this is the same as applying a patch.

26:06.080 --> 26:09.440
We only have two commands in the system, apply a patch, unapply a patch, and it does

26:09.440 --> 26:10.440
everything.

26:10.440 --> 26:12.720
So chair picking is just apply a patch.

26:12.720 --> 26:16.440
There's no need for git rararar, because conflicts are solved by changes.

26:16.440 --> 26:17.440
You can chair pick changes.

26:17.440 --> 26:23.800
So you don't have to do any special hack or Ruby Goldberg machine to remember the conflict

26:23.800 --> 26:24.800
resolution or anything.

26:24.800 --> 26:28.960
Like the conflict resolution is just a patch, and you can just send that to others, push

26:28.960 --> 26:31.880
it, pull it, and that's it.

26:31.880 --> 26:34.800
Partial clones, monorepo sub modules, so they are easy.

26:34.800 --> 26:36.840
As long as white patches are disallowed.

26:36.840 --> 26:43.000
So if you have a patch that just does some formatting across your giant monorepo, then

26:43.000 --> 26:47.080
you will have a problem, because this patch will probably have tons of dependencies, and

26:47.080 --> 26:49.920
you will end up pulling lots of dependencies into your repo.

26:49.920 --> 26:56.760
But if you're careful enough to fragment or to cut this patch into smaller pieces, then

26:56.760 --> 27:01.080
everything becomes easy, because you can just pull the patches that are relative to a tiny

27:01.080 --> 27:08.520
part of your repository, or your giant monorepo, and it just works because of commutativity.

27:08.520 --> 27:14.520
Because all the patches you produce locally by working, they do, they necessarily commute

27:14.520 --> 27:19.120
with all the patches that were produced by your co-authors and other parts of the monorepo.

27:19.120 --> 27:23.960
So after your day of work, when you push your patches to the server, others do the same,

27:23.960 --> 27:28.520
but it doesn't matter, because it gives the same results in the end.

27:28.520 --> 27:34.920
For large files, so I've showed you a graph in the previous slides that didn't talk at

27:34.920 --> 27:36.240
all about the contents.

27:36.240 --> 27:44.560
So the contents is something super important, obviously, but it's only handled during Diff,

27:44.560 --> 27:51.440
and it is not, like you don't apply a patch, the patch themselves, they are not applied,

27:51.440 --> 27:54.640
they don't use the contents of the vertices in order to be applied.

27:54.640 --> 27:58.400
You can apply a patch by just saying, well, I just added this file, it has like one terabyte

27:58.400 --> 28:04.320
of data, and that's it, and you can find the data in some change somewhere.

28:04.320 --> 28:10.240
And so a nice consequence of that is that for large files, you can apply a patch without

28:10.240 --> 28:12.080
knowing what's in the patch.

28:12.080 --> 28:14.760
You can fetch the rest later.

28:14.760 --> 28:19.320
And so if you're running a video game shop, for example, and you have artists pushing

28:19.320 --> 28:24.400
assets, large binary assets all day, then at the end of the day, when you want to just

28:24.400 --> 28:28.760
pull everything, you don't have to pull all the intermediate versions.

28:28.760 --> 28:34.720
You pull just the operational part of these versions, saying, well, I added one gigabyte

28:34.720 --> 28:40.040
here, and now I replace that gigabyte with another one, and then yet with another one,

28:40.040 --> 28:43.280
and maybe you have 10 versions of your binary asset during the day.

28:43.280 --> 28:47.200
But at the end of the day, the only thing you know is that, yeah, you had 10 versions,

28:47.200 --> 28:50.400
there's only one still alive, just pull that one.

28:50.400 --> 28:55.880
So there's no special hack or LFS needed, you're just using patches.

28:56.880 --> 28:58.880
All right.

28:58.880 --> 29:03.400
Now onto some implementation things.

29:03.400 --> 29:06.400
So there's a lot of things to say about the implementation.

29:06.400 --> 29:12.360
The project is entirely written in Rust, or mostly written in Rust, I'd say.

29:12.360 --> 29:17.880
So I won't cover all the details about how it works and our implementation, because

29:17.880 --> 29:23.720
there would be, that would take an entire day of talks, and I won't do that.

29:23.720 --> 29:28.400
But I'll just give you some cool things that I like about our implementation.

29:28.400 --> 29:36.080
So the first challenge is that we have really large graphs on disk, and we obviously don't

29:36.080 --> 29:43.240
want to load them up entirely in memory in order to edit them.

29:43.240 --> 29:49.080
We want to be able to just work directly with the on disk data structure.

29:49.080 --> 29:54.080
So we want to store edges in a key value store, because that's an easy way to do that kind

29:54.080 --> 29:55.080
of stuff.

29:55.080 --> 30:00.320
We want transactions, because we're actually inventing a new format, data format, so we

30:00.320 --> 30:06.360
absolutely want assets, properties, we want like full transactionality, we want passive

30:06.360 --> 30:08.920
crash safety, so all these things.

30:08.920 --> 30:09.920
And we want branches.

30:09.920 --> 30:15.560
So we want to be able to take a key value store and just fork it without copying a single

30:15.560 --> 30:18.200
byte, because it would take too long.

30:18.200 --> 30:22.200
It would take a time linear in the size of history, and we don't want that.

30:22.200 --> 30:26.080
So there's no key value store, there was no key value store when we started that would

30:26.080 --> 30:29.040
do that, especially the branching feature.

30:29.040 --> 30:31.960
So we had to write, I had to write one.

30:31.960 --> 30:35.120
It's called Sanakiria, which means dictionary and finish.

30:35.120 --> 30:39.280
It's a non-disk transactional key value store, but it's actually not just a key value store,

30:39.280 --> 30:41.080
it's something really generic.

30:41.080 --> 30:43.880
It's an ACID block allocator in a file, really.

30:43.880 --> 30:49.280
And that block allocator uses a key value store, uses B trees to allocate memory, but

30:49.280 --> 30:54.200
also the B trees themselves use the allocator to do their job.

30:54.200 --> 30:59.160
So that's why the minimal data structure we can have is B trees, but also you can write

30:59.160 --> 31:03.640
all sorts of data structures with Sanakiria just by using the allocator.

31:03.640 --> 31:08.800
We have crash safety using referential transparency in copy and write.

31:08.800 --> 31:16.800
The initial goal was actually done successfully, completed successfully, because the tables

31:16.800 --> 31:22.920
are forkable in big O of log n, so it's probably completely useless for a general key value

31:22.920 --> 31:23.920
store.

31:23.920 --> 31:27.800
Then in our case, branches were really needed, so we had to do it.

31:27.800 --> 31:34.320
So forkable in big O of log n, a logarithmic time in the total size of the total number

31:34.320 --> 31:35.320
of keys.

31:35.560 --> 31:43.520
As written in Rust, while it started in Rust back in 2015 or something, Rust was still a

31:43.520 --> 31:46.240
bit younger than today.

31:46.240 --> 31:54.160
And the cool bit about that is that it allows you to access generic Rust types directly

31:54.160 --> 31:57.960
as pointers into, like, storing the file.

31:57.960 --> 32:04.480
It is way too generic, way too many things, meaning that the APIs is horrible to use, but

32:04.640 --> 32:10.240
there's a good consequence of the generality is that it's even generic in the underlying

32:10.240 --> 32:11.240
storage layer.

32:11.240 --> 32:15.880
For example, we can use it on memory map file, which we do all the time in Pichol, but we

32:15.880 --> 32:19.280
can also do it in Z standard compressed files.

32:19.280 --> 32:23.560
I've also used it not super successfully, but the prototype worked on Cloudflare key

32:23.560 --> 32:29.920
values, Cloudflare KV, so storing, like, building a key value store on top of another key value

32:29.920 --> 32:30.920
store.

32:30.920 --> 32:41.760
The cool thing about that is that, you can also use it to build ropes, for example, or

32:41.760 --> 32:46.960
Patricia trees or things like that, or vector search indexes.

32:46.960 --> 32:53.200
So I thought that implementing this in Cloudflare KV was interesting, but it's actually too

32:53.200 --> 32:55.600
slow to be really useful.

32:56.600 --> 32:58.600
All right.

32:58.600 --> 33:04.040
A very unexpected consequence of that is that Senacilia is the fastest key value store we've

33:04.040 --> 33:11.440
tested and actually beats LMDB, which is the fastest C key value store by a pretty wide

33:11.440 --> 33:12.440
margin.

33:12.440 --> 33:19.040
In these graphs, I've included, actually, the coolest project ever in this space, which

33:19.040 --> 33:21.760
is not Senacilia, it's Sled.

33:21.760 --> 33:26.040
Sled is a really fantastic key value store that allows you to have multiple concurrent

33:26.040 --> 33:32.480
writers using really, really cool data, like modern database technology and so on.

33:32.480 --> 33:37.400
Senacilia is much more modest in its scope, but it's also way faster.

33:37.400 --> 33:43.840
So if we remove Sled, which is more on the experimental side, we can see that we beat

33:43.840 --> 33:47.120
LMDB by 50% or something.

33:48.000 --> 33:51.840
I've included the Rust standard B trees in these graphs.

33:51.840 --> 33:53.440
They're the theoretical limit.

33:53.440 --> 33:56.880
You cannot go faster than that because they don't even store anything on disk.

33:56.880 --> 34:00.240
We have to store stuff on disk, so we will be slower.

34:00.240 --> 34:02.240
Okay.

34:02.240 --> 34:07.880
So using Senacilia, I can build modular databases.

34:07.880 --> 34:11.880
Like I said, this is transactional block allocator with reference counting included.

34:11.880 --> 34:14.320
I've built different data structures in this.

34:14.320 --> 34:18.600
One cool thing you cannot do with others that can be done in Senacilia are composite

34:18.600 --> 34:19.600
types.

34:19.600 --> 34:25.680
So for example, in Pihu, branches are B trees of strings to other B trees that store our

34:25.680 --> 34:26.680
graphs.

34:26.680 --> 34:31.120
So you can nest data structures like that, which is cool.

34:31.120 --> 34:35.320
I have a prototype text editor with forkable files.

34:35.320 --> 34:40.120
So you can click a button and have a free copy of your file, sharing all its common bytes

34:40.120 --> 34:42.640
with the previous one.

34:42.640 --> 34:48.640
And its type is something like that, a B tree of string to rope in the Pihu graph.

34:48.640 --> 34:52.760
So if you're interested in data structures and performance challenges, join us because

34:52.760 --> 34:55.640
we're doing cool stuff in the space.

34:55.640 --> 34:56.640
All right.

34:56.640 --> 35:00.120
So back to my claim that this is both GIT.

35:00.120 --> 35:01.120
Things we get for free.

35:01.120 --> 35:07.400
I've said a few of these so far, but we can get, one thing I haven't said is we can get

35:07.400 --> 35:12.600
super fast Pihu credits, which is the Pihu equivalence of GIT blame because we don't

35:12.600 --> 35:15.080
want to blame our co-authors.

35:15.080 --> 35:16.960
We'd rather credit them.

35:16.960 --> 35:18.920
So the info is readily available in the graph.

35:18.920 --> 35:20.240
So you get that for free.

35:20.240 --> 35:27.480
So Scott was speaking in his talk about how you can use really cool hacks to speed up

35:27.480 --> 35:28.480
GIT's blame.

35:28.480 --> 35:32.720
But actually, if you don't use GIT at all, like if you model your stuff properly, you

35:32.720 --> 35:36.720
don't even need to speed things up because the information is readily available in the

35:36.720 --> 35:37.720
graph.

35:37.720 --> 35:40.880
And so it's fast by default.

35:40.880 --> 35:42.880
You can have your bug fixes in your main branch.

35:42.880 --> 35:47.520
You don't have to plan feature branches and bug fix branches in advance.

35:47.520 --> 35:50.400
You can push them to production by having them on your main branch.

35:50.400 --> 35:54.480
You can work on several features in the same branch and then decide what belongs to a feature

35:54.480 --> 35:55.880
after the fact.

35:55.880 --> 35:59.040
So no more rigid workflows.

35:59.040 --> 36:02.400
No more like way less meetings, hopefully.

36:02.400 --> 36:04.920
You can get sub modules.

36:04.920 --> 36:06.680
So sub modules don't have to suck.

36:06.680 --> 36:08.920
Don't let anyone tell you otherwise.

36:08.920 --> 36:10.080
Sub modules don't have to suck.

36:10.080 --> 36:14.040
You can get them for free using patch commutativity.

36:14.040 --> 36:20.520
And the reason is changes in unrelated projects commute because they can be produced independently

36:20.520 --> 36:25.360
because they are related to unrelated projects.

36:25.360 --> 36:26.520
So they are commutative.

36:26.520 --> 36:28.960
And so you can get sub modules for free.

36:28.960 --> 36:29.960
Signing and identity.

36:29.960 --> 36:33.080
So this is something that GIT introduced recently as well.

36:33.080 --> 36:36.720
But after we did, your identity is your public key.

36:36.720 --> 36:39.320
All patches are signed by default.

36:39.320 --> 36:45.400
And the identity changes are easy and possible because we like to welcome everyone.

36:45.400 --> 36:48.680
And people sometimes change their identity.

36:48.680 --> 36:52.480
And we don't want to let their personal life interfere with their work.

36:52.480 --> 36:54.320
You get free cherry picking.

36:54.320 --> 36:55.920
So I've said that a couple of times already.

36:55.920 --> 37:01.240
But you just apply the patch and no need to change its hash, its identity.

37:01.240 --> 37:05.720
And you can get almost free scalability to very large mono repos.

37:05.720 --> 37:06.720
So I've said that.

37:06.720 --> 37:09.560
We Goldberg machine needed.

37:09.560 --> 37:11.960
Just one cool bit of implementation.

37:11.960 --> 37:14.360
We have commutative state identifiers.

37:14.360 --> 37:22.360
So I've said earlier that we want to hash our patches to be able to make them inforgible.

37:22.360 --> 37:33.240
But we also don't want it to be just like a soup of patches and like, you know, hidden

37:33.240 --> 37:37.280
states where you cannot get your, you can get like where you don't understand anything

37:37.280 --> 37:38.280
anymore.

37:38.280 --> 37:39.920
So we do want state identifiers.

37:39.920 --> 37:41.600
It's like commit hashes.

37:41.600 --> 37:47.880
And but the thing we, the thing that's hard for us is because we want, because we, because

37:47.880 --> 37:53.440
we, the patches are commutative, we want a then B to give the same state as identifiers

37:53.440 --> 38:00.080
as B then A. And at the same time, we want these state identifiers to be fast to compute.

38:00.080 --> 38:03.200
So we want, we want, we don't want to have to like, for example, when naive, naive, naive,

38:03.200 --> 38:11.480
naive version would be like sorts all your hashes by, by hash and then hashed all of

38:11.480 --> 38:12.480
that.

38:12.480 --> 38:16.280
So that would take a time linear in the size of history, but there is a cool trick which

38:16.280 --> 38:19.120
is to use discrete log and elliptic curves.

38:19.120 --> 38:25.520
So this is where you turn each patch identity H into an integer and then you identify, you

38:25.520 --> 38:32.680
identify your states using each the part, each the product of all your hashes.

38:32.680 --> 38:38.080
And this is something you can compute very easily from a state and the next patch.

38:38.080 --> 38:42.480
So this takes a constant time to confuse and it's commutative for free.

38:42.480 --> 38:46.400
So this is, this is, this is a trick that I like.

38:46.400 --> 38:47.400
Okay.

38:47.400 --> 38:48.400
All right.

38:48.400 --> 38:51.840
Now, what's future developments in that, in that space?

38:51.840 --> 38:56.280
So we want, we're working towards a hybrid states patch system.

38:56.280 --> 39:00.480
So in, in GITS, I said that commits our states, not changes.

39:00.480 --> 39:05.920
There's like the blog posts all the time reminding us of that fact, even though patches can be

39:05.920 --> 39:08.160
applied and recomputed after the fact.

39:08.160 --> 39:11.400
Darks only has changes and recomputes states as needed.

39:11.400 --> 39:14.400
So it's completely, completely opposite approach.

39:14.400 --> 39:18.200
And Pihla's both, as I've tried to convince you.

39:18.200 --> 39:23.280
It has a data structure modeling the current states, but that data structure was not actually

39:23.280 --> 39:29.280
designed, it was found, it was, it was calculated from the nature of the patches we wanted to

39:29.280 --> 39:30.280
have on text files.

39:30.280 --> 39:32.720
And this is therefore completely transparent.

39:32.720 --> 39:34.520
So this is not a leaky abstraction.

39:34.520 --> 39:39.160
This is something that was found and calculated from the patches themselves and not just a

39:39.160 --> 39:44.280
cache that, that leaks or is like sometimes becomes irrelevant to the patches that were

39:44.280 --> 39:45.280
applied to it.

39:45.280 --> 39:46.280
All right.

39:46.640 --> 39:51.360
Ongoing projects in that direction towards a hybrid state patch system where we have

39:51.360 --> 39:58.040
tags currently, but there are a bit, there are bits of slow and, and bloated.

39:58.040 --> 40:02.880
So we want to, we're working towards a lightweight tags.

40:02.880 --> 40:07.800
And this is a feature that will add super fast history browsing in, in Pihla, while retaining

40:07.800 --> 40:10.720
all the good properties of patches.

40:10.720 --> 40:14.840
Currently tags are implemented as a semi-quill data database using compressed files as a

40:14.840 --> 40:15.840
back end.

40:15.880 --> 40:22.080
Another thing we're, we've, we've been discussing on our, Zulip is patch groups or topics or

40:22.080 --> 40:27.320
things like that to group patches together and to be able to say, well, I have just one

40:27.320 --> 40:28.320
branch.

40:28.320 --> 40:29.320
I don't want to work with branches.

40:29.320 --> 40:31.360
So I only have one branch.

40:31.360 --> 40:32.840
Maybe this is bad practice, good practice.

40:32.840 --> 40:36.240
I don't know what, I don't, I don't want to tell people what their good practices should

40:36.240 --> 40:37.240
be.

40:37.240 --> 40:39.080
Like it should be what makes them fast and efficient.

40:39.080 --> 40:40.080
That's all.

40:40.080 --> 40:44.600
So patch groups would, would allow people to group patches together to have all their

40:44.600 --> 40:49.480
patches in the, in the main branch and then push just patches related to one specific

40:49.480 --> 40:50.480
feature.

40:50.480 --> 40:55.680
So that would allow people to like be a bit more organized, for example.

40:55.680 --> 41:00.120
Someone proposed queues recently to avoid half-merged states because when, when you're

41:00.120 --> 41:06.000
merging states, patches one by one, sometimes you can get in a state that was never tested

41:06.000 --> 41:07.000
by anyone.

41:07.000 --> 41:08.680
So that's, that's not great.

41:08.680 --> 41:13.360
And so we want to add queues to get the best of both words actually to say, well, actually

41:13.360 --> 41:14.360
I've done a merge here.

41:14.360 --> 41:17.240
I've not, I've just, I've not just applied the patch.

41:17.240 --> 41:19.840
I've done, I've applied the patch together with other patches.

41:19.840 --> 41:21.680
So that's the kind of stuff we're working on.

41:21.680 --> 41:23.920
But this is not, not super, not super hard.

41:23.920 --> 41:26.680
And if you're interested in contributing, we're really welcoming.

41:26.680 --> 41:29.640
Well, we, we hope we're welcoming enough.

41:29.640 --> 41:30.640
All right.

41:30.640 --> 41:35.600
So if you want to help us, this is currently a large project and a small team.

41:35.600 --> 41:36.960
There's lots of satellite projects.

41:36.960 --> 41:40.080
So we've, we've built our own database system in order to build this.

41:40.080 --> 41:44.200
We've built our own SSH implementation in order to build this.

41:44.200 --> 41:47.000
But fortunately proper mathematics can make that work.

41:47.000 --> 41:52.000
We have way less things to implement that, that any other version control system.

41:52.000 --> 41:57.240
It's bootstrapped, meaning it's used, we've been using it for itself since 2017, which

41:57.240 --> 42:00.880
wasn't without its problems in the beginning, because some patches could only be applied

42:00.880 --> 42:03.160
if you already had the patch.

42:03.160 --> 42:09.280
So there was a interesting, interesting challenges.

42:09.280 --> 42:14.440
There's a lot of effort needed in maintaining the documentation, accessibility tutorials,

42:14.440 --> 42:18.840
UI, bike shedding, we're really demanding of that.

42:18.840 --> 42:21.960
We have good first bugs tags on our repository.

42:21.960 --> 42:26.520
Well, our repository hopefully isn't hosted on GitHub because we can't, they don't support

42:26.520 --> 42:28.240
Piholi yet.

42:28.240 --> 42:32.280
So we had to build our own forge, unfortunately.

42:32.280 --> 42:38.840
And so if you want to come help us, then yeah, good first bugs are the way to, to get started.

42:38.840 --> 42:41.720
And come say hi on our Zulip.

42:41.720 --> 42:43.840
It's the URL is here.

42:43.840 --> 42:44.960
All right.

42:44.960 --> 42:52.920
So open source version control based on algorithms and PRMs and also cool, low level stuff to

42:52.920 --> 42:59.680
optimize databases, scalable to mono repos and large files for free, potentially usable

42:59.680 --> 43:00.680
by non-coders.

43:00.680 --> 43:03.400
I've told it to absolute non-coders.

43:03.400 --> 43:10.560
I've discussed with some people in parliament, in the French parliament actually.

43:10.560 --> 43:15.000
Artists can use it without having to learn what's a rebase, without having to know whether

43:15.000 --> 43:17.880
they're in a merge shop or a rebase shop.

43:17.880 --> 43:22.600
Lawyers can use it to version their, their documents and what about others.

43:22.600 --> 43:26.960
Sonic Pi composers and music musicians, legal builders and whatnot.

43:26.960 --> 43:30.560
We have a repository hosting service available.

43:30.560 --> 43:31.560
That's it.

43:31.560 --> 43:32.560
Thank you.

43:32.560 --> 43:33.560
Okay.

43:33.560 --> 43:48.720
If you're living live quietly, we have time for like a couple of questions.

43:48.720 --> 43:50.720
Raise your hand.

43:50.720 --> 43:52.720
Okay.

43:52.720 --> 43:55.720
Quiet, please.

43:55.720 --> 43:57.720
Hi.

43:57.720 --> 44:04.800
Thank you for your talk.

44:04.800 --> 44:09.040
I had a quick question regarding diff algorithms.

44:09.040 --> 44:14.200
I think the default diff algorithm in GitHub is Meyer.

44:14.200 --> 44:17.160
There's a bunch of other ones you can select.

44:17.160 --> 44:21.320
Something I can't hear the question.

44:21.320 --> 44:23.960
Can, please.

44:24.960 --> 44:32.080
Sorry, I'll speak a bit more.

44:32.080 --> 44:34.120
My question was regarding the diff algorithms.

44:34.120 --> 44:37.680
I think in Git, the default algorithm is Meyer.

44:37.680 --> 44:40.560
There's a few other ones you can select, I believe.

44:40.560 --> 44:48.360
But something that's a bit too bad is that the diff algorithm is generic.

44:48.360 --> 44:49.880
It's only diffing text.

44:49.880 --> 44:52.080
It doesn't know what it is actually diffing.

44:52.080 --> 44:57.040
If it's a JS file or a Python file, it doesn't really care.

44:57.040 --> 45:03.040
And so, in a way, I think it could be interesting to have plug-and-play diff algorithms to have

45:03.040 --> 45:08.880
more semantic diffing based on what interpreting what you're diffing.

45:08.880 --> 45:11.400
Would that be something you're thinking about?

45:11.400 --> 45:12.400
Yeah.

45:12.400 --> 45:14.880
So the question is, can you swap?

45:14.880 --> 45:18.920
Can you replace the diff algorithm with something else?

45:18.920 --> 45:22.120
So, yes, actually you can.

45:22.120 --> 45:26.520
But unlike in Git, Git doesn't do diffs.

45:26.520 --> 45:29.880
You can do diff after the fact and change your diff algorithm after the fact.

45:29.880 --> 45:38.680
Obviously here, this won't be possible because the diff is so core to what we do.

45:38.680 --> 45:42.960
So you can definitely change the diff algorithm, but you have to do it while you're working

45:42.960 --> 45:43.960
in order to create your passion.

45:43.960 --> 45:45.160
You cannot do it after the fact.

45:45.160 --> 45:49.360
So that's a trade-off that we've made.

45:49.360 --> 45:50.360
Hi.

45:50.360 --> 45:53.720
It looks like a really interesting tool.

45:53.720 --> 45:57.840
I was going to ask how easy do you think it would be to automatically migrate from, say,

45:57.840 --> 46:04.680
an existing Git repo into a repo kind of based around this system?

46:04.680 --> 46:06.880
Well, you tell me.

46:06.880 --> 46:09.480
We have a Git importer.

46:09.480 --> 46:13.560
One pain point currently with the importer is that there's no exporter because importing

46:13.560 --> 46:19.200
and then exporting would be doing a round trip.

46:19.200 --> 46:24.440
Because diffs are ambiguous in Git, doing a round trip would create artificial conflicts.

46:24.440 --> 46:26.160
So we haven't implemented that.

46:26.160 --> 46:29.000
There are interesting challenges towards that goal.

46:29.000 --> 46:33.440
So one thing for perfect interpretability would be to have an importer and an exporter

46:33.440 --> 46:35.080
that work in a transparent way.

46:35.080 --> 46:36.840
Currently, there's only a Git importer.

46:36.840 --> 46:42.520
So if you want to convert your project into Pihl, you can use our Git importer.

46:42.840 --> 46:47.920
You cannot just work on the side using Pihl and then collaborate with the rest of your

46:47.920 --> 46:49.400
team using Git.

46:49.400 --> 46:51.200
So we'd love to have that.

46:51.200 --> 46:55.960
But there are theoretical challenges towards that goal.

46:55.960 --> 46:59.200
But yeah, how is he?

46:59.200 --> 47:00.960
I don't know.

47:00.960 --> 47:04.160
Try it and tell us if it was too hard.

47:04.160 --> 47:05.400
Hey.

47:05.400 --> 47:08.600
Thanks for the talk.

47:08.600 --> 47:12.120
I'm over here.

47:12.120 --> 47:21.920
You said that DAX can recognize it as a conflict when Alice renames a function f to g and Bob

47:21.920 --> 47:24.920
adds a call to f concurrently.

47:24.920 --> 47:28.800
How does that work?

47:28.800 --> 47:33.200
This was a little bit of exaggeration in what I said.

47:33.200 --> 47:39.560
What DAX can do is that they don't do just insertions and deletions.

47:39.560 --> 47:44.880
What they do is they have a command called DAX replace where you can replace an identifier

47:44.880 --> 47:46.680
with another one.

47:46.680 --> 47:51.720
And so they make it commutative with other operations so that they are able to detect

47:51.720 --> 47:53.160
a conflict in some cases.

47:53.160 --> 47:59.280
But I wouldn't rely on it to check for the semantics of my repository.

47:59.280 --> 48:01.120
This is just a tool.

48:01.120 --> 48:07.200
This isn't meant to solve all the problems of solving conflicts automatically or conflicts

48:07.200 --> 48:12.840
are part of a normal working process.

48:12.840 --> 48:16.640
As some say, seeing is believing.

48:16.640 --> 48:22.520
You're working on something that can be called, can be similar to a group where.

48:22.520 --> 48:31.920
So we know that someone like Douglas Engelbart provided a nice demo and showed that people

48:31.920 --> 48:33.520
actually can use that.

48:33.520 --> 48:37.800
So you're saying potentially non coders can use that.

48:37.800 --> 48:46.640
But can you or have you some demos or something that can show this actually in action and

48:46.640 --> 48:53.440
use by the non coders or do you have plans to show something like that?

48:53.440 --> 48:59.120
I don't really have a demo of non coders working something.

48:59.120 --> 49:03.440
So the non coders, the specific non coders I was thinking about when I wrote that on

49:03.440 --> 49:09.760
the slides are people doing like contracts in my company.

49:09.760 --> 49:17.160
So we're using plain text contracts for our customers to make sure that we're on the same

49:17.160 --> 49:21.640
page and so we're using version control between the sales and implementation to make sure

49:21.640 --> 49:25.120
we're not selling stuff that doesn't exist, for example.

49:25.120 --> 49:27.640
So yeah, that's that kind of stuff.

49:27.640 --> 49:32.840
But it's still very limited and we don't yet have demos, like entire demos of people

49:32.840 --> 49:36.760
working like a part of the apartment were operating entirely in Pichu because no part

49:36.760 --> 49:41.080
of the apartment has, so they've tried, they've started to look at it.

49:41.080 --> 49:43.800
But no, there's no demo of that.

49:43.800 --> 49:49.920
But yeah, we very much love to start collaborating with non coders to make it welcoming and useful

49:49.920 --> 49:51.440
and fun for them.

49:51.440 --> 49:52.920
So you think you can do that actually?

49:52.920 --> 49:54.440
Yeah, I'm pretty sure I can.

49:54.440 --> 50:01.640
I can explain the entire Pichu in just a few minutes, like the entire UI in just our CLI

50:01.640 --> 50:04.280
in just a few minutes to people who've never coded before.

50:04.280 --> 50:09.200
So yeah, apply a patch, unapply a patch, that's all you do.

50:09.200 --> 50:13.480
I thought these, I was extremely excited to see this talk.

50:13.480 --> 50:18.240
I started off very skeptical and I completely changed my opinion and I just really appreciate

50:18.240 --> 50:19.440
kind of doing that.

50:19.440 --> 50:21.720
It was a really effective talk and I'm very glad about that.

50:21.840 --> 50:28.840
I wanted to say regarding operational transforms versus the directed graph model that you have,

50:28.840 --> 50:33.840
I noticed that you had, there are boxes that you've drawn for operational transforms that

50:33.840 --> 50:38.080
seemed similar when you drew the same boxes to describe your category theory, sorry, your

50:38.080 --> 50:40.080
directed graph process.

50:40.080 --> 50:46.040
The question I wanted to ask is, could you view the vertices of the operational transform

50:46.040 --> 50:50.840
block as every vertex is the entire state of the document?

50:50.960 --> 50:56.200
I want to ask you, is it correct to say that your directed graph model instead of having

50:56.200 --> 51:00.760
each vertex be the entire state of the document, is instead individual byte ranges?

51:00.760 --> 51:07.760
So I guess would you say that this analogy to operational transforms is kind of correct

51:07.760 --> 51:12.960
in that each vertex is not the entire state and part of the reason why I would say Pjul

51:12.960 --> 51:19.960
and, sorry, I mispronounced that, Pjul and the rest of your software I think works, I

51:20.080 --> 51:24.320
think it's because it has less of a dependency on the entire state of the document.

51:24.320 --> 51:27.680
So I don't know if I explained it right, but I felt like I had a realization as all and

51:27.680 --> 51:31.560
I wanted to know whether you had, I guess, thoughts about how this directed graph model

51:31.560 --> 51:34.800
is kind of inherently easier or harder than operation.

51:34.800 --> 51:39.040
To me it makes sense why it's stronger and I just wanted to share that realization because

51:39.040 --> 51:40.720
there's less dependency on state.

51:40.720 --> 51:43.720
I wanted to know if you thought that that was a reasonable description.

51:43.720 --> 51:47.720
Yeah, this is reasonable.

51:47.720 --> 51:52.240
One comment I would have on that is the main difference with operational transforms is

51:52.240 --> 51:59.240
that you don't have, if you want to, for example, merge n batches in a sequence, in Pjul you

52:02.240 --> 52:04.760
don't have to look at pairs of batches.

52:04.760 --> 52:08.360
You can just apply one batch and then the next one and they don't have to see each other

52:08.360 --> 52:13.360
in order to, they don't modify each other when they're being applied, which is not the case

52:13.360 --> 52:14.360
in operational transforms.

52:14.360 --> 52:15.760
So that's the main difference.

52:16.200 --> 52:20.200
But I agree that it's confusing that the diagrams look similar.

52:26.040 --> 52:34.040
What is the killer feature of Pjul that will make it succeed where darks failed?

52:35.960 --> 52:36.960
Performance.

52:37.960 --> 52:46.960
Okay, speaking of performance, how much of that is attributable to the change of data

52:48.160 --> 52:55.160
structures and algorithms and how much is attributable to rewriting it in Rust or in Haskell?

52:56.600 --> 52:58.640
Most of it is algorithms.

52:58.640 --> 53:00.720
Almost 100% of it is algorithms.

53:01.040 --> 53:08.040
Sure, writing in Rust makes it faster than writing it in a garbage collected language,

53:09.800 --> 53:11.640
but this is just marginal.

53:11.640 --> 53:18.400
The main thing about Rust is that it allows you to write really low level stuff that allows

53:18.400 --> 53:20.560
you to build different kinds of algorithms.

53:20.560 --> 53:27.560
For example, Senakiria, I cannot see how this could be written in Haskell or OCaml, but

53:28.560 --> 53:30.880
it would be really, really painful.

53:30.880 --> 53:35.960
Rust makes it much easier because this is low level stuff and this is where you can get

53:35.960 --> 53:37.760
most optimizations.

53:37.760 --> 53:44.760
But yeah, performance, Pjul is, it was doubly exponentially faster than darks for mergers.

53:46.480 --> 53:52.360
So back when, like two years ago when darks had the exponential merge problem, this has

53:52.360 --> 53:53.560
been fixed since then.

53:53.560 --> 53:59.280
And we're only exponentially faster than them there.

53:59.280 --> 54:03.520
So for example, if you want to merge a patch, if you have a really large file with a really

54:03.520 --> 54:08.120
long history in Pjul and you want to apply a patch in the middle of that file, this will

54:08.120 --> 54:13.560
take a time logarithmic in the size of the file.

54:13.560 --> 54:20.080
In Git, you have to look at the entire file, do a deep pre between that file and your patch

54:20.080 --> 54:21.000
and then apply that.

54:21.000 --> 54:22.840
So it's linear in the size of the file.

54:22.840 --> 54:25.440
So we're still exponentially faster than that.

54:25.440 --> 54:31.640
Of course it doesn't matter because most files are not so crazily large that we can see the

54:31.640 --> 54:36.240
difference in the algorithmic complexity between Git and Pjul.

54:36.240 --> 54:38.840
But on really, really large files, this would matter.

54:38.840 --> 54:45.600
So what that means is, yeah, killer feature, you can scale to mono repos where darks, I've

54:45.600 --> 54:48.920
seen it fail on a paper.

54:49.240 --> 54:55.440
I've seen it take, I've seen, merged this take a really, really long time, several minutes

54:55.440 --> 55:00.000
on the mathematics paper with 10 pages of latex.

55:00.000 --> 55:06.840
And here we're like, everything works in milliseconds or less.

55:06.840 --> 55:13.400
And because of the fear, like the scalability to mono repos in large files is not done using

55:13.400 --> 55:18.600
extra hacks or extra layers or extra LFSs or extra sub modules or whatnot.

55:18.600 --> 55:22.680
They're just like a byproduct of our design.

55:22.680 --> 55:26.280
They're just, yeah, these are the killer features.

55:26.280 --> 55:28.920
I don't know if I answered the question.

55:32.440 --> 55:37.480
I get the name of Sanakya for dictionary, but why the name Pjul?

55:37.560 --> 55:45.080
Oh, this is the name of a South American bird that has the property that it lays nest.

55:45.080 --> 55:51.560
It builds a nest cooperatively in between a group of birds.

55:51.560 --> 55:57.880
And then all the females of the group lay their eggs in the same nest and they take turns to keep them warm.

55:57.880 --> 56:01.080
And so, yeah, it's just a metaphor.

56:01.080 --> 56:06.360
Okay, our time is up.

56:06.360 --> 56:08.600
And so let's thank again.

56:08.600 --> 56:11.240
Thank you.

