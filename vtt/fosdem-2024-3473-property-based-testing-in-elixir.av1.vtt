WEBVTT

05:00.000 --> 05:05.600
That's not helpful at all.

05:05.600 --> 05:08.480
Okay. Now turn from yellow,

05:08.480 --> 05:09.640
greenish to green, greenish.

05:09.640 --> 05:12.600
Okay. Okay, cool.

05:12.600 --> 05:16.160
So let's write a unit test for very simple use case

05:16.160 --> 05:19.800
in which we want to add two to number together.

05:19.800 --> 05:21.920
And it would look something like this.

05:21.920 --> 05:24.600
So we usually when I write tests,

05:24.600 --> 05:26.600
I try to come up with at least three cases.

05:26.600 --> 05:29.400
So positive one which tests the happy path,

05:29.400 --> 05:32.440
one that actually tests the opposites and then try to find

05:32.440 --> 05:36.400
or think of edge cases in which my software could actually fail.

05:36.400 --> 05:39.280
So this is such an example in which we

05:39.280 --> 05:41.160
assert that two plus two is four,

05:41.160 --> 05:43.800
that two plus two is not equal to five,

05:43.800 --> 05:46.560
and we also try to find some edge cases like if

05:46.560 --> 05:48.400
one combined types or do

05:48.400 --> 05:55.600
something other funky stuff that my software still works.

05:55.600 --> 05:59.680
So if you look at that example,

05:59.680 --> 06:02.280
you can understand why I think

06:02.280 --> 06:05.680
writing tests can be pretty boring.

06:05.680 --> 06:09.040
So that's my conclusion, testing can be boring.

06:09.040 --> 06:13.200
Then if we look at it in

06:13.200 --> 06:15.880
other aspect of writing unit tests,

06:15.880 --> 06:18.720
what if our software project grows?

06:18.720 --> 06:20.160
If we have end features,

06:20.160 --> 06:25.440
then we have some linear amount of tests accompanied to that.

06:25.440 --> 06:28.320
But what if we then start to combine features?

06:28.320 --> 06:31.520
So function A and function B,

06:31.520 --> 06:37.120
we have to test combinations like pairs of those functions as well.

06:37.120 --> 06:42.000
Then the amount of tests will grow quadratically.

06:42.000 --> 06:47.560
But then if we're going further and we combine even more features,

06:47.560 --> 06:53.040
at a certain point that growth makes it really hard

06:53.040 --> 06:56.400
to scale to write to go further.

06:56.600 --> 07:00.880
So testing I think can be hard,

07:00.880 --> 07:02.760
at least if you want to do it properly.

07:02.760 --> 07:05.520
Like if you really want to make sure that you have for

07:05.520 --> 07:11.600
confidence your code you want to have as much cases covered in those tests.

07:11.600 --> 07:14.400
If you approach it that way,

07:14.400 --> 07:16.520
then testing can be hard.

07:16.520 --> 07:19.880
So how can we fix this?

07:19.880 --> 07:24.080
Well, some people they come up with property-based testing.

07:24.080 --> 07:30.280
A summary of it is instead of us humans writing examples,

07:30.280 --> 07:37.760
let's define properties of our code and let the computer come up with cases.

07:37.760 --> 07:40.840
So that's the folks at a company called Qwik.

07:40.840 --> 07:43.640
They came up with this idea around 2000s,

07:43.640 --> 07:47.720
and they build a project and the company around those ideas.

07:47.720 --> 07:50.920
They've also added some more features to it as well.

07:50.920 --> 07:54.440
But the general idea of property-based testing is that we

07:54.440 --> 07:58.280
define properties instead of examples for our tests.

07:58.280 --> 08:03.120
So let's have a look and a comparison how we could do that.

08:03.120 --> 08:08.240
So let's say that we write a test for string reversal.

08:08.240 --> 08:11.880
So we take some string and we have a function that reverses

08:11.880 --> 08:17.680
the order of those characters and how we would unit test for such a case look like.

08:17.800 --> 08:19.400
It would be something like this.

08:19.400 --> 08:23.120
So a raise of hands, if you write test like this,

08:23.120 --> 08:31.400
who feels confident that this test are actually covering all cases of our function?

08:31.400 --> 08:35.160
No hands raised, nobody feels confident.

08:35.160 --> 08:41.040
One maybe. Yeah, everybody is like you feeling anxious, right?

08:41.040 --> 08:45.480
You're not fully convinced about this test.

08:45.600 --> 08:47.600
You could probably write it in a different way.

08:47.600 --> 08:51.640
But if you would translate these things in properties,

08:51.640 --> 08:59.480
so let's take a pause and think if you would try to express that behavior,

08:59.480 --> 09:03.760
that functionality in properties, how would you do it?

09:03.760 --> 09:08.560
Like the contest numbers, special characters and so on.

09:08.560 --> 09:13.520
You would come up with examples of special characters, numbers, these kind of things.

09:13.520 --> 09:15.760
So examples, right?

09:15.760 --> 09:20.160
Basically, examples of edge cases like weird input.

09:20.160 --> 09:26.400
But that's not how you would, for example, define your software as a property.

09:26.400 --> 09:31.040
Those are again examples, clear use cases,

09:31.040 --> 09:34.960
but they're not properties of our code, right?

09:34.960 --> 09:43.120
One property is that the length of the string in input is the same length of the string that you get out.

09:43.240 --> 09:44.280
Yeah, that's a good one.

09:44.280 --> 09:51.440
So if we reverse the string, in both cases, the length of the string should stay the same.

09:51.440 --> 09:53.440
That's the property, right?

09:53.440 --> 09:57.720
So another one, still readable.

09:57.720 --> 10:00.840
Another one would be if we reverse the string twice,

10:00.840 --> 10:04.840
then we should come back with the original one.

10:04.840 --> 10:10.280
And this is how you would write it down in a property-based test.

10:10.400 --> 10:16.000
So we define a property-reversed string twice returns the original.

10:16.000 --> 10:22.480
And we actually tell, on this second line, we tell from all the possible string inputs.

10:22.480 --> 10:27.680
So we ask the library to come up with any strings.

10:27.680 --> 10:35.040
If we reverse that string twice, it should come back with the original, right?

10:35.040 --> 10:41.360
And if we run this, then the library will generate about 100 cases for us.

10:41.360 --> 10:47.120
And in doing that, try to prove that it's property holds for our code.

10:47.120 --> 10:53.040
So other examples, if we reverse the list, then the first item becomes the last one

10:53.040 --> 10:56.400
and the last item becomes the first one.

10:56.400 --> 10:59.360
If we have a palindrome and we reverse it, it will stay the same.

10:59.360 --> 11:05.800
So palindromes are strings which, when we reverse, they return the same string as well.

11:05.800 --> 11:12.720
And like you said, the amount of items, so this applies to any kind of list or string that we're reversing.

11:12.720 --> 11:16.720
If we reverse the amount of items, it stays consistent.

11:16.720 --> 11:20.600
It's not like some things disappear magically.

11:20.600 --> 11:25.680
So if we, and the funny thing is, if we try to write a property again,

11:25.680 --> 11:29.640
so I don't know if anybody noticed, but in the previous example,

11:29.640 --> 11:34.160
I specified that I want to generate a list or generate examples of strings,

11:34.160 --> 11:37.600
but which only contain ASCII characters.

11:37.600 --> 11:42.400
But if we do the funky stuff, the funky characters part,

11:42.400 --> 11:49.760
so we say, well, generate any string from the UTF-8 set,

11:49.760 --> 11:55.360
what will actually our library tell when we run that?

11:55.400 --> 11:57.720
And then it finds an edge case.

11:57.720 --> 12:03.800
So there are unicode characters that apply to previous characters as well.

12:03.800 --> 12:08.040
So when we reverse them, you don't get back the original anymore.

12:08.040 --> 12:13.160
And these are kind of edge cases which we, as humans, probably couldn't come up with.

12:13.160 --> 12:15.880
Well, you do know that it exists,

12:15.880 --> 12:20.680
but if I ask you like now, within these five, ten minutes to actually write this example,

12:20.680 --> 12:23.640
you actually wouldn't be able to do that.

12:23.640 --> 12:28.520
And it actually, normally runs about 100 cases,

12:28.520 --> 12:31.720
but even after eight cases, it found this example.

12:31.720 --> 12:34.640
So that's great. It found an edge case.

12:34.640 --> 12:37.560
And the other thing that is not shown in the example,

12:37.560 --> 12:46.840
but if you write a property and it finds a case for which the test fail or the property fails,

12:46.840 --> 12:51.960
property-based testing tools are also able to shrink down the case.

12:51.960 --> 12:54.080
So it does a binary search.

12:54.080 --> 12:58.440
So if I have a list of numbers and our test fail,

12:58.440 --> 13:04.440
then it tries to, then it tries the half of items from that list.

13:04.440 --> 13:06.920
Sorry.

13:06.920 --> 13:12.680
And if it still fails, then it goes on and on until it finds the minimal set of input

13:12.680 --> 13:16.080
under which our property doesn't hold anymore.

13:16.080 --> 13:18.240
So let's talk about some use cases.

13:18.240 --> 13:21.200
Where has this kind of tooling been used?

13:21.200 --> 13:29.280
So Volvo, at a certain point, wanted to have third-party parts to be replaced by other companies.

13:29.280 --> 13:34.520
So they came up with specifications in which these components should interact with one another.

13:34.520 --> 13:38.520
So they wrote a specification about 3,000 pages long.

13:38.520 --> 13:44.240
They had about six vendors come in to test this, their specification,

13:44.240 --> 13:47.960
combined they had a million lines of code written.

13:47.960 --> 13:54.680
And when they used property-based testing to actually test these six vendors' implementations of the specification,

13:54.680 --> 13:57.680
they even found about 200 issues.

13:57.680 --> 14:01.960
100 of them were actually in the specification itself,

14:01.960 --> 14:05.680
and 100 of them were in the combination of those parts.

14:05.680 --> 14:08.840
Because a car consists of several parts.

14:08.840 --> 14:14.800
So it could take component A from vendor A and some other component from another vendor,

14:14.800 --> 14:18.040
and they tested components in isolation but never together.

14:18.040 --> 14:23.920
So the combination of these components actually yields some errors as well.

14:23.920 --> 14:29.760
Clana is a financial system, and at a certain point they had a problem,

14:29.760 --> 14:36.080
which occurred only once several weeks, and they had kind of a hint because

14:36.080 --> 14:43.000
it came up with when the generating files and it were over 1 gigabyte big.

14:43.000 --> 14:47.360
And they spent six weeks full time investigating this issue,

14:47.360 --> 14:49.000
and they couldn't find the source.

14:49.000 --> 14:51.400
Like they could stumble upon it, they could in some cases,

14:51.400 --> 14:58.080
trigger it, but it was actually impossible to find out how and where it came from.

14:58.080 --> 15:04.160
And it took them three days or less than three days in total to come up with a model to write the properties.

15:04.160 --> 15:11.680
Less than a day to run the properties until they actually stumbled upon race condition in which that's

15:11.720 --> 15:13.920
error occurred actually.

15:13.920 --> 15:17.960
So those are two kind of big examples.

15:17.960 --> 15:22.760
What are the other occasions in which we could actually use property based testing?

15:22.760 --> 15:27.800
One obvious one is if we have symmetrical functions, so if you serialize and deserialize something,

15:27.800 --> 15:31.600
those are opposite functions, you could easily property based test them.

15:31.600 --> 15:39.320
If you need to have some other method, if you have functionality that needs to have some kind of mathematical proof,

15:39.320 --> 15:41.040
it's good for comparing systems.

15:41.040 --> 15:45.760
So I had to, in one case, I had to rewrite the system in another language,

15:45.760 --> 15:52.120
and then it's nice to have the old system and the new system and test them against one another.

15:52.120 --> 16:01.560
And I haven't really mentioned it during this talk, but the tool that QVIC has built also has special conditions to test concurrency items.

16:01.560 --> 16:04.880
So if you have a system like the Cliana financial system,

16:04.880 --> 16:12.120
you're going to test what happens if five people do some transactions simultaneously.

16:12.120 --> 16:14.160
So conclusion.

16:14.160 --> 16:18.480
Property based testing can generate all kinds of test cases for us.

16:18.480 --> 16:29.680
Very often also edge cases that we as humans don't think about because it tries to spectrum of all inputs that you specified and find very weird items.

16:29.680 --> 16:38.120
Because of the shrinking, it also helps narrow down to diagnose what the actual culprit of the error is.

16:38.120 --> 16:40.360
It helps reduce complexity.

16:40.360 --> 16:46.480
And like I said, because you have to think about properties instead of examples,

16:46.480 --> 16:49.400
it actually makes you think differently about your tests.

16:49.400 --> 16:51.440
It makes you think more philosophically.

16:51.440 --> 16:59.080
And I think that in itself is already an advantage in learning property based testing.

16:59.080 --> 17:00.520
So I think we're out of time.

17:00.520 --> 17:04.320
So a small thank you for SliceGo.

17:04.320 --> 17:08.680
So if you think this is a nice presentation, I pulled it from their website.

17:08.680 --> 17:12.080
And I also have to contribute back and mention them.

17:12.080 --> 17:19.480
I also want to thank you all for attending this early and for listening.

17:19.480 --> 17:22.840
And for the organizers, of course, keep forgetting us.

17:22.840 --> 17:26.560
So if you think, well, this was nice introduction.

17:26.560 --> 17:28.280
It sparked my interest.

17:28.280 --> 17:30.560
How can I continue learning this?

17:30.560 --> 17:34.200
There's a good book on a website called propertesting.com.

17:34.200 --> 17:38.320
If you're not using Alexa or any of the other languages,

17:38.320 --> 17:45.640
there are also libraries in other languages like Python has hypothesis, for example.

17:45.640 --> 17:49.240
Look it up on either property based testing or generative testing.

17:49.240 --> 17:52.400
Some communities call it differently.

17:52.400 --> 17:58.120
And if you think, well, how should I think in writing properties?

17:58.120 --> 18:03.800
Then John Hughes, one of the founders of QVIC, also has a good talk in which he talks about

18:03.800 --> 18:05.360
how do you come up with these properties?

18:05.360 --> 18:08.960
How do you think in this way?

18:08.960 --> 18:13.200
So I don't know if we do have time for questions.

