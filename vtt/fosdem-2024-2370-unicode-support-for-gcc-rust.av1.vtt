WEBVTT

00:00.000 --> 00:08.360
Okay, so unique code support for GCC Rust.

00:08.360 --> 00:14.360
Okay, it's here.

00:14.360 --> 00:26.360
Sorry, wait a moment please.

00:39.360 --> 00:45.360
Okay, let me start my presentation,

00:45.360 --> 00:50.360
Unicode Support for GCC Rust frontend.

00:50.360 --> 00:53.360
And here's today's outline.

00:53.360 --> 01:00.360
First, I'll explain about my project and then how Unicode can be used in Rust.

01:00.360 --> 01:08.360
And then I'll explain about how we implement Unicode support in GCC Rust.

01:08.360 --> 01:12.360
And then I briefly explain about,

01:12.360 --> 01:18.360
introduce about two mongering schemes in Rust and then summary.

01:18.360 --> 01:23.360
So first, let me introduce a little bit about myself.

01:23.360 --> 01:25.360
My name is Raiki Tamura,

01:25.360 --> 01:29.360
and I'm an undergraduate student at Kyoto University in Japan.

01:29.360 --> 01:33.360
And I participated at Google Summer of Code 2023,

01:33.360 --> 01:38.360
and I worked with GCC organization.

01:38.360 --> 01:47.360
And other program and my main interests are compilers and low level program such as emulators.

01:47.360 --> 01:51.360
So next, I'll explain about my project.

01:51.360 --> 01:58.360
I worked on Unicode support for GCC Rust as a Google Summer of Code 2023 project last summer.

01:58.360 --> 02:11.360
And Google Summer of Code is a global online mentoring program where students work with open source organization,

02:11.360 --> 02:17.360
and they write some code and contribute to the organization.

02:17.360 --> 02:24.360
And now, I'm continuously working on supporting the new Rust manga in GCC Rust.

02:25.360 --> 02:31.360
So next, Unicode in Rust.

02:31.360 --> 02:35.360
You can use Unicode characters in Rust program,

02:35.360 --> 02:44.360
and first, you can know as key new lines and white spaces in Rust program.

02:44.360 --> 02:52.360
And next, you can create name attribute to specify the name of your Rust program

02:52.360 --> 02:58.360
and the values of this attribute accepts Unicode alphabetic and numeric characters

02:58.360 --> 03:07.360
and which includes also known as key characters such as alphabet from various languages.

03:07.360 --> 03:12.360
And last, you can use more known as key characters for identity.

03:12.360 --> 03:21.360
For example, below, you can find Germany characters and Japanese characters and Korean characters.

03:21.360 --> 03:26.360
And you can also use all varieties identifiers.

03:26.360 --> 03:33.360
Next, let's more deeply dig into Rust identifiers.

03:33.360 --> 03:42.360
Rust adapt the syntax of identifiers defining Uax31 which is a part of Unicode standard.

03:43.360 --> 03:57.360
And Uax31 is also adapted by ECMAScript, that is JavaScript, C++, Python, and other many languages.

03:57.360 --> 04:04.360
So the syntax of this Uax31 identifier are shown below,

04:04.360 --> 04:14.360
and this is something like a generalization of typical Novoski identifiers in programming languages.

04:14.360 --> 04:23.360
And in Rust, after identifiers being talked about, their normalization to special form is called normalization form C,

04:23.360 --> 04:35.360
shortly NFC, so that compiler can compare the same identifiers but with different encodings.

04:35.360 --> 04:41.360
So identifiers are normalized to some normalization form.

04:41.360 --> 04:45.360
So next, implementation.

04:45.360 --> 04:53.360
So before my project starts, there are already other front-end, GCC front-end, which supports Unicode.

04:53.360 --> 05:03.360
For example, libcpp is a C-pre-processing DCC, which implements lexer.

05:03.360 --> 05:11.360
And also, C++, as you remember, C++ adapts the same syntax of Unicode identifiers as Rust.

05:11.360 --> 05:22.360
So I took a look at it first, and next are also go front-end, go language supports Unicode,

05:22.360 --> 05:32.360
but go adapts different syntax for identifiers, so...

05:32.360 --> 05:38.360
but I read the implementation of DCC go.

05:38.360 --> 05:43.360
So my implementation is divided into three parts.

05:43.360 --> 05:47.360
First part is lexer part.

05:47.360 --> 05:56.360
In the first part, we modify the lexer to accept Unicode characters, and second part is the great-name attribute part.

05:56.360 --> 06:03.360
We added validation for values of the great-name attribute.

06:04.360 --> 06:20.360
And we checked if the values of the great-name only has Unicode alphabetical numeric characters,

06:20.360 --> 06:23.360
and last, the mangler part.

06:23.360 --> 06:29.360
We modify the mangler to handle Unicode identifiers.

06:29.360 --> 06:41.360
So the first part, the lexer part, in order to look up character properties, for example, identifiers...

06:41.360 --> 06:47.360
So we have to tell the compiler which characters can be used as identifiers,

06:47.360 --> 06:54.360
and which characters cannot be used for identifiers.

06:54.360 --> 06:59.360
So we have to tell the compiler some Unicode properties.

06:59.360 --> 07:07.360
So in order to look up such Unicode properties, we'll use some functions already in libcpp,

07:07.360 --> 07:16.360
and for other missing properties, we generated a header file from Unicode data files.

07:16.360 --> 07:24.360
Unicode data files are distributed by Unicode.org at the Unicode official site.

07:24.360 --> 07:31.360
And to achieve this, we wrote a Python script, and we pass...

07:31.360 --> 07:38.360
which passes Unicode data files and then generate C++ header files.

07:39.360 --> 07:50.360
So this is the part of the generated header file, which contains such boring table.

07:50.360 --> 07:58.360
So the next part is the great-name implementing, great-name attribute.

07:59.360 --> 08:11.360
So this is quite a simple part because all we have to do is to use a generated header file

08:11.360 --> 08:17.360
and add it to validation to the values of the identifiers.

08:22.360 --> 08:25.360
And the last part is the mangler part.

08:25.360 --> 08:32.360
First of all, we have to modify the Rust default mangler to handle Unicode characters.

08:32.360 --> 08:41.360
So the default mangler is called legacy, and legacy mangling schemes escapes non-asky characters as their code point.

08:41.360 --> 08:49.360
And also, we have to implement a new Rust mangler scheme, which is called v0.

08:49.360 --> 09:00.360
And in v0, identifiers are encoded as punicode, which is used in WebBrowser or something like that.

09:00.360 --> 09:09.360
And implementing v0.mangler to DCCRS is now still in progress.

09:11.360 --> 09:18.360
So here, I briefly explain about mangling schemes.

09:18.360 --> 09:22.360
There are two mangling schemes in Rust, legacy and v0.

09:22.360 --> 09:28.360
You can pass options to switch this mangler scheme.

09:28.360 --> 09:39.360
So in Rust C, you can use C symbol mangling version option, and in case of DCC, you can use f Rust mangling option.

09:39.360 --> 09:48.360
And v0 was introduced to Rust C on 2019, and it is used in the Rust for Linux project for some reason.

09:48.360 --> 09:50.360
I'll explain it later.

09:50.360 --> 09:57.360
So implementing v0 is so important for DCCRS project.

09:59.360 --> 10:03.360
So here, let me compare the two mangling schemes.

10:03.360 --> 10:19.360
In legacy mangling scheme, legacy symbols start with underscore z prefix, which conflict Italian ABI, which is used in C++.

10:19.360 --> 10:25.360
And v0 uses underscore r, which is unique to Rust.

10:26.360 --> 10:33.360
And next, used characters are different in legacy mangling schemes.

10:33.360 --> 10:45.360
Mangled symbol uses ASCII alphabet and ASCII number, and also uses Dara signs and period.

10:45.360 --> 10:55.360
And on the other hand, in v0, mangled symbol uses ASCII alphabet and number and underscore.

10:55.360 --> 11:07.360
So speaking of Dara signs, Dara signs are vendor-specific characters in mangled symbols.

11:08.360 --> 11:22.360
So typically, it is preferable that we avoid using these symbols.

11:22.360 --> 11:26.360
So next, type information.

11:26.360 --> 11:31.360
Basically, legacy symbols doesn't contain any type information.

11:31.360 --> 11:50.360
On the other hand, v0 has rich type information such as generic types and inherent implementation in Rust, or tried implementation in Rust, and more.

11:50.360 --> 11:59.360
And for example, these are contents namespaces like modules in Rust.

11:59.360 --> 12:14.360
And Rust, speaking of Unicode identifiers, you know, as you remember, legacy escapes Unicode characters as code points.

12:14.360 --> 12:20.360
On the other hand, v0 uses punicode to encode Unicode identifiers.

12:20.360 --> 12:26.360
So let's look at a simple example of a two-mangling scheme.

12:26.360 --> 12:40.360
If you define this function in Rust, you can see two-mangled symbols.

12:41.360 --> 12:48.360
And highlighted part is corresponding to the name of the function.

12:48.360 --> 12:54.360
And you can find Dara signs in legacy mangled scheme, which is vendor-specific characters.

12:54.360 --> 13:00.360
And you can also find a invisible symbol.

13:00.360 --> 13:05.360
You can also find a punicode encoded symbols.

13:06.360 --> 13:10.360
This is a hero part of this slide.

13:10.360 --> 13:16.360
So in summary, as a result of GSOC-223, GCCRS supports Unicode.

13:16.360 --> 13:22.360
And Rust compiler uses Unicode normalization and punicode encoding,

13:22.360 --> 13:31.360
and implementing the new-visor-mangled to GCCRS is now in progress.

13:32.360 --> 13:43.360
Thank you for free software foundation for supporting me to attend this conference.

13:43.360 --> 13:50.360
And I would like also thank to my mentors, Philippa and Arthur and other GCCRS team

13:50.360 --> 13:55.360
and another GSOC student, Mahat. And that's all. Thank you for listening.

14:02.360 --> 14:07.360
Thank you.

14:07.360 --> 14:11.360
So we have a few minutes to questions. Four minutes for questions.

14:11.360 --> 14:14.360
If people have questions.

14:19.360 --> 14:21.360
Hi.

14:21.360 --> 14:26.360
You showed the example for like the new and the old mangling.

14:26.360 --> 14:31.360
And how I can say, I can't understand how you would look at that

14:31.360 --> 14:37.360
and know if it's Unicode or if it's someone actually wrote U7 blah blah blah blah as a name of function.

14:37.360 --> 14:40.360
So how can you identify that?

14:40.360 --> 14:48.360
Oh, okay. So if I understand your question correctly,

14:48.360 --> 14:59.360
are there questions that you cannot find part corresponding to the name of function, right?

14:59.360 --> 15:08.360
Yeah, I cannot look at this and see, right, from U7 onwards, this is Unicode encoding

15:08.360 --> 15:12.360
and not something that was actually written by the user.

15:12.360 --> 15:14.360
Sorry, one more please.

15:15.360 --> 15:21.360
It's just like, imagine some user decided to write a function

15:21.360 --> 15:25.360
and they decided to call the function U7 KED blah blah blah blah.

15:25.360 --> 15:33.360
How can I tell if this encoding is saved, the user wrote that exactly, or if they used the Unicode?

15:33.360 --> 15:50.360
Okay, so your question is that you cannot tell this symbol is encoded using Unicode or low ASCII data.

15:50.360 --> 15:51.360
Oh, if it is verbating.

15:51.360 --> 15:58.360
Okay, so in visual symbol, you can find the first U character, right?

15:58.360 --> 16:13.360
So this means Unicode encoding and then you can find 7, which is a length of character string from K to H,

16:13.360 --> 16:16.360
which is an encoded part.

16:16.360 --> 16:20.360
So, yeah, thank you.

16:21.360 --> 16:23.360
One minute left for questions.

16:23.360 --> 16:33.360
Yeah, so my question is how much effort would it be for you now, after you know all this,

16:33.360 --> 16:39.360
to improve the existing lecture to also accept Unicode?

16:39.360 --> 16:45.360
Is it just 3 for things and an HR or?

16:45.360 --> 16:47.360
Are you speaking now?

16:47.360 --> 16:48.360
Current situation?

16:48.360 --> 16:55.360
Yeah, now I would add to an existing lecture the option to pass Unicode.

16:55.360 --> 16:59.360
How much work would it be?

16:59.360 --> 17:08.360
I think many developers don't use NoaSki Identifier,

17:08.360 --> 17:18.360
but what is so wide so many developers want to use NoaSki Identifier.

17:18.360 --> 17:24.360
So in terms of that, I think it is meaningful.

17:24.360 --> 17:29.360
Yeah, how much work would it be just if you edit now?

17:29.360 --> 17:30.360
Sorry?

17:30.360 --> 17:33.360
Would it take you a week or weeks?

17:33.360 --> 17:37.360
Maybe three days or so.

17:38.360 --> 17:40.360
Okay, all right.

17:40.360 --> 17:41.360
Time's up.

17:41.360 --> 17:42.360
Thank you.

