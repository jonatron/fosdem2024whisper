WEBVTT

00:00.000 --> 00:08.000
Next talk is coming up.

00:08.000 --> 00:13.000
Pudos Shreinberg does not need a lot of introduction, especially in the micro-curnal circles, but

00:13.000 --> 00:19.000
he is the author of the NOVA microhypervisor, and I believe this talk is more a state of

00:19.000 --> 00:20.000
update.

00:20.000 --> 00:21.000
The stage is yours.

00:21.000 --> 00:22.000
Thank you.

00:22.000 --> 00:24.000
Can everybody hear me fine?

00:24.000 --> 00:25.000
All right.

00:25.000 --> 00:31.000
So this talk is going to be about using the NOVA microhypervisor for trusted computing

00:31.000 --> 00:32.000
at scale.

00:32.000 --> 00:35.000
So we will talk not so much about micro-curnals or micro-hypervisors.

00:35.000 --> 00:40.000
We will talk a little bit about scaling NOVA, and we will spend the majority of the talk

00:40.000 --> 00:43.000
talking about trusted computing.

00:43.000 --> 00:48.000
So the agenda is first I am going to give you a little overview of NOVA.

00:48.000 --> 00:52.000
For those of you who have not been in the micro-curnal deaf room before, maybe a quick

00:52.000 --> 00:53.000
question.

00:53.000 --> 00:56.000
Have you ever heard of NOVA before?

00:56.000 --> 00:58.000
Maybe one-third of the people.

00:58.000 --> 01:02.000
I will explain a little bit what NOVA is and why it is a microhypervisor and not a micro-curnal.

01:02.000 --> 01:07.000
Then we look at what happened in NOVA in the last year, in 2023.

01:07.000 --> 01:12.000
The second part of the talk will be about using NOVA for trusted computing for performing

01:12.000 --> 01:16.000
what is called a measured launch to actually get some trust in the platform.

01:16.000 --> 01:20.000
At the end, hopefully we will have some time for questions.

01:20.000 --> 01:26.000
NOVA is used as the bottom piece, the screen box, the micro-curnal that is used in the

01:26.000 --> 01:33.000
Bedrock Ultravisor, which is a virtualization layer that sits underneath virtual machines.

01:33.000 --> 01:40.000
For those of you who are familiar with micro-curnals, the kernel is very small and most of the

01:40.000 --> 01:46.000
operating system functionality is implemented in a multi-server user mode, a deep privileged

01:46.000 --> 01:47.000
environment.

01:47.000 --> 01:53.000
All of these colorful boxes are actually deep privileged processes that run in user mode

01:53.000 --> 01:58.000
and they are isolated from each other and they communicate with IPC.

01:58.000 --> 02:01.000
This is what you would expect from a typical micro-curnal.

02:01.000 --> 02:07.000
The reason that NOVA is a microhypervisor is because it additionally provides a virtualization

02:07.000 --> 02:12.000
interface that allows you to reuse unmodified legacy operating systems in virtual machines.

02:12.000 --> 02:18.000
NOVA basically relays all the VM exits to those yellow virtual machine monitors, which

02:18.000 --> 02:23.000
then implement the virtualization functionality.

02:23.000 --> 02:28.000
The whole stack, all the colorful boxes are in the process of being formally verified and

02:28.000 --> 02:32.000
this is going to be important also when we talk about trust.

02:32.000 --> 02:37.000
We will not talk so much about all these boxes, we will talk primarily about NOVA, the green

02:37.000 --> 02:42.000
kernel at the bottom and a little bit about establishing the trust between NOVA and the

02:42.000 --> 02:47.000
master controller, which is sort of the inner process of the user environment.

02:47.000 --> 02:53.000
When we talk about scaling NOVA, it originally started about 20 years ago as a research project

02:53.000 --> 02:59.000
to address them and since then we have productized it to run on multiple architectures.

02:59.000 --> 03:06.000
On the left we have ARC64 which is on V8 and on the right we have X86 architecture, primarily

03:06.000 --> 03:11.000
Intel and then we run on all these platforms and more that are listed on the slide.

03:11.000 --> 03:19.000
So at the top left corner you can see a variety of arm SOCs and all the ones in yellow are

03:19.000 --> 03:27.000
actually not using standard UEFI or ACPI interfaces so they have proprietary builds, you get proprietary

03:27.000 --> 03:30.000
or board specific binaries.

03:30.000 --> 03:38.000
But for some, like the Raspberry Pi's or even AWS's Graviton Cloud servers, the same NOVA binary

03:38.000 --> 03:46.000
works all the way from small embedded devices with just a handful of cores all the way up to big cloud

03:46.000 --> 03:49.000
servers with in this case 64 cores.

03:49.000 --> 03:55.000
And we have the same on the X86 world, actually the same binary runs on all these platforms

03:55.000 --> 04:01.000
whether this atom SOCs at the top right corner or client platforms that you see up there all the way

04:01.000 --> 04:07.000
again down to the largest cloud servers with over 100 of threads.

04:07.000 --> 04:14.000
So that actually required some infrastructure changes in NOVA but before we get there,

04:14.000 --> 04:20.000
in the interest of time I'm not doing any live demos but here you can see or if you can't read it

04:20.000 --> 04:23.000
then look at the slides online.

04:23.000 --> 04:27.000
The output of NOVA boots on Raspberry Pi 4 or 5.

04:27.000 --> 04:35.000
So naturally we had an interest in making NOVA working on the Pi 5 and it just works out of the box

04:35.000 --> 04:38.000
if you use UEFI firmware.

04:38.000 --> 04:45.000
And the top line which is highlighted shows that it's actually the same build, so the same commit ID

04:45.000 --> 04:49.000
and the same build timestamp and you can see the differences in the cores.

04:49.000 --> 04:58.000
Raspberry Pi 4 uses a 72 cores and the Pi 5 uses a 76 cores.

04:58.000 --> 05:02.000
And as I said the same binary also runs in the cloud.

05:02.000 --> 05:10.000
So if you take for example an AWS C7G metal instance you can run that binary and it will enumerate 64 cores

05:10.000 --> 05:17.000
actually our Neo-verse cores and it can also drive all of the PCI devices on a platform

05:17.000 --> 05:19.000
actually in multiple PCI segment groups.

05:19.000 --> 05:21.000
So I don't want to go into the details here.

05:21.000 --> 05:29.000
The same thing on x86 where you can see on the right side, so the left side is the beginning of the log

05:29.000 --> 05:36.000
and the right side is the end of the log that we can actually run on machines with over 100 cores

05:36.000 --> 05:40.000
with hundreds of PCI devices and tons of memory.

05:40.000 --> 05:44.000
So what did we have to do to make that work?

05:44.000 --> 05:50.000
And I presented a similar thing in my talk last year, what I call an innovation timeline.

05:50.000 --> 05:56.000
We put out a new version of NOVA approximately every two months, so six releases per year.

05:56.000 --> 06:00.000
And then some releases are more packed than others.

06:00.000 --> 06:10.000
So about a year ago we added some local APIC, registered virtualization and support for Atom Sox to NOVA.

06:10.000 --> 06:17.000
But then the more interesting work happened over the course of the first two releases or the next two releases at the beginning of the year

06:17.000 --> 06:23.000
where I implemented support for Intel TXT which is trusted execution technology in NOVA.

06:23.000 --> 06:31.000
And also to make NOVA work with really large core counts, we made the current memory pool extensible.

06:31.000 --> 06:40.000
So the bootloader has the choice of giving NOVA little or very large amounts of memory depending on how much a particular platform would want to use.

06:40.000 --> 06:47.000
And then in the middle of the year there were some minor adjustments to read, copy, update and capability management

06:47.000 --> 06:53.000
that we will not talk about here today. And then at the end of last year for the Christmas release basically,

06:53.000 --> 07:01.000
the TXT work was so complete that we could actually extend the trust chain all the way to the master controller, this blue component in New Zealand.

07:01.000 --> 07:06.000
And then again for the first release of this year which is going to come out at the end of February,

07:06.000 --> 07:14.000
you actually get even more functionality for the TPM and everything that's listed in bold.

07:14.000 --> 07:19.000
So you'll be talking about in this presentation.

07:19.000 --> 07:25.000
So why do we want to do something in the area of trusted computing? What problem does that solve?

07:25.000 --> 07:31.000
And I mentioned this in the introduction that we are formally verifying the entire ultravisor stack.

07:31.000 --> 07:37.000
So once that is complete, you know that the source code that you have fulfills its specification

07:37.000 --> 07:43.000
and maybe you have a qualified compiler that compiles this verified source code into some binaries.

07:43.000 --> 07:46.000
And even if you have that, things can go wrong.

07:46.000 --> 07:52.000
The binaries can be tampered with by an attacker either during the installation process, during the boot process,

07:52.000 --> 08:00.000
or after installation and you want to know that the binaries that you built are actually the ones that are running or are being launched on a computer.

08:00.000 --> 08:10.000
So you want to know that some remote computer is actually running exactly those binaries and not some modified version.

08:10.000 --> 08:21.000
Before you give that computer some precious content like your super secret K-I algorithm or some secret data.

08:21.000 --> 08:26.000
So in order to understand what trusted computing and what a chain of trust is,

08:26.000 --> 08:31.000
we have to look at the concept of what people commonly call secure boot.

08:31.000 --> 08:35.000
And secure boot is not a very precise term. The better term is actually verified boot.

08:35.000 --> 08:42.000
And verified boot works like this, that you have some immutable root of trust in this slide showing green.

08:42.000 --> 08:48.000
And that's the initial stage and it's immutable and it's a root of trust because you cannot reason about it's correct.

08:48.000 --> 08:53.000
You have to assume it is correct and it's usually implemented in ROM which doesn't change.

08:53.000 --> 09:06.000
And then every stage like, oops, every stage measures the integrity of the next stage and verifies it against some policy.

09:06.000 --> 09:13.000
And if the verification succeeds then the next stage gets launched and if the verification fails then you fail the boot.

09:13.000 --> 09:22.000
And this is basically establishing a transitive chain of trust and the thing we care about the NOVA hypervisor is at the very end.

09:22.000 --> 09:27.000
And this chain of trust only works if everybody before gets everything right.

09:27.000 --> 09:37.000
And that's hard because there's millions of lines of code living in all these boxes and some of these boxes are actually very complicated and extensible.

09:37.000 --> 09:40.000
So the E in UEFI actually stands for extensible.

09:40.000 --> 09:47.000
And the moment you make a change in any of those components, could be you add a new PCI card or you change the order of your boot devices,

09:47.000 --> 09:49.000
it changes the measurement.

09:49.000 --> 10:00.000
So keeping your databases of permitted integrity measurements or denied measurements up to date is hard.

10:00.000 --> 10:13.000
And the industry has learned this recently when UEFI was affected by this logo fail vulnerability which basically forced every vendor to deploy a new version of their UEFI firmware

10:13.000 --> 10:18.000
and to blacklist in the DBX database the old version that they had.

10:18.000 --> 10:22.000
So it is not very flexible and it is a very brittle thing.

10:22.000 --> 10:29.000
And the screen box here in the background shows that all of this stuff actually belongs to your trusted computing base.

10:29.000 --> 10:38.000
Because if any of these components actually modifies or trashes the binary, then even though you formally verified your source code,

10:38.000 --> 10:41.000
this binary is not going to do what you want it to do.

10:41.000 --> 10:43.000
So can we do better?

10:43.000 --> 10:50.000
This is an open source conference and we are not so much interested in DRM, we are interested in freedom.

10:50.000 --> 10:56.000
So we don't want to enforce boot policies, we want to instead use a concept called measure boot.

10:56.000 --> 11:05.000
And it works very similar that a stage measures the integrity of the next stage but then doesn't take an immediate decision on whether the next stage is good or bad.

11:05.000 --> 11:15.000
Instead this measurement simply gets extended into a TPM platform configuration register which stores this value for a later attestation request.

11:15.000 --> 11:20.000
And then the next stage gets executed.

11:20.000 --> 11:31.000
And there is still the problem that certain stages like UEFI and the boot loader are extensible and that they sort of leave a very hard to manage gap in this trust chain.

11:31.000 --> 11:38.000
But there is also the problem that typically the whole boot process is not protected against DMA.

11:38.000 --> 11:46.000
So these components do not make use of an IOMU or SMMU which means even if the software is correct you could have a USB device or some FireWire device,

11:46.000 --> 11:52.000
some DMA capable device that simply DMAs into this memory and trashes the software that way.

11:52.000 --> 11:58.000
So again the trusted computing base isn't really getting any smaller.

11:59.000 --> 12:01.000
So can we do better than that?

12:01.000 --> 12:09.000
Yes, we can and this extends the concept of measured launch with a dynamic root of trust.

12:09.000 --> 12:13.000
And the core idea is that you can't really change anything in this boot chain.

12:13.000 --> 12:24.000
You still have to execute all the firmware, you still have to load all your drivers, your firmware drivers, you still have to make a boot loader like a boot choice and you still have to initialize your memory controllers.

12:24.000 --> 12:27.000
But you can do all of this in a dirty environment.

12:27.000 --> 12:35.000
So a dynamic root of trust lets the system boot into initially an untrustworthy state.

12:35.000 --> 12:45.000
So we don't really care if anything that happens to this point and only at this point we want to bring the platform into a pristine state.

12:45.000 --> 12:58.000
And this is very interesting how this works because what the effect if you do here represented by this green bolt is it is a disruptive event which feels a bit like a platform reset but it doesn't reboot the machine.

12:58.000 --> 13:02.000
It just brings the CPU into a well-defined state.

13:02.000 --> 13:07.000
It's actually a protective mode with a paging turned off and it holds all the other cores.

13:07.000 --> 13:18.000
You can see that in a moment and it forces the execution after this launch event to a code pass which has previously been measured and protected.

13:18.000 --> 13:22.000
So we don't care about all this stuff in the red box anymore.

13:22.000 --> 13:35.000
That gets eliminated from the TCB which is great because it eliminates millions of instructions and our TCB is now just this DLTM sequence plus NOVA.

13:35.000 --> 13:37.000
So what do we need for that?

13:37.000 --> 13:42.000
The technology that gives us this on Intel platforms is called Intel TXT.

13:42.000 --> 13:49.000
You may also come across the acronym CDNT which just is short for Converged Boot Guard and TXT.

13:49.000 --> 13:56.000
So Intel has fused the static root of trust which is boot guard with the dynamic root of trust which is TXT into one technology.

13:56.000 --> 13:58.000
And TXT is the one we care about.

13:58.000 --> 14:00.000
This gives us the DLTM.

14:00.000 --> 14:14.000
You need a CPU that supports this and you need a TXT capable chipset and a TPM preferably TPM 2.0 because TPM 1.2 is really old and it can only do deprecated hash algorithms.

14:14.000 --> 14:17.000
And you need an SINNET module which matches your platform.

14:17.000 --> 14:28.000
And the purpose of this SINNET module is the module that Intel provides that you can download from their website is to initialize and verify the platform in a way that it is securely configured.

14:29.000 --> 14:38.000
And once you do this you can later do a remote attestation by asking the TPM what these measurements in all the platform configuration registers are.

14:38.000 --> 14:49.000
And then you can remotely take a trust decision to say if this PCR contains some value do I recognize this value as belonging to NOVA's December release or NOVA's February release.

14:49.000 --> 14:54.000
And who knows why there is this sign of like grant here.

14:55.000 --> 15:07.000
So Intel develops all its technologies under code names and the code name for Intel TXT many years ago used to be called Lagrange technology and this is named after a city in eastern Oregon.

15:07.000 --> 15:16.000
So what happens when you do this disruptive event? How does this reset the platform without rebooting it? And it's very interesting.

15:16.000 --> 15:23.000
So first of all we have a number of processors. Here this just shows four so these are four lanes.

15:23.000 --> 15:30.000
And we have one processor which we call the initiating logical processor. That's the one which initiates the DM sequence.

15:30.000 --> 15:36.000
And we have in this case three responding processors which maybe in some arbitrary state we don't know.

15:36.000 --> 15:42.000
They could be sitting in some idle loop. They could be executing malicious code. We simply don't know what they do at this point.

15:42.000 --> 15:57.000
But we also don't care. And then some time before the disruptive launch event the code for NOVA which is in this case called MLE the measure launch environment.

15:57.000 --> 16:03.000
And this is in it ACM must have been loaded into memory and again they could have been corrupted in memory.

16:03.000 --> 16:07.000
It could be the wrong version. We don't take a decision there.

16:07.000 --> 16:14.000
And then later there can be an arbitrary amount of time that passes minutes hours. We can do this a week later. It doesn't matter.

16:14.000 --> 16:20.000
Some component is executing this DLTM which is a specific processor instruction.

16:20.000 --> 16:26.000
And what happens when you execute this processor instruction which is privileged is that everything resets.

16:26.000 --> 16:30.000
And the chipset broadcasts an S-enter cycle on the interconnect.

16:30.000 --> 16:36.000
And the S-enter cycle basically initiates all the, initializes all the processors into an S-enter sleep state.

16:36.000 --> 16:42.000
So we now know that all the other processors, all the pieces are not executing any instruction. They are sleeping.

16:42.000 --> 16:50.000
And it transitions control to this S-init ACM and it checks its integrity.

16:50.000 --> 16:55.000
So it has a signature and it has a checksum or actually a hash cryptographic hash.

16:55.000 --> 17:01.000
So the processor validates that this module is a valid Intel S-init ACM and it launches that.

17:01.000 --> 17:07.000
And this module runs entirely inside the cache. It doesn't use any memory because the memory might have been initialized wrong.

17:07.000 --> 17:12.000
The memory might have physical memory aliasing where two physical addresses point to the same page.

17:12.000 --> 17:18.000
So this operates in a very constrained environment but it is software that can validate that your platform is correct.

17:18.000 --> 17:24.000
That the processors are not overclocked. There's no undervolting.

17:24.000 --> 17:28.000
That all the chipset registers that need locking are locked and so forth.

17:28.000 --> 17:37.000
And the final thing that this thing does when it has convinced itself that the platform is in a good state is that it measures and launches NOVA.

17:37.000 --> 17:42.000
And it stores the measurement of NOVA in TPM PCR 17.

17:42.000 --> 17:47.000
And then NOVA gets control at its measured entry point.

17:47.000 --> 17:55.000
And at some point later after it has initialized enough of itself, it can wrong the rule the other processors into the secure environment.

17:55.000 --> 18:03.000
So that by the time we get to the end of this, we have now all four cores or 128 cores in this measured environment.

18:03.000 --> 18:10.000
And should anything go wrong during this process like a rogue CPU showing up that nobody knew about or a CPU leaving,

18:10.000 --> 18:19.000
surprised leaving this environment, then the platform transitions into a TXC shutdown which effectively resets the platform.

18:19.000 --> 18:32.000
So now we talk a little bit about the TPM because what we want to do is we want to measure the next stage into a platform configuration register PCR.

18:32.000 --> 18:40.000
And whenever you measure a component, what we really mean is we have a region of that component of that image that we care about that doesn't change.

18:40.000 --> 18:45.000
You can call it an immutable region which is typically the code and the read-only data.

18:45.000 --> 18:51.000
And you compute a cryptographic hash like a SHA1 or a SHA2 cryptographic hash.

18:51.000 --> 19:03.000
And you get in the case of SHA256, you get a value that is 256 bits long or a large number like that.

19:03.000 --> 19:07.000
And this measuring entity executes a command to the TPM.

19:07.000 --> 19:11.000
And the TPM is a little chip like the one shown up here that sits on your motherboard.

19:11.000 --> 19:18.000
And it has, in a typical case of a client platform, it has 24 platform configuration registers.

19:18.000 --> 19:22.000
And it invokes an operation on the TPM that's called PCR extent.

19:22.000 --> 19:29.000
And the PCR extent operation is interesting in the sense that you can't write to a PCR directly.

19:29.000 --> 19:39.000
You can only extend a new value into a PCR and what it does is it takes the existing value, concatenates it with a new value and hashes the concatenated hash.

19:39.000 --> 19:42.000
And this forms the new value of the PCR.

19:42.000 --> 19:51.000
So the sequence in which you extend values into the TPM and the values themselves are all reflected in the hash.

19:51.000 --> 19:53.000
Basically it gets mixed together.

19:53.000 --> 20:09.000
And once you look at the PCR so you can read the value, you can no longer recompute the original chain of extent operations that led to this PCR value simply because the hash function is a one-way trap function.

20:10.000 --> 20:22.000
So how would a remote verifier who can ask the TPM for a quote so you can go to the TPM and say give me the value of those PCRs that I care about and have the TPM sign that quote report so you know it's authentic.

20:22.000 --> 20:33.000
You can send that off to some other computer elsewhere and they can look at all the PCRs and say, okay, if this PCR has the value that I recognize then the platform has launched authentic software.

20:33.000 --> 20:43.000
But how do you know if multiple extent operations have happened into a PCR what the individual values are because the individual values represent the individual software components.

20:43.000 --> 20:55.000
And for that you need the left side of this picture where in addition to extending a measurement into the TPM it also gets stored in what's called a crypto agile event log.

20:55.000 --> 21:03.000
And this effectively is an auditable trace. It's a record of all the extent operations that happened.

21:03.000 --> 21:09.000
And in addition to recording which PCR and what the digest so this measurement was that was extended.

21:09.000 --> 21:20.000
There's also some event metadata that said the meaning of this extent operation is I hashed the command line or I hashed the RAM disk or whatever it may be.

21:20.000 --> 21:35.000
So you have to send both of these things both the TPM quote request and the crypto agile event log to a mode of verifier and it can correlate the two things that can use the crypto event log for a particular PCR to recompute the value in a PCR.

21:35.000 --> 21:47.000
And then you can then check if the quote from the TPM actually lists exactly that value of the TPR PCR and if it has been signed with an authentic TPM signature.

21:47.000 --> 21:53.000
And then you know what platform and what software is running on the platform.

21:53.000 --> 21:58.000
So I said the SNNIT module measures the integrity of NOVA.

21:58.000 --> 22:09.000
And NOVA is a kernel that consists it's an F image that consists of code and read only data but also of some mutable data and some heap.

22:09.000 --> 22:14.000
And not all of that thing is immutable in the sense that it doesn't change.

22:14.000 --> 22:20.000
And while some people may think it's sufficient to just do an integrity measurement at launch time.

22:20.000 --> 22:31.000
So when you boot the system that's not the full truth because you can also close the lid on your laptop which will basically shut everything down and only keep the content of memory alive.

22:31.000 --> 22:35.000
And when you resume the laptop then all your protections are gone.

22:35.000 --> 22:43.000
So on a suspended zoom cycle you actually have to repeat this integrity measurement and then this yellow section has actually changed.

22:43.000 --> 22:52.000
So not everything can be measured and how does NOVA tell the SNNIT module which region of it to measure.

22:52.000 --> 22:59.000
And there is this MLE header which enumerates the memory pages that NOVA wants to have measured.

22:59.000 --> 23:05.000
And NOVA is actually the entity that initiates the launch process.

23:05.000 --> 23:07.000
So there's no bootloader that says launch NOVA.

23:07.000 --> 23:18.000
No, NOVA gets launched in this dirty environment and then decides itself to launch its second stage and thereby tells SNNIT module what this to be measured region is.

23:18.000 --> 23:23.000
But before it actually gets measured the SNNIT module DMA protects this entire region.

23:23.000 --> 23:29.000
So the moment it gets protected no attacker can change it anymore not even visit DMA attack.

23:29.000 --> 23:36.000
Then it gets measured the measured value gets extended into TPMPCR17 and then NOVA gets launched.

23:37.000 --> 23:46.000
And there's also some TXT heap data structures that NOVA's preamble code and NOVA's post launch code used to exchange data with the TXT heap.

23:46.000 --> 23:55.000
So one of the things for example that the SNNIT module produces and stores in this TXT heap is some information about how many processes really exist.

23:55.000 --> 24:02.000
And it also stores some validated copies of ACPI tables there so that no IOM use get hidden or whatever.

24:03.000 --> 24:11.000
When you write software like that that you want to measure you have to carefully think about what should be included in the measurement versus what should be excluded.

24:11.000 --> 24:21.000
So if you measure too little then maybe something can be changed in a security relevant manner and it will not be reflected in the hash.

24:21.000 --> 24:30.000
And the thing that immediately comes to mind is let's say you have a command line parameter and NOVA has a few among them is one where you can say don't turn on the IOMU.

24:30.000 --> 24:39.000
So this is basically a chicken bit for debugging and when you execute NOVA with this command line parameter it's obviously less than fully secure.

24:39.000 --> 24:53.000
So you want that change or the configuration change to definitely be reflected in the hash that the NOVA version that runs insecurely can be told apart from the normal version which uses the IOMU with the full potential.

24:54.000 --> 25:05.000
So the command line must be included in the hash but if you have some data structures that maybe take time stamps you don't want to take them into the hash because they will change the moment that the time stamp changes.

25:05.000 --> 25:09.000
So this needs very careful considerations.

25:09.000 --> 25:19.000
And then the next question is if you have a binary like that and you've built it to the compiler, the obviously compile instruction sequences of its choice.

25:19.000 --> 25:23.000
How do you know what integrity measurement to expect?

25:23.000 --> 25:36.000
So you need some form of reference measurement and when you execute NOVA's built infrastructure and you build a binary at the end of the boot process it will output all the reference integrity measurements.

25:36.000 --> 25:48.000
So it will say the sharp one value for this binary is this and the sharp two six values is this and the sharp have 12 values is this and then you know what value to expect when you do a decision.

25:48.000 --> 25:51.000
So extending this to user mode what does it require?

25:51.000 --> 26:03.000
So it requires NOVA to compute a launch integrity measurement of the root PD which means we have to define what is the region of the master controller of this root PD to measure and we have to actually do the hashing.

26:03.000 --> 26:06.000
And for that we can do two things.

26:06.000 --> 26:17.000
We can either send the whole data over the LPC or SPI bus to the TPM and let the TPM compute the integrity measurement or we can compute it in NOVA and software using the CPU.

26:17.000 --> 26:25.000
And I originally thought that using the TPM it would be a good idea because the TPM automatically does it for all supported hash algorithms.

26:25.000 --> 26:33.000
But as you can see on the right side the TPM is really really slow and the bus that connects the TPM to the system is also very slow.

26:33.000 --> 26:43.000
So in order to hash a binary of two megabytes of size TPM actually takes almost 14 seconds and NOVA takes 50 milliseconds plus two.

26:43.000 --> 26:48.000
So the 15 are for computing the hash and the two are for extending the PCR.

26:48.000 --> 26:57.000
And then obviously NOVA needs to drive the TPM itself because it needs to send commands to the TPM and NOVA needs to append the entry to the event log.

26:57.000 --> 27:09.000
So all of that infrastructure had to be added and we actually have to measure the root PD before we launch it because we can't have a process launching some let's say malicious instruction.

27:09.000 --> 27:16.000
And then saying after I've done some malicious action I'm changing my image to look innocuous and then I'd say measure me.

27:16.000 --> 27:20.000
Then it will look correctly even though it has executed something malicious.

27:20.000 --> 27:24.000
So before you even execute the first instruction of the next module you have to measure it.

27:24.000 --> 27:29.000
So the root PD cannot tell NOVA which part of it to measure so how do we define this.

27:30.000 --> 27:41.000
And it's simple you can actually use the L headers, the program headers in the root PD and we defined it to say the first L header that is readable or executable but not writable.

27:41.000 --> 27:44.000
That's the one that contains code and read only data.

27:44.000 --> 27:46.000
That's the one that we measure.

27:46.000 --> 27:54.000
And then NOVA obviously had to learn how to compute char one and char two fifty six and char three eighty four and char five twelve.

27:54.000 --> 27:58.000
And basically the entire NISP FIPS one hundred eighty standard.

27:59.000 --> 28:13.000
And that looked like very complicated but due to the beauty of C++ templates and function overloading and inheritance the implementation of all these hash functions and NOVA is actually just one hundred thirty lines.

28:13.000 --> 28:16.000
And it can do all of these algorithms.

28:17.000 --> 28:21.000
So that brings me to almost the end of my talk.

28:21.000 --> 28:25.000
The last thing we had to add to NOVA late last year was support for the TPM.

28:25.000 --> 28:28.000
And the TPM has two interfaces.

28:28.000 --> 28:38.000
The older interface is the FIFO interface and there is a newer command response buffer interface and NOVA had to understand how to drive those that adds another two hundred fifty lines of code.

28:38.000 --> 28:44.000
And then you have to send commands across that interface and the TPM library specification is very large.

28:44.000 --> 28:54.000
It's thousands of pages but NOVA only implements the subset of TPM commands that it needs for this measured launch which is determining what capabilities it needs.

28:55.000 --> 29:01.000
And then you have to understand how many TPM has and how many PCRs and what algorithms and then performing some PCR operations.

29:01.000 --> 29:04.000
And that adds about another five hundred lines of code.

29:04.000 --> 29:09.000
But for both the old TPM one or two and the newer TPM two dot oh.

29:09.000 --> 29:15.000
And then there is a table that lists how the TPM actually gets used by various parts of the platform.

29:15.000 --> 29:18.000
The TPM has different localities.

29:18.000 --> 29:30.000
And locality four which belongs to the core root of transform measurement actually measures the next stage which is NOVA into PCR 17 and then NOVA which drives the TPM at locality three measures.

29:30.000 --> 29:43.000
No, the SNET ACM measures NOVA also into PCR 17 and then NOVA measures the next stage which is the master controller into PCR 19 and then the root PD measures the next component further up stack into PCR 20.

29:44.000 --> 29:50.000
So this is the list of all the cool security technologies that we have in NOVA now.

29:50.000 --> 30:01.000
Ranging from control flow enforcement, total memory encryption with multiple keys and the latest thing we added which we just discussed is trusted execution technology and adaptation.

30:01.000 --> 30:05.000
So with that thank you for listening and I'm happy to take questions.

30:13.000 --> 30:16.000
you

