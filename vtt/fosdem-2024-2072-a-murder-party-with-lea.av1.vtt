WEBVTT

00:00.000 --> 00:12.920
Okay, so now we can start.

00:12.920 --> 00:18.000
Thank you very much for coming to the Python Dev Room and getting up early on Sunday morning

00:18.000 --> 00:20.640
with this cool weather outside.

00:20.640 --> 00:26.280
So now we are going to have a very, very nice talk by Pierre Denis, who is a long-time

00:26.280 --> 00:27.280
Python user.

00:27.280 --> 00:31.280
He's also the creator of Liya, and he's going to talk about Liya in this talk.

00:31.280 --> 00:37.560
Liya is a Python module for helping to calculate probabilities on situations presenting uncertainties.

00:37.560 --> 00:40.360
And what that means, I hope he's going to explain to us now.

00:40.360 --> 00:42.640
Thank you.

00:42.640 --> 00:44.480
So welcome everybody.

00:44.480 --> 00:51.240
So we are here about something serious, a sad story.

00:51.240 --> 00:53.280
I'm not a good storyteller.

00:53.280 --> 00:58.880
I'm afraid, but okay, Dr. Black has been killed last night.

00:58.880 --> 01:02.160
Maybe you have heard about that.

01:02.160 --> 01:13.400
And okay, we have three suspects that have been identified with given probability to

01:13.400 --> 01:14.480
be the killer.

01:14.480 --> 01:21.640
And it seems that colonel Mustard is the most likely, is most likely the killer with 40%

01:21.640 --> 01:23.840
to be the killer.

01:23.840 --> 01:27.080
Then we have Mrs. Peacock, 25%.

01:27.080 --> 01:31.840
Mrs. White, 10%, and Professor Plum, 25%.

01:31.840 --> 01:41.720
Okay, then these are prior probabilities, but we have the help of a profiler, a segment,

01:41.720 --> 01:44.200
the profiler.

01:44.200 --> 01:46.240
This guy is very smart.

01:46.240 --> 01:53.960
And he can tell, for example, that if Mrs. White is the killer, she'll be absent for

01:53.960 --> 01:58.080
the investigation with 95%.

01:58.080 --> 02:06.200
Otherwise, if she's innocent, she'll be absent with only a probability of 20%.

02:06.200 --> 02:12.880
And the profiler tells you several statements like this with probabilities.

02:12.880 --> 02:20.560
So when you see this kind of situation, you see, okay, it's quite complex.

02:20.560 --> 02:23.520
How can I use this information?

02:23.520 --> 02:26.720
Because nothing is certain.

02:26.720 --> 02:29.960
Okay.

02:29.960 --> 02:34.440
So the investigator is Leah.

02:34.440 --> 02:39.360
Here, Leah is not a person, as you have understood.

02:39.360 --> 02:43.800
It's a module dedicated to probabilities.

02:43.800 --> 02:46.520
So okay, I have several statements here.

02:46.520 --> 02:53.880
In other presentation, I elaborate on this, but this time I prefer to show you Leah in

02:53.880 --> 03:00.360
action so you can better understand what it is about.

03:00.360 --> 03:08.720
My claim is that Leah is something quite easy to use, quite intuitive.

03:08.720 --> 03:17.600
You know probably that there are several packages dedicated to probability or statistics.

03:17.600 --> 03:26.720
The core feature of Leah is to be easy to understand and probably well suited for education.

03:26.720 --> 03:29.480
Okay.

03:29.480 --> 03:30.480
Let's start.

03:30.480 --> 03:37.840
First, I import Leah, which is here in version 401B.

03:37.840 --> 03:45.240
Anyway, so first of all, I want to define a fair coin with head and tail.

03:45.240 --> 03:48.120
I do that.

03:48.120 --> 03:51.520
So Leah can work with any Python object here.

03:51.520 --> 03:58.320
I define probabilities on strings, but you can define probabilities on numbers on any

03:58.320 --> 04:00.080
Python object.

04:00.080 --> 04:02.360
Okay.

04:02.360 --> 04:09.760
Here for education, I prefer to switch to fractions.

04:09.760 --> 04:17.920
You know that Python has fraction included.

04:17.920 --> 04:21.360
So I've switched the display to have fractions.

04:21.360 --> 04:31.720
So if I want to create a biased coin, I can define several values and here it means that

04:31.720 --> 04:37.680
tails will be three times likely to go that then head.

04:37.680 --> 04:42.240
So I have a new probability distribution.

04:42.240 --> 04:47.640
So what I'm doing here is a crash course on Leah because we want to be acquainted to it

04:47.640 --> 04:52.040
before doing the investigation.

04:52.040 --> 05:04.640
I can also use a probability mass function to define probability in a fraction.

05:04.640 --> 05:12.640
So Matplutlib is integrated so you can display your histogram about any probability distribution.

05:12.640 --> 05:13.960
Okay.

05:13.960 --> 05:17.760
So I want to make 100 throws.

05:17.760 --> 05:29.560
So I use my B coin variable, my probability distribution to calculate to make 100 random

05:29.560 --> 05:33.800
coins, throws.

05:33.800 --> 05:43.720
So you see in this random throws that there is more tail than head.

05:43.720 --> 05:50.440
But okay, how can I be sure that it follows the probability that I given?

05:50.440 --> 05:54.520
Simply you can use Leah, the same function as before, Leah, VALS.

05:54.520 --> 06:03.600
You provide the values and this time it will use the random sample as it will be a frequency

06:03.600 --> 06:11.280
counter and you see that here more or less it conforms to the probability distribution

06:11.280 --> 06:14.560
that I provided for the biased coin.

06:14.560 --> 06:22.640
So what is interesting on this kind of object is that you can use many of what you do usually

06:22.640 --> 06:24.040
on your Python object.

06:24.040 --> 06:27.000
For example, you can index.

06:27.000 --> 06:33.120
If I ask for zero, it will take the first letter, head or tail, H or T.

06:33.120 --> 06:41.360
I can chain with the Python lower method and I have lower case H or T.

06:41.360 --> 06:45.400
I can map Python function here.

06:45.400 --> 06:50.880
This means that it count the number of characters which is four, head and tail, four characters

06:50.880 --> 06:51.880
each.

06:51.880 --> 06:56.040
So we have a certain four.

06:56.040 --> 07:01.200
And as you could expect also, all the operators are overloaded.

07:01.200 --> 07:11.800
So if I concatenate my distribution B coin with fixed string, I have a new distribution

07:11.800 --> 07:17.200
that follows what has been defined.

07:17.200 --> 07:21.160
Okay and here it's something a bit funny.

07:21.160 --> 07:25.440
What happens if you multiply a dice with a coin?

07:25.440 --> 07:27.680
You get that.

07:27.680 --> 07:31.280
Okay.

07:31.280 --> 07:33.160
Let's now throw two coins.

07:33.160 --> 07:38.720
So the new method allows you to define new event with the same probability.

07:38.720 --> 07:45.240
Here I define two coins which are biased together.

07:45.240 --> 07:53.880
If I add them together, I have all the combination possible with associated probabilities.

07:53.880 --> 07:56.600
So we will see that this is very important.

07:56.600 --> 08:03.480
We are able to calculate conditional probability with the given method.

08:03.480 --> 08:10.600
So here I try to see, okay, assuming that I know that the first coin is tail, what

08:10.600 --> 08:13.280
is the combination of the two coins?

08:13.280 --> 08:22.160
So here we see that the previous result has been filtered out to get just the two remaining

08:22.160 --> 08:24.000
possibilities.

08:24.000 --> 08:31.720
So it's a common feature of LIA is that when you define variable, there is a kind of lazy

08:31.720 --> 08:32.720
evaluation.

08:32.720 --> 08:39.600
They remain linked together in a network that define the relationship, the dependencies

08:39.600 --> 08:43.720
between the random variables.

08:43.720 --> 08:45.520
Okay.

08:45.520 --> 08:53.560
And you can also define Boolean events like, okay, what is the probability to be?

08:53.560 --> 08:57.600
I define it at 140 seconds.

08:57.600 --> 09:03.760
And then I can use operator like to be or not to be.

09:03.760 --> 09:11.160
And the result is it's true, it's certain true.

09:11.160 --> 09:16.320
Because okay, to be it's either true or false and not to be it's the contrary.

09:16.320 --> 09:20.000
So together it's certainly true.

09:20.000 --> 09:23.240
Okay.

09:23.240 --> 09:30.800
And there is also a dedicated function in LIA which is P. So you can extract the probability

09:30.800 --> 09:31.800
of true.

09:31.800 --> 09:36.760
So you get really a real probability like this.

09:36.760 --> 09:37.760
Okay.

09:37.760 --> 09:40.280
Let's go on.

09:40.280 --> 09:48.800
So here it's an excerpt of a book that it's three centuries old from Abraham de Moivre.

09:48.800 --> 09:59.400
It's probably one of the first problem solved by de Moivre here.

09:59.400 --> 10:00.400
Okay.

10:00.400 --> 10:10.400
Let's ask to find the probability of throwing a nace in three throws given a fair dive.

10:10.400 --> 10:12.440
This is how to calculate in LIA.

10:12.440 --> 10:17.200
So here I define a dive.

10:17.200 --> 10:24.400
I create three instances which are independent, which are assigned to the 1, 2, 3.

10:24.400 --> 10:31.120
And then I ask for the probability of any of one of these dives is a nace.

10:31.120 --> 10:41.240
The result is 91, 216th as calculated three centuries ago by de Moivre.

10:41.240 --> 10:43.200
So far so good.

10:43.200 --> 10:44.200
Okay.

10:44.200 --> 10:49.360
No, I don't know if you like playing a role-playing game.

10:49.360 --> 10:54.240
So there's a small example that where you can use LIA.

10:54.240 --> 10:59.800
So imagine that you have here this dwarf which fights against a troll.

10:59.800 --> 11:00.960
Okay.

11:00.960 --> 11:08.680
I first define a new kind of display with percentage because it's more convenient here.

11:08.680 --> 11:13.160
I define two different kind of dice.

11:13.160 --> 11:14.160
Okay.

11:14.160 --> 11:20.800
Imagine that your attack hole is d25 plus 4.

11:20.800 --> 11:21.800
Okay.

11:21.800 --> 11:26.920
What is the probability to ever hit?

11:26.920 --> 11:32.120
You see, okay, it's easy to calculate with inequality.

11:32.120 --> 11:36.880
So you have to be greater or equal that the troll armor class.

11:36.880 --> 11:40.040
You get this probability.

11:40.040 --> 11:45.920
So the damage of the magic axe is to d6 plus 5.

11:45.920 --> 11:48.240
Here is the result.

11:48.240 --> 11:57.240
But this damage is only applied if the dwarf can hit the troll.

11:57.240 --> 12:03.560
So for that we have a special construction, LIA if underscore underscore to avoid collision

12:03.560 --> 12:06.920
with the Python if.

12:06.920 --> 12:13.800
And okay, this means if there is a hit, then I apply the magic axe.

12:13.800 --> 12:16.880
Otherwise, the damage is zero.

12:16.880 --> 12:19.120
And here is the new histogram.

12:19.120 --> 12:25.600
So this is the probability, the actual damage that is done to the troll.

12:25.600 --> 12:32.560
And then from this data you can answer the, okay, assuming that the troll has 20 health

12:32.560 --> 12:39.400
points remaining was the probability to kill him in four rounds or less.

12:39.400 --> 12:44.560
You see it's deadly simple with this formula to calculate.

12:45.000 --> 12:49.160
We find it's 40%, something like that.

12:49.160 --> 12:50.160
Okay.

12:50.160 --> 12:51.160
Okay.

12:51.160 --> 12:55.360
You follow?

12:55.360 --> 12:59.520
So I will, I have many, many, many examples.

12:59.520 --> 13:06.000
But by lack of time I will drop maybe some of these examples.

13:06.000 --> 13:12.240
Boys or girls paradox, something very funny also that you can find on Wikipedia.

13:12.240 --> 13:14.760
So the chance to be a boy or girl are even.

13:14.760 --> 13:20.000
So okay, boy, one half, girl, one half.

13:20.000 --> 13:24.480
Mr Smith asked two children, at least one of them is a boy.

13:24.480 --> 13:28.520
What is the probability that both children are boys?

13:28.520 --> 13:34.840
Many people and including myself, the first time I heard this I think, okay, the information

13:34.840 --> 13:36.800
give me no clues.

13:36.800 --> 13:38.720
It's one half.

13:38.720 --> 13:45.080
But if you calculate like this with Leah, so you define children as two, a joint of

13:45.080 --> 13:56.560
two children and that you count the number of boys, calculate the conditional probability,

13:56.560 --> 14:00.720
the answer is one third actually.

14:00.720 --> 14:07.120
And what is interesting with Leah, you can understand why this is the answer by asking

14:07.120 --> 14:10.360
Leah to show you all the combinations.

14:10.360 --> 14:18.720
So here I show you the gender of all the children, the number of boys and given that

14:18.720 --> 14:22.640
the number of boys is greater or equal to one.

14:22.640 --> 14:27.920
And we see here the answer is here and we understand better why it is one third.

14:27.920 --> 14:28.920
Okay.

14:28.920 --> 14:33.680
It's a bit fast but you can do it at your own pace later.

14:33.680 --> 14:35.080
Okay.

14:35.080 --> 14:42.640
What happens if you have more elaborate problem?

14:42.640 --> 14:45.320
Like here we have several children.

14:45.320 --> 14:49.120
The eldest is a boy and he's got three brothers at least.

14:49.120 --> 14:52.800
What is the probability that all children are boys?

14:52.800 --> 14:54.040
Okay.

14:54.040 --> 14:56.440
You can model this like this.

14:56.440 --> 15:00.160
Here I create seven children.

15:00.160 --> 15:09.280
And I put, so you see when you read this expression, it's quite close to the initial problem.

15:09.280 --> 15:15.440
Of course you have to understand the elements of Leah to do that but after that it's quite

15:15.440 --> 15:16.760
easy to model.

15:16.760 --> 15:19.760
The answer is one forty second.

15:19.760 --> 15:29.640
Again it's possible to ask why it is so and here by joining you see that's okay, seven

15:29.640 --> 15:33.280
children is this part and the other are this.

15:33.280 --> 15:36.520
So you can better understand why it is so.

15:36.520 --> 15:37.520
Okay.

15:37.520 --> 15:42.400
I will drop this Monte Hall problem which is well known.

15:42.400 --> 15:47.240
You can read that after the session offline.

15:47.240 --> 15:48.240
Okay.

15:48.240 --> 15:51.320
Let's go back to the initial problem.

15:51.320 --> 15:54.160
So okay.

15:54.160 --> 15:58.000
First I change the display options.

15:58.000 --> 16:05.240
So the, first we define the pure probabilities like that.

16:05.240 --> 16:10.760
So here I ask Leah to display the probability in one line because it's more convenient in

16:10.760 --> 16:13.240
this case and as a percentage.

16:13.240 --> 16:14.240
Okay.

16:14.240 --> 16:19.640
So we have like this and we see, okay, colon and mustard.

16:19.640 --> 16:26.360
Our priority is the killer, the most likely the killer.

16:27.360 --> 16:28.360
Okay.

16:28.360 --> 16:34.720
Let's now try to write down the different information we have.

16:34.720 --> 16:38.440
So if Mrs. White is the killer she'll be absent with probability ninety percent.

16:38.440 --> 16:40.800
So I define here a variable.

16:40.800 --> 16:45.280
Mrs. White is absent using the if as we've seen before.

16:45.280 --> 16:53.440
I put the condition if the killer is Mrs. White then she'll be absent with ninety five

16:53.440 --> 16:58.040
percent else twenty five, twenty percent.

16:58.040 --> 16:59.040
Sorry.

16:59.040 --> 17:00.040
Okay.

17:00.040 --> 17:04.520
This is the percentage that Mrs. White is absent.

17:04.520 --> 17:09.040
But it's not very interesting because we, we, we are more interested about who is the

17:09.040 --> 17:12.920
killer but we will see what will happen later.

17:12.920 --> 17:21.320
And then we can continue and define other rules like this.

17:21.320 --> 17:27.360
If Mrs. Peacock is innocent she knows who's the killer with probability seventy five percent.

17:27.360 --> 17:33.680
So you see here there is a missing information which is the else part but we assume that

17:33.680 --> 17:43.440
Mrs. Peacock is not insane and if she's the killer then she knows who's the killer hopefully.

17:43.440 --> 17:47.040
So I put here the else part as one hundred percent.

17:47.280 --> 17:48.280
Okay.

17:48.280 --> 17:53.480
And then we can elaborate on more complex information like this one.

17:53.480 --> 17:54.480
Okay.

17:54.480 --> 18:00.760
I will not detail but you see again it's quite, when you see the statement, the

18:00.760 --> 18:06.080
tradition in LIA it's quite straightforward.

18:06.080 --> 18:07.400
And the last one is here.

18:07.400 --> 18:14.080
So what have we done here is to define what we call the Bayesian network which put the

18:14.080 --> 18:17.840
relation between different random variables.

18:17.840 --> 18:25.480
What is interesting with this kind of network is that if you get evidence about something

18:25.480 --> 18:33.640
you can go backwards and refine the probability to be the killer.

18:33.640 --> 18:38.320
So for that, okay, I define a list of evidence here.

18:38.320 --> 18:46.440
So first of all it's empty and the conditional probability is the same as before because

18:46.440 --> 18:47.840
I have no new evidence.

18:47.840 --> 18:52.560
So imagine now that Mrs. White is absent.

18:52.560 --> 18:57.880
I can add it to the evidence and define a new conditional probability.

18:57.880 --> 19:01.520
So you see it change a bit.

19:01.520 --> 19:04.720
Evidence two added to the previous one.

19:04.720 --> 19:06.440
Mrs. Peacock is drunk.

19:06.560 --> 19:07.560
Okay.

19:07.560 --> 19:13.400
I add this information and I get new probability and so on.

19:13.400 --> 19:17.400
Professor Plum accuses Colin and Mustard.

19:17.400 --> 19:22.320
And finally we know that the killer is a woman.

19:22.320 --> 19:28.120
So for that I use here the Python start with Mrs.

19:28.120 --> 19:36.000
because it's a handy way to say given the suspects that the killer is a woman, I add

19:36.080 --> 19:45.640
it to the evidence like that and you see, okay, there is a new probability.

19:45.640 --> 19:50.480
So there are just two suspects remaining, two women and Mrs.

19:50.480 --> 19:55.120
White is likely the killer.

19:55.120 --> 19:56.120
Okay.

19:56.760 --> 20:01.760
Yeah.

20:01.760 --> 20:10.280
Maybe you can consider this as a game but sometimes probability can play a very important

20:10.280 --> 20:12.400
role in some trials.

20:12.400 --> 20:15.200
So long time ago there was the Dreyfus Affair.

20:15.200 --> 20:24.400
There was a big flow of a so-called expert that makes a mistake in this affair.

20:24.400 --> 20:31.720
And also more recently, Selik Larch case where also there is a bad reasoning about probability.

20:31.720 --> 20:33.120
Okay.

20:33.120 --> 20:38.320
So I want to mention also that Leah is able to do symbolic calculation.

20:38.320 --> 20:47.400
So by using the SIMPY module that maybe you know, so it's very easy.

20:47.400 --> 20:50.600
It's the same interface.

20:50.600 --> 20:58.560
So instead of number you put variable name between quotes like this and you have probability

20:58.560 --> 21:01.320
defined with formula.

21:01.320 --> 21:08.280
So you can redo all the same exercise and you will get formulas to be the killer, etc.

21:08.280 --> 21:09.960
So a small example here.

21:09.960 --> 21:10.960
Okay.

21:10.960 --> 21:12.800
I don't detail here.

21:13.800 --> 21:27.080
It's a binomial function here with P and here I calculate a conditional probability

21:27.080 --> 21:30.760
and it displays me a nice formula.

21:30.760 --> 21:35.800
So you can check offline if you want that it is correct.

21:35.800 --> 21:36.960
Okay.

21:36.960 --> 21:47.520
I want just to finish about my bullshit generator which was made 15 years ago.

21:47.520 --> 21:56.920
So here the goal is to produce sentences at random based on a list of words and a list

21:56.920 --> 22:01.360
of grammar rules like this.

22:01.360 --> 22:10.080
Then you see that I put here a probability on each grammar rule so that the most simple

22:10.080 --> 22:20.120
rule are used preferably to avoid to get to long sentences.

22:20.120 --> 22:21.120
So yeah.

22:21.120 --> 22:22.120
Okay.

22:22.120 --> 22:30.600
I get...

22:30.600 --> 22:32.000
So it has produced...

22:32.000 --> 22:36.600
I don't know why it's...

22:36.600 --> 22:40.960
Okay.

22:40.960 --> 22:48.600
So maybe I don't know what happens but...

22:48.600 --> 22:53.840
Okay.

22:53.840 --> 22:57.200
I restart my kernel.

22:58.200 --> 23:08.200
Normally it's supposed to speak and to write down sentences but...

23:08.200 --> 23:11.680
Okay.

23:11.680 --> 23:17.280
Anyway.

23:17.280 --> 23:20.400
You can play that also.

23:20.400 --> 23:27.600
The Python code is really small so you can try it at yourself.

23:28.600 --> 23:30.600
Oh yeah.

23:30.600 --> 23:31.600
Okay.

23:31.600 --> 23:39.600
Of course I didn't import LIA.

23:39.600 --> 23:45.600
Okay.

23:45.600 --> 23:53.960
That's it.

23:53.960 --> 24:02.240
But anyway, sorry for the small interruptions but I think we don't have time for questions

24:02.240 --> 24:03.240
or...

24:03.240 --> 24:04.240
Maybe one question.

24:04.240 --> 24:05.240
Maybe one question.

24:05.240 --> 24:06.240
Okay.

24:06.240 --> 24:19.560
Thank you for the presentation.

24:19.560 --> 24:22.800
I have indeed one question which is about performance.

24:22.800 --> 24:29.320
So do you have information about performance, your libraries compared to other libraries

24:29.320 --> 24:32.440
or yeah, what are your insights on that?

24:32.440 --> 24:33.440
Yeah.

24:33.440 --> 24:34.440
It's a good question.

24:34.440 --> 24:35.440
So okay.

24:35.440 --> 24:40.600
It's not really the concern.

24:40.600 --> 24:45.120
So here as you have seen the results are exact.

24:45.120 --> 24:46.120
So okay.

24:46.120 --> 24:49.680
As you have seen also it's quite fast.

24:49.680 --> 24:51.800
So there are several optimizations.

24:51.800 --> 24:55.480
I have no figures but okay.

24:55.480 --> 25:02.320
As you expect there are many problems which are very complex and for that LIA provides

25:02.320 --> 25:12.120
Monte Carlo several Monte Carlo algorithm that gives approximate results in a fair time.

25:12.120 --> 25:13.120
Yeah.

25:13.120 --> 25:16.160
But I have no figures.

25:16.160 --> 25:17.160
Yeah.

25:17.160 --> 25:18.160
Okay.

25:18.160 --> 25:19.160
Thank you.

25:19.160 --> 25:20.160
Thank you very much.

25:20.160 --> 25:20.660
Thank you very much.

