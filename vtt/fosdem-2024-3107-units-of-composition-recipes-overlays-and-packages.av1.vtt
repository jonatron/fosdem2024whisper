WEBVTT

00:00.000 --> 00:13.000
No, just rock and roll.

00:13.000 --> 00:16.000
All right, test, test.

00:16.000 --> 00:18.000
All right.

00:18.000 --> 00:22.000
Welcome to FOSDEM 2024, Nick's Dev Room.

00:22.000 --> 00:29.000
So I might have been a little bit early.

00:29.000 --> 00:34.000
Everyone's still kind of trickling in from the real hard parting last night, so that's fine.

00:34.000 --> 00:39.000
All right, I was just going to get started and kind of take it away.

00:39.000 --> 00:42.000
So my name's Tom, Tom Burrick.

00:42.000 --> 00:44.000
I work at a place called Flock's.

00:44.000 --> 00:46.000
I work on a bunch of things called Knicks.

00:46.000 --> 00:51.000
And I want to talk today about the different kind of units of composition we have in the Knicks ecosystem.

00:51.000 --> 00:57.000
Some ideas about what it is that we could maybe do to improve some of these things and just some issues.

00:57.000 --> 01:04.000
And also just a little bit of explanation of some of these units of composition that are maybe less or known or hard to understand.

01:04.000 --> 01:09.000
And maybe just start some conversations about it.

01:09.000 --> 01:15.000
All right, so I'll go over kind of a few ideas, trying to present a concept, figure out like, yeah, what is this thing?

01:15.000 --> 01:16.000
Why we care about it?

01:16.000 --> 01:18.000
What are some of the problems we have?

01:18.000 --> 01:20.000
I have some proposals, maybe some examples.

01:20.000 --> 01:24.000
And hopefully along the way we learn something and come up with some ideas.

01:24.000 --> 01:28.000
As a disclaimer, a little bit of Knicks understanding is expected here.

01:28.000 --> 01:34.000
But if you got here at 9 a.m., I assume that's not a horrible thought.

01:34.000 --> 01:39.000
All right, so basically here's where the experience might come in.

01:39.000 --> 01:41.000
Hey, like what do we call this thing?

01:41.000 --> 01:42.000
Feel free to kind of shout out.

01:42.000 --> 01:45.000
Like what is this thing we're looking at right here?

01:45.000 --> 01:47.000
A package.

01:47.000 --> 01:49.000
A package, a function.

01:49.000 --> 01:51.000
What else?

01:51.000 --> 01:53.000
A derivation.

01:53.000 --> 01:54.000
What else?

01:54.000 --> 01:55.000
Sorry?

01:55.000 --> 01:56.000
An expression.

01:56.000 --> 02:01.000
Okay, so that's a problem.

02:01.000 --> 02:07.000
This is used everywhere, and I just got how many different names for what this thing is.

02:07.000 --> 02:11.000
Right, this is something we don't, I think this is an issue.

02:11.000 --> 02:16.000
So all these names we used are not quite right, we don't know what it is.

02:16.000 --> 02:20.000
So the main idea is like, one I'm going to explain how this thing works, why it works,

02:20.000 --> 02:23.000
why it is the way it is, and then be like, hey, let's actually name this thing.

02:23.000 --> 02:25.000
Let's make this a first class concept.

02:25.000 --> 02:28.000
Let's somehow make this thing a bit more core to the system,

02:28.000 --> 02:32.000
rather than getting seven different answers for what this thing is.

02:32.000 --> 02:36.000
All right, so we have some whole bunch of issues,

02:36.000 --> 02:39.000
tried to reference some of these things, but like, hey, we tried to define what this is.

02:39.000 --> 02:45.000
But we just used package, I don't know, four or five times in the definition of what a package is.

02:45.000 --> 02:48.000
I don't think this is going to work too well.

02:48.000 --> 02:51.000
Right, that might be a problem.

02:51.000 --> 02:57.000
We have another example of Robert Hensing having an idea of let's formally define what a package is

02:57.000 --> 03:02.000
and make kind of NICS understand this, because it's funny, we don't really have a formal definition of what a package is,

03:02.000 --> 03:05.000
yet we often call NICS a package manager.

03:05.000 --> 03:06.000
Well, is it a package?

03:06.000 --> 03:08.000
It's a little bit confusing.

03:08.000 --> 03:12.000
So he's got some ideas on that, which I really like the progress on that.

03:12.000 --> 03:15.000
There's another issue that came from John Erickson.

03:15.000 --> 03:18.000
I also really like this one, like, what are these functions?

03:18.000 --> 03:25.000
We call package on them, but saying this is a call packageable function just doesn't roll off the tongue very well.

03:25.000 --> 03:31.000
And also, like, this also has issues with when you're trying to do things like cross-compilation

03:31.000 --> 03:38.000
or if you're having like your look at your memory usage, having everything be operated after the fixed point operation NICS packages doesn't quite work.

03:38.000 --> 03:41.000
So there's memory implications or performance implications.

03:41.000 --> 03:45.000
I want to address all this, or at least kind of come up with some ideas.

03:45.000 --> 03:46.000
All right.

03:46.000 --> 03:47.000
Why do names matter?

03:47.000 --> 03:49.000
Well, let us communicate.

03:49.000 --> 03:55.000
I could tell a beginner, I could teach someone, hey, here's a thing, here's its name, here's its properties,

03:55.000 --> 04:00.000
here's the form of what it looks like, here's why it's the way it is, and having a name helps.

04:00.000 --> 04:06.000
If every single time you have to kind of subtly give them a not quite right word for the thing, they're going to get confused.

04:06.000 --> 04:12.000
Because you just said this was a derivation, but then when you call it, then it becomes a derivation, but it's not quite,

04:12.000 --> 04:15.000
it's really, again, extremely confusing, especially if you're a beginner.

04:15.000 --> 04:16.000
Right?

04:16.000 --> 04:21.000
Like, we might kind of understand and look at it and recognize something like this, but look at it from the lens of someone who's new.

04:21.000 --> 04:22.000
They're not going to.

04:22.000 --> 04:25.000
So let's define this a little bit more precisely.

04:25.000 --> 04:30.000
We use this thing everywhere, and you encounter it really, really in the process.

04:30.000 --> 04:35.000
As soon as you want something like, oh, I got my own thing I want to put together, or I want to compose an environment,

04:35.000 --> 04:39.000
or compose anything, we almost always use this abstraction.

04:39.000 --> 04:40.000
So let's use it.

04:40.000 --> 04:42.000
We want this to be understandable.

04:42.000 --> 04:46.000
We also put lots of abstractions on top of this notion.

04:46.000 --> 04:49.000
Things like overlays are built on top of it, things like package set.

04:49.000 --> 04:57.000
NICS packages is built on top of this notion, but we don't even have a concrete understanding what that notion is under the hood.

04:57.000 --> 05:05.000
Alright, here's stuff you hear all the time from people, like bring you, you know, it's their first week, second week of understanding what NICS is,

05:05.000 --> 05:10.000
and you ask questions, like, I created this thing, like, now how do I build it?

05:10.000 --> 05:12.000
How do I add it to NICS packages?

05:12.000 --> 05:15.000
Oh, I built, I put this thing, but where do I put it?

05:15.000 --> 05:18.000
How do I now bring it into NICS packages?

05:18.000 --> 05:21.000
That's non-tribal, you have to kind of understand how to do this.

05:21.000 --> 05:25.000
What am I, I'm trying to add a package, but I'm trying to do this in a NICS OS system.

05:25.000 --> 05:28.000
And it starts showing up in packages.whatever, why?

05:28.000 --> 05:30.000
Or it can't find it, again.

05:30.000 --> 05:36.000
It's because, you know, they don't know how to compose these things, and it's hard, it's complicated, and we don't teach them well.

05:36.000 --> 05:37.000
What's an overlay?

05:37.000 --> 05:41.000
Oh, no, if they ask that question on their second day, you're done.

05:41.000 --> 05:43.000
It's never going to, you're never going to be able to get past them.

05:43.000 --> 05:44.000
Like, what's a fixed point?

05:44.000 --> 05:46.000
Oh, here, it's difficult.

05:46.000 --> 05:47.000
What's called package do?

05:47.000 --> 05:49.000
It calls the package.

05:49.000 --> 05:54.000
So is package the function, or what, even the naming of this is really odd.

05:54.000 --> 05:56.000
Oh, I want to do flakes.

05:56.000 --> 05:57.000
Okay, cool.

05:57.000 --> 05:58.000
How do I add my package?

05:58.000 --> 06:04.000
Oh, well, we've got to figure out what it is you're trying to do, how to compose it again, all sorts of issues.

06:04.000 --> 06:09.000
Alright, so I'm going to go quickly through a few of these things as to, like, what they are, try to explain them,

06:09.000 --> 06:14.000
and there's not going to be a full rendition of all these concepts, but just enough to get people to kind of,

06:14.000 --> 06:19.000
somewhat of a common understanding, and maybe serve as a starting point for other research.

06:19.000 --> 06:21.000
So call package, what is this thing?

06:21.000 --> 06:22.000
It's a function itself.

06:22.000 --> 06:26.000
It's going to call your definition with all the correct arguments from a scope.

06:26.000 --> 06:27.000
What's a scope?

06:27.000 --> 06:32.000
I'll go into that in a little more detail, but just consider this is the scope of things that it's available to it.

06:32.000 --> 06:35.000
And it gives you some extra usability benefits.

06:35.000 --> 06:41.000
We use this thing to kind of make things a little easier, to kind of organize mixed packages as a common way of doing it.

06:41.000 --> 06:44.000
You don't have to use this approach, but this is what mixed packages uses.

06:44.000 --> 06:46.000
This is kind of the idiom that we have.

06:46.000 --> 06:51.000
There are some people experimenting with a few other idioms, specifically with, like, the module system,

06:51.000 --> 06:53.000
but this is currently, like, the one that's in use.

06:53.000 --> 06:58.000
A pretty good explanation of this is located at this URL.

06:58.000 --> 06:59.000
All right.

06:59.000 --> 07:02.000
This is kind of a roughly a way this works.

07:02.000 --> 07:06.000
So we define a few functions to kind of, a few helper functions that's like how it works.

07:06.000 --> 07:11.000
We start defining this call package for our package set, and then we go use this thing and make things.

07:11.000 --> 07:14.000
I'll kind of break this down a little bit.

07:14.000 --> 07:15.000
So we have a helper.

07:15.000 --> 07:17.000
This helper function takes three arguments.

07:17.000 --> 07:20.000
We give it a scope, some f, some functions.

07:20.000 --> 07:22.000
This is the thing we were trying to name earlier.

07:22.000 --> 07:24.000
I'm kind of leaving it a little bit unnamed for now.

07:24.000 --> 07:26.000
And some extra stuff.

07:26.000 --> 07:34.000
There's a little bit of NYX magic here to say, hey, go grab the correct arguments from your scope, okay, and then just go call the thing.

07:34.000 --> 07:37.000
And then override it with some extras that are helpful.

07:37.000 --> 07:40.000
It just calls a function with arguments from your scope.

07:40.000 --> 07:42.000
Okay.

07:42.000 --> 07:45.000
So now that we have that defined, now we give it a scope.

07:45.000 --> 07:49.000
Here's a pretty simple scope, just, you know, a few values, not even packages.

07:49.000 --> 07:51.000
Just some values.

07:51.000 --> 07:54.000
Or this could be something massive, like all of NYX packages.

07:54.000 --> 07:57.000
The entire scope might be available to you.

07:57.000 --> 08:01.000
All right, so now we have a call package that's hopefully usable.

08:01.000 --> 08:04.000
Except, I forgot one little piece.

08:04.000 --> 08:09.000
We also extend this definition scope with something we haven't even defined yet.

08:09.000 --> 08:14.000
Something that is the value of all the packages you're going to end up with once you're done.

08:14.000 --> 08:15.000
This part's mind-boggling.

08:15.000 --> 08:18.000
It has to do with the fixed point, lazy language.

08:18.000 --> 08:21.000
It's not a very complicated thing, but this makes it complicated.

08:21.000 --> 08:23.000
This is probably what makes it hard to understand.

08:23.000 --> 08:27.000
But that's the idea is that it has access to everything once you are done.

08:27.000 --> 08:34.000
So it captures some closure, namely the scope, and then it extends it with more things that you want to define.

08:34.000 --> 08:35.000
All right.

08:35.000 --> 08:40.000
So now you've got these two helpers, and now you say, hey, I want to extend it with these extra stuff.

08:40.000 --> 08:46.000
Right, and now we have this reference packages, the packages, that whole lazy fixed point is done,

08:46.000 --> 08:48.000
and we have extra things that are now brought in.

08:48.000 --> 08:51.000
Cool, so now I should have a, b, c, and d.

08:51.000 --> 08:58.000
Well, this notion of I want to add a few packages to the scope, you're going to do that a lot.

08:58.000 --> 09:01.000
You're going to say, hey, I want to add these few things,

09:01.000 --> 09:07.000
and so we give this notion of adding a few packages or modifying them or kind of having access to them.

09:07.000 --> 09:09.000
We should call this thing an overlay.

09:09.000 --> 09:14.000
And for various reasons, we start implementing now overlays.

09:14.000 --> 09:18.000
Except this becomes almost impossible to understand, especially through a beginner.

09:18.000 --> 09:22.000
Right, you get these arguments, final prev.

09:22.000 --> 09:23.000
What are these things?

09:23.000 --> 09:27.000
I have to use the final call package, if I use the prev, I get confused or mixed up,

09:27.000 --> 09:31.000
or some things won't be available, or some things will be, but they'll be a previous version.

09:31.000 --> 09:36.000
Again, we throw this diagram in front of people, and then they go, great.

09:36.000 --> 09:38.000
This was, now I understand.

09:38.000 --> 09:40.000
Right, no.

09:40.000 --> 09:46.000
Again, that doesn't quite work, I find, in practice.

09:46.000 --> 09:48.000
So overlays are powerful, though.

09:48.000 --> 09:49.000
They are useful.

09:49.000 --> 09:53.000
They solve a really good problem if you need to do something kind of deep in the dependency chain

09:53.000 --> 09:55.000
and manage these sorts of things.

09:55.000 --> 09:58.000
And when you know what you're doing, it is powerful.

09:58.000 --> 10:03.000
But with power comes responsibility, and you can mess yourself up really easily.

10:03.000 --> 10:05.000
You know, you've got nested sets, you've got infinite recursions,

10:05.000 --> 10:09.000
like you can get confused, and very often this is what happens.

10:09.000 --> 10:12.000
But most users don't need this, especially in the beginning.

10:12.000 --> 10:16.000
Most users just say, I want to add just one more package, like the one I just started with,

10:16.000 --> 10:20.000
my toy example from the tutorial, or the project I'm working on right now,

10:20.000 --> 10:24.000
and I don't care about all this complexity, I don't need all that power.

10:24.000 --> 10:27.000
So there's a few other issues.

10:27.000 --> 10:32.000
It's hard to kind of, from an overlay, get that original function, that original thing.

10:32.000 --> 10:38.000
You can't really get it, because the way we normally define this, right, is we call it.

10:38.000 --> 10:41.000
So this thing is kind of hidden away, it's tucked away.

10:41.000 --> 10:47.000
I mean, you can probably figure out a way to extract it out, but it's not trivial, it's not easy.

10:47.000 --> 10:50.000
And we've muddled some of these concepts.

10:50.000 --> 10:52.000
All right.

10:52.000 --> 10:56.000
But overlays are essentially the correct way.

10:56.000 --> 11:01.000
Like this is the way you're supposed to use the composition with mixed packages

11:01.000 --> 11:02.000
for everything to work out right.

11:02.000 --> 11:05.000
A lot of the machinery kind of expects you to kind of go down this route.

11:05.000 --> 11:09.000
You don't have to, but again, a lot of the instructions, a lot of the idioms,

11:09.000 --> 11:12.000
a lot of the tooling will expect it.

11:12.000 --> 11:14.000
But it's hard to use.

11:14.000 --> 11:15.000
All right.

11:15.000 --> 11:17.000
There's another concept that we put in there.

11:17.000 --> 11:19.000
We have this concept of a package set.

11:19.000 --> 11:24.000
I don't even know how well this is even documented, but it's this idea of having a set of packages,

11:24.000 --> 11:29.000
a set of things, and we extend it with a few other attributes.

11:29.000 --> 11:34.000
And those attributes are the things that allow you to then further extend upon it.

11:34.000 --> 11:42.000
That's useful, except everywhere where this is used, it's implemented slightly differently.

11:42.000 --> 11:44.000
So that's another issue.

11:44.000 --> 11:46.000
So we use this all over the place, right?

11:46.000 --> 11:52.000
All the X packages, whatever packages stuff, is all the example of one of these package sets.

11:52.000 --> 11:58.000
And it's useful, again, super handy, but it also can cause confusion,

11:58.000 --> 12:00.000
because we don't explain this to people very well.

12:00.000 --> 12:03.000
Try to override something in Python packages.

12:03.000 --> 12:09.000
If someone could do that without reference or copy and pasting, I'll get you a sticker.

12:09.000 --> 12:15.000
So one proposal is, hey, how about we actually look at all the different package sets that we have in X packages

12:15.000 --> 12:17.000
and just make sure they're standardized.

12:17.000 --> 12:19.000
Right now they're slightly different.

12:19.000 --> 12:24.000
Some things are named slightly different things, or they're implemented in a kind of subtly different way.

12:24.000 --> 12:26.000
Let's perhaps try standardize this.

12:26.000 --> 12:31.000
And that way, if it's standardized, we can document it, we can talk about it.

12:31.000 --> 12:35.000
Another notion that if you dig all the way into the internals is there,

12:35.000 --> 12:37.000
but I don't think, I haven't really seen this written up.

12:37.000 --> 12:38.000
Not really anywhere.

12:38.000 --> 12:40.000
This is notion of a scope.

12:40.000 --> 12:42.000
What is a scope, right?

12:42.000 --> 12:44.000
I actually referred to this earlier on.

12:44.000 --> 12:48.000
So a scope is basically saying, hey, take your package set.

12:48.000 --> 12:55.000
I want to be able to extend upon it, and then later extract the portion that I extended it with.

12:55.000 --> 12:58.000
I mean, this is really helpful when you do something along the lines of,

12:58.000 --> 13:03.000
I want to add 10 packages to NICs packages and then pull out the 10 I just defined.

13:03.000 --> 13:06.000
That's basically the trick that this thing allows you to do.

13:06.000 --> 13:10.000
I'm not going to go into a lot of detail here, but it's a really nice trick,

13:10.000 --> 13:15.000
it's a really nice concept because otherwise it's very manual.

13:15.000 --> 13:20.000
Otherwise you have to always remember, oh, I then have to go extract back out of something.

13:20.000 --> 13:22.000
I have to go inherit or grab those attributes.

13:22.000 --> 13:27.000
Whereas with a scope, you could just say, make a scope, make a bunch of changes,

13:27.000 --> 13:29.000
and then go essentially grab the def.

13:29.000 --> 13:32.000
Go grab all the changes I just made and expose them now,

13:32.000 --> 13:36.000
and only those things, not all 80,000 remaining packages in your scope.

13:36.000 --> 13:40.000
So kind of it's a little bit like a right barrier that you could use.

13:40.000 --> 13:45.000
But probably have time to go more into detail on that one, but it's a useful notion.

13:45.000 --> 13:46.000
I don't think we talked about it enough.

13:46.000 --> 13:51.000
It's yet another thing, another abstraction we've built on top of this original thing.

13:52.000 --> 13:58.000
So let's talk about some ideas, some proposals of what we can do.

13:58.000 --> 14:00.000
And some of these stuff we could actually do today,

14:00.000 --> 14:05.000
it's just a matter of either making a decision or like thinking about it,

14:05.000 --> 14:09.000
or maybe some discussions.

14:09.000 --> 14:13.000
So first off, let's give this a name.

14:13.000 --> 14:16.000
I don't actually care all that much what name we give it.

14:16.000 --> 14:20.000
I do have some thoughts on that, but I just want to make sure we have a name

14:20.000 --> 14:23.000
so we can communicate this.

14:23.000 --> 14:25.000
So what name?

14:25.000 --> 14:28.000
Package was mentioned, not quite correct.

14:28.000 --> 14:35.000
It's related, but the by name construction that Selman has implemented

14:35.000 --> 14:40.000
for Nix packages uses package function, package fun as the notion.

14:40.000 --> 14:42.000
It's correct, but it's a little bit awkward.

14:42.000 --> 14:44.000
Not super thrilled about that one.

14:44.000 --> 14:48.000
Derivation, again, that's not quite what it is.

14:48.000 --> 14:50.000
It's the thing that will produce one.

14:50.000 --> 14:53.000
So because of that, I kind of like the, it's a proto derivation.

14:53.000 --> 14:57.000
It shall become one, but this is technical and people already run away screaming

14:57.000 --> 14:59.000
once we say the word derivation.

14:59.000 --> 15:01.000
This will make people run away screaming even harder.

15:01.000 --> 15:05.000
So that's not quite, that's for academic papers.

15:05.000 --> 15:08.000
Blueprint, kind of nice, it kind of makes sense, right?

15:08.000 --> 15:14.000
But it's pretty sterile, it's very rigid, it's not very fun, we're not very human.

15:14.000 --> 15:16.000
I kind of like recipe, right?

15:16.000 --> 15:19.000
Because it's this notion, you know, it's like you're cooking, it's human,

15:19.000 --> 15:22.000
it's food, everyone likes food, I like food.

15:22.000 --> 15:25.000
You have all sorts of other fun little concepts that could come into play,

15:25.000 --> 15:28.000
like hey, you substitute one kind of flour for another,

15:28.000 --> 15:31.000
or you substitute one ingredient for another,

15:31.000 --> 15:33.000
you could tweak your ingredients when you're cooking a lot,

15:33.000 --> 15:37.000
you know, you ran out of eggs, or I don't know, you don't like that much pepper.

15:37.000 --> 15:41.000
So that kind of gives us the notions that we like,

15:41.000 --> 15:43.000
but again, if someone comes up with a good name, I will go with it.

15:43.000 --> 15:46.000
I'm not strongly attached to anything.

15:46.000 --> 15:48.000
Any name is better than no name.

15:48.000 --> 15:50.000
So, yeah, recipe is kind of a fun one.

15:50.000 --> 15:55.000
It gives us cookbooks, variations, it's human, it's friendly, it's colorful,

15:55.000 --> 16:00.000
blueprints are usually very static and ugly.

16:00.000 --> 16:03.000
And here's some other things we could do.

16:03.000 --> 16:07.000
So once we have this thing as a concept and it has a name,

16:07.000 --> 16:10.000
well, let's say we're using flakes, not everyone is going to,

16:10.000 --> 16:14.000
but if you want to, hey, why don't we just expose these things just directly?

16:14.000 --> 16:18.000
Like, hey, here's the functions that I'm going to be using,

16:18.000 --> 16:22.000
and then from this, you can, from pretty mechanically, pretty generically,

16:22.000 --> 16:27.000
just create your overlays and create your actual hard packages,

16:27.000 --> 16:32.000
actual packages that are for a particular system or for a particular environment.

16:32.000 --> 16:35.000
But let's expose this as a top-level thing.

16:35.000 --> 16:37.000
And this has some benefits.

16:37.000 --> 16:40.000
So, hey, there's no system here.

16:40.000 --> 16:43.000
You didn't have to pick a random system just so that you could expose it

16:43.000 --> 16:45.000
so that other people can override the system you gave.

16:45.000 --> 16:48.000
Like, that whole problem is now gone.

16:48.000 --> 16:52.000
You could do cross-compiling because I could just pass whatever inputs here I want,

16:52.000 --> 16:54.000
and these are self-contained.

16:54.000 --> 16:57.000
We're not taking anything else from scope, hopefully.

16:57.000 --> 16:59.000
There's an obvious translation.

16:59.000 --> 17:02.000
So let's use that translation, implement it,

17:02.000 --> 17:04.000
I'm sure you can come up with many different ways to do so

17:04.000 --> 17:07.000
that have different usability trade-offs.

17:07.000 --> 17:10.000
And let's try to make this like a top-level output.

17:10.000 --> 17:13.000
That's just something that we use.

17:13.000 --> 17:15.000
NICS packages should expose them.

17:15.000 --> 17:18.000
Right now, one of the things people often probably do

17:18.000 --> 17:21.000
is they use the file system layout of NICS packages

17:21.000 --> 17:25.000
as like an unofficial API to grab these things.

17:25.000 --> 17:28.000
Well, now that we're migrating all those, those are all going to break.

17:28.000 --> 17:30.000
Those are all going to like the by-name construction,

17:30.000 --> 17:34.000
do we want to really rely on where it is in the file system?

17:34.000 --> 17:38.000
Like, no, let's just put them and expose them as the functions that they are.

17:38.000 --> 17:40.000
Right? We're all about functional language.

17:40.000 --> 17:42.000
Let's celebrate functions.

17:42.000 --> 17:47.000
The next thing about this is now if you start using this in the Flake ecosystem,

17:47.000 --> 17:49.000
there's no lock files needed.

17:49.000 --> 17:51.000
This doesn't refer to anything else.

17:51.000 --> 17:53.000
There's no system, there's no base NICS packages.

17:53.000 --> 17:55.000
You take NICS packages and add this,

17:55.000 --> 17:59.000
but I can grab recipes without even evaluating really much.

17:59.000 --> 18:02.000
I just have to like parse the thing and grab the function.

18:02.000 --> 18:05.000
I don't have to evaluate all of NICS packages just to end up overriding it

18:05.000 --> 18:06.000
with another NICS package.

18:06.000 --> 18:09.000
Like, that's where you get lots of memory and lock file bloat.

18:09.000 --> 18:12.000
So, I don't even need the lock file.

18:12.000 --> 18:13.000
I don't have to read the lock file.

18:13.000 --> 18:14.000
I don't have to interpret it.

18:14.000 --> 18:17.000
Right? And that prevents now a bunch of lock file bloat

18:17.000 --> 18:18.000
and the consumers of this.

18:18.000 --> 18:22.000
I could consume this thing without ever caring about that.

18:22.000 --> 18:23.000
That's a benefit.

18:23.000 --> 18:24.000
So what do I want?

18:24.000 --> 18:27.000
Hey, all the various frameworks that we have out there,

18:27.000 --> 18:30.000
like, just expose this as a top-level output.

18:30.000 --> 18:31.000
Like, nothing stops.

18:31.000 --> 18:34.000
Technically, like, I do this today, nothing stops us from doing it.

18:34.000 --> 18:37.000
Now, there's no tooling that makes it easy, you know,

18:37.000 --> 18:39.000
NICS Flake Show where other things don't present it

18:39.000 --> 18:41.000
or we can have documentation for this thing

18:41.000 --> 18:43.000
that tells you that this is a standard.

18:43.000 --> 18:46.000
But we can start doing this and there's no, nothing stops us.

18:46.000 --> 18:49.000
And we can start making it nicer and nicer to use over time.

18:49.000 --> 18:52.000
So that's kind of an idea.

18:52.000 --> 18:55.000
Yeah, I'm just kind of, I guess, reiterating that,

18:55.000 --> 18:57.000
hey, these are just pure functions.

18:57.000 --> 19:02.000
And that way, again, there's no lock file issue.

19:02.000 --> 19:05.000
So some additional thoughts.

19:05.000 --> 19:07.000
I guess they got cut off.

19:07.000 --> 19:09.000
So you show this thing to people, show it to a beginner,

19:09.000 --> 19:11.000
you go, okay, here, here's how you define your own thing,

19:11.000 --> 19:13.000
here's what you do, and you start describing it to them.

19:13.000 --> 19:16.000
And you almost inevitably, they think about this top thing

19:16.000 --> 19:18.000
as if it was like an import statement.

19:18.000 --> 19:21.000
And they always ask, what can I put here?

19:21.000 --> 19:23.000
Like, what is this thing?

19:23.000 --> 19:26.000
And you go, well, if you can grab stuff from NICS packages,

19:26.000 --> 19:28.000
okay, cool.

19:28.000 --> 19:30.000
But they also, you can grab additional stuff,

19:30.000 --> 19:32.000
stuff that you just kind of composed in with your overlays.

19:32.000 --> 19:34.000
And so they, I don't know, is Lib in there,

19:34.000 --> 19:37.000
or My Package is in there, or they only, the upstream,

19:37.000 --> 19:39.000
like, what's in there?

19:39.000 --> 19:41.000
And we don't really expose it.

19:41.000 --> 19:43.000
Like, this is the scope that's available to you at the time.

19:43.000 --> 19:45.000
Why don't we actually expose it to people?

19:45.000 --> 19:48.000
I want to be able to search within the context

19:48.000 --> 19:50.000
of what is possible for this,

19:50.000 --> 19:52.000
what's visible to call package, basically.

19:52.000 --> 19:54.000
Let's let the user search it.

19:54.000 --> 19:56.000
Why not?

19:56.000 --> 19:58.000
It's valuable information.

19:58.000 --> 20:01.000
They want to double check that what they just defined got in there.

20:01.000 --> 20:03.000
It's good for exploration.

20:03.000 --> 20:05.000
It's good for analysis.

20:05.000 --> 20:07.000
You can now analyze what's available in your scope,

20:07.000 --> 20:09.000
even, to make decisions.

20:09.000 --> 20:11.000
So, that's another kind of thing,

20:11.000 --> 20:14.000
a little bit beyond the first thought.

20:14.000 --> 20:16.000
So what next?

20:16.000 --> 20:18.000
We don't need technical changes.

20:18.000 --> 20:20.000
Again, you could do this today.

20:20.000 --> 20:22.000
You could do this by using a kind of flake schema.

20:22.000 --> 20:24.000
You could just do it yourself and just kind of rely upon it

20:24.000 --> 20:26.000
or check for it.

20:26.000 --> 20:28.000
But I want to, all the time,

20:28.000 --> 20:30.000
just kind of get this convention started,

20:30.000 --> 20:32.000
and then at some point start to get some feedback.

20:32.000 --> 20:34.000
Like, is this good?

20:34.000 --> 20:37.000
Part of me talking here today is getting an idea from everyone.

20:37.000 --> 20:39.000
Is this on the right track?

20:39.000 --> 20:41.000
Is this helpful?

20:41.000 --> 20:43.000
Do we need an RFC for this?

20:43.000 --> 20:45.000
Then we start adding support into the various frameworks and libraries.

20:45.000 --> 20:47.000
We can start, actually, at some point adding some support for this

20:47.000 --> 20:50.000
or some of the utilities we have to make it easier.

20:50.000 --> 20:53.000
And then, you know, we make that developer experience even better.

20:53.000 --> 20:55.000
Like, how do we move these around?

20:55.000 --> 20:57.000
How do we update them?

20:57.000 --> 20:59.000
How do we borrow them from another cookbook?

20:59.000 --> 21:01.000
How do we inherit cookbooks?

21:01.000 --> 21:03.000
That sort of thing.

21:03.000 --> 21:05.000
How do we mix this or combine this with all the teaching materials that we have?

21:05.000 --> 21:07.000
So there's, you know, it's not super easy,

21:07.000 --> 21:09.000
but we have things to do.

21:09.000 --> 21:11.000
Another notion that I ran across

21:11.000 --> 21:14.000
that actually seemed pretty useful in practice was

21:14.000 --> 21:18.000
if I have defined all my recipes, right,

21:18.000 --> 21:21.000
you can kind of say, hey, well, using some base,

21:21.000 --> 21:23.000
add this stuff to it.

21:23.000 --> 21:25.000
And once you can define this and use this thing,

21:25.000 --> 21:27.000
it kind of looks like the with keyword.

21:27.000 --> 21:29.000
It has a lot of other, like, benefits.

21:29.000 --> 21:31.000
You can start to define how it interprets what you gave it.

21:31.000 --> 21:33.000
So here you can start to kind of say,

21:33.000 --> 21:35.000
oh, I don't have to import the thing.

21:35.000 --> 21:37.000
I can just refer to it by path.

21:37.000 --> 21:39.000
Or other niceties.

21:39.000 --> 21:43.000
But it's another kind of useful abstraction that I'll just say has worked out well

21:43.000 --> 21:45.000
in my opinion.

21:47.000 --> 21:48.000
All right.

21:48.000 --> 21:50.000
I think that's a blank slide.

21:50.000 --> 21:53.000
I don't have time for a demo, but, like, this kind of works.

21:53.000 --> 21:54.000
I use it today.

21:54.000 --> 21:55.000
It's useful.

21:55.000 --> 21:56.000
It's friendly.

21:56.000 --> 21:58.000
It gives us a lot of benefits that I like.

21:58.000 --> 22:01.000
I'd like to expand upon it and make it kind of less of, like,

22:01.000 --> 22:07.000
a unique, strange thing that I do and something more that might be a bit more common.

22:07.000 --> 22:09.000
I've got some references in here.

22:09.000 --> 22:12.000
And I am willing to talk to people about this sort of idea,

22:12.000 --> 22:13.000
this sort of thing.

22:13.000 --> 22:15.000
So come talk to me.

22:15.000 --> 22:22.000
And I guess we're open for thoughts, questions, comments, tomatoes.

22:28.000 --> 22:32.000
Thank you very much, Tom.

22:32.000 --> 22:37.000
Is there any questions?

22:42.000 --> 22:51.000
Thanks for your presentation.

22:51.000 --> 22:58.000
If you want to expose the recipes inside of Flake, how would NixBuild work?

22:58.000 --> 23:02.000
So NixBuild, right, doesn't take a recipe.

23:02.000 --> 23:04.000
NixBuild needs a package.

23:04.000 --> 23:06.000
This is where the distinction matters.

23:06.000 --> 23:13.000
So you would still have to say, hey, my packages are, with this base Nix packages,

23:13.000 --> 23:15.000
bringing all my recipes.

23:15.000 --> 23:16.000
Right?

23:16.000 --> 23:19.000
But that's a simple kind of way to say, it's kind of like the for all systems.

23:19.000 --> 23:22.000
It's kind of a very simple helper that can do this thing for you.

23:22.000 --> 23:24.000
And that could just be kind of injected into the templates.

23:24.000 --> 23:27.000
It could be used and tell people, hey, here's how you do it.

23:27.000 --> 23:31.000
Here's the easy answer unless you need more power to, like, only, you know,

23:31.000 --> 23:34.000
but the easy answer will be, hey, convert all these recipes into packages.

23:34.000 --> 23:35.000
Boom.

23:35.000 --> 23:37.000
Now NixBuild has it available to you.

23:37.000 --> 23:41.000
So you would need a lock file and Nix packages input inside of Flake?

23:41.000 --> 23:42.000
Yes.

23:42.000 --> 23:46.000
So if you want to build a package, yes, obviously then you need a lock file,

23:46.000 --> 23:52.000
other things, but I can still grab those recipes directly without reading your input,

23:52.000 --> 23:55.000
without reading your lock file, because it's independent of them.

23:55.000 --> 23:57.000
But yes, if you want to actually build a concrete thing,

23:57.000 --> 24:02.000
well, you have to have a concrete base.

24:02.000 --> 24:03.000
Any other questions?

24:03.000 --> 24:04.000
Back.

24:11.000 --> 24:14.000
Yeah, this is kind of just a curious one, a technical one.

24:14.000 --> 24:22.000
In your proto derivations example, you have a function which takes nothing.

24:22.000 --> 24:28.000
And it, well, sorry, it takes a set, but the set has nothing in it.

24:29.000 --> 24:33.000
And it would be unexpected argument if you passed it.

24:33.000 --> 24:39.000
Yeah, my data at the bottom, what is the purpose of my data by comparison to everything else?

24:39.000 --> 24:42.000
Why put the set as an argument there?

24:42.000 --> 24:44.000
Well, it just doesn't need arguments.

24:44.000 --> 24:45.000
Great.

24:45.000 --> 24:47.000
In that case, call package goes into no arguments.

24:47.000 --> 24:52.000
Let me call it with the empty function, and the result in this case isn't even actually a package.

24:52.000 --> 24:54.000
It's just some data.

24:54.000 --> 24:59.000
All right, so it's a way of interfacing call package because it expects the function as its signature.

24:59.000 --> 25:02.000
Yeah, you could process these in such a way.

25:02.000 --> 25:09.000
For example, one trick I've been playing with is to process just a simple string as if it was the arguments to run command.

25:09.000 --> 25:10.000
It's kind of nice.

25:10.000 --> 25:13.000
You could just throw a script in there without having to define a lot of things.

25:13.000 --> 25:15.000
This is kind of serves a marker.

25:15.000 --> 25:18.000
Again, you could interpret this set in different ways.

25:18.000 --> 25:23.000
I don't know exactly what the best way is, but you can kind of figure out different types are handled differently.

25:23.000 --> 25:26.000
So you could detect, hey, oh, this thing is a function.

25:26.000 --> 25:27.000
Great.

25:27.000 --> 25:33.000
In that case, defer that evaluation, or it's a piece of data converted to a run command, or it's a path.

25:33.000 --> 25:35.000
It's a path, okay, imported.

25:35.000 --> 25:37.000
My call package does this for you right now.

25:37.000 --> 25:40.000
If you give call package a path, it goes, oh, it's a path.

25:40.000 --> 25:44.000
Let me import it, and I'm expecting inside of that path there to be a function.

25:44.000 --> 25:46.000
Or you can pass it directly a function.

25:46.000 --> 25:48.000
So this is just another little trick.

25:48.000 --> 25:51.000
Again, whether we use it or not, I don't really.

25:51.000 --> 25:53.000
Something fun.

25:57.000 --> 25:58.000
Thanks, Tom.

25:58.000 --> 26:00.000
Let's give it up for Tom again.

