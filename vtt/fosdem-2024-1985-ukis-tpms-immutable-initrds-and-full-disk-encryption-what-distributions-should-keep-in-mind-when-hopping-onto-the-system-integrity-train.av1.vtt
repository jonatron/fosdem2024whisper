WEBVTT

00:00.000 --> 00:09.760
I'm happy to introduce our first speaker in the morning, who you can already see is all

00:09.760 --> 00:10.760
set up here.

00:10.760 --> 00:15.520
Well, I'm going to go and hand it over to Leonard to open us up and kick off the distribution

00:15.520 --> 00:17.200
s Devrem for the day.

00:17.200 --> 00:18.200
Take it over from here.

00:18.200 --> 00:19.200
I have this.

00:19.200 --> 00:20.200
Does it actually work?

00:20.200 --> 00:21.200
It works, right?

00:21.200 --> 00:22.200
Hi.

00:22.200 --> 00:23.200
Good morning.

00:23.200 --> 00:25.680
And thank you for waking up so early for me.

00:25.680 --> 00:26.680
Much appreciated.

00:26.680 --> 00:27.680
It was hard for me.

00:27.680 --> 00:30.840
It was probably hard for you as well.

00:30.840 --> 00:34.640
Today I'm going to talk about TPMs and UKIs and immutable inner-ities.

00:34.640 --> 00:39.960
I'll give a second talk later today in the boot and in-it track.

00:39.960 --> 00:43.640
So the topics are kind of related.

00:43.640 --> 00:46.440
But there I want to talk more about the early boot stuff.

00:46.440 --> 00:52.520
And here I want to focus on stuff, what it actually all means for distributions.

00:52.520 --> 00:57.480
So UKI, TPMs, immutable inner-ities and full description.

00:57.480 --> 01:02.320
I think this is where we should be going on the Linux distribution world.

01:02.320 --> 01:05.560
But of course, I am not the Linux distribution world.

01:05.560 --> 01:14.160
So in this talk, I kind of want to explain what I think might be next steps for distributions

01:14.160 --> 01:17.760
that actually want to adopt all this.

01:17.760 --> 01:18.760
Yeah.

01:18.760 --> 01:22.800
To start out with, this is a fairly technical talk.

01:22.800 --> 01:26.960
I'm pretty sure some of you at least have some rough idea about what I'm going to talk

01:26.960 --> 01:28.120
about.

01:28.120 --> 01:34.000
But just to get you up to some level at least that you have a chance to follow, let's go

01:34.000 --> 01:38.680
through a couple of very basic vocabulary and what I'm talking about.

01:38.680 --> 01:41.360
The first thing, secure boots.

01:41.360 --> 01:43.440
Like many of you probably came into contact with that.

01:43.440 --> 01:48.560
It's the thing where during boots, all the various binaries that are part of the boot

01:48.560 --> 01:51.120
process are signed cryptographically.

01:51.120 --> 01:58.480
And the firmware from early on makes sure that only properly signed stuff is run.

01:58.480 --> 02:01.280
The signing keys for that are kept by Microsoft.

02:01.280 --> 02:07.960
So it's like a centralized authority kind of thing.

02:07.960 --> 02:12.480
At this point, because it's relatively like they'll sign a lot of stuff.

02:12.480 --> 02:17.800
There's probably more of a denialist of bad stuff than an allow list of good stuff.

02:17.800 --> 02:23.280
And yeah, there's certainly criticism to be had about the centralized nature of this.

02:23.280 --> 02:25.800
There's another thing called measured boot.

02:25.800 --> 02:34.280
Measured boot is not so like say accepted, well known in the Linux world yet.

02:34.280 --> 02:39.200
Measured boot is something where basically rather than in Secure Boot where you disallow

02:39.200 --> 02:42.280
components that are bad to even run.

02:42.280 --> 02:44.560
In measured boot you allow everything to run.

02:44.560 --> 02:49.840
But before you run it, you make a measurement which is basically taking a SHA sum or something

02:49.840 --> 02:54.560
like that like a hash of like a cryptographic hash or what you're going to start next.

02:54.560 --> 02:59.600
And you write that in a certain register in a TPM.

02:59.600 --> 03:03.400
And this is an irreversible way.

03:03.400 --> 03:09.800
So afterwards you can cryptographically verify that everything that was started so far is

03:09.800 --> 03:11.680
actually what you think what it is.

03:11.680 --> 03:18.040
The good thing about this is it's more democratic in a way because it doesn't restrict anyone

03:18.040 --> 03:19.320
from running anything.

03:19.320 --> 03:22.720
But you can later use these measurements to protect your secrets.

03:22.720 --> 03:25.160
And that's what we're going to talk about later.

03:25.160 --> 03:28.840
So there's no centralized authority because there isn't a restrictions made on what's

03:28.840 --> 03:29.840
booted.

03:29.840 --> 03:36.160
But it's up to you to say basically I only want that if this software is run during my

03:36.160 --> 03:38.960
boot process that I can release my disk encryption secrets.

03:38.960 --> 03:43.680
And then you know, it gives you I think a more like more specific, more focused kind

03:43.680 --> 03:46.720
of security than the Secure Boot stuff gives you.

03:46.720 --> 03:49.560
TPM of course I already mentioned the word is like this little chip.

03:49.560 --> 03:53.760
I mean it used to be a little chip that is pretty much in all the laptops.

03:53.760 --> 03:57.080
And in one form or another it's also in all the cell phones.

03:57.200 --> 03:59.400
I mean they call it Secure Enclave and stuff like this.

03:59.400 --> 04:04.040
But conceptually it's always the same thing that you have like this security isolated

04:04.040 --> 04:09.680
security environment where you can keep your keys and that maintain access policies on

04:09.680 --> 04:12.000
keys and things like that.

04:12.000 --> 04:16.320
It's pretty common, has been around like all the laptops that were sold in the last 15

04:16.320 --> 04:18.600
years probably already had a TPM.

04:18.600 --> 04:23.800
On Linux, well I mean it is automatically used because the measurements made into the

04:24.160 --> 04:28.760
TPM but actually actively used by the distributions it's generally not.

04:28.760 --> 04:34.560
Like it doesn't mean that you can't use it but it's so far typically left for hackers

04:34.560 --> 04:37.040
to actually have an interest in TPM to enable it.

04:37.040 --> 04:41.200
Regular people do not run this which is completely different like it is on Windows and these

04:41.200 --> 04:46.320
other operating systems was always used by default basically like BitLocker.

04:46.320 --> 04:53.560
If you don't do anything it just locks it to the TPM.

04:54.320 --> 04:57.080
One specific part of the TPM is the PCR registers.

04:57.080 --> 05:00.360
I already referenced them earlier, didn't call them PCRs.

05:00.360 --> 05:04.640
Those are these registers where you can write these hash values too.

05:04.640 --> 05:09.080
They do one relatively simple cryptographic operation which is like they take the old

05:09.080 --> 05:14.080
value and the new value and hash it together basically.

05:14.080 --> 05:21.080
This basically means only if the exact same stuff gets measured into it during boot the

05:21.480 --> 05:25.920
final result of the register will be as you expect.

05:25.920 --> 05:31.040
You can reverse this, I mentioned this, once something is measured into it it's measured

05:31.040 --> 05:36.240
into it and the only way to get the thing back to zero is to reboot.

05:36.240 --> 05:42.680
All the registers started zero and then you typically have 24 of these and half of them

05:42.680 --> 05:44.320
are basically used by firmware.

05:44.320 --> 05:48.200
The other one is for the operating system.

05:48.320 --> 05:53.600
Once you have these PCR values you can bind security to this like locking of disk secrets

05:53.600 --> 05:56.920
and thus you can do things like that.

05:56.920 --> 06:01.320
You can say that my disk secrets shall only be released if the operating system is in

06:01.320 --> 06:02.320
good state.

06:02.320 --> 06:05.480
How that actually works let's go into that detail a little bit later.

06:05.480 --> 06:07.120
That term is UKI.

06:07.120 --> 06:12.440
By the way I'm talking a lot and I have lots of slides and I much prefer though if we do

06:12.440 --> 06:17.120
a discussion here rather than me just talking.

06:17.200 --> 06:19.520
If any one of you has questions please interrupt me.

06:19.520 --> 06:23.760
Let's talk about this right away and let's not move the talks, the questions to the end

06:23.760 --> 06:27.520
because yeah I'm pretty sure half of you will probably then have forgotten your questions

06:27.520 --> 06:28.520
by then.

06:28.520 --> 06:32.240
Anyway so feel invited to interrupt me.

06:32.240 --> 06:37.200
So UKI's, this is actually what the other talks are going to be about is it's a unified

06:37.200 --> 06:38.200
kernel image.

06:38.200 --> 06:45.200
It's not radically new approach but it's certainly different than how most of the distributions

06:45.280 --> 06:47.280
use to manage their kernel images.

06:47.280 --> 06:51.880
UKI's are basically you take a kernel image, you take an inner d, you take a couple of

06:51.880 --> 06:56.400
other things like Chrome command line, boot splash, device tree or something like this.

06:56.400 --> 07:03.680
You glue it all together, turn it into a UFI binary like a PE binary and you sign it as

07:03.680 --> 07:07.280
a whole and during boot it gets measured as a whole.

07:07.280 --> 07:13.640
UKI's are awesome because they make things very very predictable because yeah once you

07:13.640 --> 07:18.360
deploy UKI it's one file, you drop it in the ESP like in the ESI system partition which

07:18.360 --> 07:21.000
is where the firmware starts from.

07:21.000 --> 07:26.360
You can update it as one file which is awesome because it's extremely robust right like you

07:26.360 --> 07:32.520
do not have to risk that you have half updated your kernels or something like this because

07:32.520 --> 07:36.960
it's always either you have the new file or you have the old file that's fantastic.

07:36.960 --> 07:42.200
So it's great from a cryptographic, from a robustness point of view and it's also great

07:42.200 --> 07:48.160
for other reasons like for example it's, is it always the same?

07:48.160 --> 07:52.440
You can test them better and so you have a greater chance to know that they will, like

07:52.440 --> 07:57.200
if you deploy them in lots of different machines they will probably all work equally well or

07:57.200 --> 07:59.960
equally bad but hopefully equally well.

07:59.960 --> 08:07.720
Anyway so much about the vocabulary just so that we all know at least the basics of what's

08:07.720 --> 08:08.720
coming next.

08:09.720 --> 08:12.120
How do we deal with the vocabulary?

08:12.120 --> 08:15.480
I want to explain a little bit the goals of what I'm actually doing here.

08:15.480 --> 08:21.960
So the general goal is tied to security and provide code integrity on Linux right?

08:21.960 --> 08:27.760
This is mostly about making sure that traditional Linux, like traditional Linux means distribution

08:27.760 --> 08:28.760
based Linux right?

08:28.760 --> 08:33.440
Like I do not mean Android or Chrome OS by this, I mean distributions like Fedora, Debian

08:33.440 --> 08:40.520
and these kind of things that have a, I would say the sudden democratic approach to things

08:40.520 --> 08:42.480
that everybody can participate in.

08:42.480 --> 08:46.080
It's not this over the wall open source but actual open source.

08:46.080 --> 08:53.000
So I want to make sure that these traditional Linux catch up to the level of security that

08:53.000 --> 08:55.200
the other ones actually provide you with.

08:55.200 --> 08:59.640
That Windows provides you since long time that Mac OS provides you these days Android,

08:59.640 --> 09:04.200
Chrome OS, they all have these code integrity protections.

09:04.200 --> 09:09.520
The general goal of this of course like if you want to talk about threat models is usually

09:09.520 --> 09:13.240
evil made stuff that you leave your laptop in your hotel room and you want to be sure

09:13.240 --> 09:19.240
that when you come back it's still your laptop with your software in it and it's not back

09:19.240 --> 09:24.960
doored because right now it's very easy to back door.

09:24.960 --> 09:29.800
So focus is generic distributions Fedora, Debian and so on and the goal is to make things

09:29.800 --> 09:31.120
just work right?

09:31.120 --> 09:36.680
Like I want to move this stuff out of this area where it's a specialist thing that TPM

09:36.680 --> 09:43.080
loving hackers enable and I'd rather want this that this is stuff that just works and

09:43.080 --> 09:49.640
defaults to just being enabled in distributions rather than being something you actually have

09:49.640 --> 09:52.240
to opt in and do work to get to.

09:52.240 --> 09:57.480
That is of course like it's a big ask but I think it's necessary because we nowadays

09:57.480 --> 10:03.560
like everybody knows the value of IT security and it's really sad that Linux has very little

10:03.560 --> 10:11.400
in this area by default because it's laughably easy to back door a laptop right now even

10:11.400 --> 10:15.520
if it uses full description because inner IDs and things like that are not protected

10:15.520 --> 10:16.520
at all.

10:16.520 --> 10:21.720
I already mentioned the word democratic a couple of times.

10:21.720 --> 10:25.280
My own focus is much more on measured boot than on Sacky boot right?

10:25.280 --> 10:29.520
Like Sacky boot is established like all the big distributions assigned the kernels with

10:29.520 --> 10:34.120
Microsoft key and things like that.

10:34.120 --> 10:38.600
I actually work for Microsoft as you might know but still I don't want to assign my kernels

10:38.600 --> 10:39.600
with Microsoft key.

10:39.600 --> 10:44.520
So I think measured boot is actually a much more interesting technology because it allows

10:44.520 --> 10:48.000
you to define your local policies yourself.

10:48.000 --> 10:52.320
You can sign your kernels yourself, you can define the policies for your secrets yourself

10:52.320 --> 10:57.200
and you can just say yeah I don't want to allow my machine to run Chrome OS or Windows

10:57.200 --> 10:58.920
or whatever else.

10:58.920 --> 11:03.640
I just want it to run my choice of kernels and my choice of inner dean, my choice of

11:03.640 --> 11:06.240
Linux operating system.

11:06.240 --> 11:11.760
So yeah the goal is definitely to, I think it fits nicely into how Linux distributions

11:11.760 --> 11:18.760
are traditionally organized because yeah they are in a way democratic too.

11:18.760 --> 11:22.680
So to be more technical what are your specific goals?

11:22.680 --> 11:26.720
I want that measured boot is done by default and that means not only, I mean it is done

11:26.720 --> 11:32.840
by default because you have, I am like up to the kernel do this anyway by default and

11:32.840 --> 11:36.680
have been doing this for the last 10 years or something but I want that this actually

11:36.680 --> 11:42.800
continues into the rest of the boot process and actually during the runtime of the operating

11:42.800 --> 11:46.800
system later as well.

11:46.800 --> 11:49.600
I also want that secure boot covers the whole boot process.

11:49.600 --> 11:53.080
Right now we end this really weird situation where it only covers the basic kernel and

11:53.080 --> 11:55.840
not the inner AD and I find that kind of laughable.

11:55.840 --> 11:57.480
But again measured boot is my main focus.

11:57.480 --> 12:03.720
Secure boot is, yeah we should do the two if we can but it is two different protections.

12:03.720 --> 12:07.440
Also you get the best results but I find the protection that measured boot provided was

12:07.440 --> 12:12.480
much more interesting than the one secure boot provided was.

12:12.480 --> 12:16.720
All the measurements that we make during the boot process right like the hashes like all

12:16.720 --> 12:23.040
the stuff that gets hashed I want to be predictable.

12:23.040 --> 12:26.440
Predictable basically means is that even before you boot it you have got to know if

12:26.440 --> 12:29.760
you know the components involved what these PCR values are going to be.

12:29.760 --> 12:35.800
This actually matters because you bind the security of your full description keys to

12:35.800 --> 12:39.160
these PCR values and if you cannot predict them you cannot do that.

12:39.160 --> 12:43.520
Only if you know that if I run the Fedora kernel from this version on and that is going

12:43.520 --> 12:48.720
to result in these hashes being measured into the PCR values you can say only unlock my

12:48.720 --> 12:52.440
keys if the PCRs have this value.

12:52.440 --> 12:54.600
So yeah predictability means a lot.

12:54.600 --> 12:56.200
Why do I even mention this?

12:56.320 --> 13:01.520
For example in Grubber things like that measurements are not so predictable because they don't

13:01.520 --> 13:07.240
measure the actual code so much but the selected pass through the code which basically means

13:07.240 --> 13:11.840
there are lots of variables in how it actually ends up in the PCR values depending on like

13:11.840 --> 13:21.120
I don't know if you move up your menu it might end up in different measurements.

13:21.120 --> 13:24.840
One of the goals is specifically also just encryption easy by default and this particularly

13:24.880 --> 13:26.640
also means service.

13:26.640 --> 13:30.560
Right now I'm pretty sure most of the people in the room probably use this encryption

13:30.560 --> 13:35.360
on their laptop and my assumption is also that most of you probably use it interactively

13:35.360 --> 13:36.880
with the keyboard unlock.

13:36.880 --> 13:39.360
You boot up the machine you type in your password.

13:39.360 --> 13:44.080
That's great but also we can do so much better and it's not something you could ever do in

13:44.080 --> 13:45.080
service.

13:45.080 --> 13:49.920
On service there's nobody in the server room to even unlock this stuff usually.

13:49.920 --> 13:56.440
So what TPMs give you is this ability that you can non interactively do disk encryption

13:56.440 --> 14:00.080
because the TPM keeps the secret for you.

14:00.080 --> 14:06.640
You do the PCR dance and you basically tell it to unlock the secrets only when the operating

14:06.640 --> 14:13.040
system like if it's your version of rel or your version of marina or whatever else that

14:13.040 --> 14:14.920
is booted up and nothing else.

14:15.920 --> 14:21.920
And this also means like I think actually we should get into that mode where distributions

14:21.920 --> 14:30.120
by default enable disk encryption right and even if people didn't ask for this and without

14:30.120 --> 14:33.960
necessarily even asking during the install time even for a passphrase or something like

14:33.960 --> 14:38.680
this simply because by default they should be locked to the TPM and then if people want

14:38.680 --> 14:43.040
to enroll a manual key or a FIDO key or whatever else then that would be on top of the TPM and

14:43.040 --> 14:47.240
not what you start out with.

14:47.240 --> 14:51.400
I mean this is like yeah this is the goal eventually we're not there yet.

14:51.400 --> 14:54.840
We don't even have the infrastructure to make this but I think it's I mean this is basically

14:54.840 --> 14:59.680
what Chromebooks and all these things generally do and I think we should catch up and kind

14:59.680 --> 15:04.160
of try to make this something that also works in Linux that way.

15:04.160 --> 15:09.600
Yeah another goal of boot process is testable I'll already mention it because if you have

15:09.640 --> 15:14.000
everything strictly predictable and uniform and on all the installations you kind of

15:14.000 --> 15:18.520
have the same set of software maybe in slightly different versions because one already updated

15:18.520 --> 15:22.960
his machine to the version of today and the other one didn't but still it should be a

15:22.960 --> 15:27.000
small set of different versions and yeah.

15:27.000 --> 15:30.000
By the way again questions yeah.

15:30.400 --> 15:37.400
So when you were talking about the measured boot regarding being local do you mean here

15:41.080 --> 15:45.640
local in terms of the hardware vendor or local based on the distribution or local based

15:45.640 --> 15:50.640
on the owner of the machine because at the moment with secure boot you have a buy from

15:50.640 --> 15:55.280
lots of parties Microsoft for signing, frameworks, vendors and then distribution that follows

15:55.280 --> 15:56.600
the whole process.

15:57.200 --> 16:00.520
Ultimately I mean you right like on your laptop you should be in power but the thing

16:00.520 --> 16:05.080
is like of course that's a big ask like if I install my mother Linux laptop she's not

16:05.080 --> 16:08.680
going to be capable of like it.

16:08.680 --> 16:13.960
So ultimately that basically means that I mean we come to this later hopefully given

16:13.960 --> 16:20.640
the time but it's like my assumption is that by default you get kernels and the OS provided

16:20.640 --> 16:25.920
to you and signed by you and protected by you by the distro vendor but I certainly want

16:25.960 --> 16:30.680
to enable you to that you can say basically fuck this I'm going to enroll my own stuff

16:30.680 --> 16:35.000
and we want to make this easily easy so that it's robust and you can actually do this right.

16:35.000 --> 16:42.000
So that you can basically be more restrictive even you can say not just it's okay that Fedora

16:42.640 --> 16:48.600
gets access to my disk encryption but you can even say something like only Fedora in

16:48.600 --> 16:52.520
the version that I picked on the architecture that I picked and so on and so on like you

16:52.560 --> 16:57.680
can make it much more focused because you know you machine better and the way like that

16:57.680 --> 17:01.760
you know that you don't boot from ice guzzies and things like that Fedora doesn't right

17:01.760 --> 17:05.680
like so you can make it much more focused and saying yeah I think I'm not involved right

17:05.680 --> 17:10.280
so but I'll be the goal is definitely to democratize it right like to put the people in the control

17:10.280 --> 17:15.840
if they if they want to but also knowing that this is not what in there like what people

17:15.840 --> 17:16.840
could do.

17:16.840 --> 17:22.200
So basically you said you but instead of you is your TPM so you don't even have to know

17:22.240 --> 17:23.240
about it.

17:23.240 --> 17:24.240
Sorry?

17:24.240 --> 17:31.240
Your TPM so you don't even have to know about it so it's easy for everybody to use.

17:31.280 --> 17:32.280
Yeah right.

17:32.280 --> 17:34.280
That's okay.

17:34.280 --> 17:39.280
Okay let's talk a little bit about the status quo like how it's right now.

17:39.280 --> 17:45.280
So most of the release distribution currently provide minimal second I call it minimal

17:45.280 --> 17:48.480
second boot because it only really covers the boot loader and the kernel and it doesn't

17:48.480 --> 17:53.480
only cover the inner d which I find really embarrassing for the fact that in 2024 you

17:53.480 --> 17:59.000
can just go to the ESP or boot petition and modify the inner d that anywhere you want

17:59.000 --> 18:06.000
and we'll just boot from it and nobody takes notice.

18:11.280 --> 18:13.280
But inner d is just a file system right?

18:13.280 --> 18:17.720
Why is it the same order as the kernel for measuring it?

18:17.720 --> 18:22.720
I mean the kernel could authenticate it if it wants to.

18:22.720 --> 18:24.720
I mean it could it just doesn't that's the thing that I'm saying.

18:24.720 --> 18:27.800
There is no authentication of the inner d right now.

18:27.800 --> 18:34.000
Not in the generic distributions at least and that's I mean it's rooted in the fact

18:34.000 --> 18:39.640
that inner d's are in the traditional line it's always generated locally on the system

18:39.640 --> 18:43.320
but basically they ultimately are different on every single system.

18:43.320 --> 18:49.920
They import not only code but also configuration local configuration and that basically means

18:49.920 --> 18:52.080
you cannot sign it on vendor systems right?

18:52.080 --> 18:59.080
Like if you are a customer of I don't know Suze and they give you kernel inner d then

18:59.520 --> 19:03.000
they cannot sign the inner d for you because that inner d only exists on your system and

19:03.000 --> 19:04.800
a specific system.

19:04.800 --> 19:08.960
So yeah so I think it's really bad situation right?

19:08.960 --> 19:13.240
Because it basically means that any evil mate can go into my hotel room just take the hardest

19:13.240 --> 19:20.680
guys on their laptop they can just go to the inner d change any file they want in particularly

19:20.680 --> 19:26.080
the password prompt for my lux stuff and send it all to send central server if they want

19:26.080 --> 19:28.240
and I will not be able to notice this.

19:28.240 --> 19:32.960
That is a situation that I think is really stupid all the way.

19:32.960 --> 19:37.280
So yeah I've already mentioned this the inner d's are locally built they are not protected

19:37.280 --> 19:42.520
by Secure Boot then there are very little measurements actually being done.

19:43.000 --> 19:48.200
The kernel now does a couple of them on its own like there's the inner id basically but

19:48.200 --> 19:55.200
in general the ones that are made by Grappa I already mentioned this are not predictable

19:56.480 --> 20:00.480
and it stops the moment the kernel actually does anything right?

20:00.480 --> 20:05.960
Like because the measurement that the kernel does and it still does in unify mode and then

20:05.960 --> 20:09.960
user space doesn't do anything anymore traditionally.

20:10.000 --> 20:11.440
So I think that's bad right?

20:11.440 --> 20:17.320
Because actually what I think makes a ton of sense for root disk encryption is that

20:17.320 --> 20:24.320
the key for the root disk encryption is only released by the TPM to the system in the inner

20:24.600 --> 20:27.560
d phase but never later right?

20:27.560 --> 20:34.080
That is a really nice property that you basically drop as you boot any chances to recover the

20:34.080 --> 20:35.920
boot the disk encryption key.

20:35.920 --> 20:38.600
I mean the kernel will always have it somewhere in memory because it actually needs to do

20:38.640 --> 20:44.600
the encryption but via the PCR mechanism you can make it relatively easily and we have

20:44.600 --> 20:48.360
now the infrastructure in place to do this that later on you can talk as much to the

20:48.360 --> 20:52.880
TPM as you want you will not be able to recover the disk encryption key from itself anymore

20:52.880 --> 20:58.120
because we basically blew a fuse through this but anyway this requires that we make measurements

20:58.120 --> 21:02.760
during the boot process and during the run time so that policy like this are actually

21:02.840 --> 21:03.840
very expressible.

21:03.840 --> 21:09.840
Yeah I remember this like in the status quo on the TPM based stuff again like there is

21:09.840 --> 21:16.840
a stat like two stacks even of TPM and Linux but except for hacker circles nobody uses

21:18.000 --> 21:22.880
them I would say you can't script it together there's many how-to's on the internet but

21:22.880 --> 21:26.600
nobody does 15 people in the world do it.

21:26.600 --> 21:31.320
So yeah I already mentioned this as well like the Lux password prompt is implemented in

21:31.400 --> 21:32.400
the Internet.

21:32.400 --> 21:36.440
Internet is not protected either way that's trivial backdoor it's a terrible thing.

21:36.440 --> 21:42.960
I would call this in summary pretty weak security and you could use words like laughable or

21:42.960 --> 21:45.440
something and compare to other operating systems.

21:45.440 --> 21:47.680
So what's the vision?

21:47.680 --> 21:52.640
Primary we want that kernels are shipped as UKIs by distributions so that they are everything

21:52.640 --> 21:56.320
is secured protected including the Internet and they are measured as ones and they are

21:56.320 --> 21:58.160
fully predictable.

21:58.160 --> 22:02.960
This means that the kernels and interities need to be pre-built right not on a local

22:02.960 --> 22:09.960
system I mean for the kernels they traditionally weren't except if you run Gantu but yeah the

22:09.960 --> 22:14.400
move would be to pre-build the interities centrally.

22:14.400 --> 22:17.920
If you do all this then you get stable hashes in the PCRs you can buy the disk encryption

22:17.920 --> 22:22.040
to it you get the universal predictability because the software doesn't deviate between

22:22.040 --> 22:23.800
systems it's always the same software.

22:23.800 --> 22:27.200
You have robust updates I mentioned already because the kernels can be updated in one

22:27.200 --> 22:31.720
file and yeah you test the combinations very well.

22:31.720 --> 22:38.920
Secondary is like a secondary goal that I have is what I just described is again central

22:38.920 --> 22:42.720
authority to some way because it's the distributions that do this.

22:42.720 --> 22:47.640
I think it's also important to keep people who actually want to sign their own stuff

22:47.640 --> 22:52.160
in pictures as well I mentioned that was your question basically earlier that yeah if you

22:52.160 --> 22:56.480
want to run your own like if you want to generate a key pair and sign your stuff yeah we should

22:56.480 --> 22:57.800
help you with this.

22:57.800 --> 23:03.280
So in this model you probably will still use a pre-built kernel by your distribution you

23:03.280 --> 23:06.960
might however combine it with a local Internet ID and then sign it with your key instead of

23:06.960 --> 23:08.360
the distribution key.

23:08.360 --> 23:13.240
Benefit of course is maximum flexibility but also you need to know your shit.

23:13.240 --> 23:18.840
The advantage of this of course is that the PCRs remain predictable but they only remain

23:18.840 --> 23:22.480
predictable within your local scope because only you know what you're actually going to

23:22.480 --> 23:26.920
build into the Internet IDs and how you're going to combine it.

23:26.920 --> 23:32.360
Yeah it's a it's a it's a it's a large installation footprint because you suddenly need to actually

23:32.360 --> 23:34.680
build to its installed to do this.

23:34.680 --> 23:38.200
I mean it might not be worse than the current situation with Drake and things like that but

23:38.200 --> 23:43.360
in some ways it is because you now need signing tools and things like this.

23:43.360 --> 23:52.000
But certainly both of these models are certainly in focus of what we should do I think.

23:52.000 --> 23:56.120
So the ultimate vision is there that yeah distributions in their install are to figure

23:56.120 --> 23:57.280
out is there a local TPM.

23:57.280 --> 24:01.800
I mean not all systems have TPMs in particular like ARM based they have other stuff but not

24:01.800 --> 24:07.640
TPMs and then the M's sometimes have them sometimes do not so we always have to work

24:07.640 --> 24:10.960
with the fact that TPMs might be there might not be there but the goal is certainly that

24:10.960 --> 24:14.760
if one is there we should lock to that by default.

24:14.760 --> 24:20.240
Locking to that by default doesn't mean non-interactive stuff exclusively it means yeah we can do

24:20.240 --> 24:23.840
non-interactive stuff but also mean you can combine it still with a pin.

24:23.840 --> 24:29.040
A pin is the exact same thing as a passphrase except that TPM people call it a pin.

24:29.040 --> 24:31.600
It doesn't imply a number or anything yeah.

24:31.600 --> 24:39.560
So the goal is to always encrypt the data when it's at rest and yeah we validate the

24:39.560 --> 24:43.760
boot process when we unlock things though so that we make sure that the right software

24:43.760 --> 24:46.280
at the right time and other conditions.

24:46.280 --> 24:51.560
Yeah and the goal is to install things by default that way.

24:51.560 --> 24:56.120
And then yeah I want that measurements are further done during for all facets of the

24:56.120 --> 25:01.760
system like not just for the boot code also for the OS itself for the applications for

25:01.760 --> 25:05.200
the configuration itself right like these for example measurements that are inherently

25:05.200 --> 25:09.440
local always because configurations always kind of local thing even if my mother would

25:09.440 --> 25:13.840
use her machine she probably would configure different backgrounds than somebody else.

25:13.840 --> 25:18.080
Backgrounds color is a shitty example because you probably don't need to measure that but

25:18.080 --> 25:20.360
still you get the idea.

25:20.360 --> 25:25.600
System identity by that I mean things like hostname machine stuff should probably also

25:25.600 --> 25:29.440
be measured so that you can use it in policies and can say yeah I want to have the secret

25:29.440 --> 25:33.680
that only is released on that machine and none on others.

25:33.680 --> 25:38.840
I want to see that these basic building blocks like the PCRs but also the policies generated

25:38.840 --> 25:43.280
of it out of it are automatically managed by the West because this is not entirely trivial

25:43.280 --> 25:47.400
right like because every time you update the West any component of a boot loader UKI or

25:47.400 --> 25:52.480
things like that you have to regenerate like you have to re predict what the PCRs are going

25:52.480 --> 25:56.920
to be in the next boot and then do something about that because you still want that when

25:56.920 --> 26:02.880
the system boots up next the disk encryption shall be released but not on other conditions

26:02.880 --> 26:06.480
so there's some extra work where you when you update something you need to predict the

26:06.520 --> 26:08.440
PCRs and do something with it.

26:08.440 --> 26:13.440
We'll talk about this hopefully later but let's see how much time we have.

26:13.440 --> 26:17.880
The result of this of course comprehensive code integrity the inner dirty gap is closed

26:17.880 --> 26:21.720
we are ready for remote attestation that's also kind of goal that remote attestation

26:21.720 --> 26:29.720
works I think I mean it's good for some cases if you actually run more than one system I'm

26:29.720 --> 26:33.600
pretty sure it's not so interesting for regular people themselves but we should at least be

26:33.600 --> 26:38.040
ready for this and that the stuff is that we have the building blocks ready so that

26:38.040 --> 26:43.840
people can use the TPM in any ways they want and we give them already building blocks for

26:43.840 --> 26:49.160
defining their policy on their own encrypted objects based on the state of the operating

26:49.160 --> 26:53.800
system because right now they're kind of lost in this and the result is that it's somewhat

26:53.800 --> 26:56.920
democratic because people can just do this on their own laptop and do not necessarily

26:56.920 --> 27:01.640
like get a high level of security of code integrity without necessarily getting the

27:01.680 --> 27:04.080
key sign by Microsoft.

27:04.080 --> 27:09.400
So to make all this any questions at this point so.

27:09.400 --> 27:12.560
Does division cover KXAC?

27:12.560 --> 27:19.840
That's a very specific and good question so KXAC is a big problem and like in the project

27:19.840 --> 27:24.200
that I work at Microsoft it's also a big problem.

27:24.200 --> 27:30.640
I have ideas how to deal with that but frankly we have so many problems we have to fix before

27:30.680 --> 27:35.720
we can fix that one too that I don't think that's gonna be fixed anytime soon right

27:35.720 --> 27:39.880
like but I have a pretty good idea what we probably should do with KXAC because KXAC

27:39.880 --> 27:43.720
for those who don't know KXAC is a thing where you basically boot one operating system and

27:43.720 --> 27:47.440
then while the operating system is running you decide you want to run another operating

27:47.440 --> 27:51.160
system usually new version of the operating system so you execute the new kernel.

27:51.160 --> 27:55.400
Now suddenly you didn't reboot so the DPM didn't get reset so all the PCR values will

27:55.400 --> 27:59.080
still have all the measurements from the first operating system and then the second operating

27:59.120 --> 28:03.880
system starts and the PCR measurements the PCR values just get added to that on top and

28:03.880 --> 28:08.800
then all your policies fall flat because they were predicted assuming that you started zero.

28:08.800 --> 28:13.280
So this creates a problem but I think we can deal with it like having a handover of secrets

28:13.280 --> 28:18.600
that are predicted that moment where you're about to start this up but let's not talk

28:18.600 --> 28:23.400
about that since it's highly specific for like we have way too much material before

28:23.400 --> 28:27.880
we start talking about KXAC.

28:27.880 --> 28:29.880
Any other questions at this point?

28:29.880 --> 28:31.880
Next question.

28:31.880 --> 28:43.880
So from my understanding if you had your computer that you've predicted all the values on if

28:43.880 --> 28:46.880
I was to take that drive and put that drive into another machine that said enterprise

28:46.880 --> 28:53.880
and I bought 100 of these laptops is there some kind of unique seed per machine or would

28:53.880 --> 28:58.880
it go oh this is functionally the same machine it has the same device tree it has the same

28:58.880 --> 29:01.880
hardware I'm going to unlock.

29:01.880 --> 29:09.880
The TPM generally contains like an encryption key that's specific to the TPM so no you cannot

29:09.880 --> 29:14.880
unlock the encryption key that you prepare for machine A on machine B I mean unless you

29:14.880 --> 29:19.880
have the same keys like the seed keys in the TPM but then yeah everything's out of the

29:19.880 --> 29:25.880
control and you don't have a TPM you have bullshit on your hands.

29:25.880 --> 29:27.880
Okay let's continue.

29:27.880 --> 29:33.880
So to make this all reality I'm the system guy so yeah that's what I'm talking about is all

29:33.880 --> 29:35.880
system stuff.

29:35.880 --> 29:39.880
We added different components these different components have shown up in the various distributions

29:39.880 --> 29:46.880
interestingly I find that different distributions adopted different parts of all this big tool set

29:46.880 --> 29:52.880
first so I think at this point there are very few distributions that adopted them all but there's

29:52.880 --> 29:56.880
at least one distribution that adopted each one of them individually.

29:56.880 --> 30:02.880
So I want to system reboot it's like we call it a boot lower it's actually not a boot lower it's a boot menu

30:02.880 --> 30:07.880
it's just a UFI program that allows you to select a different like a set of kernels and then chain loads

30:07.880 --> 30:13.880
those kernels it doesn't do anything fancy it doesn't have any understanding of how to load a kernel into memory

30:13.880 --> 30:22.880
and prepare it it doesn't do cryptography or anything like this it's just a dumb menu that xx other stuff.

30:22.880 --> 30:28.880
But it has nice properties because it takes inspiration from how Linux does drop-in directories like with

30:28.880 --> 30:36.880
RPM and DPKG there's this established pattern that you can extend other RPMs and DPKGs via drop-in files

30:36.880 --> 30:43.880
and directories so we took this idea and said okay new boot menu items are simply files that you drop in directories

30:43.880 --> 30:51.880
and as you install a new kernel you just drop in a file in a directory and that makes one new menu item show up.

30:51.880 --> 30:56.880
This is inherently different like how Grub works because in Grub you always have these boot scripts that need to be generated

30:56.880 --> 31:02.880
based on whatever you find and things like this this is much much simpler because it's just there's one file per kernel

31:02.880 --> 31:09.880
you find it and that's a boot menu item there you go. So that's one thing there's also system you stop.

31:09.880 --> 31:15.880
System you stop is a UFI bootstuff it's basically a little UFI program that you glue in front of a Linux kernel

31:15.880 --> 31:21.880
it runs in UFI mode does a couple of preparatory steps and then jumps into the actual kernel proper.

31:21.880 --> 31:31.880
These preparatory steps we'll discuss a little bit later but it's measurements and finding certain sidecars if you want them.

31:31.880 --> 31:38.880
So usually like in my perfect model where you use all these components the boot process is basically that the firmware invokes

31:38.880 --> 31:45.880
system to boot and then in system to boot you pick one kernel or automatically the newest kernel is picked and that then gives control to the

31:45.880 --> 31:50.880
stub inside of the kernel image and then that thing does a couple of things and gives control to the kernel inside of it

31:50.880 --> 31:56.880
which already has the init-rd loaded and then you jump to the init-rd so much about the boot path.

31:56.880 --> 32:06.880
Uki-fi or I don't know how we pronounce that you haven't really agreed on the pronunciation yet but it's a tool basically that allows you to build

32:06.880 --> 32:14.880
UKIs it takes a couple of different components glues them together can sign them from SecureBoot can do PCR predictions

32:14.880 --> 32:23.880
and spits out one EFI binary which you then can drop in your ESP. There's a tool called system demasher probably by this time you don't

32:23.880 --> 32:32.880
have to interact with it anymore because Uki-fi does it for you all it does it does that PCR prediction step for all the stuff that is

32:32.880 --> 32:41.880
contained in a UKI basically so you can run it and basically it tells you if you boot that UKI PCR 11 is going to be this value and then you

32:41.880 --> 32:48.880
can use that for policy but usually you don't have to interact with that anymore because Uki-fi is probably the tool you should be using

32:48.880 --> 32:54.880
and that calls it in the background so you don't have to bother. There's a thing called kernel install in system retweet.

32:54.880 --> 33:04.880
It used to be shell script but nowadays it's actually a proper program. Its job is to I mean Fedora has been using for a while other distributions are

33:04.880 --> 33:12.880
catching up I guess but the idea is basically that if the package manager drops its file in slash user and slash user is package

33:12.880 --> 33:23.880
manager then kernel install will take these and copy the kernel itself into the ESP to make the system bootable. So that you basically monopolize

33:23.880 --> 33:32.880
the OS vendor resources managed by the package manager and slash user and if you copy it into anything else like the ESP which is a shared

33:32.880 --> 33:40.880
location like it's not owned by the OS vendor it's owned by the system if you will and OS's just get the privilege to all drop something in there

33:40.880 --> 33:47.880
and the kernel is told to do this. The reason why you need something that's better than the CP is usually that you want to do a couple of things when you do this

33:47.880 --> 33:56.880
like create, I don't know, run MopPro, do a couple of other things. We have support even to generate the UKI at that step right so that you install on the system

33:56.880 --> 34:05.880
like a traditional kernel but locally it gets converted to UKI as you go and sign and things like that so that you basically can keep the old workflow in place how

34:05.880 --> 34:12.880
distributions generated in RIDs even and things like that but you end up in the new world with the UKI that is signed by your local key automatically

34:12.880 --> 34:20.880
without you even thinking about this. Other components, there is MKOS in RID, I'll ask a question.

34:21.880 --> 34:38.880
On the previous slide you mentioned, on the previous slide you mentioned system debuts, STUB measures the UKI. What measures system destub because you have...

34:38.880 --> 34:49.880
The firmware. So the stuff that I'm talking about system debuts, system destub, they are ultimately UFEI binaries and the firmware measures everything right so there's a full chain, the firmware does that part

34:49.880 --> 35:01.880
and then we like actually you know because system destub is just glued in front of the kernel to make the UKI which is a PE binary, actually the stuff that is in the UKI is already measured anyway by the

35:01.880 --> 35:18.880
firmware. The reason why we also measure the stuff ourselves a second time which sounds redundant is simply that PCRs, we have multiple of these and we want some separation of the stuff that...

35:18.880 --> 35:33.880
So there's one PCR basically, nine I think, where all the firmware stuff gets measured into AND the stuff right so there's going to be stuff that is specific to the local machine as well as the stuff that we as the OS vendor or whatever you want to call distributions

35:33.880 --> 35:46.880
and then we measure the control as measured into the same PCR and that basically makes the whole thing unpredictable. So we measure the second to the time just the stuff from the OS vendor into another PCR so that's what we combine the policy to.

35:46.880 --> 35:52.880
So that's why you have the double thing, it's two different PCRs.

35:53.880 --> 36:08.880
So MKSI, there's going to be another talk about this as basically a tool how you can build predictable reproducible in a D from generic Linux distributions and then make them ready for use in UKIs.

36:08.880 --> 36:20.880
The system you could set up is basically just a wrapper around like lip crypts up and it does a couple of these integrations, TPMs, FIDO and these kind of things and policy management and things like this.

36:20.880 --> 36:26.880
System decrypt and roll is the other side that allows you to enroll the TPM and roll the FIDO thing locally.

36:26.880 --> 36:40.880
System decrat is something, if we have the time we'll talk about it a little bit more later, it's basically, you know, if you have this vendor build UKI you might still want to be able to parameterize it, right?

36:40.880 --> 36:50.880
There's a reason why Inodore D generators the traditional way mix code from the West plus configuration into one CPIO Inodore D image.

36:50.880 --> 36:55.880
It's because people want to parameterize things. So parameterization is problematic, right?

36:55.880 --> 37:00.880
Like because it means things are not predictable anymore. Also you need to authenticate it again, right?

37:00.880 --> 37:02.880
Like that's what we want to come to.

37:02.880 --> 37:07.880
So the concept they came up with to fix this thing is called system decredentials.

37:07.880 --> 37:13.880
System decredentials are like ultimately they are way how you can pass secrets into system dec services.

37:13.880 --> 37:17.880
They have nothing, originally had nothing to do with the boot process.

37:17.880 --> 37:24.880
It's supposed to be like, you know, all these, the cloud people they love passing secrets in environment variables.

37:24.880 --> 37:29.880
I think that's a terrible idea because that gets inherited down the process tree.

37:29.880 --> 37:32.880
So this is supposed to be something better in that regard.

37:32.880 --> 37:37.880
So one of the nice things that system credentials actually has is that they can be encrypted, right?

37:37.880 --> 37:41.880
Like you can encrypt them and bind them to a TPM and local policy and things like that.

37:41.880 --> 37:46.880
This is extremely useful because it basically means that these credentials you can put them on untrusted territory,

37:46.880 --> 37:50.880
meaning the UFI ESP which has no authentication itself.

37:50.880 --> 37:58.880
It's an unprotected VFAT file system where basically the rule is the stuff that you read from the ESP you need to authenticate before you use it.

37:58.880 --> 38:07.880
So you can just drop these credentials in there and be reasonably safe that the contents of them cannot be read.

38:07.880 --> 38:09.880
What's the use case for things like that?

38:09.880 --> 38:17.880
Like for example, if you have a UKI with an inner ID and you actually want to make it open so that you can log into the inner ID with root password to debug things,

38:17.880 --> 38:21.880
you can stick that in an assistant decredential put in the ESP next to the UKI,

38:21.880 --> 38:25.880
how that actually works, we'll hopefully still find the time later to look into this.

38:25.880 --> 38:30.880
And be sure that this thing, because it's bound to the local TPM, is not accessible,

38:30.880 --> 38:35.880
like the root password is not accessible to anything, but that specific system and things like that.

38:35.880 --> 38:39.880
So system decred is kind of an approach for local parameterization.

38:39.880 --> 38:41.880
It's an option though.

38:41.880 --> 38:46.880
It's not like, I would assume that in most of the consumer kind of things you would never use this,

38:46.880 --> 38:49.880
but it needs to be there because some people want something like this.

38:49.880 --> 38:52.880
There's no restrictions on what you actually encode with this.

38:52.880 --> 38:59.880
It could also be, I don't know, ISCSI server data or HTTPS, like X5 or 9 certificates or something like this.

38:59.880 --> 39:01.880
Another thing is system is sys-axed, right?

39:01.880 --> 39:11.880
Like if you have predictable inner IDs, this of course means that they will come by default with a very clearly defined set of criminal model you was built in.

39:11.880 --> 39:13.880
This is restrictive, right?

39:13.880 --> 39:18.880
Because people nowadays have NVIDIA drivers, which are like hundreds of megabytes.

39:18.880 --> 39:27.880
If you want to make the system work well with all the current consumer hardware, you will have a massive inner ID.

39:27.880 --> 39:30.880
That might be something people want to avoid.

39:30.880 --> 39:37.880
So on one hand, we kind of push everybody to say, put everything in one file and the world will be a better place,

39:37.880 --> 39:45.880
but on the other hand we also know that this is probably not necessarily doable for all environments because these files will get massively used.

39:45.880 --> 39:48.880
They will work perfectly if you know your system.

39:48.880 --> 39:53.880
For example, if you just focus on Azure cloud stuff, right?

39:53.880 --> 39:56.880
Then you know exactly the drives you need. You can build a tiny UKI. It's all good.

39:56.880 --> 40:02.880
It's going to be entirely generic for Azure, but you could probably even cover multiple clouds in one UKI.

40:02.880 --> 40:04.880
It's still going to be small, all great.

40:04.880 --> 40:10.880
But once you get into the wide world where all kind of shit exists, it might be too limiting.

40:10.880 --> 40:12.880
So we thought about this.

40:12.880 --> 40:16.880
Once we came up with the system, we also had a different use case.

40:16.880 --> 40:22.880
Originally it was mostly focused on system, but we can use it great for modularizing inner ID to some point.

40:22.880 --> 40:26.880
So the idea basically is system is system extension.

40:26.880 --> 40:33.880
It's basically a disk image, a GPT disk image that contains a traditional Linux file system, usually something like squashFS,

40:33.880 --> 40:39.880
EROFS plus a signature for the variety partition.

40:39.880 --> 40:48.880
Variety for those who don't know, it's a, like DM variety is like a kernel concept for adding integrity protection to immutable file systems.

40:48.880 --> 40:53.880
So basically that, like it was like the first user of this was Chromebooks back in the day.

40:53.880 --> 41:01.880
I mean it's old now, but it basically says that on every sector access of the file system,

41:01.880 --> 41:05.880
you do make sure that it's actually authentic.

41:05.880 --> 41:12.880
It's a fantastic technology and we can use it to have these disk images that are, when you enable them,

41:12.880 --> 41:15.880
overlaid on top of slash user.

41:15.880 --> 41:23.880
So suddenly you get a certain level of modularity where the basic identity has slash user populated with lots of stuff,

41:23.880 --> 41:30.880
but you can add a couple of other things into it by adding a couple of systems to the system, which are just overlaid.

41:30.880 --> 41:32.880
Overlaying is basically overlayFS.

41:32.880 --> 41:42.880
It's really nice because it's atomic, it's cheap to do, and ultimately nothing new about it, it's just regular GPT disk images.

41:42.880 --> 41:49.880
So this is me, contract is actually the same idea, but it's about overlaying things on top of Etsy instead of slash user.

41:49.880 --> 41:56.880
Also with all the integrity, cryptography, things like this, but it's really nice because in contrast to the credentials

41:56.880 --> 42:04.880
that focus on individual bits of secrets, the system in contracts focuses on combination of stuff.

42:04.880 --> 42:11.880
Like you can drop 55 configuration files into one of these contracts, and these contracts either are applied or they're not applied.

42:11.880 --> 42:13.880
They're never half applied.

42:13.880 --> 42:21.880
You cannot use them out of context, hence, because either you get all of these files dropped into Etsy or appear in Etsy,

42:21.880 --> 42:23.880
or none of them.

42:23.880 --> 42:27.880
Honestly, contracts in my point of view is actually like the perfect configuration management tool,

42:27.880 --> 42:35.880
and everybody should just use that and stop using all the weird, Ansible Chef things because they do not have these nice security

42:35.880 --> 42:41.880
or atomicity properties, and the security and atomicity properties are just awesome.

42:41.880 --> 42:43.880
Another component, system in PCR lock.

42:43.880 --> 42:46.880
So I talked a lot about the predictability of the PCRs,

42:46.880 --> 42:51.880
but so the way how you actually lock disk secrets to PCR is basically you say,

42:51.880 --> 42:56.880
this PCR has to have that value, that PCR has to have that value, and that's all the case.

42:56.880 --> 43:02.880
You tell the TPM, you will release your encrypted secret to the West so that full disk encryption can work.

43:02.880 --> 43:05.880
But now you need some infrastructure to do the prediction for this.

43:05.880 --> 43:10.880
System in PCR lock is that infrastructure that we added to do this prediction.

43:10.880 --> 43:16.880
Basically, it manages a set of components that you assume are part of the boot.

43:16.880 --> 43:22.880
Then it does some magic, figures out if that's actually true, if that actually matches the reality so far,

43:22.880 --> 43:28.880
and then calculates a TPM policy, it's how it's called, from that, which says, OK,

43:28.880 --> 43:34.880
we will now create a policy that basically says if you use that policy to lock down secrets,

43:34.880 --> 43:38.880
then you have to have this firmware component in this version.

43:38.880 --> 43:43.880
You have to have this bootloader version in this version, and this UKI in this version,

43:43.880 --> 43:47.880
and a couple of other components that might be part of the boot, and it allows alternatives.

43:47.880 --> 43:53.880
Because usually if you update a kernel, you do not just want to say the new kernel is now the only one you can boot,

43:53.880 --> 43:57.880
you want to still allow the old kernel, the preceding kernel, to boot.

43:57.880 --> 44:01.880
You want this concept of alternative options for every step.

44:01.880 --> 44:04.880
So firmware updates the same thing.

44:05.880 --> 44:10.880
If you prepare a firmware update, and it fails, you have to boot up with the old firmware in place.

44:10.880 --> 44:13.880
If your policy says no way, then you have a problem.

44:13.880 --> 44:16.880
So you always need this kind of alternative system.

44:16.880 --> 44:18.880
So that's what System.UPCI-Rlock does.

44:18.880 --> 44:22.880
This policy is like, all the operating systems have a prediction,

44:22.880 --> 44:26.880
like all the other ones, like Windows, Chromebook, they all have prediction engines like this.

44:26.880 --> 44:30.880
We have the luxury that we come 15 years later than anybody else with this.

44:30.880 --> 44:35.880
So we can actually rely on newer types of TPM functionality, because we can start from zero now,

44:35.880 --> 44:42.880
instead of having to be compatible with the original TPM2 stuff that is really old by now.

44:42.880 --> 44:44.880
So we actually can do nicer things.

44:44.880 --> 44:48.880
We can actually store these policies in the TPM itself.

44:48.880 --> 44:57.880
The traditional way how BitLocker and Windows does it, for example, is that they store these policies in the BitLocker superblock on disk.

44:58.880 --> 45:05.880
Storing this stuff in the TPM is much nicer, because it basically means that you can have 500 different disks,

45:05.880 --> 45:09.880
and when you do your PCR predictions, you do not have to touch them.

45:09.880 --> 45:12.880
You do not have to go through every single disk and rewrite the superblock,

45:12.880 --> 45:16.880
but it's entirely sufficient to store some slightly different value in the TPM.

45:16.880 --> 45:20.880
That's a fundamental benefit, like improvement over what Windows can do,

45:20.880 --> 45:23.880
because we have the luxury that we are so late to the party.

45:24.880 --> 45:26.880
Any questions at this point?

45:26.880 --> 45:32.880
I only got like 10 minutes left, so if you have questions, this is the time to start asking.

45:32.880 --> 45:36.880
If you do not have questions, I'll continue with parameterization, modelarization.

45:36.880 --> 45:38.880
Which we actually kind of covered already.

45:38.880 --> 45:40.880
No one has questions.

45:40.880 --> 45:44.880
So, yeah, I mentioned already pre-building UKIs and alreadys are problematic,

45:44.880 --> 45:48.880
because they are identical and that makes them large.

45:49.880 --> 45:52.880
And you kind of parameterize them anymore.

45:52.880 --> 45:59.880
So, there's optional parameterization of the UKIs that breaks up the fact that they are one big thing.

45:59.880 --> 46:05.880
Our way of mentioning system-deserved credentials, like system-de-creds, encrypted,

46:05.880 --> 46:10.880
and individual bits of information, and then there are system-de-confects,

46:10.880 --> 46:15.880
which is the overlay thing on Etsy, which is like combinations of configuration.

46:15.880 --> 46:18.880
And the third one, which I have not talked about yet, is,

46:18.880 --> 46:22.880
but there was a talk yesterday in the VM mini-conf about this.

46:22.880 --> 46:25.880
It's kernel command line add-ons, right?

46:25.880 --> 46:29.880
Because one of the fundamental ways how you configure your learning system

46:29.880 --> 46:31.880
is by making additions to the kernel command line.

46:31.880 --> 46:37.880
Now, in all the stuff that I was talking about, the idea is, yeah, you don't get to do that, right?

46:37.880 --> 46:41.880
Because it's the most powerful thing in the world,

46:41.880 --> 46:44.880
because you can do in it as an agent, do whatever you want, right?

46:44.880 --> 46:46.880
So, we lock that down, right?

46:46.880 --> 46:49.880
Like, if you're in secure boot mode and you use that kind of stuff,

46:49.880 --> 46:52.880
yeah, you don't get to edit that, because security policy doesn't allow that.

46:52.880 --> 46:55.880
That, of course, doesn't necessarily fly with everybody.

46:55.880 --> 46:56.880
People hate that, right?

46:56.880 --> 46:59.880
Like, people want to be able to do this, but they want to have controls on this.

46:59.880 --> 47:04.880
One of the things that we came up with, like this guy over there came up with,

47:04.880 --> 47:07.880
is kernel command line add-ons.

47:07.880 --> 47:13.880
Add-ons is what we call basically, you build a UKI,

47:13.880 --> 47:16.880
but actually leave the kernel out and the NRAD out and everything else out.

47:16.880 --> 47:18.880
You just put the kernel command line in there.

47:18.880 --> 47:24.880
So, you have the UFIPE binary that looks exactly like a UFIPE binary,

47:24.880 --> 47:27.880
but you can't actually boot it because it doesn't actually contain any code.

47:27.880 --> 47:29.880
But what it contains is a kernel command line.

47:29.880 --> 47:30.880
Why would you do such a thing?

47:30.880 --> 47:37.880
It's because you can authenticate them and measure them like any other kind of binary that UFI deals with.

47:37.880 --> 47:40.880
Or actually, not you can do this, but the firmware will do it for you,

47:40.880 --> 47:42.880
because you can just tell the firmware,

47:42.880 --> 47:44.880
oh, I'm going to work with this binary now, please load and authenticate it,

47:44.880 --> 47:46.880
and then it will do this for you.

47:46.880 --> 47:48.880
Do measuring, dance, all in the background, you don't have to care.

47:48.880 --> 47:52.880
Because after all, SD boot and things like that are just a stupid boot menu

47:52.880 --> 47:54.880
with no understanding of loading and authenticating anything.

47:54.880 --> 47:56.880
And that's how it should be, right?

47:56.880 --> 47:59.880
Like, we want our boot pass to be stupid and not replicate, like,

47:59.880 --> 48:02.880
with Schimel and these kind of things, all the authentication over and over again.

48:02.880 --> 48:05.880
So, add-ons are basically a way how you can, yeah,

48:05.880 --> 48:10.880
sign a little kernel command line and then you can extend the one that is built in the UKI

48:10.880 --> 48:14.880
and then modulate away so that you can have one UKI and a couple of these add-ons that are,

48:14.880 --> 48:18.880
extend this thing and with proper authentication.

48:21.880 --> 48:24.880
Modularization, I mentioned this already with System DesistEx,

48:24.880 --> 48:29.880
yeah, because of NVIDIA drivers in particular, because they're massive firmwares,

48:29.880 --> 48:31.880
we have to do something.

48:31.880 --> 48:35.880
So, I mentioned these things, add-ons, system extensions, credentials,

48:35.880 --> 48:38.880
and config extensions like ConfaxSys, stuff.

48:38.880 --> 48:40.880
We call them sidecars, right?

48:40.880 --> 48:43.880
Like, because you have the unified kernel, but then it's not so unified,

48:43.880 --> 48:45.880
you have these things as well in there.

48:45.880 --> 48:47.880
How to manage those?

48:47.880 --> 48:51.880
So, the general idea is to extend this drop-in concept, right?

48:51.880 --> 48:55.880
Like, so that you have the UKI and you put next to it a directory where you put all these add-ons.

48:55.880 --> 48:57.880
So, how does it actually look?

48:57.880 --> 49:02.880
In the ESP, you put the UKI in the directory EFI Linux,

49:02.880 --> 49:08.880
and next to it, you have a sub-directly called exactly like the UKI with a suffix Xter.d,

49:08.880 --> 49:12.880
and there you put cred files for the credentials or confax.raw,

49:12.880 --> 49:22.880
that's the suffix we picked for confax.ddis, or sysex.raw and addon.efi, the EFI, those are the P.E. add-ons.

49:22.880 --> 49:26.880
So, it's simply relatively simple, right?

49:26.880 --> 49:34.880
You lose some of the extreme sexiness of the approach, which is updates and things like that are not single file anymore,

49:34.880 --> 49:39.880
but that's on you, I guess, if you actually make use of this functionality.

49:39.880 --> 49:40.880
So, this is all optional.

49:40.880 --> 49:49.880
Like, the focus, I think if you know your hardware, if you know the environment you want to run your stuff in, don't bother, right?

49:49.880 --> 49:55.880
So, I think that's a good side, like, just focus on the UKI's one kernel and everything simple and robust and idiot-proof and things like that.

49:55.880 --> 50:03.880
We've got like five minutes left, let's focus more on questions.

50:03.880 --> 50:10.880
Alright, so, taking a scenario like you just said, where you don't know what the hardware is,

50:10.880 --> 50:18.880
how's your vision of, okay, how do all these sidecars get selected, indicated, put in there?

50:18.880 --> 50:19.880
That's a very good question.

50:19.880 --> 50:25.880
That's not something I imagine you want like an RPM distro to be dumping stuff in there, but what should we do?

50:25.880 --> 50:28.880
That's a really good question, and there's actually two new list items about this in SystemDTree.

50:28.880 --> 50:36.880
I'm not sure how many people have seen that, but so, you know, in UDEV, in SystemDT in UDEV, we have already this concept,

50:36.880 --> 50:40.880
how we can automatically determine which kernel drivers to load on which machine, right?

50:40.880 --> 50:42.880
Like, it's called mod alias.

50:42.880 --> 50:47.880
It's basically like for PCI devices and USB devices, the vendor product that you turned into a string

50:47.880 --> 50:51.880
and then having a mapping database that maps that to the actual K mod to load.

50:51.880 --> 50:56.880
And nowadays, there's all kinds of mod alias for SM bias and things like that.

50:56.880 --> 51:04.880
So, we have this already, right, and there is infrastructure to have a database that we use it as input

51:04.880 --> 51:07.880
and you get kernel module information as output.

51:07.880 --> 51:14.880
And there's another database, the HW database, where you use these strings as input and you get UDEV properties as output.

51:14.880 --> 51:17.880
So, to me, that's what you should just use, right?

51:17.880 --> 51:24.880
So, a distribution that figures out how to split things up, like they would have one 6-6-6-x for NVIDIA drivers,

51:24.880 --> 51:27.880
one for AMD drivers and things like that.

51:27.880 --> 51:33.880
And then you would just maintain this in HWDT, basically, where you match against vendor product,

51:33.880 --> 51:36.880
add in and then specify the thing.

51:36.880 --> 51:43.880
And then we should have some tool that helps you figure that out and then probably should turn it into RPM command lines

51:43.880 --> 51:47.880
if you are RPM based distribution or in something equivalent, right?

51:47.880 --> 51:49.880
Like that's distribution material, yeah.

51:49.880 --> 51:53.880
But I think just using the mod alias stuff, perfect solution for this.

51:53.880 --> 52:01.880
It solves exactly that problem except that now it's not just one K mod, it's just a 6-6 that you pick up.

52:02.880 --> 52:11.880
Okay, so just for me to understand something, so system debut would be able to parse the add-ons and show you a similar menu to do.

52:11.880 --> 52:20.880
So, how can you start to choose something from the add-ons because I assume that the add-on will have multiple commands boot options, for example.

52:20.880 --> 52:27.880
Okay, so the whole command line stuff is still working, probably we'll have more stuff later that hooks that up with the menu.

52:27.880 --> 52:35.880
But right now the way it works basically is you drop in one kernel and you put the add-ons next to it and it's not as debut that has any understanding of this.

52:35.880 --> 52:41.880
As debut only finds the main UKI and turns it into an entry and then boot it eventually.

52:41.880 --> 52:48.880
But it's SD stub, right? Like this early code that is glued in front of the UKI that then sees, okay, I got invoked.

52:48.880 --> 52:50.880
Let's see, in which directory did I get invoked?

52:50.880 --> 52:56.880
Let's see if that has the sub-directory stuff and then loads everything that's in between that, right?

52:56.880 --> 53:03.880
So right now it's, you pick the UKI and that pins basically all the stuff next to it.

53:03.880 --> 53:06.880
So what you're asking for basically is that it shows up in the boot menu.

53:06.880 --> 53:14.880
We have been discussing this for a while and everybody agrees we should do this, we just haven't done it yet and well, we don't actually know how it precisely will look like.

53:14.880 --> 53:22.880
But the idea basically is that sooner or later we want to be able to not embed a single kernel command line into your UKI but a choice of them, right?

53:22.880 --> 53:30.880
So one is going to be the default one if nobody picks anything and this would then basically mean that, yeah, if SD boot finds one of these UKIs in the directory,

53:30.880 --> 53:42.880
it generates one menu item per kernel command line so that you basically have one UKI where you can select the factory set choice or the debug choice or the regular choice.

53:42.880 --> 53:51.880
And it, yeah. So everybody agrees that's the way to go, nobody does it. It's really high on my to-do list.

53:51.880 --> 54:01.880
Any last question? How much? Do we still have a minute or something?

54:01.880 --> 54:04.880
Are these like system extensions, credential extensions only?

54:04.880 --> 54:05.880
Sorry, I don't understand where.

54:05.880 --> 54:10.880
Sorry, are these extensions only useful in the case when you haven't enrolled your own machine owner key?

54:10.880 --> 54:14.880
Like, or is there still an advantage like so obviously these are going to be signed upstream.

54:14.880 --> 54:22.880
But if you've enrolled your own machine owner key, is the better approach or do you approach now just to build your own UKIs locally and take advantage of the secure boot there.

54:22.880 --> 54:25.880
In fact, did you have an authenticated NITRD?

54:25.880 --> 54:31.880
So I'm not sure I understood the full question but I answered it. It's about the machine owner key like the shim thingy.

54:31.880 --> 54:38.880
So all these components that I was just described have individual ways how they authenticate it, right?

54:38.880 --> 54:43.880
Like the add-ons because they're PE, UFI binary, okay my time's over.

54:43.880 --> 54:47.880
But basically let's, I'd like to finish the question.

54:47.880 --> 54:52.880
That's okay. So they are authenticated by a secure boot means, right?

54:52.880 --> 54:54.880
And that also means shim, right?

54:54.880 --> 54:56.880
Like so that's where the mock comes into control.

54:56.880 --> 55:02.880
The other ones are preferably authenticated by the kernel key ring stuff, right?

55:02.880 --> 55:05.880
Like we asked the kernel key ring to authenticate them.

55:05.880 --> 55:09.880
Now kernel key ring, populating that is a mess, right?

55:09.880 --> 55:12.880
Like because you can do it via the mock stuff, that works.

55:12.880 --> 55:16.880
But I think it's a mess that this is how it has to go, right?

55:16.880 --> 55:27.880
Ideally I would have the way how I can upload from user space a new kernel, like a couple of additional keys, so your local one, and then basically blow a fuse so that later nobody can do this, right?

55:27.880 --> 55:29.880
Like because that would be the democratic thing, right?

55:29.880 --> 55:35.880
So I would take a Fedora kernel and then in the early boot phase I can install an additional kernel and then nobody else can.

55:35.880 --> 55:37.880
And that's like for me, that's the perfect security.

55:37.880 --> 55:39.880
Well, we don't live in this area.

55:39.880 --> 55:44.880
But I added this concept that we can do authentication user space instead.

55:44.880 --> 55:49.880
Depending on security policies, the kernel might say no though, but on the kernel in assistive reasons they all say yes.

55:49.880 --> 55:51.880
You can mock, easy talk, the data is done.

55:51.880 --> 55:54.880
Yeah. Anyway, so, yeah.

55:54.880 --> 55:55.880
Thank you very much.

55:55.880 --> 55:56.880
Thank you very much.

