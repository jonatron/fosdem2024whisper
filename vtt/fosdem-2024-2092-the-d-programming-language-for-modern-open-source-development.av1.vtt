WEBVTT

00:00.000 --> 00:01.000
Hello.

00:01.000 --> 00:02.000
All right.

00:02.000 --> 00:03.000
Great to see everybody.

00:03.000 --> 00:12.840
See some familiar folks here.

00:12.840 --> 00:14.720
Just a quick show of hands here.

00:14.720 --> 00:17.720
How many folks have heard about the D programming language?

00:17.720 --> 00:20.000
Oh, wow, awesome.

00:20.000 --> 00:23.920
Keep your hand up if you've used the D programming language or tried it out.

00:23.920 --> 00:24.920
Okay.

00:24.920 --> 00:25.920
Yeah, I see you there, Dennis.

00:25.920 --> 00:26.920
Yeah.

00:26.920 --> 00:28.360
A few other folks here.

00:28.360 --> 00:29.360
Great.

00:29.360 --> 00:30.360
This is perfect.

00:30.360 --> 00:31.360
You're in the right space.

00:31.360 --> 00:32.360
We're going to have a lot of fun today.

00:32.360 --> 00:36.120
And I'm going to give you an introduction to the D programming language here.

00:36.120 --> 00:40.280
I'm not going to show you everything because the D programming language is a really large

00:40.280 --> 00:45.720
programming language, but hopefully enough to get you excited here.

00:45.720 --> 00:50.560
And ultimately to show you some open source projects where you can get some inspiration.

00:50.560 --> 00:54.680
So let's go ahead and get into it here.

00:54.680 --> 00:57.760
So again, it's been six years since my last Boston talks.

00:57.760 --> 01:02.720
I just want to thank the organizers for inviting me back and letting me talk again.

01:02.720 --> 01:05.080
So again, the goal today is just to have fun.

01:05.080 --> 01:09.960
You can kind of sit back, relax, have a good time and just learn about, again, what I think

01:09.960 --> 01:14.760
is really interesting programming language that's expanded my mind as far as how I think

01:14.760 --> 01:17.520
about programming.

01:17.520 --> 01:23.960
So with that said, hopefully I'll come back sooner than every six years.

01:23.960 --> 01:25.800
So a little bit about me.

01:25.800 --> 01:28.720
My primary role is to do teaching.

01:28.720 --> 01:31.680
So I'm an associate teaching professor.

01:31.680 --> 01:32.840
So I love teaching stuff.

01:32.840 --> 01:34.760
I do teach the D programming language.

01:34.760 --> 01:38.680
I'll talk about that towards the end or give you a reference for that.

01:38.680 --> 01:43.680
Otherwise, I'm really interested in other sort of performance systems, these stuff.

01:43.680 --> 01:45.360
Again, you folks are my crowd.

01:45.360 --> 01:49.080
So again, I'm really excited to be here with you.

01:49.080 --> 01:53.480
And with that said, here's the abstract, of course, that you read and led you here.

01:53.480 --> 01:58.760
Again, to get you excited about the D programming language.

01:58.760 --> 02:02.600
And any code that I have for the talk will be linked here.

02:02.600 --> 02:07.760
If it isn't already shortly after this talk, I'll post it.

02:07.760 --> 02:09.480
All right.

02:09.480 --> 02:15.200
So again, what I want to do today is, again, get you curious about a really, really cool

02:15.200 --> 02:16.600
open source project.

02:16.600 --> 02:22.120
Now that open source project happens to be the D compiler.

02:22.120 --> 02:26.080
In fact, all the D compilers that we're going to find out have the source code available.

02:26.080 --> 02:29.880
So how cool is it that you can actually look at a programming language that's been around

02:29.880 --> 02:35.440
for quite some time and see some really awesome work by some really smart engineers.

02:35.440 --> 02:40.240
So at the very least, I hope that's exciting for you that you will have some place where

02:40.240 --> 02:44.600
you can look or send other people to look and see how optimizations are done or code

02:44.600 --> 02:46.200
is written or organized.

02:46.200 --> 02:49.960
So again, I think that's in itself very interesting.

02:49.960 --> 02:55.760
And maybe one day you yourself might find yourself contributing to this compiler, this

02:55.760 --> 03:03.720
ecosystem, or find inspiration elsewhere for using this programming language.

03:03.720 --> 03:10.280
And again, my secret dream for you, if I do a good job during this talk, is to get you

03:10.280 --> 03:13.040
excited enough to say, yeah, I'm going to contribute.

03:13.040 --> 03:16.160
There's been some awesome videos on how to just do that.

03:16.360 --> 03:21.680
Again, a lot of the open source projects that we've seen today and we'll see tomorrow have

03:21.680 --> 03:22.680
these resources.

03:22.680 --> 03:26.840
So again, I just want to point out that those are available as well.

03:26.840 --> 03:31.800
So again, it's really cool to look through the source code of the D compiler, which is

03:31.800 --> 03:35.880
a very, very, very fast compiler for the D programming language.

03:35.880 --> 03:42.760
Okay, so with that in mind, with my interest out there on what I want you to get out of

03:42.760 --> 03:46.720
this, or maybe to get excited about, again, whether you're a student practitioner, somebody

03:46.720 --> 03:47.720
in industry.

03:47.720 --> 03:52.480
Again, we'll continue moving forward here.

03:52.480 --> 03:56.800
And as I'm talking about this, I do want you to know that I'm a bit of a programming language

03:56.800 --> 03:58.040
enthusiast myself.

03:58.040 --> 04:02.080
So I love using different programming languages.

04:02.080 --> 04:06.800
This has been a problem for me since I started programming, always looking and kind of moving

04:06.800 --> 04:11.600
around to different languages, seeing what was new, what kind of features.

04:11.600 --> 04:13.840
And honestly, I think there is some value in that.

04:13.840 --> 04:16.320
You get to see how different languages approach things.

04:16.320 --> 04:20.600
Actually, we were just at a previous talk on the Hector script talking about actor model

04:20.600 --> 04:25.320
and mutability, how parallel processes are organized.

04:25.320 --> 04:29.520
I think there's a lot of value in taking away some of those core concepts from different

04:29.520 --> 04:31.440
languages.

04:31.440 --> 04:38.800
So what I've been doing lately is, again, every few days now at this point, I've been

04:38.800 --> 04:43.720
just turning on my camera for an hour and live streaming myself, learning a programming

04:43.720 --> 04:46.360
language for the first hour or so.

04:46.360 --> 04:51.000
And you pick up interesting things from different languages.

04:51.000 --> 04:56.800
But just to be clear, the languages that I use professionally and teach most are C++

04:56.800 --> 04:58.080
and the D programming language.

04:58.080 --> 05:02.400
I'm always kind of thinking in terms of, oh, you know, Golang does it this way with their

05:02.400 --> 05:08.560
defer statement and D has scope, or oh, there's message passing in this language and this

05:08.560 --> 05:11.240
is how you do it in D in this way.

05:11.240 --> 05:16.160
So it's been a really interesting sort of experiment going through this process.

05:16.160 --> 05:21.320
And I'm thinking in the language that you ultimately, well, use.

05:21.320 --> 05:24.280
You kind of wire your brain a little bit sometimes.

05:24.280 --> 05:29.440
So that could be something kind of curious, again, looking at new languages, looking at

05:29.440 --> 05:35.240
languages that are popular, looking at languages that are maybe not so popular as well as far

05:35.240 --> 05:37.400
as mainstream.

05:37.400 --> 05:41.680
At the end of the day, what I hope one of your other takeaways will be is, you know,

05:41.680 --> 05:44.320
as we know, sometimes it doesn't matter what the language is.

05:44.320 --> 05:48.280
It's going to be what gives you a competitive advantage, what is fun for you to build software

05:48.280 --> 05:54.520
in, what is, you know, the tool that you can use to create something.

05:54.520 --> 05:59.800
So then my goal is not going to be to convince you today one programming language is better

05:59.800 --> 06:01.360
than the other.

06:01.360 --> 06:04.920
Even as I look at those programming languages, I try not to do that.

06:04.920 --> 06:05.920
I'm smarter than that.

06:05.920 --> 06:06.920
I think I am.

06:06.920 --> 06:09.400
We'll see if I slip today.

06:09.400 --> 06:13.720
You know, we sort of like our program languages and get used to it, right?

06:13.720 --> 06:14.720
We have our favorites.

06:14.720 --> 06:20.640
But again, I do want to share my enthusiasm for D, why it stands out, and why you might

06:20.640 --> 06:23.000
also have fun with it.

06:23.000 --> 06:26.880
So with that said, we're going to do that same little experiment that I've been doing,

06:26.880 --> 06:31.320
just turning the camera on for an hour, looking at a programming language for the first time,

06:31.320 --> 06:34.080
and just investigating some interesting parts of it.

06:34.080 --> 06:38.720
I hope that will get you curious about the different parts of the D programming language

06:38.720 --> 06:41.600
and again get you excited.

06:41.600 --> 06:46.080
And maybe, just maybe if I'm successful, and I looked around, I saw everybody who rose

06:46.080 --> 06:47.640
their hand and who didn't.

06:47.640 --> 06:49.520
We'll see more hands raised.

06:49.520 --> 06:50.520
What was it?

06:50.520 --> 06:52.760
Six years from now when I'm invited back.

06:52.760 --> 06:53.760
So anyways.

06:53.760 --> 06:54.760
All right.

06:54.760 --> 06:59.600
So I'll show you a few cool projects for inspiration.

06:59.600 --> 07:01.960
Most if not all are open source.

07:01.960 --> 07:06.000
The only ones that aren't are the scripts that I haven't put in my GitHub repo yet.

07:06.000 --> 07:08.240
So we'll be true by then to this top.

07:08.240 --> 07:10.640
And all something that you can learn from a specific feature.

07:10.640 --> 07:12.240
I'm a big proponent.

07:12.240 --> 07:17.400
Again, my background being in teaching in some industry, that we need to read more code

07:17.400 --> 07:21.880
as we're learning as well, because there's lots of smart engineers, you folks, writing

07:21.880 --> 07:24.280
that code and I want to learn from you.

07:24.280 --> 07:29.280
So with that said, we'll look at these projects all in the D programming language here.

07:29.280 --> 07:31.080
So let's go ahead and begin.

07:31.080 --> 07:36.040
I'm going to go ahead and start with something cool made in D. Why not get some inspiration

07:36.040 --> 07:37.840
to start this talk off.

07:37.840 --> 07:39.720
And here it is.

07:39.720 --> 07:42.600
A project that's built in the D programming language.

07:42.600 --> 07:43.600
TILIX.

07:43.600 --> 07:47.200
How many folks have used this terminal emulator?

07:47.200 --> 07:49.600
Yeah, I'm seeing a few hands go up here.

07:49.600 --> 07:53.280
Yeah, this is something I like to occasionally download and try out different ones.

07:53.280 --> 07:56.720
But to my surprise, I actually looked at the source code.

07:56.720 --> 08:00.320
One of my students actually told me TILIX is built in D. I didn't know that.

08:00.960 --> 08:03.520
So that was really cool what you find sometimes in the wild.

08:03.520 --> 08:06.600
But again, oftentimes as a user, you don't really care.

08:06.600 --> 08:09.720
Just a cool piece of software as an end user.

08:09.720 --> 08:14.800
But you get to see as a practitioner some of the cool tricks they do.

08:14.800 --> 08:19.360
So along with just showing you some different tools that have been built in the D programming

08:19.360 --> 08:26.080
language, I think it's important to say, well, why don't we care to look at this closer?

08:26.080 --> 08:29.800
So with all these slides here, again, I'm not going to ask you to read these or click

08:29.800 --> 08:30.800
on all the links.

08:30.800 --> 08:32.720
The slides will be available.

08:32.720 --> 08:37.280
But what you might be curious about or with this particular project, what's interesting

08:37.280 --> 08:40.200
is to see that, well, it's something that's very visual.

08:40.200 --> 08:45.560
And if you dig into the source code, it's using the GTK libraries.

08:45.560 --> 08:47.200
And those are C-based libraries.

08:47.200 --> 08:49.720
So how does D interface with C code?

08:49.720 --> 08:56.320
Well, the answer is D actually does a really, really nice job interfacing with C code.

08:56.320 --> 09:02.960
So if you are C programmers or have been using C, you can basically call directly your C

09:02.960 --> 09:06.720
functions in the D compiler.

09:06.720 --> 09:07.720
Easy as that.

09:07.720 --> 09:12.960
Now, of course, there are bindings and wrappers and other things that folks do with the D programming

09:12.960 --> 09:13.960
language.

09:13.960 --> 09:14.960
But that's nice.

09:14.960 --> 09:19.800
You get a head start by being able to use some of your C code or even C++ and Objective

09:19.800 --> 09:21.960
C. There's ways to squeeze stuff in.

09:22.400 --> 09:28.920
So I thought that was very neat, just looking at the main app file from this particular

09:28.920 --> 09:33.760
program to see the different libraries that they were bringing in and was it just straight

09:33.760 --> 09:36.280
C code or library?

09:36.280 --> 09:39.720
Some other neat things that I'm just going to trickle in some details about the D programming

09:39.720 --> 09:42.520
language as we go along here.

09:42.520 --> 09:47.880
There is something called import C, which is a really cool, well, it's effectively a

09:47.880 --> 09:50.040
C compiler built into D.

09:50.120 --> 09:56.320
So you can, on the command line, like you would with whatever your tool was, type in

09:56.320 --> 10:02.720
compiler, DMD, your D source files, and your C source files as well.

10:02.720 --> 10:03.720
So that's kind of neat there.

10:03.720 --> 10:08.120
Again, just giving you a head start if you're going to consider migrating to different programming

10:08.120 --> 10:12.880
language, which is a big decision to make if you already have some open source project.

10:12.880 --> 10:14.920
All right, so that's Tylix.

10:14.920 --> 10:15.920
That's kind of a fun one.

10:16.000 --> 10:20.080
I'm learning about how D can also play with C code.

10:22.080 --> 10:24.920
Okay, so let's just get a first impression of the D language.

10:24.920 --> 10:28.480
Again, pretend you're doing this experiment that I'm doing.

10:28.480 --> 10:34.960
You go into Google, you type in Dlang, and you go to the homepage, Dlang.org, and what

10:34.960 --> 10:35.960
do we see here?

10:35.960 --> 10:39.160
We'll actually see something that looks like this.

10:39.160 --> 10:44.480
I'm going to give everybody a minute or so to just look at this piece of code.

10:44.520 --> 10:45.480
There's a sample code there.

10:45.480 --> 10:48.000
And then I'll ask for some participation.

10:48.000 --> 10:51.680
We can make this interactive on the afternoon.

10:51.680 --> 10:57.600
But just take a look at this and let me know what you think it does or what's interesting.

10:57.600 --> 11:01.240
I'll take hands and get some volunteers here.

11:01.240 --> 11:03.240
I'll give everyone a minute to think about that.

11:14.480 --> 11:17.040
What's popping out there, folks?

11:17.040 --> 11:19.640
Give me a hand and then something out.

11:19.640 --> 11:20.640
Yeah.

11:23.640 --> 11:28.000
So the few things I see on the first line, the import is local to main.

11:28.000 --> 11:33.000
On the second one, there is an object-style notation for a string.

11:33.000 --> 11:38.160
On the third one, there is an enum for an array, so that one I don't get.

11:38.160 --> 11:42.320
Then there is this immutable keyword, which is interesting because it's doing a mutable

11:42.320 --> 11:46.560
operation on A, but then B is immutable, I guess.

11:46.560 --> 11:52.920
And MSG is apparently a program that you send to the compiler, so I suspect it emits something

11:52.920 --> 11:53.920
at the end of compilation.

11:53.920 --> 11:54.920
Okay.

11:54.920 --> 11:55.920
How many did I get?

11:55.920 --> 11:58.920
Yeah, so we got a good staff at it.

11:58.920 --> 12:00.760
I saw other hands going up here.

12:00.760 --> 12:04.480
There was one actually right behind, if you wanted to share.

12:04.480 --> 12:07.920
Yeah, it could be the same thing or to add on.

12:07.920 --> 12:14.720
It really looks like a C, next one, like a C+++, free plus, so I don't know why they

12:14.720 --> 12:18.920
gave a name D, but they could just keep it with the pluses.

12:18.920 --> 12:22.880
In a way, it's really kind of easily to read.

12:22.880 --> 12:29.720
If you know anything of C or family, you can easily jump in and just do it.

12:29.720 --> 12:30.720
Yeah.

12:30.720 --> 12:34.400
So immediately when we're looking at program language, just to recap, we see it's sort

12:34.400 --> 12:38.040
of a curly brace, C style, algo style language, right?

12:38.040 --> 12:43.680
So we can kind of read it if we know C or C++, objective C, whatever.

12:43.680 --> 12:46.160
And it does look like a C+++, kind of language.

12:46.160 --> 12:47.560
We'll talk about that in a second.

12:47.560 --> 12:52.400
There's another hand here.

12:52.400 --> 12:58.080
Is that program manipulating types as values at compile time using decode like you would

12:58.080 --> 12:59.760
do in the ZIP program language?

13:00.440 --> 13:04.800
So the question about is it manipulating types here?

13:04.800 --> 13:09.360
Or something's kind of interesting about the types, certainly here.

13:09.360 --> 13:16.480
So for instance, what's the type of B, for instance?

13:16.480 --> 13:18.200
So what's it doing with the types there?

13:18.200 --> 13:19.280
Okay, it's static.

13:19.280 --> 13:23.200
We sort of know static and C and stuff, something about memory storage.

13:23.200 --> 13:25.360
Immutable, some sort of qualifier.

13:25.360 --> 13:28.320
It turns out a stronger than const.

13:28.320 --> 13:29.520
But what's the actual type?

13:29.720 --> 13:35.600
Well, there actually is some types being inferred here for us, like auto and other languages.

13:35.600 --> 13:39.280
Now I will let you know, again, I'll repeat some of these details.

13:39.280 --> 13:42.800
D is statically typed, but at compile time, yeah, we do have to make a decision about

13:42.800 --> 13:44.960
what the actual type's gonna be and what's returned.

13:44.960 --> 13:46.960
Yeah, this is great.

13:46.960 --> 13:53.840
I'm gonna advance it one slide forward here, and you'll see what the label is on the program

13:53.840 --> 13:57.040
here on the D language homepage here.

13:57.080 --> 13:59.200
And it's sort of an array at compile time.

14:00.480 --> 14:01.400
And that's kind of cool.

14:02.760 --> 14:06.360
Just this first example, this is usually the first example that comes up here.

14:06.360 --> 14:10.200
And I've got a description of the stuff that you folks recapped very nicely.

14:10.200 --> 14:15.000
But let's actually, we'll run or look at a few codes, but

14:15.000 --> 14:18.680
I think we should at least look at this basic one here.

14:19.800 --> 14:20.960
Let's make it a little bit bigger here.

14:22.480 --> 14:27.000
Just to get a feel, again, this is the same Hello World sort of program.

14:27.000 --> 14:29.720
Well, this is maybe even after Hello World, I would say.

14:30.720 --> 14:32.720
But interesting enough here.

14:32.720 --> 14:33.960
And let's just go ahead and compile it.

14:33.960 --> 14:38.320
So with DMD, again, I'm looking towards the bottom of my terminal here.

14:38.320 --> 14:40.000
I'm gonna compile it out.

14:40.000 --> 14:43.760
This program I called compile time sort.d for the extension.

14:43.760 --> 14:48.600
And the output file is going to be prog or prog.

14:48.600 --> 14:53.880
And as soon as I hit enter, interesting here.

14:53.880 --> 14:57.000
It's finishing compilation here.

14:57.000 --> 14:59.120
And boy, I didn't run the program.

14:59.120 --> 14:59.840
I'll tell you I didn't run it.

14:59.840 --> 15:03.760
But while I was compiling it, yeah, there is something interesting here going.

15:03.760 --> 15:05.360
It is called compile time sort.

15:07.400 --> 15:09.280
So you might have guessed that.

15:09.280 --> 15:13.320
But interestingly, and this is one of the big, why should you care?

15:13.320 --> 15:15.680
Or things to look out in languages that you care about.

15:15.680 --> 15:18.560
We can do computation at compile time.

15:18.560 --> 15:22.520
So this is a really powerful feature of the D programming language,

15:22.520 --> 15:27.480
the D compilers specifically, that we can take something like in a new,

15:27.480 --> 15:29.680
something that would maybe be a constant, right?

15:29.680 --> 15:31.520
Usually in another language.

15:31.520 --> 15:33.800
Set some values here, like an array.

15:33.800 --> 15:36.320
And then actually evaluate it with sort.

15:36.320 --> 15:39.800
But again, if you look at sort, this looks like a function that you might just

15:39.800 --> 15:41.320
call in your regular programming language, right?

15:41.320 --> 15:44.960
So there's nothing really different than the compile time sort to the run time sort.

15:44.960 --> 15:47.080
That's probably what we want, right?

15:47.080 --> 15:51.160
To be able to execute as much as possible at compile time and

15:51.400 --> 15:54.040
save our work for when we're actually running, right?

15:54.040 --> 15:56.040
Before aiming for performance.

15:56.040 --> 15:57.920
Of course, there's always trade offs for that.

15:57.920 --> 16:00.800
You notice that might take a little longer to compile.

16:00.800 --> 16:02.520
Again, let's go ahead and compile it.

16:02.520 --> 16:04.200
Again, pretty fast.

16:04.200 --> 16:07.720
Actually, we're gonna talk about how fast the D compiler is later here.

16:07.720 --> 16:12.040
Now if I actually run it, the program here, PROG, right,

16:12.040 --> 16:15.800
we just get hello, Fostum, because that's the actual run time computation that's

16:15.800 --> 16:17.880
going on, okay?

16:17.880 --> 16:21.120
This part here, this is the only thing we're really doing at run time.

16:21.120 --> 16:25.000
Now if we go on and later do something with B or print it out,

16:25.000 --> 16:28.760
we'll get to our sorted array, but that's the point there.

16:28.760 --> 16:30.280
So, already kind of neat.

16:30.280 --> 16:32.360
This is kind of an attention grabbing thing.

16:32.360 --> 16:35.920
And again, something that might be new depending on what programming languages

16:35.920 --> 16:36.480
you've looked at.

16:37.640 --> 16:40.880
And the thing, again, one of the things that certainly caught my attention.

16:42.720 --> 16:43.240
All right?

16:43.240 --> 16:48.640
And I mean, there's some other interesting stuff here like the,

16:48.640 --> 16:52.840
I think was mentioned here, the quoted string before, right line, dot right line.

16:52.840 --> 16:54.560
Okay, we'll talk about this.

16:54.560 --> 16:57.200
It's called universal function call syntax, but

16:57.200 --> 17:00.480
you know, some nice potential quality of life features for us.

17:00.480 --> 17:04.400
All right, so that was our pop quiz, only pop quiz we have here.

17:04.400 --> 17:07.760
But I do invite folks to raise their hand high if they see something interesting

17:09.000 --> 17:09.800
as we move forward.

17:11.000 --> 17:15.080
All right, so again, the sample and why you might choose to care.

17:15.080 --> 17:20.360
Just to go back, we call this CTFE or just Compile Time Function Execution.

17:20.360 --> 17:22.760
This idea that we can do work at compile time.

17:22.760 --> 17:25.400
Didn't we know there's a lot of other languages, templates, or

17:25.400 --> 17:29.520
sort of a mechanism to do this if you're coming from C++ background.

17:31.020 --> 17:35.320
To various extravagance levels of metaprogramming that you can do.

17:35.320 --> 17:39.440
Other languages might do this a little bit more explicitly otherwise, but

17:39.440 --> 17:42.120
that's the idea with the decompiler.

17:42.120 --> 17:43.960
So a big win in my mind.

17:44.920 --> 17:47.120
In a big win, how clean this syntax is.

17:48.800 --> 17:51.760
Okay, so a little bit about this deep programming language.

17:51.760 --> 17:56.720
Somebody mentioned, it kind of looks like C, plus, plus, plus, plus.

17:56.720 --> 18:00.880
Yeah, so a little bit of history here.

18:00.880 --> 18:05.840
Walter Bright, who's highlighted there with the arrow, that's him at D-Comp.

18:05.840 --> 18:07.960
A few years ago, two years ago now.

18:07.960 --> 18:10.400
He was the initial creator of the deep programming language.

18:10.400 --> 18:13.680
It's called the Digital Buyer's compiler originally.

18:13.680 --> 18:19.360
But folks kept saying, hey, it looks like C++, plus, plus, or whatever.

18:19.360 --> 18:21.880
And they just started calling it D, and that just sort of stuck.

18:21.880 --> 18:23.120
So that's what we got here.

18:24.240 --> 18:27.160
So a little bit about Walter, again, he's a compiler expert.

18:27.160 --> 18:29.240
He's worked on C compilers.

18:29.240 --> 18:33.240
Hence why there's sort of a C compiler in the D language.

18:33.240 --> 18:35.240
C++ compilers.

18:35.240 --> 18:37.920
And then of course, thought about it for a while and said, well,

18:37.920 --> 18:42.440
I'd like to make something new, something that's fun and efficient to program in as

18:42.440 --> 18:45.160
well, and that's where D sort of came about.

18:45.160 --> 18:50.760
And then also, a major collaborator was Andre Augsindrescu,

18:50.760 --> 18:53.520
around 2006 or so, joined.

18:53.520 --> 18:58.720
And then for the next 10 plus years was a very active contributor in building what

18:58.720 --> 19:00.640
we now use as D2.

19:00.640 --> 19:03.520
And we actually got other audience members who are contributors.

19:04.640 --> 19:07.600
I don't know if you want to out yourself, you can raise your hand, but you don't have to.

19:07.840 --> 19:12.600
So anyway, so there's a full history with the D programming language and

19:12.600 --> 19:17.600
a really interesting article if you want to learn about the history and

19:17.600 --> 19:23.360
the origins about how to evolve and the sort of why's you do things in the programming languages.

19:23.360 --> 19:27.560
Again, that can be interesting sometimes if you know the historical context,

19:27.560 --> 19:29.000
why things look a certain way they do.

19:29.000 --> 19:32.280
Sometimes that helps you understand when or when not to use a feature.

19:32.280 --> 19:36.040
So anyways, that's just a little bit about the history of the D programming language here.

19:38.320 --> 19:40.520
So again, what is the D programming language?

19:40.520 --> 19:47.600
Still on the front page, it's a general purpose programming language with static typing.

19:47.600 --> 19:51.080
So whether or not you see those types, they can be inferred.

19:51.080 --> 19:53.320
It's a systems level programming language.

19:53.320 --> 19:57.200
So you have low level access to things like pointers, for instance, and

19:57.200 --> 19:58.760
you get the C likes syntax.

19:58.760 --> 20:02.480
So it's relatively familiar again if you've used C or C++, right?

20:02.480 --> 20:05.440
I imagine pretty much everyone who knows I hand who had heard of it's new.

20:05.440 --> 20:09.400
Yeah, something like the next C or whatever.

20:09.400 --> 20:12.520
But the mantra with the D programming language, at least on the home page,

20:12.520 --> 20:15.080
is write fast, read fast, and run fast.

20:15.080 --> 20:17.120
So we'll try to see if it holds up to those things and

20:17.120 --> 20:20.720
again why it might be a good choice for playing around with or

20:20.720 --> 20:22.200
maybe your next open source project.

20:24.480 --> 20:30.400
So over the last 25 years now, there are three compilers for D.

20:30.400 --> 20:34.960
There's the DMD compiler, that's the main one that Walter has and works on.

20:35.760 --> 20:38.520
And that compiler is completely open source.

20:38.520 --> 20:42.240
So you can dig into it, you can make a fork of it and modify it and

20:42.240 --> 20:45.160
play around with that DMD compiler.

20:45.160 --> 20:49.680
And it's a very, very fast compiler as far as compiling your code.

20:49.680 --> 20:54.600
So you can compile the actual D compiler, I want to say in a matter of seconds,

20:54.600 --> 20:57.640
tens or hundreds of thousands of lines of code.

20:59.240 --> 21:02.040
And that has in part to do with these module system,

21:02.040 --> 21:06.920
being able to do concurrent builds and how many passes it does over the language.

21:06.920 --> 21:08.240
But it's very, very fast.

21:08.240 --> 21:12.560
Your edit compile and run cycle is very quick as you're iterating and

21:12.560 --> 21:15.040
doing development, which I find something important.

21:16.600 --> 21:22.400
There is also the equally as important the GDC front end for

21:22.400 --> 21:23.880
the GCC compiler suite.

21:23.880 --> 21:28.360
I think it was around GCC 9 or 10 that was added in officially.

21:28.360 --> 21:34.440
So you've got the front end there with Ian Buchwald working on that and

21:34.440 --> 21:40.280
LDC work on by Martin, which gives you all the LLVM infrastructure.

21:40.280 --> 21:43.240
So if you're trying to target lots of different platforms, for

21:43.240 --> 21:48.720
instance, the LDC or the LLVM based D compiler is available for that.

21:48.720 --> 21:51.080
So you've got three compilers, which is great.

21:51.080 --> 21:53.440
So you don't have to worry about it disappearing anytime soon.

21:54.200 --> 21:59.360
And it is very common for D programmers to take advantage of the very fast edit

21:59.360 --> 22:01.320
compile cycle with DMZ.

22:01.320 --> 22:04.360
And then when it comes time to build an optimized build,

22:04.360 --> 22:09.240
you want to take advantage of all your GCC tool sets and infrastructure or

22:09.240 --> 22:13.080
your LLVM infrastructure and all the optimization passes.

22:13.080 --> 22:15.360
You can use those compilers afterwards.

22:18.800 --> 22:22.080
So as far as downloading the tools, don't need to spend too much time on it.

22:22.080 --> 22:24.440
But again, if you're on one of these platforms,

22:24.440 --> 22:28.960
you probably have a way to get the D compiler built for that platform.

22:28.960 --> 22:32.720
Or otherwise, there is a zip file or

22:32.720 --> 22:34.920
something on your package manager available.

22:36.360 --> 22:41.200
And with the D programming language, you get a package manager that's called

22:41.200 --> 22:45.400
dub, which will help you manage dependencies, bring in packages, and

22:45.400 --> 22:46.880
these types of things.

22:46.880 --> 22:49.680
It's also sort of a lightweight build tool as well.

22:49.680 --> 22:52.720
There's other tools that you might expect, like Dformat,

22:52.720 --> 22:56.520
which are being worked on and already exist for code formatting.

22:56.520 --> 22:58.560
Dscanner, which is like a linter.

22:58.560 --> 23:01.800
And if you're a VS code user and want to intelligence and

23:01.800 --> 23:05.880
these types of things, there's support for that, as well as for IntelliJ.

23:07.720 --> 23:08.220
Okay.

23:10.400 --> 23:13.080
So D, where is it being used right now?

23:13.080 --> 23:15.040
Again, we've heard of this language.

23:15.040 --> 23:19.040
Maybe we've used some of the applications without realizing that they were

23:19.040 --> 23:23.480
written in D. Again, from the website, lots of different companies have used it

23:23.480 --> 23:24.480
internally.

23:24.480 --> 23:28.760
Again, folks like myself just use it for our own projects or research.

23:30.040 --> 23:34.880
But I think D has done a really nice job finding itself in various performance

23:34.880 --> 23:36.480
based niches.

23:36.480 --> 23:39.960
From some of these various companies, there's different stories about

23:41.120 --> 23:43.440
how different tools were being used, which I'm happy to go into.

23:44.600 --> 23:46.840
So I want to go ahead and show a few.

23:46.840 --> 23:50.880
And this was another built in the deep programming language tool.

23:50.880 --> 23:51.920
I tried to pronounce it correctly.

23:51.920 --> 23:57.160
I think it's Elmer, but it's a compressible flow simulator.

23:57.160 --> 23:58.080
Okay, super cool.

23:58.080 --> 24:04.080
So they're doing computational simulation, something very expensive to do.

24:05.400 --> 24:09.000
So this tool now is 10 plus years old,

24:09.000 --> 24:12.960
being used by various PhDs and postdocs and researchers.

24:13.960 --> 24:17.880
But again, why should we care about this tool other than it generates really pretty

24:17.880 --> 24:18.880
pictures?

24:18.880 --> 24:21.520
Their website has some really beautiful pictures.

24:21.520 --> 24:23.200
These are just the ones I sort of understand.

24:24.200 --> 24:26.120
So I could post in case anyone asked a question.

24:27.400 --> 24:30.720
But again, it's a project that's been around for 10 plus years.

24:30.720 --> 24:34.440
Most of the code is in D and it's shelling off high performance.

24:35.440 --> 24:38.560
And I thought this was a great message to share from their GitHub saying,

24:38.560 --> 24:42.640
our focus is on open source development to give a simple access point for

24:42.640 --> 24:46.400
doing their gas dynamics and research and teaching.

24:46.400 --> 24:50.160
So what a great place to start if again you're in this area and

24:50.160 --> 24:53.680
want to look at some open source D software.

24:56.200 --> 24:59.160
Okay, so that's a nice tool.

24:59.160 --> 25:01.720
Getting back to some of the D language features.

25:01.720 --> 25:04.200
Sort of already thrown out one of the main big ones here,

25:04.200 --> 25:06.600
the compile time function execution.

25:06.600 --> 25:09.800
Which again, we're starting to see in more other modern languages, but

25:09.800 --> 25:14.760
that's sort of a staple of D and why I think it's really interesting.

25:14.760 --> 25:19.240
But the language itself has a lot of really nice quality of life features.

25:19.240 --> 25:23.440
So these are things like you get a bunch of built in data structures

25:23.440 --> 25:25.040
without having to import anything.

25:25.040 --> 25:29.600
Dynamic arrays, associative arrays or maps or dictionaries.

25:29.600 --> 25:32.600
They're bounds checked, which you can enable or disable.

25:32.600 --> 25:35.200
There's always a path to performance here.

25:35.200 --> 25:38.000
You get things like your land does and delegates.

25:38.040 --> 25:43.760
The object oriented functional style, generic programming designed by

25:43.760 --> 25:47.520
introspection, concurrent paradigms, all of that.

25:47.520 --> 25:48.880
Again, they said it's a really big tool.

25:48.880 --> 25:53.520
We can't cover all of it, but there's probably something interesting here for

25:53.520 --> 25:56.360
you or it's a domain where you might expand.

25:56.360 --> 26:00.200
I personally found that I started doing more functional style programming when I

26:00.200 --> 26:04.400
started using D because it was very accessible in their standard library.

26:05.400 --> 26:11.480
The D language also by default is garbage collected.

26:11.480 --> 26:15.160
But you can turn that off if you want.

26:15.160 --> 26:16.920
You can malloc and free.

26:16.920 --> 26:18.360
You can do reference counting.

26:18.360 --> 26:21.280
You can implement from scratch your own strategy if you want.

26:21.280 --> 26:23.240
There is a question and I'll repeat.

26:53.240 --> 26:58.240
Yeah, so the question, just to repeat and I'll break it into two,

26:58.240 --> 27:03.920
is how granular are these, this ability to turn off things like garbage collection.

27:03.920 --> 27:07.080
If you do need performance in a certain sectionary code.

27:07.080 --> 27:09.840
That's as granular as putting an attribute on the function.

27:09.840 --> 27:11.920
You could say at no GC on it.

27:11.920 --> 27:16.320
And in practice, no garbage collections will happen.

27:16.320 --> 27:17.320
And you can do that.

27:17.320 --> 27:18.320
You can do that.

27:18.320 --> 27:20.520
You can do no GC on it.

27:20.520 --> 27:26.320
And in practice, no garbage collections will happen in that section there.

27:26.320 --> 27:31.520
I think there are more in the actual tools you can do like a GC.disable,

27:31.520 --> 27:35.360
which I think is similar to what Java and other languages have.

27:35.360 --> 27:39.120
I think you could do like a system.noGC or whatever.

27:39.120 --> 27:40.200
So you get that granularity.

27:40.200 --> 27:45.680
That could be at a function based level, saying this code, no GC, and

27:45.680 --> 27:47.120
being able to handle it.

27:47.120 --> 27:53.560
The array bounds checking, I know that is set as a compiler flag.

27:53.560 --> 27:57.040
I don't know if, for that one, I actually don't know the answer if you could do that

27:57.040 --> 27:59.520
on a per function level.

27:59.520 --> 28:03.920
What I would say is if you wanted an array that wasn't bounds checked.

28:03.920 --> 28:05.840
There is, I think, of a standard library.

28:05.840 --> 28:13.040
I think one of the standard array containers doesn't do allocations.

28:13.040 --> 28:17.240
And then I would also just say, so you don't have to worry about that container

28:17.240 --> 28:18.000
of garbage collections.

28:18.000 --> 28:22.280
But for the bounds checking, I would probably just, to be sure,

28:22.280 --> 28:25.080
you could implement your own dynamic array.

28:25.080 --> 28:28.480
No problem, just like you wouldn't see if you want that granularity.

28:30.720 --> 28:34.360
I will also show, what will I show here?

28:34.360 --> 28:36.400
Yeah, so does that answer the question?

28:36.400 --> 28:41.600
GC as granular as garbage collection per function, you can enable, disable.

28:43.080 --> 28:46.800
And then for the array bounds checking, you can always implement your own.

28:46.800 --> 28:48.960
But there is a compiler flag for on or off.

28:48.960 --> 28:53.480
And typically, folks would use that again for that last little performance game,

28:53.480 --> 28:56.960
if they're like building a video game or something, and super certain,

28:56.960 --> 29:01.520
there's not gonna be any arrays that got bounds.

29:01.520 --> 29:05.440
Because typically, you know the thick size allocation, you would just turn that off.

29:07.800 --> 29:08.920
Perfect.

29:08.920 --> 29:12.480
All right, questions or features that look exciting here?

29:12.480 --> 29:16.120
And there's lots and lots, and the point is you have control, which is really,

29:16.120 --> 29:19.400
really cool for what you need.

29:19.400 --> 29:22.120
And we're gonna even dive a little bit further into this.

29:22.120 --> 29:26.400
There's some other cool stuff you can do, if you only need a subset of this feature.

29:26.400 --> 29:29.200
But let's continue getting inspired here.

29:29.200 --> 29:31.560
So we've got a standard library.

29:31.560 --> 29:35.800
So again, batteries included, like pretty much every other programming language

29:35.800 --> 29:41.280
these days, you have to have a standard library with containers or data structures,

29:41.280 --> 29:42.800
various algorithms, right?

29:42.800 --> 29:46.880
We've already seen sorts in the very first example, but there are things like map and

29:46.880 --> 29:48.680
filter and fold and so on.

29:50.600 --> 29:54.480
There's various concurrency primitives and so on, and we'll take a look at some of those.

29:54.480 --> 29:58.960
So you have a pretty decent standard library here.

29:58.960 --> 30:03.880
That's in discussion about expanding and refactoring and so on.

30:05.240 --> 30:09.960
So most of the common stuff you would need, handling JSON, CSV, files and so on.

30:11.920 --> 30:17.240
So that brings me to another built in D here, why do we care?

30:17.240 --> 30:20.160
I'll get into my code, so B's, Yanmi.

30:22.080 --> 30:26.200
But so here's just the type of way that I started using the D

30:26.200 --> 30:30.280
programming language was writing these little scripts, 50 line, 100 line,

30:30.280 --> 30:34.160
throw away codes to automate some tasks that I'm doing at my desk.

30:34.160 --> 30:40.440
I found myself doing a lot of queries to YouTube to gather data about what videos

30:40.440 --> 30:44.040
have been published in a channel or what videos are in my playlist, these types of

30:44.040 --> 30:45.520
things.

30:45.520 --> 30:53.320
So what was really nice was just to find that there is the standard.net.curl in

30:53.320 --> 30:55.840
the D standard library.

30:55.840 --> 31:01.520
And then I could just build a query string and then effectively make a query and

31:01.520 --> 31:05.920
retrieve my data from that curl request.

31:06.920 --> 31:12.120
And then I have standard JSON and then I can just, again,

31:12.120 --> 31:18.160
if I'm retrieving from some API, JSON data, again, common format for that JSON or

31:18.160 --> 31:23.040
JSON, then I can work with that data as needed here.

31:25.040 --> 31:29.000
And then you've got other sort of quality of life things like range-based loops.

31:29.000 --> 31:33.120
So you can go through the keys, you can put the keys and the values here if you

31:33.120 --> 31:35.000
wanted to iterate through them as well.

31:35.080 --> 31:38.880
So nice little script you end up writing a few of these here.

31:40.120 --> 31:43.280
So there's one example with YouTube.

31:43.280 --> 31:47.960
I do this a lot for GitHub for, again, pulling repos, looking at them,

31:47.960 --> 31:50.720
pushing code to students.

31:50.720 --> 31:55.760
So again, same sort of pattern that I'm always using with any rest-based API

31:55.760 --> 31:56.720
where I'm pulling data in.

31:57.960 --> 32:01.600
One little interesting thing here, looking at line 53,

32:01.600 --> 32:06.120
we can start to see that if you want to set various event handlers,

32:06.120 --> 32:10.040
again, here's just a little example of a lambda function here.

32:10.040 --> 32:12.120
You can have anonymous functions.

32:12.120 --> 32:15.480
You can have delegates and these types of things in the D language.

32:15.480 --> 32:17.880
So nice little quality of life things here.

32:20.680 --> 32:25.120
Okay, so this is kind of interesting here.

32:25.120 --> 32:29.760
My little scripts, and I'm sure many of you folks have your shell scripts or

32:29.760 --> 32:31.680
Python scripts or whatever.

32:31.680 --> 32:32.760
And again, that's what happened to me.

32:32.760 --> 32:34.480
I had a bunch of shell scripts.

32:34.480 --> 32:36.920
Mostly I had scripts in Python.

32:36.920 --> 32:40.840
And then I just started translating them to D because again,

32:40.840 --> 32:43.760
I liked it, it was a little bit less cognitive overload for me.

32:43.760 --> 32:50.000
Again, if I'm working in C++ and D, they're pretty similar in how I can

32:50.000 --> 32:51.400
think about some of those intakes.

32:52.800 --> 32:55.560
But it's sort of interesting that when I'm using D,

32:55.560 --> 33:00.720
I'm still effectively executing my scripts like I do in Python.

33:00.720 --> 33:03.200
Okay, so let me go ahead and explain this here.

33:04.360 --> 33:05.320
And what do I mean by that?

33:05.320 --> 33:07.600
Yeah, question first.

33:11.600 --> 33:13.600
Let's see, line 54.

33:18.600 --> 33:21.880
Maybe a bug or something there, line 54.

33:21.880 --> 33:22.680
Sorry, I didn't hear.

33:22.680 --> 33:23.680
Unreceived.

33:26.400 --> 33:28.360
Oh, the E and the I backwards, uh-oh, okay.

33:28.360 --> 33:31.400
I knew I shouldn't have put my code here.

33:34.400 --> 33:36.280
Good catch, I'll fix it in the post, yeah.

33:38.560 --> 33:39.680
Gotta do some fixing tonight.

33:41.320 --> 33:44.160
But the good news is, right, we can iterate quickly.

33:44.160 --> 33:47.120
So I'm gonna give you an even faster tool that I use to iterate and run these

33:47.120 --> 33:48.240
scripts.

33:48.240 --> 33:51.760
Just a little helper tool, it's called rdmd, run,

33:51.760 --> 33:55.200
you know, the dmd, basically just does on the fly compilation.

33:56.280 --> 34:00.200
And it does, you know, it compiles, you know, as fast as your

34:00.200 --> 34:04.080
decompiler basically does, dmd, but then it'll just execute your program

34:04.080 --> 34:05.320
immediately.

34:05.320 --> 34:08.680
And the advantage of this is then you can use D like a shell scripting

34:08.680 --> 34:09.680
language, right?

34:09.680 --> 34:12.960
You can actually, if I get a read down here, I'll try to highlight my cursor.

34:12.960 --> 34:17.360
I know it's a little bit small here, but you can just put the pound

34:17.400 --> 34:21.760
into the bang sign slash user slash bin slash environment, rdmd, you know,

34:21.760 --> 34:26.400
chmod, execute, or whatever, and then you just run your program,

34:26.400 --> 34:28.120
just like a regular script.

34:28.120 --> 34:32.160
So again, that's a really nice way to, if you need to, transition your

34:32.160 --> 34:35.960
scripting language to something that's statically typed, or you can just think

34:35.960 --> 34:40.160
in the deprogramming language rather than multiple languages.

34:40.160 --> 34:42.960
I found that as a nice quality of life improvement.

34:42.960 --> 34:47.280
Again, I understand I'm the enthusiast here, but I found that as a really big

34:47.320 --> 34:48.280
win for me.

34:48.280 --> 34:50.280
So rdmd is available.

34:50.280 --> 34:55.280
The LDC compilers, you also have this available as well with L, dmd2.

34:55.280 --> 34:58.280
I haven't checked the GDC one actually.

34:58.280 --> 35:01.280
So that was really cool.

35:01.280 --> 35:07.280
So, you know, generally speaking to, you know, my effort because I was running

35:07.280 --> 35:11.280
somebody who does little scripts was, you know, if you use a compiled language,

35:11.280 --> 35:13.280
generally, gotta be careful with talking about performance.

35:14.280 --> 35:18.280
You get better performance than an interpreted scripting language.

35:18.280 --> 35:22.280
So again, a big win for me and my projects.

35:22.280 --> 35:27.280
But there is still more to this performance story beyond just, you know,

35:27.280 --> 35:30.280
switching to a compiled language here.

35:30.280 --> 35:33.280
Because I started stumbling upon other really cool things in the deprogramming

35:33.280 --> 35:36.280
language, the community pointed me to.

35:36.280 --> 35:39.280
I started doing this in my scripts here.

35:39.280 --> 35:42.280
So you'll see here highlighted, let me draw your attention towards the top.

35:43.280 --> 35:44.280
Dot parallel here.

35:44.280 --> 35:48.280
So I just kind of stick that on the end of some collection or some array.

35:48.280 --> 35:53.280
And basically what I get is the equivalent of, for those of you who've done

35:53.280 --> 35:57.280
OpenMP, a parallel-based for loop here, right?

35:57.280 --> 36:00.280
We're able to launch multiple threads here.

36:00.280 --> 36:04.280
That's a small change that you can make, right?

36:04.280 --> 36:07.280
If you don't have any dependencies on the data in between, you still have to

36:07.280 --> 36:10.280
think about it, certainly to make sure you get correct code.

36:10.280 --> 36:13.280
But imagine just going through all of your range-based for loops and doing dot

36:13.280 --> 36:14.280
parallel.

36:14.280 --> 36:17.280
And if you're doing separate tasks, getting a performance boost, right?

36:17.280 --> 36:18.280
Use your CPU.

36:18.280 --> 36:21.280
You paid a lot of money for it, so put it to work.

36:21.280 --> 36:25.280
So again, quality of life feature there.

36:25.280 --> 36:27.280
Now does it make things faster?

36:27.280 --> 36:28.280
Again, you have to profile.

36:28.280 --> 36:32.280
You always got to check these things out.

36:32.280 --> 36:37.280
So, you know, maybe a better use case, another open source project from a

36:37.280 --> 36:44.280
D conference, just a standard, you know, Hello World Ray Tracer project where I

36:44.280 --> 36:47.280
used standard parallelism.

36:47.280 --> 36:52.280
And again, if you're looking per pixel or doing something graphically, right,

36:52.280 --> 36:55.280
you have a lot of pixels, however wide your resolution is, a thousand pixels,

36:55.280 --> 36:58.280
but, you know, a thousand something of that nature.

36:58.280 --> 37:03.280
You can try dot parallel on it and see if it speeds things up.

37:03.280 --> 37:06.280
And of course, my performance wizards and the spiniers.

37:06.280 --> 37:09.280
You're launching too many threads or what's going on, you know.

37:09.280 --> 37:12.280
So, you know, does it make things faster?

37:12.280 --> 37:14.280
I'll get to that in one slide here.

37:14.280 --> 37:19.280
Because I also see something interesting that I've touched on but haven't explained.

37:19.280 --> 37:22.280
What's going on in this for each loop?

37:22.280 --> 37:27.280
For each Y and for each X, okay, those must be like the pixels going across and up and

37:27.280 --> 37:28.280
down.

37:28.280 --> 37:29.280
Okay, so there's a lot of them.

37:29.280 --> 37:31.280
But this next part's kind of interesting.

37:31.280 --> 37:37.280
Okay, I've got a camera dot get screen height dot iota, which is like a range,

37:37.280 --> 37:39.280
and then that dot parallel.

37:39.280 --> 37:44.280
Well, what this is, is an example of that uniform function call syntax.

37:44.280 --> 37:47.280
This idea that we can sort of chain functions together with a dot.

37:47.280 --> 37:50.280
Again, maybe you've seen this about programming languages.

37:50.280 --> 37:53.280
Maybe you've implemented design patterns that allow you to do this.

37:53.280 --> 37:57.280
But it's a really nice quality of life feature if you just sort of compare the camera dot

37:57.280 --> 38:02.280
get screen height dot iota dot parallel versus, you know, trying to figure out how do I nest

38:02.280 --> 38:03.280
these things.

38:03.280 --> 38:08.280
Parallel, okay, iota, and then you're counting your parentheses or, you know, you're hoping

38:08.280 --> 38:11.280
them or whatever counts them correctly for you.

38:11.280 --> 38:16.280
Again, just a little quality of life thing, more readable code, and you can actually think

38:16.280 --> 38:21.280
and sometimes see like, oh yeah, I see that is just a range there.

38:21.280 --> 38:22.280
Maybe I can paralyze it.

38:22.280 --> 38:26.280
Maybe there is some data independent thing there.

38:26.280 --> 38:29.280
So anyways, that's just, you know, following up on that.

38:29.280 --> 38:33.280
And then as a little aside, and you can look a little bit more, there is a built-in profiler

38:33.280 --> 38:41.280
in the D compiler for seeing how many times a function executes, how much time you spend

38:41.280 --> 38:46.280
in it, and there's also a memory profiler so you can see how many garbage collections

38:46.280 --> 38:48.280
you're doing if you're using the garbage collector.

38:48.280 --> 38:51.280
Okay, so built into the compiler, you don't have to search for them.

38:51.280 --> 38:55.280
You know, I do use other tools like perf and choose your favorite tools, but nice that

38:55.280 --> 38:56.280
it's there, okay?

38:56.280 --> 39:03.280
It's an easy tool that you could build into a continuous integration system or whatever.

39:03.280 --> 39:10.280
Okay, so, you know, speaking of some graphics projects, again, that's sort of one of my

39:10.280 --> 39:15.280
passions, so, and it turns out that D is a great language for building graphics projects.

39:15.280 --> 39:22.280
So, you know, the must-need-it, you know, pretty picture slide, and there's actually games

39:22.280 --> 39:24.280
and physics, you know, if you click into this.

39:24.280 --> 39:30.280
The cool D language project, Daegon, here is a game engine, so, you know, something sufficiently

39:30.280 --> 39:31.280
complex.

39:31.280 --> 39:33.280
Why do we care about this, though?

39:33.280 --> 39:36.280
Other than it's, you know, pretty in a slideshow.

39:36.280 --> 39:37.280
Very, very beautiful.

39:37.280 --> 39:39.280
Lots of hard work there.

39:39.280 --> 39:45.280
But again, just to see the substantial project by engine and graphics developers, you can

39:45.280 --> 39:48.280
see how it's laid out, how different core systems are laid out.

39:48.280 --> 39:51.280
Again, might be interesting for you to, again, think about if you're going to use D for

39:51.280 --> 39:56.280
building games, how you organize different components and game objects and these types

39:56.280 --> 39:57.280
of things.

39:57.280 --> 39:59.280
And you can kind of look through the directory structure.

39:59.280 --> 40:06.280
D uses a sort of directory structure for packages like Java or other languages, and

40:06.280 --> 40:08.280
that's kind of interesting.

40:08.280 --> 40:13.280
And there's also just a fun comparison to C++ here if you want to see the video.

40:13.280 --> 40:15.280
It's not really to say anything.

40:15.280 --> 40:20.280
Both these applications are very GPU bound, so that's sort of the point, right?

40:20.280 --> 40:25.280
Use the language you want, and if you're GPU bound, that's all on the GPU anyway, so,

40:25.280 --> 40:27.280
you know, you can think about those tradeoffs.

40:27.280 --> 40:29.280
So there's one game engine.

40:29.280 --> 40:33.280
Another one, Dash, this is a cool, I think it started off as a student project, and then

40:33.280 --> 40:36.280
I gained some steam with several folks.

40:36.280 --> 40:38.280
So there's a little game they made.

40:38.280 --> 40:40.280
Why do you care about this?

40:40.280 --> 40:45.280
Well, you know, I spent just a few minutes looking at the code to see how things were

40:45.280 --> 40:46.280
structured.

40:46.280 --> 40:54.280
And very interestingly, they were using this idea of mixins in their code.

40:54.280 --> 40:58.280
How many folks, just as a survey, have heard of a mixin by hand?

40:58.280 --> 41:04.280
Okay, we've got about 40% or so around there.

41:04.280 --> 41:09.280
But that's the idea that you're literally just taking in a string and pasting in your

41:09.280 --> 41:12.280
code, and it should be like valid decode that gets compiled.

41:12.280 --> 41:15.280
Sounds trivial, sounds like, kind of, why would you do this?

41:15.280 --> 41:20.280
But it makes sense in use cases if you've got graphics code, if you can just import

41:20.280 --> 41:24.280
or paste in some shader code and do a mixin.

41:24.280 --> 41:31.280
Or maybe you can use other compiler or compile time techniques to sort of build out a string

41:31.280 --> 41:33.280
at compile time and then generate code.

41:33.280 --> 41:39.280
It's a very simple idea that you can compose and generate some really cool graphics things.

41:39.280 --> 41:45.280
I think it tends to work well in this use case that the game showed.

41:45.280 --> 41:48.280
Another later project here, Hypreem Engine.

41:48.280 --> 41:51.280
So they built, you know, some nice stuff.

41:51.280 --> 41:52.280
Why do you care about it?

41:52.280 --> 41:54.280
Why should we look at it?

41:54.280 --> 41:58.280
Well, Hypreem is very active in the community, so a good person to know for one.

41:58.280 --> 42:03.280
But a really interesting example of just seeing how to support multiple platforms.

42:03.280 --> 42:09.280
So again, Hypreem can build a D project on PlayStation Vita, Xbox, Mac, iOS, Android,

42:09.280 --> 42:10.280
et cetera.

42:10.280 --> 42:15.280
Just to see that that's accessible, I think that's a project worth studying and to see,

42:15.280 --> 42:16.280
you know, how did they get there?

42:16.280 --> 42:17.280
Okay.

42:17.280 --> 42:18.280
All right.

42:18.280 --> 42:21.280
So there's lots of other graphics resources.

42:21.280 --> 42:26.280
Mike Parker, who's a member of the community, has done a great job with common libraries

42:26.280 --> 42:29.280
and graphics stuff, sort of an FYI.

42:29.280 --> 42:32.280
We're talking about open source today, so I'm going to sort of ignore the commercial game

42:32.280 --> 42:38.280
projects done in D, but there's a few interesting talks, again, if that's your sort of domain.

42:38.280 --> 42:45.280
And, okay, so talking about a few of the other D language things of interest, the paradigms,

42:45.280 --> 42:46.280
okay?

42:46.280 --> 42:49.280
Because again, I said when I started using D, I started doing things more functionally.

42:49.280 --> 42:51.280
I started thinking more about concurrency.

42:51.280 --> 42:56.280
I started thinking about object-oriented programming, I think in the right way.

42:56.280 --> 43:02.280
At least, you know, how message passing is supposed to be one of those pillars of object-oriented

43:02.280 --> 43:05.280
programming that kind of gets forgotten sometimes.

43:05.280 --> 43:08.280
At least that's what I think of with object-oriented programming.

43:08.280 --> 43:11.280
But anyways, just a couple of examples.

43:11.280 --> 43:18.280
You can take a peek at these again after the talk, but I've got the range-based loop here,

43:18.280 --> 43:21.280
and then I've got the sort of the mantra of no raw loops.

43:21.280 --> 43:28.280
Get rid of those raw loops and just use functions like filter or, you know, these types of components here.

43:28.280 --> 43:35.280
So again, very nice, often easy to substitute, often you find instances where you can just do a dot-parallel

43:35.280 --> 43:37.280
much more easily.

43:37.280 --> 43:39.280
And on the right here is just a classic.

43:39.280 --> 43:47.280
You've got an interface, and you want to create a type of dog, a husky golden retriever, you know,

43:47.280 --> 43:54.280
like your favorite dog, Belgian Shepherd, et cetera.

43:54.280 --> 44:00.280
Okay, and then I can't leave D without giving a hollow world of metaprogramming,

44:00.280 --> 44:03.280
because that's really, again, one of the strengths here, right?

44:03.280 --> 44:06.280
We talked about stuff that you could do at compile time.

44:06.280 --> 44:09.280
So just a sort of simple function here.

44:09.280 --> 44:12.280
It's called print data.

44:12.280 --> 44:14.280
So I'll draw your attention towards line 38.

44:14.280 --> 44:18.280
T is the template parameter, so there's no angular brackets.

44:18.280 --> 44:21.280
You just put the template parameters right after here.

44:21.280 --> 44:27.280
So T, whatever the data type would be, and I've got another T for whatever that type is, and then the struct.

44:27.280 --> 44:29.280
Okay, what is the struct and why do we care about it?

44:29.280 --> 44:37.280
Well, we care about this struct only if it has members, right, attributes called memory and elements.

44:37.280 --> 44:48.280
Okay, so memory might be a chunk of the, you know, I don't know, some attribute of the elements is maybe, again, an array of the data.

44:48.280 --> 44:54.280
So what's sort of interesting is, one, you can think about this as a sort of template constraint, or a concept,

44:54.280 --> 44:58.280
again, depending on what language you're coming from, that has to be adhered to.

44:58.280 --> 45:06.280
So I can only use this templated function on structs to print their data if it has memory and elements.

45:06.280 --> 45:10.280
Well, I think that's kind of a nice constraint to think about or to have that ability to do it.

45:10.280 --> 45:13.280
So that's kind of interesting here.

45:13.280 --> 45:21.280
If we have time at the end, I'll flash some of the examples that I'm going to put in the GitHub repository for other introspection things you can do.

45:21.280 --> 45:26.280
You've got a traits library, so you can see, you know, what member functions you have.

45:26.280 --> 45:31.280
Is this thing a unit test? Does it have some attribute on it, like no GC or whatever?

45:31.280 --> 45:32.280
A question?

45:33.280 --> 45:39.280
And the question was, is there static if? There is static if. There's static for each.

45:39.280 --> 45:41.280
My question is why you use static.

45:41.280 --> 45:49.280
Why it's not static? Here, it's, I guess I could make this static. I don't know if it's implicit actually here.

45:49.280 --> 45:52.280
I need to think if it is or not.

45:53.280 --> 46:08.280
Yeah, I guess, yeah, we don't need it because technically we wouldn't generate this template if it wasn't valid, since that's happening at compile time.

46:08.280 --> 46:15.280
Okay. So, you know, here's, you know, leading us towards the end.

46:15.280 --> 46:22.280
So, I know, I've gone through this. I've tried not to make it a sales pitch just to show you things that I'm excited about.

46:22.280 --> 46:28.280
But if you're not ready to try, D, there's still yet other interesting things in the compiler.

46:28.280 --> 46:32.280
There's something called better C, which is a subset of the D language.

46:32.280 --> 46:38.280
And basically what this does is it gets rid of or sort of removes a lot of the language run time.

46:38.280 --> 46:46.280
So, this is if you want to do some more like bare metal programming, for instance, and you don't want to carry the standard library phobos,

46:46.280 --> 46:49.280
or you don't need some of these other features.

46:49.280 --> 46:59.280
You get most of the quality of life things, like the bounds checking with arrays, you get slices for working with them, you know, delegates,

46:59.280 --> 47:05.280
land as all those nice things, all the compile time execution, but you can sort of just use it as a better C language.

47:05.280 --> 47:09.280
Some of the stuff you're starting to see in C23, for instance.

47:09.280 --> 47:18.280
And there's a really nice talk introducing that on kernels and how they're using better C for kernel development.

47:18.280 --> 47:21.280
So, again, getting into a little level stuff here.

47:21.280 --> 47:27.280
So, as far as learning more about the language, again, great tour on the website.

47:27.280 --> 47:34.280
The good news is, you know, anybody who's written a book on the D programming language, and there's seven or eight, I think,

47:34.280 --> 47:39.280
they're all good books, right? They're all written by enthusiasts, reviewed by the community.

47:39.280 --> 47:44.280
These are the first two I'm going to recommend that folks who are beginners take a look at.

47:44.280 --> 47:50.280
They're more, you know, for someone who's an audience who knows how to program, and we'll get you started here.

47:50.280 --> 47:53.280
Forums and Discord, otherwise, are very active as well.

47:53.280 --> 47:56.280
YouTube, that's me.

47:56.280 --> 47:58.280
And then teaching the D language.

47:58.280 --> 48:02.280
So, you can hear it from my perspective again, but even better if you hear it from the students, right?

48:02.280 --> 48:09.280
They're unbiased thoughts on what the value was, if it was useful for them.

48:09.280 --> 48:18.280
And the last sort of resources as we're kind of wrapping up here to talk about, again, from Andre, he wrote this really nice piece here called The Case for D.

48:18.280 --> 48:28.280
This was in 2009. I think a lot of it still holds in a way, but, you know, basically, he summarizes it as a high-level systems language where it can be productive and enjoy coding.

48:28.280 --> 48:32.280
That's what I found. You know, maybe you'll find that too.

48:32.280 --> 48:34.280
Okay, again, that's up to you to decide.

48:34.280 --> 48:39.280
I hope I just shared some cool stuff for you to get excited about otherwise.

48:39.280 --> 48:43.280
So, again, what do we care maybe as an open-source developer?

48:43.280 --> 48:50.280
You know, you've got a readable, writeable, performance language that hopefully gives you a lot of quality of life features like fast iteration time.

48:50.280 --> 48:55.280
You know, I think there's a competitive advantage here with any project.

48:55.280 --> 49:01.280
I found it with my students. Again, that's something you'll have to test, but that's what I found.

49:01.280 --> 49:06.280
My students get further using D than other programming languages.

49:06.280 --> 49:14.280
And there's three compilers available. You don't have to worry about it disappearing or, you know, other stuff, you know, going on here.

49:14.280 --> 49:16.280
All right, what's next for me?

49:16.280 --> 49:20.280
Well, I talked a whole lot about graphics. That's my passion. That's what I've worked in.

49:20.280 --> 49:24.280
But I'm now working on learning a web framework called Vibe, which is super cool.

49:24.280 --> 49:32.280
If you're more on the website, there's a great book about it to get you started on building, you know, scalable and performance web applications.

49:32.280 --> 49:37.280
Alrighty, so we learned a bunch of things. Here's sort of a summary slide on some of our takeaways.

49:37.280 --> 49:43.280
Again, I'm going to leave that wall of text for you because I want you to leave excited and not tired from reading.

49:43.280 --> 49:46.280
I just want to go ahead and close off by thanking you.

49:46.280 --> 49:50.280
I'm going to be around so you can ask me any questions now or after as well.

49:50.280 --> 49:52.280
Thank you.

49:52.280 --> 50:02.280
Thank you.

50:02.280 --> 50:09.280
A question?

50:09.280 --> 50:13.280
What you will say, why Rust and why not Rust and why D?

50:13.280 --> 50:21.280
That's a good question. I don't want to pit languages against each other, so it's why Rust or why D?

50:21.280 --> 50:30.280
What I would say, because that's a hot question I get asked a lot, D's code is very plastic, the plasticity is high.

50:30.280 --> 50:34.280
Meaning I can mold it and change it, which I very much like.

50:34.280 --> 50:41.280
In a way that, again, I'm not as much a Rust expert. I've used it a little bit, but D's plasticity is very good.

50:41.280 --> 50:47.280
It writes how I want to write the code. It's got the memory safety with the garbage collection itself.

50:47.280 --> 50:54.280
I find it very, very productive. I find if you're going to write an application, again, I'm in games and so on where there's lots of mutable state.

50:54.280 --> 51:04.280
D's a perfect fit for that, for writing safety and maintainable code that I can change later.

51:04.280 --> 51:14.280
Yeah.

51:14.280 --> 51:21.280
So the comment was coming from a C, this was sort of easier code to C and to read.

51:21.280 --> 51:26.280
Yep, yeah. That's the other read. It's easy to get into.

51:26.280 --> 51:29.280
Yeah.

51:29.280 --> 51:32.280
Another question?

51:32.280 --> 51:41.280
Testing. The UFCS looks very cool, but how do I know if it's like a function or if it's a method of the object like that I'm calling?

51:41.280 --> 51:46.280
Because it felt, it was all the same color on your VIM script and I was like, oh no.

51:46.280 --> 51:55.280
Yeah, when you're doing the dot, so a few nice things that D language does when you're working with pointers in classes one, you know, if you're coming from C or C++, there's no arrow.

51:55.280 --> 51:59.280
So, you know, you don't have to worry about that. Everything's a dot.

51:59.280 --> 52:05.280
But then the idea of, is it a variable that I did a dot or the function call?

52:05.280 --> 52:10.280
Usually function calls are not required if they don't have any parameters, you can leave them empty.

52:10.280 --> 52:12.280
I usually just put the parentheses after.

52:12.280 --> 52:20.280
Otherwise, this is for things like language server protocol and your text editor make easy enough.

52:20.280 --> 52:22.280
It's not usually a problem.

52:22.280 --> 52:24.280
Yeah.

52:34.280 --> 52:36.280
Alrighty, thank you.

