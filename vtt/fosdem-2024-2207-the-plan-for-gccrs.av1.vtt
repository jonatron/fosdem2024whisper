WEBVTT

00:00.000 --> 00:05.000
So, today we have a, despite the slide saying Arthur,

00:11.360 --> 00:16.060
this is with Pierre Manu, going to speak about GCCRS.

00:16.060 --> 00:17.400
Give him a welcome.

00:17.400 --> 00:22.400
And, really well.

00:24.320 --> 00:28.360
Hello everyone, so I'm not Arthur, so I try my best

00:28.920 --> 00:31.800
so please be with me and I'll do my best.

00:31.800 --> 00:32.640
Yeah, okay.

00:34.560 --> 00:37.720
So, I'm a compiler engineer at Ambicosm

00:37.720 --> 00:40.160
and I'm not the co-lead of GCCRS.

00:40.160 --> 00:45.160
I believe there's Philip in the room but I can't see it.

00:45.920 --> 00:49.600
So, yeah, Philip is one of the co-lead of GCCRS.

00:51.080 --> 00:52.720
What will we talk about?

00:52.720 --> 00:55.440
So, I'll introduce GCCRS because some of you

00:55.440 --> 00:58.280
may not know the project.

00:59.520 --> 01:01.560
I'll talk about what we've achieved this year

01:01.560 --> 01:03.720
and what we've done, basically.

01:05.840 --> 01:10.440
And what we will do in the future in the upcoming year.

01:10.440 --> 01:13.880
So, there's a lot of things that's gonna change

01:13.880 --> 01:16.160
and I need to introduce those.

01:17.640 --> 01:18.580
So, let's begin.

01:19.960 --> 01:21.720
So, what is GCCRS?

01:21.720 --> 01:26.040
GCCRS is an alternative compiler for Rust.

01:26.040 --> 01:28.520
So, you may already know Rust C

01:28.520 --> 01:31.600
and we aim to provide a new front end

01:31.600 --> 01:35.700
for the Rust language within the GCC project.

01:37.920 --> 01:40.760
So, there's already a lot of front end in GCC.

01:40.760 --> 01:44.040
There's Hada, Go, and many of them Fortran.

01:44.040 --> 01:47.800
So, there's just one new front end

01:47.800 --> 01:50.280
that could leverage the GCC back end

01:50.280 --> 01:53.160
as well as the GCC plugin system

01:53.160 --> 01:55.200
on the GIMP representation.

01:55.200 --> 02:00.200
We are targeting for version 1.49 of the Rust language

02:01.600 --> 02:05.080
and the work is funded by Mbacosm

02:05.080 --> 02:07.060
as well as Open Source Security.

02:09.840 --> 02:12.840
So, we'll talk about the points.

02:12.840 --> 02:15.360
Why should we create a new compiler?

02:15.360 --> 02:18.520
So, there's a whole lot of architecture

02:18.560 --> 02:21.840
that aren't supported by the LLVM back end.

02:21.840 --> 02:26.640
So, there's already work for a new Rusty compiler

02:26.640 --> 02:30.760
for to leverage, for example, GCC JIT

02:33.120 --> 02:35.400
to get some GCC targets.

02:35.400 --> 02:40.400
And yeah, so basically, we are to leverage

02:41.040 --> 02:45.720
those new architecture and provide more target

02:45.720 --> 02:47.040
for Rust C.

02:48.040 --> 02:52.160
You may check the GCC room later tomorrow actually.

02:52.160 --> 02:54.120
So, there will be more about this.

02:58.200 --> 02:59.800
There's another big point.

02:59.800 --> 03:03.160
It's the Rust for Linux project.

03:03.160 --> 03:07.680
Basically, the Linux channel wants to integrate

03:07.680 --> 03:10.480
Rust program language in Scott Bayes.

03:10.480 --> 03:15.480
And this means we need some people want some support

03:16.280 --> 03:21.280
for the Rust language from the GCC project.

03:25.320 --> 03:26.960
Having multiple compiler apps,

03:26.960 --> 03:31.460
there was multiple domains where helping on this service

03:34.560 --> 03:38.960
draws some attention on some dark spot in the Rust language.

03:38.960 --> 03:43.000
So, we could show the Rusty people

03:43.000 --> 03:48.000
what could be improved, what is good.

03:48.000 --> 03:52.320
Yeah, so this brings some discussion about some subjects.

03:52.320 --> 03:56.320
And after I've been working on Rusty,

03:56.320 --> 03:59.440
on the macro group, for example.

03:59.440 --> 04:04.200
So, a lot of things that's brought by new compiler.

04:04.200 --> 04:06.000
It's bring new point of view for things.

04:08.560 --> 04:12.320
One last thing is working with very old

04:12.440 --> 04:14.200
plus plus compilers.

04:14.200 --> 04:16.040
There are some architecture systems

04:16.040 --> 04:18.320
that have some very old compilers.

04:18.320 --> 04:20.880
We just compile them in C++ or C.

04:20.880 --> 04:24.080
And you may want to bring the Rust ecosystem

04:24.080 --> 04:25.280
to the systems.

04:25.280 --> 04:26.120
So, yeah.

04:30.440 --> 04:32.600
What we've been doing in 2023.

04:33.840 --> 04:38.840
2023, we had three multiple Google summer of code projects.

04:39.440 --> 04:41.240
One was by

04:42.600 --> 04:47.600
Mohamed, who was working on the error framework for GCC.

04:48.520 --> 04:50.320
We basically want to introduce

04:52.640 --> 04:56.680
friendier error codes,

04:58.360 --> 05:02.080
like we can find in the Rusty compiler.

05:02.080 --> 05:04.080
If you've used the Rusty compiler,

05:04.080 --> 05:08.360
you may have seen friendly error codes or user error.

05:08.360 --> 05:11.640
And we want to bring this to the GCC ecosystem.

05:11.640 --> 05:16.640
And the second new Google summer of code was from Raikey,

05:18.160 --> 05:20.120
which I believe, yeah, he's there.

05:21.600 --> 05:24.920
You could see tomorrow in the GCC dev room,

05:26.360 --> 05:30.040
which implemented multiple things to support Unicob.

05:32.520 --> 05:34.920
We've been working on borrow checking,

05:34.960 --> 05:39.080
closure, iterators, and a lot of things.

05:41.360 --> 05:45.280
We, I also worked on Proc Macros.

05:45.280 --> 05:48.800
So, Proc Macros are baking Rusts.

05:48.800 --> 05:52.240
Their views are used almost everywhere.

05:52.240 --> 05:55.720
So, yeah, I've been working on this in the past year.

05:55.720 --> 05:59.240
We are able to expand some Macros right now.

05:59.240 --> 06:04.000
And it's not completely polished, but it's almost finished.

06:05.880 --> 06:10.880
We had to develop a new binary interface.

06:11.960 --> 06:16.160
This is a new system in GCC to leverage Proc Macros.

06:16.160 --> 06:21.160
And you may as well see my talk from code one,

06:22.560 --> 06:24.360
Google code one 2023,

06:24.360 --> 06:26.640
if you want to get deeper into the subject.

06:29.760 --> 06:30.600
Okay.

06:32.160 --> 06:34.200
I've been talking about the borrow checking.

06:34.200 --> 06:39.200
So, we, Jacob Dupac has been working on the borrow checker.

06:41.400 --> 06:45.600
Basically, Rust C has a pass in the compiler

06:45.600 --> 06:50.600
which emits an IR on the borrower checker,

06:50.600 --> 06:55.600
work on this IR to attest and check that some facts are valid,

06:56.480 --> 06:58.840
that the code is valid and that the borrow checking rules

06:58.840 --> 07:02.560
are all assorted.

07:02.560 --> 07:07.560
So, Jacob Dupac has been working on a new IR in GCC.

07:07.960 --> 07:10.560
So, we could have a borrow checker.

07:12.200 --> 07:13.760
It leveraged Polonius.

07:13.760 --> 07:16.200
So, if you've been working on Rust C,

07:16.200 --> 07:19.080
you probably already know Polonius.

07:23.280 --> 07:26.120
So, this is representation of Rust C on the left

07:26.120 --> 07:29.600
and GCC on the right.

07:30.600 --> 07:33.800
As you may see, Rust C,

07:35.200 --> 07:38.280
MIR is the borrower checking steps

07:38.280 --> 07:42.280
and the MIR is then lowered to LVMIR.

07:43.600 --> 07:47.480
In GCC, we've been doing things a bit differently.

07:47.480 --> 07:52.080
Basically, we had to separate two IRs

07:52.080 --> 07:55.280
and there is one kind of dead end IR

07:56.920 --> 07:58.720
specialized in borrower checking

07:58.720 --> 08:02.640
because we couldn't create an IR that could send

08:02.640 --> 08:04.640
below words to the GCC back end.

08:04.640 --> 08:09.200
So, at one time in the compiler,

08:09.200 --> 08:12.760
there will be two parallel IRs that could be created

08:12.760 --> 08:15.520
and on one end there will be GCC tree

08:15.520 --> 08:19.520
and on the other end there will be BIR

08:19.520 --> 08:22.160
and those will be checked.

08:23.400 --> 08:27.520
But the BIR won't be reused for the creation

08:27.520 --> 08:30.120
of your final record.

08:36.960 --> 08:39.200
I've been talking about the InCode support.

08:39.200 --> 08:42.800
So, yeah, I told the InCode support was by Raikey.

08:43.880 --> 08:45.760
Told you tomorrow there will be more.

08:45.760 --> 08:50.840
Rust code, so we want to be able to pass the Rust C test

08:50.840 --> 08:55.080
so this means we should be able to emit the proper error codes

08:55.080 --> 09:00.080
and this means we need to fix our own error codes

09:01.200 --> 09:04.640
to make those the same as Rusty.

09:07.240 --> 09:12.240
We are opening a few more entries this year

09:12.280 --> 09:16.560
for the GSOC for students to help us.

09:16.560 --> 09:18.480
Feel free to apply if you want.

09:20.200 --> 09:23.840
So, what we will be doing in 2024.

09:24.800 --> 09:29.800
We aim to implement format arg macro

09:29.800 --> 09:34.800
as well as the continue the work on the Polynesboro checker

09:37.280 --> 09:39.280
as well as the traits.

09:39.280 --> 09:41.800
Why do we need a smart arg macro?

09:41.800 --> 09:43.320
Basically, this macro is required

09:43.320 --> 09:45.400
in order to compile the standard library

09:45.400 --> 09:48.560
and we would like to be able to compile

09:48.560 --> 09:51.240
even a simple yellow world.

09:51.240 --> 09:55.000
If you have ever used yellow world,

09:55.000 --> 09:57.800
you may not know it, but under the hood,

09:57.800 --> 10:02.800
there is the format arg macro to format all your arguments

10:02.920 --> 10:06.440
and without this, we cannot even compile a simple yellow world.

10:06.440 --> 10:11.440
So, yes, this will come soon before GCC 14, hopefully.

10:15.680 --> 10:19.200
Currently, our borrow checking pass only

10:20.040 --> 10:24.600
rejects some invalid code for some facts

10:24.600 --> 10:27.200
and we still miss a lot of facts

10:27.200 --> 10:29.280
and we still miss a lot of things.

10:29.280 --> 10:34.280
So, yeah, we hope to implement more fact validation

10:35.200 --> 10:36.480
from the Polynesian engine.

10:40.800 --> 10:41.640
Okay.

10:42.520 --> 10:47.520
So, we cannot change our strategy for GCRS.

10:49.320 --> 10:53.520
We've met people at the ERRORUST in Brussels

10:53.520 --> 10:58.120
a few months ago and those were people from the ERRORUST team,

10:58.120 --> 11:00.400
I believe as well as the type language team

11:02.240 --> 11:03.840
as well as the trait team.

11:03.840 --> 11:06.600
And those people told us that the work required

11:06.600 --> 11:11.240
to make the trait solver work was like

11:14.280 --> 11:18.160
easy to do, but to get it right,

11:19.040 --> 11:21.840
you need a lot more work.

11:21.840 --> 11:26.680
So, basically, if you want 90% of the work done,

11:26.680 --> 11:29.880
it's easy, but if you want 99% of the work

11:29.880 --> 11:32.520
on the trait solver, it will be a whole lot of work

11:32.520 --> 11:34.800
because there is many rules

11:37.400 --> 11:41.480
that are very specific to some code and, yes,

11:41.480 --> 11:42.720
it will be very hard.

11:42.720 --> 11:45.840
So, in order to do this,

11:45.840 --> 11:49.680
we chose to not implement those ourselves

11:49.680 --> 11:52.600
but leverage existing RUST code.

11:52.600 --> 11:57.080
So, we'll be using different RUST libraries

11:57.080 --> 11:59.880
in the RUST compiler within GCRS.

12:05.880 --> 12:08.160
So, yeah, what I was saying,

12:08.160 --> 12:12.120
we'll be using RUST code within GCRS.

12:13.120 --> 12:16.160
So, that means there will be two steps

12:16.160 --> 12:19.680
in the GCC bootstrapping process.

12:19.680 --> 12:23.360
The first one will compile GCC RUST

12:23.360 --> 12:27.880
without Borough Checker, without a proper trait solver.

12:27.880 --> 12:32.760
And that's only a later step that GCRS will compile itself

12:32.760 --> 12:37.040
with the Borough Checker as well as all those fancy stuff.

12:38.040 --> 12:39.480
Yeah.

12:39.480 --> 12:42.240
The first version of GCRS,

12:42.240 --> 12:43.880
the one without Borough Checker,

12:43.880 --> 12:48.880
without all those things should never land

12:48.960 --> 12:50.000
in the end of users.

12:50.000 --> 12:52.080
That's only for bootstrapping purpose

12:52.080 --> 12:55.480
and, yeah, nobody should use it.

12:57.640 --> 12:59.880
Here is a schematic about it.

12:59.880 --> 13:02.560
So, yes, as I told you,

13:02.560 --> 13:05.480
bootstrapping process will be in two stages.

13:06.440 --> 13:09.720
First, we'll compile GCC RUST stage one

13:09.720 --> 13:11.560
without the Borough Checker.

13:11.560 --> 13:14.120
Then we'll compile Polyneus

13:14.120 --> 13:17.600
and then we will compile GCC RUST

13:17.600 --> 13:20.480
with Polyneus within embedded inside it.

13:22.920 --> 13:25.000
The format argument parser

13:26.280 --> 13:27.760
follow the same principle.

13:29.000 --> 13:31.560
We will compile it as a separate library

13:31.560 --> 13:33.440
and then we will link it.

13:34.440 --> 13:36.560
So, in order to do this,

13:36.560 --> 13:40.040
we need to make a version of GCRS

13:40.040 --> 13:44.800
which can compile the format argument parser RUST code.

13:44.800 --> 13:46.320
And, yeah, that'll be it.

13:50.720 --> 13:51.560
Let's look at the plan.

13:51.560 --> 13:55.360
So, we need a type checker,

13:55.360 --> 13:57.120
micro expansion, name resolution,

13:57.120 --> 13:58.760
as well as format argument.

13:58.760 --> 14:02.600
So, we will integrate those

14:02.600 --> 14:07.600
in the compiler in a two-step bootstrapping process

14:08.480 --> 14:12.320
in order to then be able to compile the standard library

14:12.320 --> 14:15.960
and then be able to call your favorite print line macro.

14:19.120 --> 14:20.480
Yeah, compile it after.

14:24.520 --> 14:27.320
On a long term, what should we do?

14:27.320 --> 14:29.120
So, we want to catch up with RUST

14:29.120 --> 14:31.320
or line exterior requirements.

14:31.320 --> 14:35.040
We want to be able to compile RUST code

14:35.040 --> 14:40.040
that should be used for Linux model.

14:40.040 --> 14:42.960
So, RUST for Linux targets

14:42.960 --> 14:46.040
a much more recent version of RUST.

14:46.040 --> 14:51.040
I believe it's 1.70, I'm not sure, don't quote me on that.

14:52.040 --> 14:57.040
But, yeah, we still have some additional work.

14:57.040 --> 14:59.440
It won't be that hard because once we have

15:00.440 --> 15:02.280
the standard libraries that compiles,

15:04.720 --> 15:08.880
there's not many things that are left

15:08.880 --> 15:10.920
because most of the work in RUST

15:10.920 --> 15:12.760
is done within the standard library,

15:12.760 --> 15:14.680
not in a language itself.

15:17.640 --> 15:18.480
Yeah.

15:22.800 --> 15:26.680
And then, we need some analysis

15:26.680 --> 15:28.400
as well as semantic testing.

15:30.440 --> 15:34.440
We do not enforce at the current time

15:34.440 --> 15:38.320
some runtime guarantees.

15:38.320 --> 15:41.880
So, for example, array bound checkings,

15:41.880 --> 15:42.920
that kind of things.

15:44.240 --> 15:47.320
RUST panic when you try to access an array

15:47.320 --> 15:49.440
out of bounds, those kind of things.

15:49.440 --> 15:51.760
So, those are not generated yet by compiler,

15:51.760 --> 15:53.760
so we still need to add that.

15:53.760 --> 15:58.200
And we need to ensure the compiler assembly

15:58.280 --> 16:00.400
produces the exact same behavior as RUST.

16:02.160 --> 16:04.200
We want to leverage the RUST test suite

16:04.200 --> 16:06.760
in order to be sure that GCRS is compliant

16:06.760 --> 16:07.960
with the RUST compiler.

16:12.920 --> 16:16.320
We need to work on a lot of improvements,

16:16.320 --> 16:19.000
more CI because currently all CI

16:19.000 --> 16:22.040
is like four little steps and that's all.

16:23.400 --> 16:26.960
We want to make sure the GCRS work

16:27.000 --> 16:30.480
with every architecture supported by GCC.

16:30.480 --> 16:32.840
For example, we have some build failure

16:32.840 --> 16:35.440
with some Spark backend, so yeah,

16:35.440 --> 16:38.280
let's make sure Spark work again.

16:39.240 --> 16:40.680
Spark 64.

16:42.480 --> 16:46.720
And one thing we want to add in the upcoming year

16:46.720 --> 16:48.960
is more upstreaming.

16:50.000 --> 16:52.280
Last year, we were a bit late

16:52.280 --> 16:55.720
and work was coming and coming

16:56.160 --> 17:00.640
and we didn't upstream as soon as we wanted to do.

17:00.640 --> 17:04.200
So yeah, we want to upstream more frequently.

17:04.200 --> 17:07.120
This will avoid this kind of situation

17:07.120 --> 17:12.120
where we want to push 900 commits in one mail

17:12.680 --> 17:17.360
and we GCC a new repository and we're everything crashed

17:17.360 --> 17:21.240
because well, it is not supposed to under 900 commit

17:21.240 --> 17:22.080
in one time.

17:25.800 --> 17:28.120
We want more contributors, more students

17:28.120 --> 17:29.440
and yeah, more fun too.

17:31.840 --> 17:36.240
Thank you for two open source security and because them

17:36.240 --> 17:39.360
and a few members from the RUST community

17:39.360 --> 17:44.360
which are helping us getting detailed from RUST.

17:44.480 --> 17:47.960
There's a lot of people with a lot more experience

17:47.960 --> 17:50.480
in the RUST compiler that's helped us

17:50.480 --> 17:53.320
to improve the GCRS compiler

17:53.320 --> 17:56.600
and as well as many contributors.

17:56.600 --> 18:00.120
So Tomah, Mark and even Riki here.

18:00.120 --> 18:00.960
Thank you.

18:02.600 --> 18:05.560
Here are different links to our blog, Github

18:05.560 --> 18:08.440
if you want to contribute the ISC channel

18:08.440 --> 18:11.600
as well as the main list.

18:16.560 --> 18:20.520
Yeah, so I'm a bit early, I'm sorry, but yeah.

18:20.520 --> 18:22.880
Not my slide, sorry.

18:22.880 --> 18:25.520
Yeah, you're the second replacement speaker.

18:25.520 --> 18:26.360
What?

18:26.360 --> 18:28.520
You're the second replacement after Arthur and then.

18:29.680 --> 18:30.920
I don't know.

18:30.920 --> 18:33.760
So you're, yeah, as a replacement speaker.

18:33.760 --> 18:35.080
I think you did a very good job.

18:35.080 --> 18:35.920
So can we.

18:35.920 --> 18:36.760
Yeah.

18:36.760 --> 18:37.600
Yeah.

18:37.600 --> 18:38.440
Thank you.

18:38.440 --> 18:39.280
Thank you.

18:39.280 --> 18:40.120
Thank you.

18:43.960 --> 18:46.600
Great, we do have some questions up here at the back

18:46.600 --> 18:47.480
coming around.

18:48.880 --> 18:51.600
Yes, so they'll have a microphone for the

18:52.600 --> 18:55.560
the stream, but if you could repeat the question anyway.

18:55.560 --> 18:56.400
Thank you very much.

18:57.480 --> 18:58.320
Thank you.

18:58.320 --> 19:00.600
I have two questions actually.

19:00.600 --> 19:04.520
The first one is related to the borough checker.

19:04.520 --> 19:07.480
So right now the borough checker is really deeply tied

19:07.480 --> 19:09.160
into MIR.

19:09.160 --> 19:11.480
How are you going to guarantee that you have

19:11.480 --> 19:14.320
compatibility between the MIR based borough checker

19:14.320 --> 19:16.720
and the beer based borough checker?

19:18.360 --> 19:20.600
Basically we.

19:20.600 --> 19:21.440
Repeat the question.

19:22.280 --> 19:27.280
So the question was, will we integrate the borough checker?

19:27.680 --> 19:30.120
Is that right in the GCR?

19:30.120 --> 19:32.160
How do you make sure that it's compatible?

19:32.160 --> 19:33.120
I'm sorry, I didn't.

19:33.120 --> 19:36.400
How do you make sure that the borough checker is compatible?

19:37.600 --> 19:39.000
We'll be using the same.

19:39.000 --> 19:43.920
So how will we make sure the borough checker is compatible?

19:44.920 --> 19:49.920
Basically we will reuse the same borough checker as RACI.

19:49.920 --> 19:51.520
We'll be using Polonius.

19:51.520 --> 19:56.520
So Polonius could be compiled as a library.

19:57.160 --> 20:00.600
We'll just be making an FFI interface

20:00.600 --> 20:04.640
and use that interface in order to directly use

20:04.640 --> 20:07.000
Polonius within GCC.

20:07.000 --> 20:08.400
Okay.

20:08.400 --> 20:11.320
And my second question is, do you think you will be able

20:11.320 --> 20:13.200
to emit wasm also?

20:13.200 --> 20:15.680
I'm sorry, it's very hard for me.

20:15.680 --> 20:19.280
One of the nice things with the current REST-C

20:19.280 --> 20:22.200
is that you can emit wasm, WebAssembly.

20:23.080 --> 20:24.040
Can you do that?

20:24.040 --> 20:27.760
Do you think you will be able to do that with GCC-RS?

20:28.720 --> 20:29.680
Yeah.

20:29.680 --> 20:30.520
Okay.

20:30.520 --> 20:33.200
That was a nice answer.

20:35.560 --> 20:36.640
Hello.

20:36.640 --> 20:39.520
From, as a GCC developer,

20:39.520 --> 20:42.280
how can we help from the GCC side?

20:43.720 --> 20:48.720
Well, you could drop by our GitHub repo.

20:49.280 --> 20:54.280
I mean, there's a whole lot of controversy within the GCC.

20:55.480 --> 20:58.320
Sorry, I will repeat the question.

20:58.320 --> 21:00.800
How as a GCC developer could we help

21:00.800 --> 21:02.840
on the GCC-RS project?

21:02.840 --> 21:03.760
Is that right?

21:03.760 --> 21:04.600
Yeah.

21:04.600 --> 21:07.160
So as GCC, there's a whole lot of controversy

21:07.160 --> 21:10.680
on the GCC project somewhat because we're using GitHub

21:10.680 --> 21:14.000
and GCC guys don't really like it.

21:14.000 --> 21:18.160
So there's, I mean, you could,

21:18.160 --> 21:23.160
I believe you could use your user workflow

21:23.280 --> 21:26.240
for pushing patches upstream, but I'm not sure.

21:26.240 --> 21:29.480
I think the best way to help us is to come to

21:29.480 --> 21:33.080
and in our GitHub repository, clone it

21:33.080 --> 21:38.080
and basically to like everyone, submit issues,

21:38.080 --> 21:39.840
solve issues and yeah.

21:41.840 --> 21:45.280
So over here we have a gentleman who would like to.

21:45.280 --> 21:48.040
Hey, I just want to clarify the WebAssembly

21:48.480 --> 21:52.640
so GCC does not currently have a backend for WebAssembly.

21:52.640 --> 21:55.360
So if you want to emit WebAssembly,

21:55.360 --> 21:58.520
you first have to write a backend unfortunately.

21:58.520 --> 22:00.640
There is however precedent in GCC

22:00.640 --> 22:03.720
for other high level assembly backends.

22:03.720 --> 22:06.360
So it should actually not be too difficult to do,

22:06.360 --> 22:08.120
but not available right now.

22:08.120 --> 22:08.960
Okay.

22:16.840 --> 22:17.880
Two questions.

22:17.880 --> 22:20.120
First one is you mentioned at the beginning

22:20.120 --> 22:23.280
compatibility with GCC 4.8.

22:24.400 --> 22:27.600
What are the consequences of this choice

22:27.600 --> 22:29.000
from a technical point of view?

22:31.280 --> 22:32.120
Yes, here.

22:32.120 --> 22:32.960
Yeah.

22:33.800 --> 22:38.080
I mean, you have the modern GCC code base

22:38.080 --> 22:40.760
and you want to your code to be compatible

22:40.760 --> 22:42.800
with this old code base.

22:42.800 --> 22:46.840
Basically for those who are not accustomed to GCC,

22:46.840 --> 22:51.840
GCC 4.8 is a very old version of GCC

22:52.640 --> 22:57.160
which doesn't even support C++11 at least not entirely.

22:57.160 --> 23:02.040
So we have few steps in our CI to make sure

23:02.120 --> 23:05.320
our code is compatible with GCC 4.8

23:05.320 --> 23:08.760
because there are some constructs in C++11

23:09.880 --> 23:13.800
that are not supported by GCC 4.8.

23:13.800 --> 23:15.840
So we need to make sure we don't introduce

23:15.840 --> 23:17.800
those constructs into compiler.

23:17.800 --> 23:22.800
So GCC 4.8 could bootstrap our GCCRs compiler.

23:26.200 --> 23:27.040
Thanks.

23:27.040 --> 23:28.640
And second question.

23:28.640 --> 23:31.720
Rust performance rely on LTO

23:31.720 --> 23:35.980
and GCC and LLVM have different LTO strategies.

23:38.240 --> 23:40.520
Does that impact you in any way?

23:42.960 --> 23:44.440
I haven't much to say about that

23:44.440 --> 23:49.040
because we're not at the stage in the compiler

23:49.040 --> 23:51.600
development where this matter,

23:51.600 --> 23:55.080
we want things to work first and then apply

23:55.080 --> 23:59.720
fix on tricks to improve performance.

23:59.720 --> 24:02.000
For now we won't focus on a working compiler

24:02.000 --> 24:05.600
before focusing on things that work fast.

24:06.560 --> 24:07.400
Thanks.

24:17.080 --> 24:19.720
Yeah, I just had a...

24:19.720 --> 24:20.840
Oh, loud, loud, very loud.

24:20.840 --> 24:21.680
Oh.

24:23.080 --> 24:24.560
I had a...

24:24.560 --> 24:27.120
If I didn't misunderstand,

24:27.120 --> 24:30.760
you said that one of your goals was to be able

24:30.760 --> 24:35.440
to compile GCCRs with itself,

24:35.440 --> 24:38.880
but without the borrower checker or string formatting.

24:38.880 --> 24:42.600
I would just like to know what would be the benefit

24:42.600 --> 24:46.120
of doing that instead of just compiling with Rust C

24:46.120 --> 24:50.920
until you have a working borrower checker.

24:52.640 --> 24:54.480
I'm not sure I understood your question.

24:54.480 --> 24:56.720
Could you please speak louder?

24:57.120 --> 25:01.720
What would be the benefit of compiling GCCRs with itself

25:01.720 --> 25:04.840
without a borrower checker or compiling it with Rust C?

25:04.840 --> 25:08.360
Okay, so what are the benefits of compiling GCCRs

25:08.360 --> 25:10.680
without borrower checker and then with a borrower checker?

25:10.680 --> 25:15.680
So basically, that's the slide here.

25:18.880 --> 25:22.760
Borrower checker as well as trait solver

25:22.760 --> 25:27.040
and many systems like this are very hard to implement.

25:27.040 --> 25:30.160
We would need a lot of time

25:30.160 --> 25:32.960
and we don't have much resources.

25:32.960 --> 25:37.560
So we want to focus on making the compiler work,

25:37.560 --> 25:39.440
even if it means compiling,

25:40.920 --> 25:43.480
reusing components from Rust C.

25:43.480 --> 25:47.560
So this means we first produce a first compiler

25:47.560 --> 25:51.240
without borrower checker that knows

25:51.240 --> 25:55.560
that the Polonius, for example, works well

25:55.560 --> 25:59.360
because Polonius has been compiled with Rust C.

25:59.360 --> 26:04.240
So Rust C leveraged the missing borrower checker step

26:04.240 --> 26:09.240
for GCCRs and this version of GCCRs

26:09.800 --> 26:11.880
will then be linked with Polonius

26:11.880 --> 26:16.880
so it can leverage it itself.

26:17.880 --> 26:21.880
So basically, this is a temporary version

26:21.880 --> 26:24.480
that the user should never see

26:24.480 --> 26:26.680
and that the user will probably never see.

26:26.680 --> 26:29.120
This is a version that will stay on the build machine

26:29.120 --> 26:31.960
of someone who wants to build GCC.

26:31.960 --> 26:35.440
And yeah, most of you won't ever see it.

26:35.440 --> 26:38.800
And yeah, that's it.

26:40.880 --> 26:44.760
You didn't understand quite well, am I right?

26:44.920 --> 26:48.640
Yeah, I understood that you were going to use

26:48.640 --> 26:52.360
the GCCRs version that didn't have

26:53.600 --> 26:55.160
the borrower checker and string formatting

26:55.160 --> 26:58.000
to compile GCCRs itself.

26:58.000 --> 26:59.600
That's what I'm saying, I don't know.

27:01.240 --> 27:02.240
Maybe I misunderstood.

27:04.320 --> 27:05.160
How do you say it?

27:08.360 --> 27:09.200
Quite...

27:10.080 --> 27:15.080
I think what he meant is he wanted to know

27:15.960 --> 27:19.360
why you want a bootstrap step

27:19.360 --> 27:23.640
that is free of Rust C.

27:25.200 --> 27:27.120
What the need is in this?

27:28.440 --> 27:32.800
Because we need to be able to compile Polonius.

27:34.480 --> 27:38.080
You need to be a separate compiler.

27:40.200 --> 27:42.880
I don't remember.

27:42.880 --> 27:46.800
I'm sorry, but those are steps that are not yet implemented

27:46.800 --> 27:48.960
and events look much into it.

27:48.960 --> 27:53.000
So I don't want to say some mistakes or anything.

27:53.000 --> 27:53.840
So...

27:53.840 --> 27:56.520
So you don't support all the architectures that GCC supports.

27:56.520 --> 27:58.440
So if you want a bootstrap on an architecture

27:58.440 --> 28:00.320
that's not Rust C, you want to put it back on.

28:00.320 --> 28:01.800
Oh yeah, okay, thank you.

28:03.840 --> 28:06.160
I had another question.

28:06.160 --> 28:11.160
You talked about the Rust C type of errors

28:11.160 --> 28:14.960
and also panic with out of bound access.

28:14.960 --> 28:17.960
Is there a possibility that we will see this

28:17.960 --> 28:22.120
for other languages in GCC from the work you have done?

28:24.080 --> 28:26.600
Yes, because...

28:27.960 --> 28:31.680
Don't quote me on that, but as I remember it,

28:32.680 --> 28:35.960
the students that made the change of framework

28:35.960 --> 28:40.960
for the errors made change to some common directory

28:44.080 --> 28:45.600
in the GCC project.

28:45.600 --> 28:49.520
So Auto Frontend may be able to use this new code.

28:51.440 --> 28:52.280
So maybe.

28:53.200 --> 28:54.640
But I mean,

28:55.760 --> 28:57.640
ZodChanger won't...

28:58.640 --> 29:03.160
Won't come by themselves.

29:05.400 --> 29:07.920
Confibrators on all of the languages.

29:07.920 --> 29:11.640
We need to integrate those in ZodChanger Frontend.

29:17.440 --> 29:18.280
Good, okay.

29:23.040 --> 29:26.760
So I understand your point in reusing

29:26.760 --> 29:29.760
the Borow Checker and the Format Arc stuff

29:29.760 --> 29:32.720
because it's already done and it's known to work,

29:32.720 --> 29:34.400
so why not reuse it?

29:34.400 --> 29:36.800
On the other hand, on your slide,

29:36.800 --> 29:40.440
why you are doing this GCC-RS project,

29:40.440 --> 29:44.440
you quoted the point that you want to provide

29:44.440 --> 29:48.200
an alternative second implementation next to Rust C

29:48.200 --> 29:53.200
because it oftentimes helps to have different implementations

29:53.480 --> 29:55.600
of the same stuff to better understand

29:55.600 --> 29:57.160
what the stuff is all about,

29:57.160 --> 30:00.880
to better understand the design.

30:00.880 --> 30:03.320
Maybe there is something strange in the design,

30:03.320 --> 30:06.800
you just don't notice if you only have one implementation.

30:06.800 --> 30:11.800
So this would be a point for also having a second Borow Checker,

30:12.040 --> 30:14.880
for also having a checking format ArcSwan.

30:14.880 --> 30:17.360
So what is your philosophy?

30:17.360 --> 30:19.560
Where do you draw the line between

30:19.560 --> 30:23.000
we want to implement a second independent system

30:23.000 --> 30:26.120
and we want to reuse proven code?

30:26.120 --> 30:30.160
Yeah, the question was where do we draw the line

30:30.160 --> 30:33.000
between components that we need to code ourselves

30:33.000 --> 30:35.200
or reuse from the Rust C project?

30:39.200 --> 30:40.640
I would say that.

30:40.640 --> 30:42.560
I mean, we don't draw the line

30:42.560 --> 30:47.040
because those are merely temporary solutions.

30:47.920 --> 30:52.920
We want to project to get to a better understanding

30:53.120 --> 30:55.320
of a state which compiles the Rust code,

30:55.320 --> 30:58.960
but in the long run, that won't be the case.

30:58.960 --> 31:02.960
We will probably reimplement those components

31:02.960 --> 31:06.000
in C++ within GCC.

31:06.000 --> 31:08.760
So yes, for now,

31:11.080 --> 31:14.280
we simply choose components that are too hard

31:14.280 --> 31:16.720
or need too much time.

31:18.720 --> 31:21.160
Yeah, in the long run, we may replace them

31:21.160 --> 31:23.360
with our own implementation.

31:34.880 --> 31:39.880
Hi, so my question is a bit, let's say different,

31:40.160 --> 31:43.200
in the sense that what would be wrong with, for example,

31:43.200 --> 31:46.880
emitting GCC tree directly from Rust C?

31:46.880 --> 31:49.960
This way you have, I think, maximum reuse

31:50.240 --> 31:54.760
already compiled Rust, you know,

31:54.760 --> 31:59.360
because you don't use LVM, but instead you use Rust GCC tree.

31:59.360 --> 32:01.680
And you could, for example, use a feature flag

32:01.680 --> 32:04.520
to toggle between these two things.

32:06.120 --> 32:11.120
So would there be a merit to exploring this?

32:11.240 --> 32:13.000
I'm not sure.

32:13.000 --> 32:15.240
I'm not sure, I'm understanding your question.

32:15.240 --> 32:18.480
Are you talking about the GCC JIT backend in Rust C?

32:20.840 --> 32:21.680
Yes.

32:21.680 --> 32:22.520
Yes?

32:24.280 --> 32:26.080
Well, one thing,

32:27.680 --> 32:29.680
this means we get a new front end

32:29.680 --> 32:33.440
which bring diversity on one end.

32:33.440 --> 32:38.440
And I believe we could backport the new front end

32:40.760 --> 32:43.040
as well as some multiple things

32:43.040 --> 32:47.600
to an earlier version of GCC for really old systems,

32:47.640 --> 32:51.040
which we cannot do on Rust C.

32:54.160 --> 32:55.000
Yeah.

32:56.800 --> 32:59.040
Well, I think my question was a bit different

32:59.040 --> 33:02.000
in the sense that Rust is a bootstrapping compiler.

33:02.000 --> 33:07.000
And the only C++ parts it really needs to function,

33:07.400 --> 33:11.000
I might be wrong here, but is LLVM in the end?

33:11.000 --> 33:12.920
So instead of LLVM, you could substitute

33:12.920 --> 33:15.760
in just a different backend.

33:18.320 --> 33:19.640
I don't want to say any mistakes,

33:19.640 --> 33:23.040
so I think you should come to Zulip

33:23.040 --> 33:25.000
and ask directly to Arthur

33:25.000 --> 33:28.000
because it will be way better than me

33:28.000 --> 33:30.920
to give you a proper answer.

33:30.920 --> 33:32.280
I'm sorry.

33:32.280 --> 33:33.360
No problem, thank you.

33:37.720 --> 33:38.560
Sorry.

33:42.040 --> 33:45.360
So to answer that question, you gave the reason yourself.

33:45.400 --> 33:48.880
You said you want to support GCC for eight,

33:48.880 --> 33:50.200
but the thing is GCC for eight

33:50.200 --> 33:52.400
doesn't have the JIT part yet.

33:52.400 --> 33:53.240
Yeah.

33:53.240 --> 33:55.560
So like if what he was talking about

33:55.560 --> 34:00.560
was the Rust C code can GCC thing

34:00.920 --> 34:03.080
that Rust already supports.

34:03.080 --> 34:06.680
So you can actually already use GCC JIT

34:06.680 --> 34:11.640
to generate code using the Rust C front end.

34:11.640 --> 34:13.000
But again, that does not work

34:13.000 --> 34:15.600
when you want to support very old versions of GCC.

34:15.600 --> 34:17.640
And that is actually what I wanted to ask.

34:17.640 --> 34:22.640
I wanted to ask, do you actually plan to upstream GCC RS

34:22.640 --> 34:25.920
support in GCC for eight so that people

34:25.920 --> 34:28.760
who actually want to use it in an old GCC version

34:28.760 --> 34:31.740
don't have to like patch it themselves?

34:33.720 --> 34:36.320
Probably, I mean for now we're focusing

34:36.320 --> 34:40.560
on only upstreaming things that we could maintain and support,

34:40.560 --> 34:42.560
but it could be possible in the future.

34:42.600 --> 34:44.840
So probably, I don't know yet.

34:48.840 --> 34:53.400
So to answer your question, follow up on your thing.

34:53.400 --> 34:56.160
So I'm the maintainer of libGCC JIT.

34:56.160 --> 34:57.680
I apologize for the name,

34:57.680 --> 34:58.960
because it also does ahead of time

34:58.960 --> 35:01.640
compile compilation and worst project name ever.

35:02.480 --> 35:07.480
And that itself is a part of GCC

35:08.200 --> 35:11.680
and therefore its build time dependency

35:11.680 --> 35:14.360
is the same as your build time dependency.

35:14.360 --> 35:19.360
So as in the subset of C++11 that GCC 4.8 supports.

35:22.840 --> 35:24.240
In terms of the other question,

35:24.240 --> 35:29.000
in terms of back porting the GCC RS work

35:29.000 --> 35:33.480
into GCC 4.8 itself, I believe GCC 4.8

35:33.480 --> 35:35.440
is still written in C.

35:35.440 --> 35:38.560
I'm not sure it's about then that we migrated from C

35:38.560 --> 35:43.560
to C++98 and that sounds like, that sounds difficult.

35:46.160 --> 35:48.720
That sounds like, yeah.

35:48.720 --> 35:51.400
But there is a bootstrapping path.

35:55.760 --> 35:57.720
We had another question over here

35:57.720 --> 36:00.680
and then thank you for being a good sport.

36:04.720 --> 36:06.320
Is there a question over here?

36:07.320 --> 36:09.160
Okay, all right.

36:10.240 --> 36:11.880
No more questions.

36:13.120 --> 36:16.320
Wonderful, can we thank our speaker again?

36:16.320 --> 36:17.160
Thank you.

