WEBVTT

00:00.000 --> 00:07.800
Ah, good.

00:07.800 --> 00:11.160
So if you're on YouTube, you probably just missed the first five minutes of this.

00:11.160 --> 00:12.160
I said nothing.

00:12.160 --> 00:15.240
Don't worry about it.

00:15.240 --> 00:21.640
So I decided rather than do what I had done previously, I'm just going to give an overview

00:21.640 --> 00:26.080
of all the major features of Karina for the minimum viable product that we're putting

00:26.080 --> 00:27.080
together.

00:27.080 --> 00:30.680
So it can be, you can have a fairly complete idea in your mind what's going to happen,

00:30.680 --> 00:33.960
because I actually haven't done that talk before, and you probably don't want to go

00:33.960 --> 00:39.600
and read a multi-section RFC and all the work we did to put that together.

00:39.600 --> 00:47.040
So since PURL 5, object-oriented syntax here was just less in IZA.

00:47.040 --> 00:51.200
There's a little bit more than that, but this is primarily the bulk of it.

00:51.200 --> 00:57.160
The model was mostly stolen from Python, and I also do Python programming.

00:57.160 --> 00:59.040
I can see the similarities.

00:59.040 --> 01:01.000
Larry regrets stealing it from Python.

01:01.000 --> 01:05.960
I can understand why, even though I like Python, I'm wrong.

01:05.960 --> 01:12.000
But blessing is that all they do is say, we have methods, and where are those methods?

01:12.000 --> 01:16.920
I'm taking the short version of this, because we're not going to spend a lot of time talking

01:16.920 --> 01:20.800
about the original version of object-oriented programming at PURL.

01:20.800 --> 01:23.360
Because it didn't give you much.

01:23.360 --> 01:28.840
Basically if you wanted everything that you want out of a class-based OO system, then

01:28.840 --> 01:30.720
you've got to write your own constructors.

01:30.720 --> 01:36.400
You've got destroy method in PURL, but destruction is non-deterministic, so that's kind of a

01:36.400 --> 01:37.400
frustration.

01:37.400 --> 01:38.600
It doesn't work as well as you'd like.

01:38.600 --> 01:42.080
If you want to maintain state, if you want encapsulation, all the sorts of things that

01:42.080 --> 01:47.840
you expect to have out of an out-of-the-box OO system you don't have with bless and IZA.

01:47.840 --> 01:51.760
And everyone had to redo it themselves every single time, and if you're a programmer, you

01:51.760 --> 01:53.840
know you don't want to do that.

01:53.840 --> 01:57.280
You want to abstract that away.

01:57.280 --> 02:02.600
So people have abstracted that away a lot.

02:02.600 --> 02:06.720
It's going to depend upon your definition of what a class is or support for a class is.

02:06.720 --> 02:07.720
Well over 80 modules.

02:07.720 --> 02:09.320
This is not an exhaustive list.

02:09.320 --> 02:12.680
I just decided to order them alphabetically by link.

02:12.680 --> 02:17.240
Have fun picking out the one that you happen to like.

02:17.240 --> 02:21.360
If you're familiar with the Lisp Curse, or if you're not familiar with it, go out here,

02:21.360 --> 02:22.880
your favorite search engine for the Lisp Curse.

02:22.880 --> 02:28.200
It will be the top hit, and it will explain how that mess came about and what we're trying

02:28.200 --> 02:29.720
to fix.

02:29.720 --> 02:34.960
So let me make that a bit larger because I can't read that.

02:34.960 --> 02:39.400
Okay, so not everything that you see here is implemented, and not all of it's going

02:39.400 --> 02:43.800
to be implemented, but you do want to see object pad that Paul Evans put together.

02:43.800 --> 02:45.720
That's a test bed for many of the ideas of Karina.

02:45.720 --> 02:48.600
So we can make sure that it actually does what we want it to do.

02:48.600 --> 02:50.520
And there are companies who are using this in production.

02:50.520 --> 02:53.120
It is so valuable to them.

02:53.120 --> 02:55.240
So some of the things you might see will change.

02:55.240 --> 02:59.800
It's work in progress, but I think I've tried to strip out anything really problematic.

02:59.800 --> 03:03.320
I'll call out the things which are what you're saying is work in progress, but this is pretty

03:03.320 --> 03:07.680
close to what we can expect.

03:07.680 --> 03:08.680
A simple class.

03:08.680 --> 03:09.680
It's very simple.

03:09.680 --> 03:10.680
It's not exciting.

03:10.680 --> 03:11.680
You create a new person.

03:11.680 --> 03:12.680
Name is Ovid.

03:12.680 --> 03:14.520
You print the name Ovid.

03:14.520 --> 03:15.520
Here you give them a title.

03:15.520 --> 03:16.520
You print the name.

03:16.520 --> 03:18.560
It automatically pre-pens it with the title.

03:18.560 --> 03:21.440
So there's Dr. McCoy.

03:21.440 --> 03:22.440
Very simple.

03:22.440 --> 03:24.840
This is not complex.

03:24.840 --> 03:31.040
On the left-hand side, that's how you're going to do that using Bless in Old Style Pearl.

03:31.040 --> 03:32.760
Here's how you do this in Karina.

03:32.760 --> 03:36.840
Note that almost all of this is very declarative in nature.

03:36.840 --> 03:38.200
You might quibble on one point.

03:38.200 --> 03:39.760
We'll come back to that later.

03:39.760 --> 03:42.440
But it's very short, very concise.

03:42.800 --> 03:45.360
You probably didn't notice this.

03:45.360 --> 03:53.200
That will mean your code's not going to work correctly because you misspelled the name.

03:53.200 --> 03:54.600
It's not even going to give you a warning.

03:54.600 --> 03:57.120
It's just going to silently fail.

03:57.120 --> 04:00.480
Sort of bugs we love to have, silent failures in code.

04:00.480 --> 04:04.920
In Karina, because that's a lexical variable field title, that's going to be a compile time

04:04.920 --> 04:09.760
error if you misspell it.

04:09.760 --> 04:12.280
That's Moose, by the way.

04:12.280 --> 04:15.720
Moose didn't gain us a lot.

04:15.720 --> 04:16.720
Not true.

04:16.720 --> 04:17.720
It does have Izzah.

04:17.720 --> 04:19.520
Izzah string for those various things.

04:19.520 --> 04:22.640
You could do non-empty string for one of them might be better.

04:22.640 --> 04:24.040
We argue about that all day long.

04:24.040 --> 04:26.920
But basically, Moose is not more terse.

04:26.920 --> 04:30.880
And it also has a lot of startup overhead.

04:30.880 --> 04:35.400
It's not slow per se anymore, but it's not the fastest thing in the world.

04:35.400 --> 04:37.400
But it does make writing an OO code better.

04:37.400 --> 04:42.680
In Karina, same thing, much more terse with the exception of the Izzah.

04:42.680 --> 04:47.240
So let's just walk through this so you can understand what's going on.

04:47.240 --> 04:50.960
To declare a class, you just say class, person.

04:50.960 --> 04:54.480
It used to be to declare a class, you couldn't.

04:54.480 --> 04:56.360
You would say package, person.

04:56.360 --> 04:58.840
And then you would bless a reference into that package.

04:58.840 --> 05:02.120
And it wasn't really a class or package.

05:02.120 --> 05:05.280
It was kind of this thing.

05:05.280 --> 05:06.800
Now they can be separate.

05:06.800 --> 05:10.560
They have a future where we can truly disambiguate these things.

05:10.560 --> 05:14.280
I might add, you can also do it this way with the post-fix syntax.

05:14.280 --> 05:15.440
I prefer this syntax.

05:15.440 --> 05:17.200
I will have it on the slides.

05:17.200 --> 05:20.800
I argued strongly, as the lead designer, I thought I could get away with this, that

05:20.800 --> 05:23.320
we're going to require the post-fix syntax.

05:23.320 --> 05:24.960
I lost that fight.

05:24.960 --> 05:29.560
And so everyone basically almost everyone disagreed with me.

05:29.560 --> 05:33.720
So I went ahead and said, OK, we'll go ahead and make this optional.

05:33.720 --> 05:36.320
But a lot of my examples, well, the post-fix syntax,

05:36.320 --> 05:37.240
absolutely not required.

05:37.240 --> 05:42.720
So don't stress about it, because I know people gave me grief at first a lot.

05:42.720 --> 05:46.120
Field, dollar, name, colon, param.

05:46.120 --> 05:49.840
That is an instance attribute, or instance field, instance slot,

05:49.840 --> 05:52.240
depending upon the language you're coming from.

05:52.240 --> 05:55.600
That's just a piece of data tied to the instance after you construct it.

05:55.600 --> 06:00.160
Because it has colon, param, it is required in the constructor.

06:00.160 --> 06:04.880
You cannot not pass that, or else it will blow up.

06:04.880 --> 06:09.280
Same thing with field, dollar, title, except it has the equals on death.

06:09.280 --> 06:11.520
That means it is optional in the constructor.

06:11.520 --> 06:13.600
You do not need to pass it in.

06:13.600 --> 06:18.240
Or you can use equals misses or something.

06:18.240 --> 06:21.240
You can give it a fake default title if you want to.

06:21.240 --> 06:23.640
Anything after the equals, you can just evaluate and run it,

06:23.640 --> 06:26.360
and that will be assigned as a default value.

06:26.360 --> 06:30.560
And then we have our name method down here,

06:30.560 --> 06:33.880
where we just access those variables directly.

06:33.880 --> 06:36.920
This gives us a chance for a lot of performance benefits.

06:36.920 --> 06:39.480
It also tremendously encapsulates this data,

06:39.480 --> 06:43.400
something which has been traditionally very, very hard to do with older

06:43.400 --> 06:48.400
Perl, because you could always reach inside the object and do stuff.

06:48.400 --> 06:52.560
Many languages make it easy to reach inside the object and do stuff.

06:52.560 --> 06:55.680
When we eventually get around to implementing a meta object protocol,

06:55.680 --> 06:58.400
you will be able to reach inside the object and do stuff.

06:58.400 --> 07:00.000
But we're going to make it harder.

07:00.000 --> 07:03.080
And the intent is you will be allowed to do it, but when you're doing things you

07:03.080 --> 07:04.960
shouldn't do, you got to put some more effort in there.

07:04.960 --> 07:08.120
It's going to be easier to show up on code reviews or just with grep.

07:11.960 --> 07:14.360
Karina, out of the box provides constructors, destructor, state,

07:14.360 --> 07:16.720
composition, encapsulation, private methods, and so on.

07:17.920 --> 07:21.400
The private stuff might actually not make it in the MVP.

07:21.400 --> 07:22.480
We won't cover that.

07:22.480 --> 07:25.560
But basically, most of what you want out of a class-based OO system

07:25.560 --> 07:30.160
is there in a very short declarative syntax.

07:32.160 --> 07:33.440
Just like that, very easy.

07:33.440 --> 07:34.600
But there's more than one way to do it.

07:34.600 --> 07:36.200
So I mentioned this is mostly declarative.

07:36.200 --> 07:41.080
You see the method down there and you're going, I don't have any way I can change

07:41.080 --> 07:41.840
the name and title.

07:41.840 --> 07:47.080
Everything by default is pretty much immutable externally with Karina.

07:47.080 --> 07:48.520
So I'm not mutating that.

07:48.520 --> 07:50.640
So why am I even calculating it every time?

07:51.800 --> 07:53.120
I could just make that a field.

07:53.680 --> 07:57.320
Reader equals if defined title, title name, else name.

07:57.320 --> 08:01.040
And that's computed once and only once at object construction time.

08:01.040 --> 08:07.080
And fields are generally evaluated in the order that they are declared,

08:07.080 --> 08:09.000
which makes it much easier to reason.

08:10.320 --> 08:12.400
In Moose, I think it's evaluated alphabetically.

08:12.400 --> 08:13.960
No, hash order.

08:13.960 --> 08:15.080
Hash order.

08:15.080 --> 08:16.080
Oh, sweet.

08:16.960 --> 08:23.480
Thank you, Steven, for just making me feel even worse about it.

08:23.480 --> 08:28.400
But I've long wanted to submit a patch to see if I could fix that, but

08:28.400 --> 08:30.160
they've said no more patches.

08:30.160 --> 08:32.280
Which is fine, I totally get why.

08:32.280 --> 08:36.760
So because they're constructed in the order that they're found,

08:36.760 --> 08:39.840
you can now have the potential for deterministic destruction because you

08:39.840 --> 08:45.080
can track that order and unwind them in last in, first out order.

08:47.080 --> 08:49.760
I don't know that that will be in the MVP either.

08:52.360 --> 08:54.760
Okay, there's only four keywords.

08:54.760 --> 08:57.240
By the way, class, field, method, and role.

08:57.240 --> 09:00.240
We actually had a lot more originally and then Damian Conway came along and

09:00.240 --> 09:01.800
did a deep dive into the spec.

09:01.800 --> 09:05.920
And he pointed out a way we could reorganize everything just by having four

09:05.920 --> 09:07.600
keywords, class, field, method, and role.

09:07.600 --> 09:10.080
And then attributes to modify their behavior.

09:10.080 --> 09:13.880
Tremendously simplified the code, made the logic much easier to follow,

09:13.880 --> 09:15.280
made the structure much easier to follow.

09:15.280 --> 09:17.920
And now I apologize, this is a much bigger slide,

09:17.920 --> 09:20.280
probably harder for some of you in the back to read.

09:20.280 --> 09:24.600
Class character is a person, that means we've inherited from person.

09:24.600 --> 09:26.200
Karina is single inheritance only.

09:27.600 --> 09:31.080
You'll notice there's a number of OO languages out there which allow no

09:31.080 --> 09:32.360
inheritance.

09:32.360 --> 09:36.080
Some of them allow only single inheritance, they almost invariably give you a way to

09:36.080 --> 09:41.000
work around that, such as interfaces or mix-ins or something else.

09:41.000 --> 09:44.240
Or you can do that with delegation, which delegation is much more powerful than

09:44.240 --> 09:45.720
people think, but there's not a talk about that.

09:47.760 --> 09:49.040
So I've now declared this class.

09:50.200 --> 09:53.000
And you'll notice I have an underscore defense for my reader.

09:53.000 --> 09:54.600
I don't have readers or writers for anything.

09:54.600 --> 09:59.200
Reader means that you can call target arrow underscore defense and read that value.

10:01.040 --> 10:03.520
There's something called trusted methods where you want methods to be

10:03.520 --> 10:07.040
callable by other classes, but you don't want people outside to be able to call them.

10:08.200 --> 10:10.360
We have done a lot of bike shedding on how to get there, and

10:10.360 --> 10:11.760
it's not gonna happen anytime soon.

10:11.800 --> 10:15.760
So for now, I punted and thought this is a reasonable compromise.

10:15.760 --> 10:19.440
We use a familiar pearl syntax for saying underscore defense.

10:19.440 --> 10:23.400
That is, think of it as a trusted method or a private method.

10:23.400 --> 10:27.240
And as a result, you can call that and people outside know not to.

10:27.240 --> 10:30.480
Notice the only methods we have public are isDead, adjust hit points, and

10:30.480 --> 10:33.800
attack, because you want your interfaces to be as small as possible.

10:33.800 --> 10:35.960
Because later on, if you have to change your interfaces,

10:35.960 --> 10:38.440
you're stuck if you've exposed everything publicly.

10:39.440 --> 10:42.920
So, Karina by default forces you to add the colon reader and

10:42.920 --> 10:47.640
colon writer keywords to fields because you have to choose,

10:47.640 --> 10:51.320
you have to opt in to making your contract public.

10:51.320 --> 10:55.680
Rather than with moose and moo and others, the default is everything's public.

10:55.680 --> 10:57.200
And if you want a private, too bad.

11:00.720 --> 11:03.680
And we have this constrain function.

11:03.680 --> 11:06.720
I'll talk more about subroutines being imported.

11:06.720 --> 11:08.840
But basically constrain is a function.

11:08.840 --> 11:12.640
Again, this is something I don't think we're gonna get to in the MVP.

11:12.640 --> 11:16.040
The intent is methods and subroutines are not the same thing.

11:16.040 --> 11:18.880
And you should not be able to call a subroutine as a method.

11:18.880 --> 11:22.000
You should not be able to call a method as a subroutine.

11:22.000 --> 11:25.800
And you can disambiguate them even if they have the same name.

11:28.000 --> 11:30.320
But just something to think about for later work.

11:32.480 --> 11:35.840
So, we did our subclassing, there's a little Dorothy there.

11:35.840 --> 11:39.680
And we create a new dothvader object, a captain Kirk object.

11:39.680 --> 11:44.560
And while not Kirk is dead, Vader beats him with his lightsaber until Kirk is dead.

11:44.560 --> 11:46.000
It's just very simple, it's easy.

11:46.000 --> 11:47.640
It works, yes, Vader will kill Kirk.

11:47.640 --> 11:51.280
I'm sorry, I do for Star Trek to Star Trek to Star Wars.

11:51.280 --> 11:53.560
But in this case, yeah, Vader, yeah, he wins.

11:54.560 --> 11:57.920
Very simple, very easy, and there's nothing when you get down to it,

11:57.920 --> 12:00.320
there's nothing really complicated about the code.

12:00.320 --> 12:03.040
It's simpler, it's easier to write, it's well encapsulated.

12:03.880 --> 12:06.720
But I want to talk about constructors a little bit so

12:06.720 --> 12:09.400
you understand some of the design work that we put in here.

12:10.520 --> 12:14.280
A lot of it we argued, I think it took like three years of arguing to finally

12:14.280 --> 12:16.560
get to something we could agree on.

12:16.560 --> 12:21.860
So, we have key value pairs, named arguments to the constructor,

12:21.860 --> 12:24.400
name, title, and offense.

12:24.400 --> 12:26.760
And it is absolutely required that you do that.

12:26.760 --> 12:31.840
You can create an alternate constructor if you want, called new unnamed and

12:31.960 --> 12:35.520
have a delegate off, but we do this for readability.

12:35.520 --> 12:37.800
And there's also some other benefits.

12:37.800 --> 12:41.080
So right now, here's a constructor in Java, character of Vader equals new character.

12:41.080 --> 12:44.000
And then if you didn't know what those were,

12:44.000 --> 12:46.200
it might not be clear what you're constructing.

12:47.560 --> 12:52.640
And in fact, you've got alternate, you've got optional data for your constructors.

12:52.640 --> 12:55.720
So you have to create multiple constructors.

12:55.720 --> 12:59.320
I won't go into details, but you might have to create multiple, multiple constructors.

12:59.320 --> 13:03.760
If we have in this particular example, or use a hash map and extract it manually.

13:03.760 --> 13:04.400
It's a pain.

13:04.400 --> 13:05.520
Karina, you don't have to do that.

13:05.520 --> 13:08.360
You have a declarative specification at the top of your code.

13:08.360 --> 13:10.280
Here's how our instance data works.

13:14.280 --> 13:19.480
So, writing the manual constructor in Java for a car, that's actually very readable.

13:19.480 --> 13:20.600
It's very easy to read.

13:22.160 --> 13:24.080
Calling it is not.

13:24.080 --> 13:26.440
I don't, I just looked at the code.

13:26.440 --> 13:28.560
I wrote this code and I don't remember it.

13:28.560 --> 13:31.040
I don't know what those numbers necessarily mean.

13:32.240 --> 13:35.400
So, that's why we try to avoid that.

13:35.400 --> 13:37.720
And in Perl, we have named arguments.

13:37.720 --> 13:39.600
Yes, you have to do a little bit more typing.

13:39.600 --> 13:41.400
This is for maintenance.

13:41.400 --> 13:44.160
You absolutely want to make it easier to maintain your code.

13:47.680 --> 13:49.520
And it's gonna kill you a few times.

13:49.520 --> 13:52.440
And you're not gonna be happy about this, but you'll get used to it because it's

13:52.440 --> 13:53.680
gonna become natural, I hope.

13:55.920 --> 13:58.080
So here, that's not character class.

13:58.080 --> 13:59.120
That's a person class.

13:59.120 --> 14:00.920
And we've passed in offense.

14:00.920 --> 14:03.840
Offense is not defined as one of your param fields.

14:03.840 --> 14:04.760
So that's gonna die.

14:06.680 --> 14:10.600
And I've heard people argue, well, I should be able to pass in extra data.

14:10.600 --> 14:13.680
Maybe my son class will use it, or there's some other way I can handle it.

14:13.680 --> 14:17.840
Yes, there is other way you can handle it, like every other authoritarian language does.

14:17.840 --> 14:21.320
Provide something which is actually going to properly capture that.

14:21.320 --> 14:25.560
But the real reason is, remember, title is optional.

14:25.560 --> 14:30.760
So if I misspelled title, it would think it's simply optional data.

14:30.760 --> 14:35.840
Now, because it's mandatory, you can't pass in anything which is not known to the

14:35.840 --> 14:39.680
constructor, then that is going to be a fatal error.

14:39.680 --> 14:44.040
And it's gonna be a very hard to detect bug that you don't have to worry about anymore.

14:44.040 --> 14:48.960
If you want to pass in extra optional data, make a parameter called extra.

14:48.960 --> 14:52.440
Extra column param equals hash ref.

14:52.440 --> 14:55.880
And then just allow them to muddle around with that.

14:55.880 --> 14:56.480
It's much cleaner.

14:58.800 --> 15:03.280
Moose allows you to pass in a hash ref instead of a list.

15:03.280 --> 15:04.600
We do not do that.

15:04.600 --> 15:07.960
We want one way of being able to call the object because it's just simple.

15:07.960 --> 15:13.160
This also preserves the ordering of those in case that becomes necessary in the future.

15:13.160 --> 15:18.040
Also, a hash ref will, any duplicate name in the hash ref will collapse over a previous

15:18.040 --> 15:20.400
one, which is kind of annoying.

15:20.400 --> 15:23.000
There are ways you can work around that if you actually want this behavior for

15:23.000 --> 15:24.600
setting defaults.

15:24.600 --> 15:27.880
But we decided this was the safest way to go, just to make one and

15:27.880 --> 15:30.400
only one way of calling the constructor.

15:30.400 --> 15:30.920
Thank you.

15:33.560 --> 15:35.720
So, I didn't talk fast enough, apparently.

15:37.960 --> 15:42.600
Here, field name, dollar name, dollar name, in both of those, those are lexically scoped.

15:42.600 --> 15:44.760
There is no conflict anymore.

15:44.760 --> 15:50.760
And with bless, if you had a arrow, open print name in your hash ref, but

15:50.760 --> 15:52.640
your parent did too, you're going to blow up.

15:52.640 --> 15:56.040
Here, it's completely encapsulated until you expose it.

15:57.200 --> 15:59.760
Now when you expose it, I have column parameter each, and

15:59.760 --> 16:03.520
I now have two param methods, and that's going to blow up.

16:03.520 --> 16:05.200
You can't override params.

16:05.200 --> 16:06.400
We might restrict that later.

16:06.400 --> 16:08.400
You can override methods.

16:08.400 --> 16:12.720
Sorry, methods automatically generated by param or, sorry, field and other things.

16:13.720 --> 16:15.240
I got ahead of myself.

16:15.240 --> 16:16.200
Never mind.

16:16.200 --> 16:17.920
So I can do this param car name.

16:17.920 --> 16:20.360
That means now you pass that to the instructor's car name, and

16:20.360 --> 16:22.360
there's no longer a conflict with parent class.

16:22.360 --> 16:25.560
Your parent and children classes should always be able to trust their internal

16:25.560 --> 16:27.960
implementation, always.

16:27.960 --> 16:30.680
So when they hit an external implementation, they're making a contract,

16:30.680 --> 16:32.640
and then they've got to negotiate and find out what works.

16:35.080 --> 16:36.160
Here's another example.

16:36.160 --> 16:37.400
Those are also going to blow up.

16:37.400 --> 16:39.880
That's the case where we're actually generating methods, but

16:39.880 --> 16:42.000
we cannot override those directly.

16:42.160 --> 16:44.560
You can create your own little stub method if you want to override it.

16:46.920 --> 16:50.560
Again, you can rename those in order to allow that to be safe.

16:53.000 --> 16:57.560
Class data, field, num characters, colon common means this is class data.

16:57.560 --> 17:01.520
You can also slap colon comma on a method and call that a class method.

17:01.520 --> 17:05.440
Adjust is called after the object is constructed, or actually it's called when

17:05.440 --> 17:08.360
it's hit, sorry, Paul.

17:08.360 --> 17:10.600
Is it called when it's hit or after the object's constructed?

17:11.600 --> 17:12.960
It's called when it's hit, right?

17:12.960 --> 17:16.520
Adjust was run as part of the constructor, yeah.

17:16.520 --> 17:21.320
Okay, destruct will run when the object is destroyed.

17:21.320 --> 17:23.920
So here I can track how many character instances I've created.

17:23.920 --> 17:26.120
It's very simple, works naturally in the language.

17:27.360 --> 17:29.400
And then I have another class, my world class.

17:29.400 --> 17:31.320
I can figure out the difficulty of my world.

17:31.320 --> 17:33.040
I've got my class method available.

17:33.040 --> 17:35.880
I can figure out how many characters and I can tell them how difficult the world is.

17:37.160 --> 17:39.320
Again, it's stuff which is now built into the language and

17:39.320 --> 17:40.960
you don't have to worry about that anymore.

17:43.800 --> 17:45.520
Is there anyone here who does not know what roles are?

17:48.520 --> 17:52.480
Okay, just in case roles are kind of like mixins you'd find in Ruby or

17:52.480 --> 17:55.680
interfaces with default implementations you'd find with other languages.

17:55.680 --> 17:59.520
And these allow you to take a small subset of behavior which doesn't

17:59.520 --> 18:04.400
necessarily belong to a class, a specific class, and move it often to its own role.

18:04.400 --> 18:07.200
And then you can compose it into the class.

18:07.200 --> 18:09.280
And then you will get that behavior.

18:09.280 --> 18:12.440
However, those methods are flattened into the class directly.

18:12.440 --> 18:16.200
There's no tricks with inheritance, there's no funky dispatch or

18:16.200 --> 18:17.640
anything like that, it's actually in the class.

18:18.560 --> 18:24.200
So method as hash ref, because this is what we call a forward declaration,

18:24.200 --> 18:26.280
because it doesn't have a body for the method.

18:26.280 --> 18:29.800
Anything with a forward declaration is required to be implemented by whatever is

18:29.800 --> 18:30.240
calling it.

18:31.320 --> 18:33.320
It can be implemented by the class directly or

18:33.320 --> 18:36.240
if the class consumes other roles as other roles might implement it.

18:39.280 --> 18:42.920
And then to JSON, here's another example where we want to get to the point where

18:42.920 --> 18:44.120
we can disambiguate.

18:44.120 --> 18:48.000
This is probably a terrible example because you don't wanna confuse those.

18:48.000 --> 18:51.040
But the reality is you should be able to call those separately and

18:51.040 --> 18:55.200
have them work correctly, even though you probably shouldn't name them the same.

18:55.200 --> 18:59.080
But it gets you some safety in the code and avoids the odd case where you called

18:59.080 --> 19:01.720
subroutine as a method, and believe me, I've hit that before.

19:03.760 --> 19:07.320
And self is injected directly into the method.

19:07.320 --> 19:09.000
You don't have to declare it in your signature.

19:10.320 --> 19:14.520
If you have a common method, so self, you also get a dollar class variable,

19:14.520 --> 19:16.840
which is the class name of the invocant.

19:16.840 --> 19:21.360
If you have a dollar common attribute, that means it's a shared method,

19:21.360 --> 19:24.720
which means self will not be available, but dollar class will.

19:24.720 --> 19:28.000
And again, those will fail at compile time if you get them spelled wrong.

19:28.000 --> 19:31.360
Which means if you declare something as a class method with a colon common and

19:31.360 --> 19:34.240
you're trying to access dollar self in there, that should be a compile time failure.

19:37.800 --> 19:42.120
You don't wanna use this code, but here, field dollar cash, once again,

19:42.120 --> 19:45.400
my implementation should be able to trust its internals.

19:45.400 --> 19:49.960
So nothing else actually gets to see the dollar cash that I have declared in my role.

19:49.960 --> 19:52.760
You don't wanna use this because this would work if you can guarantee your

19:52.760 --> 19:55.200
objects are immutable, but you can't.

19:55.200 --> 19:57.280
So you actually probably don't wanna cash those.

19:57.280 --> 20:01.000
But this is one way you can have of accessing data inside the role,

20:01.000 --> 20:02.680
which you don't share with others.

20:05.320 --> 20:06.840
And then using a role, it's pretty simple.

20:06.840 --> 20:10.600
So there's my serializable role, this one just does JSON.

20:10.600 --> 20:13.080
My character is a person, does serializable.

20:13.080 --> 20:15.440
All I have to do is define a hash ref method.

20:15.440 --> 20:18.000
And hopefully, when it's called up there,

20:18.000 --> 20:21.080
it will properly serialize into JSON, depending upon.

20:21.080 --> 20:23.200
I did a lot of hand waving there.

20:23.200 --> 20:24.880
But that's basically how it works.

20:24.880 --> 20:28.160
If you're familiar with roles, it's what you expect out of roles.

20:32.200 --> 20:35.200
So here's the various attributes we have.

20:35.200 --> 20:36.040
Class attributes.

20:36.040 --> 20:38.000
We have is a and does.

20:38.000 --> 20:39.680
Is a, again, is single inheritance.

20:39.680 --> 20:40.640
You can put one class in there.

20:41.800 --> 20:43.200
Okay, great, I've got plenty of time.

20:44.360 --> 20:49.880
Does, however, can have a comma separated list of roles that are allowed in there.

20:49.880 --> 20:54.720
If you're familiar with roles, there's ways you can exclude or alias methods.

20:54.720 --> 20:59.680
We don't actually provide that syntax here because we argued too much about how to

20:59.680 --> 21:01.760
make that work, and we just punted on that.

21:01.760 --> 21:02.360
I apologize.

21:03.080 --> 21:07.000
Well, attributes, it simply does.

21:07.000 --> 21:11.560
Roll serializable does some other role, whatever.

21:11.560 --> 21:16.480
Maybe it does a YAML role, an JSON role, and a TAML role, and

21:16.480 --> 21:19.680
can serialize all those different things if it's given the right data structure.

21:19.680 --> 21:22.440
Quite possibly cannot, but that's how roles work.

21:22.440 --> 21:24.120
Roles can consume other roles.

21:24.120 --> 21:27.200
And we do want to make sure we preserve the commutative and

21:27.200 --> 21:31.960
associative behavior so you can mix and match roles any way you want to in any order.

21:31.960 --> 21:36.240
In any combination, and it should work correctly unlike with inheritance and

21:36.240 --> 21:40.480
mixins where if you shuffle the order, you have no guarantee your code's gonna work anymore.

21:43.320 --> 21:45.560
Field attributes, this one's a little bit more.

21:46.800 --> 21:49.000
Reader, or you can rename your reader.

21:49.000 --> 21:54.760
Writer, automatically propends the name with set underscore,

21:54.760 --> 21:58.000
because we're disambiguating between the reading and the writing.

21:58.000 --> 22:02.560
And there's reasons for that dealing with return types and

22:02.560 --> 22:04.600
not being able to overload things properly.

22:04.600 --> 22:08.040
And also wanting to discourage people from writing mutable objects, but

22:08.040 --> 22:10.800
making it easy for them to do if they wish to.

22:10.800 --> 22:12.160
But it's available there.

22:12.160 --> 22:15.600
Param, whether or not it's available in the constructor.

22:15.600 --> 22:17.680
Week, to create a weak reference.

22:17.680 --> 22:20.640
Column common means it's a class data.

22:22.920 --> 22:26.560
Method attributes, do we override a parent method?

22:29.000 --> 22:33.800
If you want a method to be abstract in your parent class, just again,

22:33.800 --> 22:36.880
just declare it as method, method name, do not use a signature.

22:36.880 --> 22:39.480
And do not provide a method body, it's automatically an abstract class.

22:39.480 --> 22:43.800
And it must be overridden in a child class or with luck it will be a compile time error.

22:45.360 --> 22:49.400
Common, so you can have a class method which does not inject the dollar self variable.

22:49.400 --> 22:53.080
Around before and after are the standard method modifiers that you have.

22:54.080 --> 22:59.360
To be honest, I wish we had gone with something like, sorry folks,

22:59.360 --> 23:03.200
Python decorators because it's so much easier to use.

23:03.200 --> 23:09.040
But that would require attributes to be modified and how they actually get handled.

23:09.040 --> 23:14.240
Because right now the data inside of the arguments to an attribute is just a simple

23:14.240 --> 23:17.720
string, can't be parsed effectively or can't be run effectively.

23:17.720 --> 23:21.080
There's some discussion, I think Paul has been handling some of that,

23:21.080 --> 23:22.800
about how to maybe change that in the future.

23:25.160 --> 23:30.240
Some of the things we have already written in just the very beginnings of Karina.

23:30.240 --> 23:32.400
We have Stella, an actor model for Pearl.

23:32.400 --> 23:35.040
An actor model basically means if you have a box of toys,

23:35.040 --> 23:38.280
they know how to play with each other, you don't have to play with them yourself.

23:38.280 --> 23:39.480
That's the simple explanation.

23:39.480 --> 23:41.160
What's that?

23:41.160 --> 23:54.160
Okay, thank you.

23:54.160 --> 23:55.240
I'm very curious to see that.

23:57.040 --> 24:00.480
We also have a yellow cooperative message passing concurrency event loops,

24:00.480 --> 24:02.520
actors, promises.

24:02.520 --> 24:04.680
That one looks like a lot of fun.

24:04.680 --> 24:05.720
That's also done by Steven.

24:05.720 --> 24:07.200
You don't like that?

24:07.640 --> 24:13.240
Okay, these are some of the early prototypes we've been building with this.

24:13.240 --> 24:15.560
I used Karina a lot.

24:15.560 --> 24:21.360
This is a rogue-like tutorial that Chris Prather has been putting together.

24:21.360 --> 24:23.480
You've seen Rogue before, most of you.

24:23.480 --> 24:28.160
And I elated some of those, but basically parts one through six.

24:28.160 --> 24:29.240
He hasn't done more than that.

24:29.240 --> 24:35.240
What amazed me is I thought we would have to have much more of Karina built for

24:35.240 --> 24:36.160
it to actually be useful.

24:36.640 --> 24:38.560
I was wrong.

24:38.560 --> 24:44.720
Even a very tiny subset, properly designed subset of a class-based system works very

24:44.720 --> 24:46.440
well and is very powerful.

24:46.440 --> 24:48.000
I was really surprised by that.

24:48.000 --> 24:52.120
It also might force you to use composition and delegation more often,

24:52.120 --> 24:53.680
which trust me, that's your friend.

24:53.680 --> 24:54.600
I won't go into it right now.

24:56.440 --> 24:57.960
And I'm sorry, that was very fast.

24:57.960 --> 24:58.560
It was an overview.

24:58.560 --> 25:01.600
It was probably one of my least exciting talks, but I wanted to be able to have

25:01.600 --> 25:04.880
something that I can refer people to this and say, look, here's a short overview.

25:04.880 --> 25:08.280
If you want to have a video instead of reading the RFC or something like that.

25:08.280 --> 25:12.240
The actual RFC is at github.com, Perlapallo, Karina, BlavMessor.

25:12.240 --> 25:13.320
I'll put this up a slideshare.

25:15.200 --> 25:19.200
There's the seven stages which are referred to in that MVP of what we're

25:19.200 --> 25:22.680
trying to implement, unknown timeline as to when it's going to be done.

25:22.680 --> 25:25.320
It's already much more powerful than I thought.

25:25.320 --> 25:26.840
Really surprised by that.

25:26.840 --> 25:28.520
There's lots more to be done.

25:28.520 --> 25:34.480
If you want to see this, the single best thing I think you can do is download it,

25:34.480 --> 25:38.440
compile it, start playing around with it, send bug reports to Paul,

25:38.440 --> 25:42.640
give feedback, write tests for it, write documentation for it.

25:42.640 --> 25:47.400
We need that because conceptually it's very small, but under the hood,

25:47.400 --> 25:49.640
there's a lot of stuff which has to happen to make that done.

25:49.640 --> 25:53.680
And anything you could do to help Paul take some of that work off of him means

25:53.680 --> 25:54.920
we will get it out there faster.

25:56.360 --> 25:57.400
Does anyone have any questions?

26:01.840 --> 26:03.200
No, yes, sorry.

26:04.160 --> 26:06.080
Please speak up by the way, I'm a bit hard of hearing.

26:06.080 --> 26:11.280
Yeah, you mentioned the overrides as a way of following my pessimism.

26:11.280 --> 26:16.600
What happens if you have a base method and a derived class method with the same

26:16.600 --> 26:20.560
name without the overrides attribute?

26:20.560 --> 26:25.400
Right now I think that should be a, if the method is defined in the, sorry,

26:25.400 --> 26:30.040
what happens if in a subclass you're overriding a class which already has

26:30.040 --> 26:34.160
that method defined but doesn't, but has a body, so

26:34.160 --> 26:36.640
you're overriding something which already exists.

26:36.640 --> 26:40.800
That's something I, one thing a parent class generally should not know who or

26:40.800 --> 26:42.640
what is subclassing it.

26:42.640 --> 26:47.360
It shouldn't have to know that if that is at all possible, because that winds up

26:47.360 --> 26:49.440
coupling it too tight with the subclass.

26:49.440 --> 26:52.800
And as a result, if we try to put any sort of annotation on the parent class

26:52.800 --> 26:57.760
saying this is sub, subclassable, we might want to be able to allow a final

26:57.760 --> 27:02.160
attribute on something so you can't overwrite it, but we had to get an MVP out

27:02.160 --> 27:02.360
there.

27:02.360 --> 27:04.640
So right now it's a method body's defined.

27:04.640 --> 27:08.520
If you overwrite it in a subclass, adding the override tag is good.

27:08.520 --> 27:13.280
And I would like it to have a warning if you override something and you don't

27:13.280 --> 27:15.000
have the override tag.

27:15.000 --> 27:18.600
Or if it's an abstract method and you don't overwrite it, then it's fatal.

27:18.600 --> 27:21.880
Or maybe if you override, you don't have the override attribute, then it should

27:21.880 --> 27:24.440
be fatal, but we can punt on that.

27:24.440 --> 27:26.760
Any other questions?

27:26.760 --> 27:30.320
Can the rules have a method body?

27:30.320 --> 27:31.320
I'm sorry?

27:31.320 --> 27:38.320
Can the rules have a method body?

27:38.320 --> 27:43.360
If it's a required method in the role, it cannot have a method body.

27:43.360 --> 27:44.600
There are ways you could work around that.

27:44.600 --> 27:48.000
You could create a default method, which has a separate name from the required

27:48.000 --> 27:48.960
method.

27:48.960 --> 27:52.920
And inside of your methods, it's going to, no, you'd still have to have the other

27:52.920 --> 27:53.920
method required.

27:53.920 --> 27:54.920
So it's a yada, yada, yada, operator.

27:54.920 --> 27:55.920
I found a very nice.

27:55.920 --> 27:56.920
Oh, I forgot about that.

27:56.920 --> 28:00.920
So basically you make a method and then you just, the body of method is dot, dot,

28:00.920 --> 28:05.920
dot, which is the yada, yada, yada operator, which was added, I don't know when.

28:05.920 --> 28:06.920
5, 5.

28:06.920 --> 28:07.920
5, 5.

28:07.920 --> 28:08.920
So it's been around forever.

28:08.920 --> 28:11.920
And all it does is it just blows up different times.

28:11.920 --> 28:13.920
It's died with no messages.

28:13.920 --> 28:15.920
But it's very useful for, yeah.

28:15.920 --> 28:19.920
Yeah, that might work.

28:19.920 --> 28:21.920
Any other questions?

28:21.920 --> 28:24.920
Or do we still have time?

28:24.920 --> 28:28.920
Two minutes.

28:28.920 --> 28:29.920
Not you.

28:29.920 --> 28:34.920
You were exporting stuff, or exporting subroutines.

28:34.920 --> 28:36.920
Lexical, exportated.

28:36.920 --> 28:39.920
I've been using it and it's been working quite well with it, Corinna.

28:39.920 --> 28:41.920
And it doesn't seem to conflict.

28:41.920 --> 28:42.920
Oh.

28:42.920 --> 28:43.920
Lexically exporting subroutines.

28:43.920 --> 28:44.920
And then it removes the symbol.

28:44.920 --> 28:45.920
Yeah.

28:45.920 --> 28:46.920
So it's bound but not callable.

28:46.920 --> 28:49.920
Yeah, in the built-in package, there's an export Lexically, right?

28:49.920 --> 28:53.920
And then you put that inside your import, you can export things flexibly.

28:53.920 --> 28:56.920
And then they're entirely different scope.

28:56.920 --> 28:57.920
Nice.

28:57.920 --> 28:58.920
OK.

28:58.920 --> 28:59.920
I very much like that.

28:59.920 --> 29:00.920
I'll show you.

29:00.920 --> 29:01.920
OK.

29:01.920 --> 29:03.920
Actually, talk to Paul, because he's the one who's going to be doing some.

29:03.920 --> 29:05.920
We'll talk 20 minutes and I'll talk about it.

29:05.920 --> 29:06.920
What's that?

29:06.920 --> 29:07.920
Wait 20 minutes and I'll be talking.

29:07.920 --> 29:10.920
OK.

29:10.920 --> 29:15.920
One last question.

29:15.920 --> 29:16.920
OK.

29:16.920 --> 29:17.920
Thank you very much.

29:17.920 --> 29:18.920
Thank you.

29:18.920 --> 29:19.920
Thank you.

29:19.920 --> 29:20.920
Thank you.

29:20.920 --> 29:21.920
Thank you.

29:21.920 --> 29:22.920
Thank you.

29:22.920 --> 29:23.920
Thank you.

29:23.920 --> 29:24.920
Thank you.

29:24.920 --> 29:25.920
Thank you.

29:25.920 --> 29:26.920
Thank you.

29:26.920 --> 29:27.920
Thank you.

29:27.920 --> 29:28.920
Thank you.

29:28.920 --> 29:29.920
Thank you.

29:29.920 --> 29:30.920
Thank you.

29:30.920 --> 29:31.920
Thank you.

29:31.920 --> 29:32.920
Thank you.

29:32.920 --> 29:33.920
Thank you.

29:33.920 --> 29:34.920
Thank you.

29:34.920 --> 29:35.920
Thank you.

29:35.920 --> 29:36.920
Thank you.

29:36.920 --> 29:37.920
Thank you.

29:37.920 --> 29:38.920
Thank you.

29:38.920 --> 29:39.920
Thank you.

29:39.920 --> 29:40.920
Thank you.

29:40.920 --> 29:41.920
Thank you.

29:41.920 --> 29:42.920
Thank you.

29:42.920 --> 29:43.920
Thank you.

29:43.920 --> 29:44.920
Thank you.

29:44.920 --> 29:45.920
Thank you.

29:45.920 --> 29:46.920
Thank you.

