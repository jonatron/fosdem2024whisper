WEBVTT

00:00.000 --> 00:09.000
Okay, so this talk will be a little different. That was very impressed by the other talks,

00:09.000 --> 00:13.560
so now I feel like I have the worst one. But it will be a little different because the

00:13.560 --> 00:17.560
problem we have is a little bit different than the problems you have seen in previous

00:17.560 --> 00:24.080
presentations. The talk is called Confed's and Postem asked me to make a nice title,

00:24.080 --> 00:31.560
this is what I came up with. Who am I? I am Jeffrey, Jeffrey Rungen. I work at the NFI

00:31.560 --> 00:37.960
already for 10 years, as you can see by the loss of my hair, I'm getting old. I am the lead

00:37.960 --> 00:47.680
scientist of the exploitation team at the NFI. Oh, sorry, we'll get to what the NFI is. My favorite

00:47.680 --> 00:52.120
area of study is the overlap between hard and software, as we've seen the memory map

00:52.160 --> 00:56.080
profiles and register interfaces is where I'm at. My expertise is in reverse engineering

00:56.080 --> 01:03.080
exploitation, which requires emulation and some non-invasive hardware attacks. This is Luke,

01:03.080 --> 01:12.480
my colleague. Oh, yes, this works. Yeah, so I'm also a member of the exploitation team. Now I did

01:12.520 --> 01:21.760
this research at the NFI before I worked there just during my master thesis. Yeah, and that's

01:21.760 --> 01:29.080
also how I wrote into this subject. The NFI is the Netherlands Forensic Institute, and it's a bit

01:29.080 --> 01:34.280
weird because in other countries, if you get a case and it goes to court, the police do the

01:34.280 --> 01:40.800
forensic investigation. In the Netherlands, that's not the case because in a weird way,

01:41.000 --> 01:46.840
the police are considered not to be independent all of the time. So the defense should also be

01:46.840 --> 01:53.480
able to request evidence and request research and evidence. So what we have is the Netherlands

01:53.480 --> 02:00.640
Forensics Institute, and the police can request cases from us, but also the court itself and the

02:00.640 --> 02:07.880
defense, of course. That makes it also a bit weird in how it's set up because it's not just a digital

02:08.040 --> 02:14.440
lab. We have almost all the forensic principles in one building, which includes biological traces,

02:14.440 --> 02:20.520
chemical and physical. So biological is DNA, pathology, all kinds of stuff. Chemical and

02:20.520 --> 02:27.360
physical traces includes, for example, fiber research for clothing and other stuff, glass research,

02:27.360 --> 02:37.680
but also explosives. And toxicology, which has the drugs, which is, well, digital and biometric

02:37.680 --> 02:42.760
traces. This is where we come in. So we are the digital traces, but the digital and biometrics,

02:42.760 --> 02:46.960
they thought it was handy to put them together. So we're also together in a department with,

02:46.960 --> 02:52.400
for example, fingerprint research and other stuff. One of the weird things that comes out of this is

02:52.400 --> 02:59.640
that we get a lot of cooperation with other departments, mostly on machinery for us, and to

02:59.640 --> 03:05.800
make databases for all kinds of stuff. But for example, we used to use the X-ray scanner that

03:06.000 --> 03:13.760
pathology had to examine bodies, to examine PCBs. But then the resolution was not that great. So we

03:13.760 --> 03:18.760
got our own X-ray scanner. And they had just installed it. I was very excited to see it,

03:18.760 --> 03:23.640
and I come in, and there's a full human head and a jar inside of it. They heard we got a new one.

03:23.640 --> 03:33.600
Yes. And we also, I will not tell too much about this. See me after this presentation,

03:33.640 --> 03:43.120
if you want to know more. So what do we do at the NFI, except the human head thing? We are

03:43.120 --> 03:49.640
team exploitation, which is just a part of the digital team. And most of what we do is extracting

03:49.640 --> 03:55.480
and decrypting evidence from digital devices. And that's a very hard thing to do, and it requires

03:55.480 --> 04:03.240
some legal hard to place things. And that's why the NFI can only do offline methods. So of

04:03.280 --> 04:07.720
course, when you do exploitation, you're actively might be looking for vulnerabilities, for example.

04:07.720 --> 04:13.280
And because of that, we are not allowed to do anything outside of the building. So if we find

04:13.280 --> 04:18.320
your Facebook or off tokens, we're not allowed to look at your vacation pictures, but we can just

04:18.320 --> 04:23.520
give them to the police, and then they can ask permission if we find something. And the evidence

04:23.520 --> 04:28.560
takes many forms, which is what makes this job a lot of fun for me, at least. So of course,

04:28.680 --> 04:36.080
phones is a big one, but also USB sticks, crypto wallets, cars, everything from airplanes as well

04:36.080 --> 04:45.640
to cranes and building sites, we've had them as well. It's a very varying job. And of course,

04:45.640 --> 04:53.200
how do you do decryption of data if you don't have the keys or you don't have a method? You do

04:53.240 --> 04:58.720
reverse engineering, as we've seen the iPhone talk just now. Through reverse engineering, we can

04:58.720 --> 05:05.120
do exploitation. We use fuzzing as well to not have the manual labor. And we use various hardware

05:05.120 --> 05:10.960
based methods, which I will not go into now, because the scale is really large. So let's get

05:10.960 --> 05:16.720
into the technical stuff of things. How did this talk come about? Well, first, you need to know a

05:16.760 --> 05:23.520
little bit about how we do our reverse engineering. And if we just take, for example, as a use case,

05:23.520 --> 05:31.280
an Android boot chain, how does it work? We always start on Android with a primary boot loader,

05:31.280 --> 05:36.160
which is the same as Secure ROM that you saw on the iPhone. It's a piece of ROM that's fused into

05:36.160 --> 05:43.800
the chip, cannot be changed. If you find anything, that's nice for us. But the primary boot loader's

05:43.840 --> 05:51.720
main job is to initialize the storage, for example, EMMC or UFS, and then verify, load the next

05:51.720 --> 05:57.400
boot part from there and verify it and jump into it. The next part is called the secondary boot

05:57.400 --> 06:02.240
loader, which does most of the rest of the hardware initialization to get the system further up and

06:02.240 --> 06:08.320
running. And then we get into the specifics, the A boot, the Android boot loader. And the Android

06:08.320 --> 06:13.240
boot loader just sets everything up for the kernel, in a trim of S. It has some modes, for

06:13.280 --> 06:19.400
example, a lot of you might know fast boot. There's also an A boot that's for rescue type

06:19.400 --> 06:27.280
operations if you destroyed something else. And A boot, again, takes the kernel, verifies it in

06:27.280 --> 06:31.880
the boot image with the inner RD inside of it, verifies it, sets it up, jumps into it. And the

06:31.880 --> 06:39.000
kernel boots the user LAN. In the case of Android, Xigote, doesn't have to be, Graphene doesn't use

06:39.080 --> 06:46.280
it, I think. But from a reverse engineering standpoint, what is interesting about all these

06:46.280 --> 06:52.920
things and is how we can reverse them and how hard that is. For example, user LAN, you have a lot

06:52.920 --> 06:57.680
of library calls, there's a well-defined system, you know, how it works, what it does for most of

06:57.680 --> 07:05.440
the time. So we can quite, we can reverse it quite well, I would say. Linux kernel has the same

07:05.480 --> 07:11.520
thing, it also has a lot of known structures, which is really nice. As you also saw, I will

07:11.520 --> 07:16.840
grab back on the iPhone talk again, you saw a lot of these structs that were already defined. We

07:16.840 --> 07:21.120
can do that in the Linux kernel as well, because all these structs are preset and we know about them,

07:21.120 --> 07:26.440
so we can use them to our advantage. And we have A boot, which is already a bit more proprietary.

07:26.440 --> 07:31.560
There are some strings, some known interfaces, you know, some hardware that lives in there and how

07:31.600 --> 07:38.080
it works. And that gives you some device registers, which gives you some context. The secondary

07:38.080 --> 07:43.520
boot loader is getting a lot harder already, because that is very proprietary, there's not too

07:43.520 --> 07:49.040
many strings. There's some known protocols, but for example, sometimes it will speak a sort of

07:49.040 --> 07:55.000
debug protocol for a few, you can actually destroy the A boot boot loader, because it's on flash. If

07:55.000 --> 07:58.800
you do that, then you're going to talk to the secondary boot loader to repair your phone. And we

07:58.840 --> 08:04.800
know those protocols, so we can check to see what's happening. The primary boot loader, you're not

08:04.800 --> 08:11.800
going to do it for fun, probably. I was really happy, you also said it didn't work out. It's not

08:11.800 --> 08:19.920
nice. So let's look at some examples, because this is all text, I'm already a government employee,

08:19.920 --> 08:26.560
so I'm boring by default. Let's look at some examples. This is a library, I hope it's a bit

08:26.640 --> 08:36.880
visible. But you can see some library calls, for example, a fopen fcfget s. And you can see some

08:36.880 --> 08:40.440
strings in there, and you know what these calls do, because it's post-exdefined behavior, so

08:40.440 --> 08:45.480
that's nice. That gives you a good idea, a good overview of what it does. If you're very lucky,

08:45.480 --> 08:49.920
of course, symbols are still in there, parse proc of s, that kind of gives you a good idea of what

08:50.000 --> 08:58.000
it does. Then we get the kernel, it's a lot smaller, unfortunately. But you can still see some strings

08:58.000 --> 09:01.640
that give you a good idea, because you know what a kernel does. For example, at the bottom there,

09:01.640 --> 09:06.600
it says unexpected syscall invocation. So it might have something to do with syscall handling here.

09:06.600 --> 09:14.840
And you can all annotate that and get further into it. Then we have a boot. It looks a bit better

09:14.840 --> 09:18.320
than you might expect, because there's a lot of strings, for example, signature verification

09:18.320 --> 09:23.480
failed, secure check fail. That gives you some idea, like if there's a branch in there, which there

09:23.480 --> 09:28.280
is, that might be the signature verification. And you can work your way up from that.

09:28.280 --> 09:35.200
Then we get the sbl. And the only thing we see here, and bear in mind that everything that says

09:35.200 --> 09:42.640
r underscore is annotated by me, so that's not originally in there. There's just one string

09:42.640 --> 09:48.920
there, XML packet not formed correctly, run out of room looking for tag. It gives you some idea

09:48.920 --> 09:53.240
that it's probably XML parsing, as you can see on the top row there as well. It's looking for some

09:53.240 --> 10:00.280
new lines, some spaces. But there's a lot less to go on here, also because as we all are not

10:00.280 --> 10:04.680
running against a kernel or anything, there's no syscall interfaces, there's no library calls,

10:04.840 --> 10:12.120
it's a big binary blob talking to device registers basically. And the pbl gives you

10:12.120 --> 10:20.640
constructions like this. It's an absolute pain in the ass. There's no strings, because the way

10:20.640 --> 10:26.880
they make pbls, they're fused onto the sock, but they're rom, so they're generated in the masking

10:27.000 --> 10:34.800
for a chip. And the way it works when you build asics, which socks essentially are, asics go by

10:34.800 --> 10:40.920
square area. And the more square area you use, the more, just one of the parameters, but the more

10:40.920 --> 10:46.760
expensive they get. So they really don't like to use a lot of pbl memory. And that makes it so

10:46.760 --> 10:51.480
that there's very little strings in there usually. And you get constructions like this, which is a

10:51.520 --> 10:57.120
double D reference of an index in an array, which is code, which gets called with some parameters.

10:57.120 --> 11:04.160
It's not nice. You're not going to write this usually in C code. This is probably some struct

11:04.160 --> 11:12.880
indexing. And another thing there is as well. Pbls often from what I can see, but that's more of an

11:12.880 --> 11:18.400
assumption that I made based on the work. They don't use normal compilers. There are some weird

11:18.480 --> 11:23.840
constructions in there. For example, there are some constructions in there so that with one bit you

11:23.840 --> 11:29.640
can get different code paths and patch in new stuff. And I think that is because if they make

11:29.640 --> 11:36.720
masks for chips, once the masks are made for lithography in the factory, it's very, very expensive

11:36.720 --> 11:42.480
to make new masks, but editing one bit in a mask is a little bit less expensive. So there's all kinds

11:42.520 --> 11:50.720
of weird constructions in there. Now, we have normal solutions for debugging. So let's say we want

11:50.720 --> 11:57.480
to get some dynamic stuff going. Kernels, we can emulate them and debug them using QEMU and

11:57.480 --> 12:04.000
debugging with KGDB in QEMU, if you want. Userspace can be debugged with normal GDB. Android supports

12:04.000 --> 12:08.640
it. There's documentation on it. And the reason I say everything before that is signed and hard to

12:08.680 --> 12:15.320
emulate. The kernel, of course, is also signed and some parts of user run. But the kernel, you can

12:15.320 --> 12:20.080
unlock your boot loader and you can use a reference on for that and work your way up from there. You

12:20.080 --> 12:26.600
cannot unlock your boot loader in a way using normal processes so that you can patch a boot. So it

12:26.600 --> 12:31.920
makes it a lot harder. It's not made to be debugged or something like that. And everything before

12:31.960 --> 12:39.640
that. Oh, sorry. And so the state is unknown in a lot of these boot processes. You have no idea what

12:39.640 --> 12:46.160
should be where. A lot of hardware is still being initialized. So, for example, in SBL, the MMU is

12:46.160 --> 12:51.840
initialized. So we don't have it before that, which makes it easier, but also less easy for some

12:51.840 --> 12:57.800
tricks in exploitation. And there's lots of memory map peripherals because, like you saw in the iPhone

12:57.840 --> 13:05.400
talk, it's a von Neumann architecture and peripherals are 99% memory mapped if they're not on a bus. So

13:05.400 --> 13:10.400
let's take a look at how we do some static reversing. Let's take that awful, godawful piece of code and

13:10.400 --> 13:18.200
then PBL and see what it would do normally. So let's visualize it for a bit. So this part, just this

13:18.240 --> 13:28.640
part, the code call, what it would do, if you look, there's a 143680 there. Let's look what should be at

13:28.640 --> 13:35.440
that address given this code. There should be a pointer because it's dereference. So the first dereference

13:35.440 --> 13:42.520
will go to a pointer. Then that pointer will point you to another pointer because it's a double dereference.

13:43.520 --> 13:51.160
That pointer is a pointer, but not the pointer we want because it's an index and an array. So we take the

13:51.160 --> 13:57.560
next one and so on until we get to the right index in the array. And there should be another pointer. And

13:57.560 --> 14:04.800
that pointer is the actual pointer to the function that we're looking for. This is all pretty good and

14:04.800 --> 14:09.080
reasonable. If we have some state, we can say, okay, we'll follow that pointer, we'll go here, blah, blah,

14:09.120 --> 14:13.960
blah, blah. And then we get to the actual function that is referencing. And that function, you can make one

14:13.960 --> 14:20.720
other assumption about it. That function will be inside the memory map and inside the PBL that you have

14:20.720 --> 14:26.760
probably. Otherwise, it's in the SBL, but that's not loaded yet. So it has to be somewhere here because

14:26.760 --> 14:34.360
it's code that gets executed. That is a damn shame because this is very followable. You can do this if

14:34.360 --> 14:41.160
you know what these values are. But in real life, when you do static reversing, this is what that looks

14:41.160 --> 14:46.600
like. You have no idea. Of course, you know that here should be a pointer. And if you're lucky, there's a

14:46.600 --> 14:52.360
direct right to that address. And you know, okay, get set up here by this function. But then still, you

14:52.360 --> 14:57.960
have to follow that array, which is also uninitialized. And somewhere is that actual function, but we have

14:58.040 --> 15:07.400
no idea where at this point. So static reversing gets quite hard. And then if static reversing gets

15:07.400 --> 15:15.000
hard, we usually grab back to dynamic reversing if we can. And there are some nice assumptions we can

15:15.000 --> 15:20.760
make for dynamic reversing. Nothing runs before the primary boot loader. So the memory state is

15:20.760 --> 15:24.840
either zero dot or garbage. It doesn't matter for our setup because we're never going to read anything

15:24.840 --> 15:32.120
uninitialized, maybe. All state is set up inside the emulator. So we don't have to worry about

15:32.120 --> 15:38.280
peripherals having a certain state already and having to account for that. And then structures

15:38.280 --> 15:43.240
and their initialization because what you saw here is, of course, a structure. This is not something

15:43.240 --> 15:47.960
you write by hand. Like, oh, I really want to double the reference. This is just a structure

15:47.960 --> 15:54.200
being set up and used. And then complex logic. You can be single-stamped. And you can see the values

15:54.200 --> 15:58.200
to have a better understanding of what it does in smaller steps. And that's often what you do in

15:58.200 --> 16:07.640
reversing. You break a big problem up in small steps. It makes it a lot easier. So what I did was

16:07.640 --> 16:14.680
I just cobbled together a lot of tools with some glue logic. They make an emulator. This was the

16:14.680 --> 16:22.840
first version of this was done in an afternoon with a lot of anger. But the main thing that we used

16:22.840 --> 16:28.360
was killing. Killing is just a framework on top of Unicorn. But it allows you to write hooks,

16:28.360 --> 16:33.560
which Unicorn also allows you. But it also runs a GDB server, which makes a lot of stuff a lot

16:33.560 --> 16:42.040
easier. So it's built on top of QMU, but not the current version. Long story. So killing runs a GDB

16:42.040 --> 16:48.120
server. And this is the glue logic. So there was no logos for that. This is actually a Dutch tram

16:48.120 --> 16:56.680
company because Redsync also doesn't have a logo. But the killing uses, we attach GDB to killing.

16:56.680 --> 17:01.880
And then you have a tool called Redsync. It's made by Quark's lab. It's really nice. I like it a lot.

17:01.880 --> 17:08.280
And it hooks up GDB to Gidra. And now I know what you're thinking. There's already a GDB

17:09.480 --> 17:14.920
debugger in Gidra. And you can attach it. Yes. But not when we started this. And it was

17:14.920 --> 17:21.320
upcoming for like a year. So we used Redsync. And then we used Gidra Bridge, which is just a

17:22.120 --> 17:26.280
bridge in Python 3 to Gidra because I'm not going to write Python 2. It's 2023.

17:28.440 --> 17:36.680
And the glue logic pulls in all the programming, all the memory mapping, everything from Gidra,

17:36.680 --> 17:41.960
puts it in killing, starts execution. We attach the GDB server to killing and connect that back

17:41.960 --> 17:48.120
to Gidra via Redsync. And then we can single-step logic and set breakpoints and everything we wish to do.

17:50.360 --> 17:57.480
But there is still some problems in the emulation. I'm running this PowerPoint in wine,

17:57.480 --> 18:05.640
just so you know. So I hope the animations will function well. Yes. So the memory map here,

18:05.640 --> 18:10.600
we have DRAM at this point, fully uninitialized. It's not a problem for us at all. It's not

18:11.160 --> 18:16.440
in the way. But it's un-initialized. It's unpowered. You can actually see the powering up of the DRAM

18:16.440 --> 18:23.320
inside the secondary boot loader. And the offset of that DRAM is known from the DDB files. The

18:23.320 --> 18:32.600
kernel has to know it, meaning we know it. Then we have SRAM. And SRAM is a RAM that's on the sock

18:32.600 --> 18:37.400
that's always there. And it's used mainly for boot initialization. There are some weird use cases

18:37.400 --> 18:43.400
for it at runtime. But it's always there and it's initialized. Only the offset is somewhat known.

18:43.400 --> 18:50.200
We don't know all the time where it is. Sometimes it's not in one piece. It's not homogeneous. But

18:50.200 --> 18:55.160
that doesn't matter for our purposes. It's somewhat known by reversing. And the status is known,

18:55.160 --> 19:02.360
because at boot it's all zeros. And SRAM, we know it's all zeroed. So there is no logic in SRAM.

19:02.360 --> 19:07.320
There's no asynchronous state. So emulating SRAM is really, really easy. It's just RAM.

19:08.840 --> 19:13.320
Then we get to the peripherals, which are the actual problems. As we've already seen in the

19:13.320 --> 19:19.400
previous talks, the offset is usually unknown. We know some offsets from the DDB. But there are

19:19.400 --> 19:23.560
things like crypto engines and stuff that get initialized and that the kernel never touches,

19:23.560 --> 19:28.920
because in Android, you have your normal world. You have your secure world with trust zone. And

19:28.920 --> 19:32.520
the problem is that these peripherals, they have to be initialized, but the kernel doesn't know

19:32.520 --> 19:37.960
about them. So DDB doesn't know about them. We don't know about them. So we have to kind of reverse

19:37.960 --> 19:44.600
our way through it sometimes. The status also unknown, because there might be some state set up.

19:44.600 --> 19:49.560
Think about the serials or MAC addresses, some stuff like that. That is a state that is known

19:49.560 --> 19:55.960
at boot time, but not necessarily to us. And the status based on unknown logic. As we've also seen

19:56.040 --> 20:02.200
in the previous talks, it does a read of a memory map peripheral or a write. The things that you

20:02.200 --> 20:07.240
can see is I write one bit and then I wait for another bit to another offset. And we don't know

20:07.240 --> 20:13.960
that logic. And it changes asynchronously from the CPU. So it might have changed at any point

20:13.960 --> 20:21.960
in the execution and we have to deal with that. And the problem here is, and I got a little insight

20:22.600 --> 20:28.200
from the other talks, we can emulate on an peripherals. Of course, a lot of it is stub hooking.

20:28.200 --> 20:33.080
You saw the return 2042. A lot of that is what we did as well. Just write simple hooks. We know

20:33.080 --> 20:37.080
you're going to read from this or return something. It doesn't matter what. And sometimes we can see

20:37.640 --> 20:45.000
it should be a one. It's also good. But the big problem we have is that this is a tool for reverse

20:45.000 --> 20:50.200
engineering and not so much a real fully-flagged emulator. And it needs to work on a lot of things.

20:51.160 --> 20:56.520
So, for example, we'll be reversing a phone one day and then next time it will be a USB stick or

20:56.520 --> 21:02.360
an SSD self-encrypting thing. And then the emulator still needs to work. So we cannot

21:02.360 --> 21:07.880
hard-code peripherals every time. We can. It's a lot of work. And it turned out that I thought

21:07.880 --> 21:12.760
about it too simply when I started this. I thought, how many peripherals can there be needed for a

21:12.760 --> 21:17.320
boot? We just start with some stub hooks and then we implement some simple logic, vertical stacking.

21:18.280 --> 21:24.440
But it turns out there's quite a lot of peripherals needed to boot the phone.

21:26.760 --> 21:35.480
And it was less fun after doing 20 of them or something. So I thought, how can we do peripheral

21:35.480 --> 21:40.920
emulation? It's a really hard problem to do peripheral emulation if you don't know what the

21:40.920 --> 21:46.360
peripheral is. And it turns out that if you have really hard problems, you can just ask for an

21:46.360 --> 22:02.040
intern and they will do their master thesis on it. Okay. Yeah. So as Jeffrey told, we now have to

22:02.040 --> 22:15.240
emulate. Is it on? Hello, everyone. Yes, that works. So we have to emulate the peripherals, but

22:15.640 --> 22:19.720
we don't know what the peripherals are or where they are. So that's quite difficult.

22:21.000 --> 22:28.360
But let's first start with what goals we have. We want the emulation to be automatic. We don't want

22:28.360 --> 22:35.960
to have to do things every time we encounter a new peripheral or a new device. We also want the

22:36.600 --> 22:44.520
peripheral to behave somewhat realistically in the sense that, yeah, it should, the device should

22:44.520 --> 22:50.280
not go into an error state saying, oh, the peripheral was broken or whatever. And we also

22:50.280 --> 22:55.800
want it to be generic. So it works for one thing. It works for the other thing. It's nice.

22:59.160 --> 23:05.240
So of course I did a master thesis. So you have to look at the literature. And there basically

23:05.240 --> 23:12.360
are three different methods that are used to emulate peripherals. There's a hardware in the loop

23:13.000 --> 23:18.600
approach, which basically, well, just you have the hardware and you connect it to your computer

23:18.600 --> 23:24.120
that you're using for emulation. And every time the emulator requests some peripheral

23:24.760 --> 23:29.800
interaction, then you just pass it on through the hardware and then pass the value back.

23:30.840 --> 23:40.920
It works. The values are realistic, but it's not that scalable. Like every time you have a different

23:40.920 --> 23:44.760
device that you're emulating, you have to fetch a new device, buy it. I don't know.

23:46.600 --> 23:57.000
That's not too nice. The other method is to emulate it. And here we mean by emulates,

23:57.000 --> 24:03.880
just write those stops for every peripheral. If you do that well, which also is quite a bit of

24:03.880 --> 24:08.840
effort, if you do it well, the values will be realistic. But it is a lot of effort, especially

24:08.840 --> 24:15.880
if you have all those peripherals that Jeffrey just showed. So it's also not scalable. However,

24:15.880 --> 24:22.520
there is a third method that at least has the, or at least is scalable, symbolic abstractions,

24:22.520 --> 24:28.520
where you use symbolic execution to guess what's the correct value would be. But that might not be

24:28.520 --> 24:37.320
realistic. So this symbolic execution, what is that? Let's talk about that here. We have a simple

24:37.320 --> 24:44.840
function that takes two inputs and returns an output. And if we just execute that classically,

24:44.840 --> 24:52.680
normally, then we might start with a memory state here, a equals 11, b equals 5, and c equals 0.

24:54.280 --> 25:00.200
And in blue, we have the instruction pointer, and it just executes the code. It checks is a equal

25:00.200 --> 25:07.640
to 0, a is 11, so it's not equal to 0. So it goes through the else. It sets a to 4, and then it

25:07.640 --> 25:16.120
calculates c, which is 4 plus 5 equals 9. And then it returns 9 from that function. Pretty simple.

25:17.720 --> 25:24.040
But then symbolic execution, we don't have concrete values for a and b, but we have variables

25:24.120 --> 25:31.160
for us values where I'm using Greek characters for that. So a equals alpha, b equals beta,

25:31.160 --> 25:38.120
and c equals 0. And then we start executing. But then we have a problem. We have to decide is a equal

25:38.120 --> 25:43.960
to 0, but a is equal to alpha, is alpha equal to 0? So, well, for the moment, let's assume it is.

25:45.080 --> 25:52.200
And we'll also draw a nice graph saying, and a note that we assume that alpha is equal to 0.

25:52.200 --> 26:02.040
And we can just continue. We write 9 to b, and then we calculate c, which is 0 plus 9,

26:02.040 --> 26:08.280
which is equal to 9, and then we turn that. So we're done. Not quite. We also have to

26:09.560 --> 26:17.080
take care of the else branch. What happens when alpha is not equal to 0? Well, then a is a to 4,

26:18.040 --> 26:24.520
but b is still beta. So when we calculate c, then c doesn't have a concrete value. It has a symbolic

26:24.520 --> 26:33.080
value 4 plus beta. And then we would just return that. One of the main differences that you can

26:33.080 --> 26:39.160
already see is if we just normally execute a function, we just have one result. We have to

26:39.160 --> 26:45.880
reach result 9. But if we do it symbolically, then we have two results, either 4 plus beta or 9,

26:46.440 --> 26:56.840
depending on the value of alpha. So back to the peripheral emulation. If we use symbolic execution

26:56.840 --> 27:03.400
for the peripheral emulation, then we potentially have some problems. One of the problems is that

27:03.400 --> 27:10.920
there might be multiple states, and that often becomes very many states. So some of those states

27:10.920 --> 27:17.880
lead to successful emulation, and other states lead to bad emulation. They lead to infinite loops.

27:17.880 --> 27:25.400
They lead to the PBL thinking, oh, this peripheral is broken. Let's just sit in this infinite loop

27:25.400 --> 27:33.400
for a while. And another problem is that if you have many peripherals, which we do and many

27:33.400 --> 27:39.640
peripheral interactions, then we also have a lot of states. And we need to somehow remember all those

27:39.640 --> 27:47.240
states, so it quickly takes up a lot of memory. So the solution for these, or at least this last

27:47.240 --> 27:55.320
problem, is to only run symbolic execution just for a bit. Not the entire program, but only a few

27:55.320 --> 28:00.680
steps after the peripheral access, and then we probably will have already seen if the value

28:00.680 --> 28:08.760
that we have returned from the peripheral is actually good or not. So that's what I mean by

28:08.760 --> 28:14.360
concretizing the symbolic values. You run with this potentially symbolic value, for example,

28:14.360 --> 28:21.000
4 plus beta for a while, and then after a while you check and you see, well, this seems like a good

28:21.000 --> 28:27.720
value. You pick a value for beta, say 0, and then you continue with 4 plus 0, namely 4, and then

28:27.720 --> 28:37.480
everything is concrete again, and you can just run the emulator. So that also brings another

28:37.560 --> 28:45.880
question. How do we concretize a value? What value do we pick? For that, I thought it would be nice

28:45.880 --> 28:52.520
to use different heuristics to add more constraints. And each heuristic, I called it a tactic,

28:53.800 --> 28:59.560
and every tactic defines a nice property, something that would indicate sort of success.

29:00.760 --> 29:05.160
For example, a nice property could be return 1 from the function that we're currently in. Maybe

29:05.160 --> 29:09.960
the function is checking if the peripheral is there, and it returns 1 if the peripheral is there,

29:09.960 --> 29:18.200
and 0 if it's not. Then the result of the read from the peripheral, if that leads to a 1 being

29:18.200 --> 29:24.840
returned, then we're probably returning the right value. And how do we know if we want to return 1

29:24.840 --> 29:31.400
or 0 or something else? Well, we can just use first one, and if that doesn't seem to work,

29:31.400 --> 29:39.880
then we try another, and then another, which is to try that. That's also a nice thing that we don't

29:39.880 --> 29:47.560
have to be fast about this. We can just take a little more time. So what are these tactics? I

29:47.560 --> 29:54.360
defined three tactics, or infinitely many, but depends on how you look at it. I defined the

29:54.360 --> 30:00.920
dummy tactic, which is not that clever. It just continues to the next instruction. Many peripheral

30:01.000 --> 30:07.720
interactions are not really that relevant. You just write the value somewhere, or they read some

30:07.720 --> 30:14.840
value and store it in some other memory location. It's not that important. So symbolic execution

30:14.840 --> 30:21.080
is also quite intensive, so we don't have to have all this overhead if it's not necessary. So at first,

30:21.080 --> 30:26.520
we just try to ignore it and just continue to the next instruction. And then there's another

30:26.520 --> 30:32.200
tactic that's a bit more involved, actually uses the symbolic execution return tactic that also

30:32.200 --> 30:37.880
takes a value, value n, and it returns that value from the current function, or at least it tries to

30:37.880 --> 30:44.040
find a peripheral read value that returns n from the function that the peripheral read occurs in.

30:44.680 --> 30:54.120
And the step tactic, it just steps a certain number n states forward in the symbolic execution,

30:54.200 --> 30:59.560
and then it sort of judges the states and sees, well, maybe this state got into an

30:59.560 --> 31:03.560
infinite loop, and the others didn't, so probably don't want to be in the state that

31:05.080 --> 31:11.160
got into the infinite loop. So here is a nice diagram of how this part of the system works.

31:12.600 --> 31:18.200
We have at the top the analysis tool, which is a Ghidra. It provides the binary.

31:19.000 --> 31:22.520
Then on the left, we have the emulator that Jeffrey already talked about,

31:22.520 --> 31:29.320
which is based on killing. And yeah, it uses hooks, and instead of having hooks for different

31:29.320 --> 31:35.400
peripherals, we just hook the, pretty much the entire memory region. And every time there's a

31:35.400 --> 31:40.360
read from there, we say, oh, well, that's probably peripheral read, and we pass it on to a different

31:40.360 --> 31:47.320
component, which I called the read resolver. And there is another hook in there that detects bad

31:47.320 --> 31:58.760
states. The read resolver uses Z3 or anger, uses anger, anger is built on Z3, the symbolic execution

31:58.760 --> 32:04.040
framework, and it passes on the state of the emulator to the symbolic execution and instructs

32:04.040 --> 32:11.160
the symbolic execution what constraints it tried to find a solution for. It also chooses a tactic

32:11.160 --> 32:19.000
that I talked about. And finally, it pushes some things to the history, which is nice if you find

32:19.000 --> 32:24.120
that we chose the wrong tactic, then we can later backtrack, which is why do you have a hook for a

32:24.120 --> 32:29.080
bad state. If we end up in a bad state, we go to the backtracker. The backtracker looks at the history,

32:29.080 --> 32:34.040
and says, oh, well, maybe we should have come back to the previous state. It restores the state, and

32:34.040 --> 32:42.680
then a different tactic is selected. So how does this tactic selection work? It's pretty simple.

32:42.680 --> 32:50.360
We have a hard-coded list of tactics that is as tried. And the first time we come across a read,

32:50.360 --> 32:58.280
we pick the first one in that list. And then if it doesn't work or we go back, we backtrack, or we

32:58.360 --> 33:05.400
have 10 consecutive reads from the same address, then we go to the next item in the list. And if

33:05.400 --> 33:09.640
there are no tactics left, then we're probably in a hopeless state, and we might have made a problem

33:09.640 --> 33:13.000
or made a mistake earlier on, and we have to backtrack even further.

33:17.480 --> 33:22.360
I'll have to be quick about this. So this is a quick example of how this works.

33:22.840 --> 33:28.280
Yeah, so first we try the dummy tactic, which returns zero, which is fine. It just or is in a

33:28.280 --> 33:35.480
flag. Then we go to the second part of the code. First we return zero, but that doesn't work. We

33:35.480 --> 33:40.600
end up in the infinite loop. So we backtrack and we try to return zero. But this function doesn't

33:40.600 --> 33:46.200
return anything. So it gives an error. Return one also feels for the same reason. We step five

33:46.280 --> 33:52.200
things and we five steps forward and we find that, well, maybe if we end the value with two and we

33:52.200 --> 33:58.200
don't have zero, then and it's not equal to zero because we already tried zero. Then we should

33:58.200 --> 34:04.040
probably try that. And the symbolic, symbolic execution finds the value two. So we go to the

34:04.040 --> 34:12.120
next thing where we call a function. We first try zero, zero calls a panic function, which ends up

34:12.120 --> 34:17.560
in the infinite loop. So that's bad. Returning zero also leads to the panic function being called

34:18.120 --> 34:24.520
or well, returning zero doesn't work because we already tried returning zero. So returning one

34:24.520 --> 34:29.000
doesn't work because we end up in the panic function and stepping five actually does work here.

34:30.600 --> 34:37.240
And we return five and we not in the panic function. And then we have this infinite loop

34:37.240 --> 34:41.400
and in every iteration of the loop, it checks the flag checking to see if the peripheral is alive,

34:41.400 --> 34:48.120
probably, or done initialization. And every time we try the dummy tactic because well,

34:48.120 --> 34:53.320
we find this thing, but after 10 times, we find, oh, well, we're reading from the same address

34:54.520 --> 34:59.400
every time 10 times in a row. We probably should try a bit harder and return zero,

34:59.400 --> 35:03.720
which doesn't work because this function doesn't return and step five. And then we see, well,

35:03.720 --> 35:10.120
if we return zero, then we are in this infinite loop. We should try returning one.

35:10.920 --> 35:16.600
And then it works. So then I did the whole thing about evaluation, which combination of tactics

35:16.600 --> 35:24.600
is best. Well, most of them are roughly equally good. And then I did some tests with different

35:25.400 --> 35:34.920
programs to see, well, how fast is this? Not too fast, but it's fast enough. And we also find that

35:35.000 --> 35:41.960
there are, and I compared it to like the real hardware on our Raspberry Pi. And I compared it to

35:42.600 --> 35:48.520
the amount of instruction that were taken, well, fewer because our system exited out of a lot of

35:48.520 --> 35:54.920
loops early because they didn't have to do any initialization. But yeah, it was much, much lower.

35:56.200 --> 36:03.160
But most importantly, the data that is stored and returned, that is pretty much identical.

36:04.120 --> 36:08.360
And so that's nice. Also compared with another framework, which is,

36:11.880 --> 36:18.280
yeah, it was a little slower on these things. Data was nearly identical and the number of

36:18.280 --> 36:22.920
instructions was the same. Also not too important. Not sure what this slide is in your

36:24.360 --> 36:29.720
duplicate slide, I guess. There are some limitations. Sometimes we concretize the wrong value.

36:30.440 --> 36:35.320
And there's a lot of communication overhead, which is also part of future work.

36:37.240 --> 36:42.520
And we also have a summary, and we also have a live demo. So I guess we're going to try the live

36:42.520 --> 36:54.280
demo now. If we can switch the... Yeah. If someone could deliver a cellphone to us today.

36:59.720 --> 37:10.280
Yeah. Thank you.

37:30.280 --> 37:51.400
this.

37:51.400 --> 37:52.400
Yeah.

37:52.400 --> 37:54.400
Yeah, you can all say that's a solution for you.

37:54.400 --> 37:56.400
And then, uh...

37:58.400 --> 38:00.400
I can stand on that side.

38:00.400 --> 38:02.400
I hope I can see it.

38:08.400 --> 38:10.400
So, uh...

38:10.400 --> 38:13.400
Yesterday I noticed that in the description of this talk,

38:13.400 --> 38:15.400
I said there was a live demo.

38:15.400 --> 38:18.400
And then I told Luke, I read the description,

38:18.400 --> 38:20.400
and apparently we're giving a live demo.

38:20.400 --> 38:23.400
So, it's a bit tiny,

38:23.400 --> 38:28.400
but it really shows what this thing does.

38:28.400 --> 38:30.400
And it's definitely not a full-flag simulation.

38:30.400 --> 38:32.400
That is very...

38:33.400 --> 38:36.400
I'm very much a tool for reversing.

38:46.400 --> 38:48.400
It used to be called Firmulator.

38:48.400 --> 38:50.400
Luke didn't like the name.

38:57.400 --> 38:59.400
You maybe make it bigger?

38:59.400 --> 39:01.400
The text.

39:01.400 --> 39:02.400
That'll be it?

39:02.400 --> 39:04.400
That'll be all shit.

39:09.400 --> 39:11.400
I hope we make it in the time.

39:11.400 --> 39:18.400
So, first, we run it without the symbolic execution part.

39:18.400 --> 39:21.400
It loads all the memory mappings from Gidra,

39:21.400 --> 39:23.400
starts the emulation,

39:23.400 --> 39:25.400
and then it crashes, so let's stack them.

39:25.400 --> 39:27.400
Make it one smaller,

39:27.400 --> 39:29.400
then you can see the bottom, probably.

39:29.400 --> 39:33.400
And it says unmapped memory on the bottom.

39:33.400 --> 39:35.400
It's hard to see.

39:35.400 --> 39:37.400
Anyways.

39:37.400 --> 39:39.400
It crashes on an unmapped memory,

39:39.400 --> 39:42.400
because it tries to write, this is a Raspberry Pi,

39:42.400 --> 39:45.400
that's trying to initialize its video driver,

39:45.400 --> 39:48.400
and it tries to write to the video driver

39:48.400 --> 39:51.400
and read something back, and it fails, obviously,

39:51.400 --> 39:53.400
because it's not there.

39:53.400 --> 39:55.400
So, then we can run it again,

39:55.400 --> 39:58.400
using the part with symbolic execution.

40:10.400 --> 40:12.400
No one needs to matter.

40:20.400 --> 40:23.400
Now we run it again, and you can see that it connects to Gidra

40:23.400 --> 40:25.400
using the bridge.

40:25.400 --> 40:27.400
It loads the memory mappings that are there,

40:27.400 --> 40:30.400
loads the code from that, starts executing.

40:30.400 --> 40:32.400
But, unfortunately, now, is what you get.

40:32.400 --> 40:36.400
It's reading from two addresses, one after another.

40:36.400 --> 40:39.400
So, it's hanging, because it thinks it's not in a loop,

40:39.400 --> 40:42.400
but it definitely is in a loop.

40:42.400 --> 40:45.400
And that's the thing you run into here.

40:45.400 --> 40:49.400
Now you can set inside Gidra, you can set a command,

40:49.400 --> 40:52.400
just as I see you're in a loop,

40:52.400 --> 40:57.400
and a lot of what we do is just using this as a reversing tool,

40:57.400 --> 40:59.400
so we just want to be able to set things fast.

40:59.400 --> 41:02.400
And now we tell it in the right part of the loop,

41:02.400 --> 41:05.400
and it just returns here. It's good.

41:25.400 --> 41:28.400
And now you can see that everything went correctly.

41:28.400 --> 41:31.400
It has returned from that loop.

41:31.400 --> 41:35.400
Then it gets to the GPU initialization point.

41:35.400 --> 41:41.400
It should say at some point, yes.

41:41.400 --> 41:43.400
It sees that it has to return,

41:43.400 --> 41:46.400
command parsed, return value none.

41:46.400 --> 41:49.400
Now it returns out of that loop, tries to initialize the GPU,

41:49.400 --> 41:52.400
it maps a memory for that, symbolically executes the function

41:52.400 --> 41:55.400
for initializing the GPU.

42:02.400 --> 42:05.400
More returning.

42:12.400 --> 42:15.400
The demo effect is in full effect.

42:18.400 --> 42:22.400
The fun part about this is that it ends up initializing the GPU,

42:22.400 --> 42:24.400
but it gives you another error.

42:24.400 --> 42:27.400
I couldn't get this weird ass resolution that you wanted,

42:27.400 --> 42:31.400
and for us, that is the thing that differentiates it

42:31.400 --> 42:33.400
from a full blown emulator.

42:33.400 --> 42:35.400
It will not initialize it nicely,

42:35.400 --> 42:38.400
but it will initialize it enough for us to continue on our work

42:38.400 --> 42:41.400
where we are interested.

42:48.400 --> 42:50.400
Thank you, Jeffrey and Luke.

42:57.400 --> 43:00.400
Thank you.

