{"text": " Hello everyone. My name is Marcus. I would like to share some lessons that I learned while working on the Firefox Profiler. So yeah, I work at Mozilla. I'm on the Firefox Performance Team and I work on Firefox itself and on the Profiler and I also have my own Profiler called Sample which you can use on macOS and Linux to profile your own applications. And I'll give you a brief overview of the Profiler. So this is what it looks like when you have a profile loaded. You have a timeline at the top. You have a call tree and you have a sidebar here in the call tree. It's very, very small down there. I'll zoom in a little bit. In the call tree you can see which function called which function. You can see how much time each function spent running. So let's say this function here dispatch event. Firefox Profiler is a sampling Profiler. So it interrupts the thread at a given interval like usually one millisecond every one millisecond. It checks what's on the stack and then it accumulates that into this call tree. So one thing that I want to call out here is the category breakdown in the sidebar. So here we have a bunch of categories. User is just regular code. Ion here means this is JavaScript code that was jitted into the IonMonkey subengine of our JavaScript engine. And yeah, there are a bunch of other categories. And you can select in the timeline and as you draw your selection, oops, as you draw your selection, the category breakdown updates in the sidebar. So we can also zoom in, see something a little smaller. So here we have more code in Ion, more code in the user category. It also has a flame graph. So zoom back out. And flame graph, you're probably familiar with flame graphs. They're a different representation of the same information. Like you have a call tree, you have nested functions, the width of each box is the time that is spent in that function. And we also have a tooltip here in the call tree, which again gives us a category breakdown. I'm emphasizing the category breakdown so much because we're going to implement our own profiler in a minute, which, and we're going to focus on calculating this category breakdown. So here we see it's a bit sluggish as you move the mouse around, because it actually needs to iterate over all the samples in the timeline. It checks for every sample is the stack inside of the function that you're hovering. If so, check the category that the CPU is spending its time on for that sample, accumulate that into a map of categories to counts, and yeah, do that for all the samples. And we can see here at the root node, we have about 500,000 samples in this profile. So what I didn't tell you is this is actually the version from last July. And I fixed this performance problem here. So this is what's live now on profile.farfax.com. Hovering these boxes is no instant. And it's still doing the work. It's still going through all 500,000 samples every time you move your mouse. So I want to talk a bit about how we can crunch through all that data in in very short time. Wrong direction. So yeah, even with lots of samples, we can now have a fast UI. And I made an example project just for this talk called mini profiler. It is on GitHub. It's also live on Netlify. You can try it out in your browser if you want to. And this is what it looks like. It has a very reduced feature set, but it also has this timeline. You can select parts of the timeline and it calculates this category breakdown. So yeah, let's say here, we spent 30% in Ion Monkey Jitter JavaScript code. At the same time, it also calculates the heaviest stack. The heaviest stack is the stack that we spend the most samples in. All right. So yeah, mini profiler features. There's only two features. You select the range, and it gives you a category breakdown and a heaviest stack. So how does it calculate that? We have an input JSON, which describes the profile contents. The JSON is a list of samples. Every sample has a time, a weight, and a stack. Every stack is an array of frames. Every frame has a name and a category. I'll show you that here in an example. So as I said, a list of samples, every sample has a time property, a stack property, a weight property. The stack is an array. Each stack frame has a name and a category. To calculate the category breakdown, we take in the profile. We take in a range of the indexes of the samples that are in the selection. Then we iterate over this range. We get each sample. Whoops. We get its stack and its weight. We get the top frame from the stack. We get the category from the frame. And then we check. Does our map have this category already? If so, get the current value. Otherwise, default to zero. We add the weight of the current sample. We put the sum back into the map. And then this map is what gets used by this spelt component. For the heaviest stack, it's somewhat similar. We again iterate over all the samples in the selected range. For each sample, we again get the stack and the weight. And now we need to check if this stack has been used by multiple samples. And how do we find two samples with the same stack? Well, the stack is an array, and you can't really check them for equality easily. So what I'm doing here is I'm stringifying the stack into a JSON string. I'm using that as the map key. And then here is a similar issue to what we had with the category breakdown. We check. Do we have an entry in the map for this stack? If so, take its current value. Otherwise, default to zero. Add the weight. Put that back into the map. And if this stack is the heaviest that we've seen so far, we remember it, and then at the end, we return it. So these are the two main algorithms in this mini-profiler. Category breakdown, heaviest stack. Both of them have to iterate over all the samples. So how fast is it? So if I select here, it's reasonably fast. If I make the selection bigger, it starts getting a little janky. I'm computing some throughputs down here. So 100 nanoseconds per sample is how long the algorithm for the category breakdown takes. And 30,000 something nanoseconds per sample for computing the heaviest stack. Because, yeah, we saw the heaviest stack algorithm, it was really inefficient. It used JSON stringify. It looked up this gigantic string in a map. It needs to hash the entire big string and so on. So this is obviously not the way to go. But this is just a place to start so that we understand what's going on. So this is the throughput here. The nanoseconds per sample might not tell you much. But what you can think about is, how does it limit the size that you can handle while still being responsive? So let's say you have 100,000 samples. In this example here, we just had 1,600 something samples. What if you have 100,000? Then you get 10 milliseconds for computing the category breakdown and 3.6 seconds for computing the heaviest stack. 3.6 seconds per update, that's not acceptable. So we need to do something. And also the JSON file, because it has all those repeated stacks, it's just massive. So let's use a different format, different JSON format. Here I made a V2 format. It still has samples, but instead of having the stacks right in the sample, it just has an index. And this index now goes into a stack list. Each element in the stack list has a frame index, which goes into the frame list. Each frame has a name and a category index, which goes into the category list. So I hope that's not too overwhelming. We just have a bunch of indexes now. Instead of nested objects, we just have some side-by-side lists and we index into them. And also here the stacks are a little special because of this parent stack index here. So if, for example, a sample refers to stack number two, then this is the frame at the top of the stack. Then we go to the parent stack, find this frame, that's the next frame on the stack, find this stack, put this frame on the stack, and then the parent here is null. So that means we're at the end of the stack. Hope I haven't lost anyone yet. So let's go back to the compute-heavy stack algorithm. So we were iterating over the samples. We were stringifying the stack arrays and we were checking the JSON string. Now we don't need to do that anymore. Now we have an index. If two samples have the same stack index, that means they have the same stack. So we just use the stack index now here and we don't need the JSONification. We don't look up big strings. And this is like a massive performance improvement. So 300 times faster. The category breakdown is also affected by the new format changes. So now instead of getting the stack and the frame directly from inside the sample, we instead get a stack index. We look up the stack index in the stack array, which gives us a frame index. We look that up again, get the category index, look that up again, get a category name. This is a string. Put that in the map or add up the weight. This string here, this is kind of unnecessary. We know if two samples have the same category index, we can use that as the key. So I made an optimization here to remove this name lookup. And now we're just accumulating category index weights in this map here. There needs to be some process, post-processing afterwards to make sure we get these names here in the category breakdown again. But that's outside of our algorithm. All right. So here I had selected the small profile for the format version one. Let's switch to the same profile in format version two and do the selection again. And now we can see, we can select to the full width and it's still very responsive. So here's our throughputs. So how fast is it now? 47.1 nanoseconds per sample for the category breakdown is what I measured, 51 for the heaviest stack. Okay. So that's much better. Let's see how far we can go. We want to see if there's more we can do here. So we use a profiler. I am going to start the profiler. Oh, what I didn't show you is how to use the profiler. Well, let me do that really quick. So if you use Firefox and you go to profiler.firefox.com, you can click this big button here, which gives you a toolbar button. And then if you click that toolbar button, it starts recording. So let's record our current implementation. Do a little bit of this, capture a profile and see where the time is spent. Well, where is the time spent? One second. Let's try that again. Let me refresh this page. Ah, I can tell you for this time spent. It is so fast that it barely shows up in the profiler because we are still using the small profile size. So let's do that again. Capture profile. The local host here, there's barely any CPU usage. You would see more yellow in here. So let's switch to a bigger profile. We still have just the 1600 samples. Let's switch to the medium profile. So here, yeah, it still works okay. It gets a little bit janky towards the edge here. So again, we're going to start the profiler, select, play around a little bit so that we get lots of samples. Capture the profile. And there we go. This is what I was expecting. So now we have lots of yellow in here. I'm going to show just this thread. I'm going to switch to JavaScript only. I'm going to switch to the flame graph. And now what we can see here is we are spending time in compute category breakdown with string key map and compute heaviest stack with map. And what we see here is that we are spending some time in map.prototype.set, both over here and over there. That makes sense. We're assigning things to a map. So can we not use a map? Wrong direction here. So we're seeing the time in map prototype set. We have the map here. For the category breakdown computation, we're getting the category index out and putting it back in. But we know these are integers. They're integers into the category list. The category list doesn't have lots of elements. We can just use an array here instead. I'm going to use a float 64 array here. Because the weights are floats, using a typed array means I know that the maximum number of elements is already preallocated. It's initialized to zero. I don't need to check if there's something in it already. I know that it starts with zero. I can just add the weight. And that's it. We can do the same modification to getting the heavier stack, the seriously compute heavy stack algorithm. It was also using a map. We can use a float 64 array because we know how many stacks there are. Here the key is the index into the stacks array. We use that key as our index into the map array. And then it should work as before. And what we see down here, it is three times faster to skip the map to use a typed array instead. Let's try that out. Here I'm going to switch from the basic implementation to the integer keys for category breakdown. No, sorry, to the typed arrays instead of maps implementation. And now I'm going to select, and it's very smooth through the entire profile. And we have 500,000 samples now here. And we are still responsive. And let's see if we get an even bigger profile. This one here has two million samples. How responsive are we? It's okay. It gets a little janky towards the end here. It's mostly okay. So where are we now? Let's just take some, take some recap. We've addressed the obvious load ons. We've done what the profile told us. We fixed the hotspots. We changed the format so that comparing stacks is cheap, we changed two maps into typed arrays. Got us a 3x perf boost. In the heaviest stack case, the map or the amount of memory we're using might be a bit bigger now because we're allocating an array where we have an element for every single stack index, even if no sample references that stack index. So maybe some extra memory, but we have a performance boost. And so we have the throughput here. Yeah. So for the medium profile, our throughput is like 16 nanoseconds. Or let's see, sometimes it goes up and down a little bit. Yeah, let's say 16 nanoseconds for the category break down, 40 nanoseconds for the heaviest stack. I was seeing some other numbers when I was trying this at home. So it's pretty impressive. Modern computers are pretty fast, but maybe we can do even better. So let's try better. Let's go back to the category breakdown algorithm. We are taking these two values out of every sample. The sample is an object. It has three properties. We're ignoring the time property. We're getting these two properties out. So what does that mean at a byte level? So how are arrays of objects stored in memory? Well, it depends a little bit on which JS engine you're using, how you're allocating the object, if you happen to be on a fast path or not. But in SpiderMonkey, this is what you might expect. So we have a samples array, which is backed just by a list of pointers. Every pointer takes up 8 bytes on a 64-bit system, and it points to a JS object. So let's say here, the first entry in our samples array points to this JS object here. The JS object starts with a header. SpiderMonkey takes up 24 bytes on a 64-bit machine. Then if we're lucky, we have the fields inline just after the header. We might not be lucky, but let's say we're lucky. We might also have a bit of padding here at the end, because the inline slots might be only sized to four or eight, and we're using three properties here, so there might be a bit of extra memory used up by that. So this is just one representation that we could have. It varies a lot by engine. For example, Chrome has pointer compression, so these things here might be four bytes each, but then the time field might be an extra pointer, because in Chrome, sometimes the floating point values are a separate heap allocation. The padding could vary, the object header size could vary. These fields here could be behind another pointer if they're stored out of line, and so on. But anyway, what it comes down to is we wanted to get these two fields here, 16 bytes in total, but what we ended up with is all of these other not-so-useful bytes clogging up our cache. So when the CPU wants to get those bytes, it gets them in 64-bit chunks. Cache line is 64 bytes. So if you're getting this value here, you're getting the other bytes that are in the vicinity, even if you don't need them. Well, here we do need the JS object header, because the JIT needs to check that the object is of the right shape, and so on. But we really just want those values here. So can we do anything about that? We want to improve our cache line utilization, and we want to reduce the indirection. Maybe we can. Let's do something radical. Let's turn everything on the side. So we have this array of objects. What we could do instead is to have an object of arrays, or struct of arrays, where we have a column, or where we have just one key for the time column with a big array that has just the time values, one for the stack index, just the stack index values, the weight, just the weight values, and a length stored on the side. These arrays must all have the same length. So now everything's backwards. If we want to access the weight in the past, we had samples i.weight. Now it looks a bit weird, because we have the sample table.weight column, and then we get the ith element of that. But let's do it. Let's see where it goes. And so what we end up with here is a new profile format again. Now we have a sample table, a stack table, a frame table. The calories are still a list, because it's just some strings. And same thing as before, the stack index goes into the stack table, the frame index goes into the frame table. We just need to access the properties differently. So what does it do for the computation of the heavier stack? Here we were getting the stack index and the weight property from an object. Now we just get them from separate columns. And already we're seeing a 2x performance improvement. For the category breakdown, similar story. Instead of getting the properties from objects, we get the column first, access the ith element, and get that. This here is even faster, like 3.5x faster. Let's see that in practice. So we're switching to format v3 now, struct of arrays. Let's get the medium, medium sized profile. And now it just flies. It's just responsive all the way. 4.5 nanoseconds per sample, that's really not a lot of time. This is super fast now. Let's get an even bigger profile. Still super responsive. So when we think about the memory model, or the memory, how it is represented in memory again. We're accessing these columns now. We're accessing them in order. And what happens is that our cache lines are now fully utilized. We don't have object headers clogging up our cache anymore. We just have the numbers that we wanted. But yeah, it's just super efficient now. We get all the stack indexes, we got all the weights. The time column is now pretty much irrelevant. It was clogging up our cache before, but now we're not accessing the time column at all. So it just doesn't bother us anymore. Okay, so let's recap quickly. We have a struct of arrays. Some people call it parallel arrays, commonly used in game engines, databases, and so on. It has a few drawbacks. It looks a bit backwards if you read it. Sometimes when you want to pass around an object, you need to manually materialize it because you don't just want to pass around an index. But it also means that the type system, at least in TypeScript, is now less of a help. We can introduce mistakes that it wouldn't catch. So for example, if we build up our arrays and we end up not putting our values in every one of the columns, we end up with mismatched lengths, and that is hard to catch at the type level. Also, when we pass around indexes, sometimes, yeah, you get a number, you don't really know, is this an index into the stack table, into the frame table? I don't know. The type system, at least in TypeScript, I don't think is well set up to catch these kinds of mistakes. But it's much more cache efficient. It's easier on the garbage collector. You need to traverse fewer objects. Some engines skip the contents of arrays and numbers, so it should speed up that too. Less memory overhead from object headers and padding. And we can just treat columns separately. Like sometimes we want to make a change to one column. Let's say we want to shift the entire profile by some time delta. We can change just the time column. The other columns stay untouched. We don't need to recreate any objects. And it also gives us a little more control over sizes and how compact our integers or our numbers are stored. We can pick with our typed array. We could pick an int32 array. We could pick an int16 array. If we know what the domain of our values are, we can store things more compactly and we get back in control of the representation. Okay. I want to make it even faster. So if we look back at our category breakdown, we're getting the stack index, we're getting the frame index, but it's all just to look up the category from the frame table. We're not really interested in the stack of the frame. We just want the category for a sample table, for a sample. So what if we just got the categories for each sample and use that instead of here, stack, frame, category, just go category, boom. Well, it would be great if we had this column. Where does it come from? Well, we can compute it here with the get sample categories method. We iterate over all the samples. We do the stack frame category conversion here. We cache that in the sample categories column. We pass that to our existing function, but we only want to do this once, not on every call. So we need to cache it somewhere. We can use memorization for that. So here's a memorized call. We get the profile. We only run this once. So if we call this multiple times with the same profile, let's say our profile is immutable, we have it cached from last time. And we can make the caching even more precise. If we memorize a function which takes just the columns that we need, then we get it. We wrap this into the existing get sample categories function, which takes the profile, but then it takes out the categories. Sorry, it takes out the columns we want, passes those separately to the memorized function, and that makes the caching even more or even tighter. If you touch a column that is not involved, you don't invalidate your cache. And did it work? Yes, it did. Oops, wrong direction again. Memorized sample categories. We're now down to three nanoseconds. So I'm basically done with the talk. Let's just look at the graph here at the end. This V1 graph is off the charts like this. It's way higher than this. But we made it faster with every change here. And this last step of caching the sample, the categories for each sample, it looks like it's not much, like 25% on these nanoseconds. But what it actually means is we can handle more data. We can handle a higher count of samples in, let's say, a 16 millisecond interval. And like 25% more data, that's massive. Okay, I want to say really quick, what is data-oriented design? It's a mindset and it's a collection of techniques. The main technique here is structure of arrays. The mindset is more about how you think about it. The shape of the data determines the algorithm and its performance. You need to know which things are small, which things are big. We might have seven elements in this array and 100,000 in that array. If you keep that in mind, you're better set up to write fast code. And if you also think about cache line utilization, you're even better set up. The rest is not that important. Thanks, everyone. You can find me in the Firefox Profiler channel. You can check the Firefox Profiler online. Happy profiling!", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 11.4, "text": " Hello everyone. My name is Marcus. I would like to share some lessons that I learned while", "tokens": [50364, 2425, 1518, 13, 1222, 1315, 307, 26574, 13, 286, 576, 411, 281, 2073, 512, 8820, 300, 286, 3264, 1339, 50934], "temperature": 0.0, "avg_logprob": -0.22855686460222516, "compression_ratio": 1.5895953757225434, "no_speech_prob": 0.06019797548651695}, {"id": 1, "seek": 0, "start": 11.4, "end": 17.36, "text": " working on the Firefox Profiler. So yeah, I work at Mozilla. I'm on the Firefox Performance", "tokens": [50934, 1364, 322, 264, 46613, 6039, 5441, 13, 407, 1338, 11, 286, 589, 412, 3335, 26403, 13, 286, 478, 322, 264, 46613, 25047, 51232], "temperature": 0.0, "avg_logprob": -0.22855686460222516, "compression_ratio": 1.5895953757225434, "no_speech_prob": 0.06019797548651695}, {"id": 2, "seek": 0, "start": 17.36, "end": 23.8, "text": " Team and I work on Firefox itself and on the Profiler and I also have my own Profiler called", "tokens": [51232, 7606, 293, 286, 589, 322, 46613, 2564, 293, 322, 264, 6039, 5441, 293, 286, 611, 362, 452, 1065, 6039, 5441, 1219, 51554], "temperature": 0.0, "avg_logprob": -0.22855686460222516, "compression_ratio": 1.5895953757225434, "no_speech_prob": 0.06019797548651695}, {"id": 3, "seek": 2380, "start": 23.8, "end": 30.28, "text": " Sample which you can use on macOS and Linux to profile your own applications. And I'll give you", "tokens": [50364, 4832, 781, 597, 291, 393, 764, 322, 7912, 4367, 293, 18734, 281, 7964, 428, 1065, 5821, 13, 400, 286, 603, 976, 291, 50688], "temperature": 0.0, "avg_logprob": -0.19176439138559195, "compression_ratio": 1.7004405286343611, "no_speech_prob": 0.14332249760627747}, {"id": 4, "seek": 2380, "start": 30.28, "end": 34.56, "text": " a brief overview of the Profiler. So this is what it looks like when you have a profile loaded.", "tokens": [50688, 257, 5353, 12492, 295, 264, 6039, 5441, 13, 407, 341, 307, 437, 309, 1542, 411, 562, 291, 362, 257, 7964, 13210, 13, 50902], "temperature": 0.0, "avg_logprob": -0.19176439138559195, "compression_ratio": 1.7004405286343611, "no_speech_prob": 0.14332249760627747}, {"id": 5, "seek": 2380, "start": 34.56, "end": 41.040000000000006, "text": " You have a timeline at the top. You have a call tree and you have a sidebar here in the call tree.", "tokens": [50902, 509, 362, 257, 12933, 412, 264, 1192, 13, 509, 362, 257, 818, 4230, 293, 291, 362, 257, 1252, 5356, 510, 294, 264, 818, 4230, 13, 51226], "temperature": 0.0, "avg_logprob": -0.19176439138559195, "compression_ratio": 1.7004405286343611, "no_speech_prob": 0.14332249760627747}, {"id": 6, "seek": 2380, "start": 41.040000000000006, "end": 47.88, "text": " It's very, very small down there. I'll zoom in a little bit. In the call tree you can see which", "tokens": [51226, 467, 311, 588, 11, 588, 1359, 760, 456, 13, 286, 603, 8863, 294, 257, 707, 857, 13, 682, 264, 818, 4230, 291, 393, 536, 597, 51568], "temperature": 0.0, "avg_logprob": -0.19176439138559195, "compression_ratio": 1.7004405286343611, "no_speech_prob": 0.14332249760627747}, {"id": 7, "seek": 4788, "start": 47.88, "end": 55.440000000000005, "text": " function called which function. You can see how much time each function spent running. So let's say", "tokens": [50364, 2445, 1219, 597, 2445, 13, 509, 393, 536, 577, 709, 565, 1184, 2445, 4418, 2614, 13, 407, 718, 311, 584, 50742], "temperature": 0.0, "avg_logprob": -0.1787128033845321, "compression_ratio": 1.6752136752136753, "no_speech_prob": 0.0037599282804876566}, {"id": 8, "seek": 4788, "start": 55.440000000000005, "end": 62.24, "text": " this function here dispatch event. Firefox Profiler is a sampling Profiler. So it interrupts the", "tokens": [50742, 341, 2445, 510, 36729, 2280, 13, 46613, 6039, 5441, 307, 257, 21179, 6039, 5441, 13, 407, 309, 12729, 82, 264, 51082], "temperature": 0.0, "avg_logprob": -0.1787128033845321, "compression_ratio": 1.6752136752136753, "no_speech_prob": 0.0037599282804876566}, {"id": 9, "seek": 4788, "start": 62.24, "end": 67.88, "text": " thread at a given interval like usually one millisecond every one millisecond. It checks what's on", "tokens": [51082, 7207, 412, 257, 2212, 15035, 411, 2673, 472, 27940, 18882, 633, 472, 27940, 18882, 13, 467, 13834, 437, 311, 322, 51364], "temperature": 0.0, "avg_logprob": -0.1787128033845321, "compression_ratio": 1.6752136752136753, "no_speech_prob": 0.0037599282804876566}, {"id": 10, "seek": 4788, "start": 67.88, "end": 75.04, "text": " the stack and then it accumulates that into this call tree. So one thing that I want to call out", "tokens": [51364, 264, 8630, 293, 550, 309, 12989, 26192, 300, 666, 341, 818, 4230, 13, 407, 472, 551, 300, 286, 528, 281, 818, 484, 51722], "temperature": 0.0, "avg_logprob": -0.1787128033845321, "compression_ratio": 1.6752136752136753, "no_speech_prob": 0.0037599282804876566}, {"id": 11, "seek": 7504, "start": 75.08000000000001, "end": 80.44000000000001, "text": " here is the category breakdown in the sidebar. So here we have a bunch of categories. User is", "tokens": [50366, 510, 307, 264, 7719, 18188, 294, 264, 1252, 5356, 13, 407, 510, 321, 362, 257, 3840, 295, 10479, 13, 32127, 307, 50634], "temperature": 0.0, "avg_logprob": -0.17683728535970053, "compression_ratio": 1.7630331753554502, "no_speech_prob": 0.011821088381111622}, {"id": 12, "seek": 7504, "start": 80.44000000000001, "end": 87.28, "text": " just regular code. Ion here means this is JavaScript code that was jitted into the IonMonkey", "tokens": [50634, 445, 3890, 3089, 13, 286, 266, 510, 1355, 341, 307, 15778, 3089, 300, 390, 361, 3944, 666, 264, 286, 266, 32498, 4119, 50976], "temperature": 0.0, "avg_logprob": -0.17683728535970053, "compression_ratio": 1.7630331753554502, "no_speech_prob": 0.011821088381111622}, {"id": 13, "seek": 7504, "start": 87.28, "end": 95.08000000000001, "text": " subengine of our JavaScript engine. And yeah, there are a bunch of other categories. And you", "tokens": [50976, 1422, 25609, 295, 527, 15778, 2848, 13, 400, 1338, 11, 456, 366, 257, 3840, 295, 661, 10479, 13, 400, 291, 51366], "temperature": 0.0, "avg_logprob": -0.17683728535970053, "compression_ratio": 1.7630331753554502, "no_speech_prob": 0.011821088381111622}, {"id": 14, "seek": 7504, "start": 95.08000000000001, "end": 100.32000000000001, "text": " can select in the timeline and as you draw your selection, oops, as you draw your selection,", "tokens": [51366, 393, 3048, 294, 264, 12933, 293, 382, 291, 2642, 428, 9450, 11, 34166, 11, 382, 291, 2642, 428, 9450, 11, 51628], "temperature": 0.0, "avg_logprob": -0.17683728535970053, "compression_ratio": 1.7630331753554502, "no_speech_prob": 0.011821088381111622}, {"id": 15, "seek": 10032, "start": 100.67999999999999, "end": 107.27999999999999, "text": " the category breakdown updates in the sidebar. So we can also zoom in, see something a little", "tokens": [50382, 264, 7719, 18188, 9205, 294, 264, 1252, 5356, 13, 407, 321, 393, 611, 8863, 294, 11, 536, 746, 257, 707, 50712], "temperature": 0.0, "avg_logprob": -0.16407510638237, "compression_ratio": 1.6724137931034482, "no_speech_prob": 0.0013421208132058382}, {"id": 16, "seek": 10032, "start": 107.27999999999999, "end": 113.16, "text": " smaller. So here we have more code in Ion, more code in the user category. It also has a flame", "tokens": [50712, 4356, 13, 407, 510, 321, 362, 544, 3089, 294, 286, 266, 11, 544, 3089, 294, 264, 4195, 7719, 13, 467, 611, 575, 257, 13287, 51006], "temperature": 0.0, "avg_logprob": -0.16407510638237, "compression_ratio": 1.6724137931034482, "no_speech_prob": 0.0013421208132058382}, {"id": 17, "seek": 10032, "start": 113.16, "end": 120.96, "text": " graph. So zoom back out. And flame graph, you're probably familiar with flame graphs. They're a", "tokens": [51006, 4295, 13, 407, 8863, 646, 484, 13, 400, 13287, 4295, 11, 291, 434, 1391, 4963, 365, 13287, 24877, 13, 814, 434, 257, 51396], "temperature": 0.0, "avg_logprob": -0.16407510638237, "compression_ratio": 1.6724137931034482, "no_speech_prob": 0.0013421208132058382}, {"id": 18, "seek": 10032, "start": 120.96, "end": 127.08, "text": " different representation of the same information. Like you have a call tree, you have nested functions,", "tokens": [51396, 819, 10290, 295, 264, 912, 1589, 13, 1743, 291, 362, 257, 818, 4230, 11, 291, 362, 15646, 292, 6828, 11, 51702], "temperature": 0.0, "avg_logprob": -0.16407510638237, "compression_ratio": 1.6724137931034482, "no_speech_prob": 0.0013421208132058382}, {"id": 19, "seek": 12708, "start": 127.64, "end": 134.84, "text": " the width of each box is the time that is spent in that function. And we also have a tooltip here", "tokens": [50392, 264, 11402, 295, 1184, 2424, 307, 264, 565, 300, 307, 4418, 294, 300, 2445, 13, 400, 321, 611, 362, 257, 2290, 83, 647, 510, 50752], "temperature": 0.0, "avg_logprob": -0.15092327156845403, "compression_ratio": 1.6853448275862069, "no_speech_prob": 0.0014735213480889797}, {"id": 20, "seek": 12708, "start": 134.84, "end": 141.07999999999998, "text": " in the call tree, which again gives us a category breakdown. I'm emphasizing the category breakdown", "tokens": [50752, 294, 264, 818, 4230, 11, 597, 797, 2709, 505, 257, 7719, 18188, 13, 286, 478, 45550, 264, 7719, 18188, 51064], "temperature": 0.0, "avg_logprob": -0.15092327156845403, "compression_ratio": 1.6853448275862069, "no_speech_prob": 0.0014735213480889797}, {"id": 21, "seek": 12708, "start": 141.07999999999998, "end": 145.52, "text": " so much because we're going to implement our own profiler in a minute, which, and we're going to", "tokens": [51064, 370, 709, 570, 321, 434, 516, 281, 4445, 527, 1065, 1740, 5441, 294, 257, 3456, 11, 597, 11, 293, 321, 434, 516, 281, 51286], "temperature": 0.0, "avg_logprob": -0.15092327156845403, "compression_ratio": 1.6853448275862069, "no_speech_prob": 0.0014735213480889797}, {"id": 22, "seek": 12708, "start": 145.52, "end": 152.28, "text": " focus on calculating this category breakdown. So here we see it's a bit sluggish as you move the", "tokens": [51286, 1879, 322, 28258, 341, 7719, 18188, 13, 407, 510, 321, 536, 309, 311, 257, 857, 1061, 3562, 742, 382, 291, 1286, 264, 51624], "temperature": 0.0, "avg_logprob": -0.15092327156845403, "compression_ratio": 1.6853448275862069, "no_speech_prob": 0.0014735213480889797}, {"id": 23, "seek": 15228, "start": 152.32, "end": 158.64000000000001, "text": " mouse around, because it actually needs to iterate over all the samples in the timeline. It checks", "tokens": [50366, 9719, 926, 11, 570, 309, 767, 2203, 281, 44497, 670, 439, 264, 10938, 294, 264, 12933, 13, 467, 13834, 50682], "temperature": 0.0, "avg_logprob": -0.13330784051314645, "compression_ratio": 1.6828193832599119, "no_speech_prob": 0.001955646090209484}, {"id": 24, "seek": 15228, "start": 158.64000000000001, "end": 164.64, "text": " for every sample is the stack inside of the function that you're hovering. If so, check the", "tokens": [50682, 337, 633, 6889, 307, 264, 8630, 1854, 295, 264, 2445, 300, 291, 434, 44923, 13, 759, 370, 11, 1520, 264, 50982], "temperature": 0.0, "avg_logprob": -0.13330784051314645, "compression_ratio": 1.6828193832599119, "no_speech_prob": 0.001955646090209484}, {"id": 25, "seek": 15228, "start": 164.64, "end": 169.8, "text": " category that the CPU is spending its time on for that sample, accumulate that into a map of", "tokens": [50982, 7719, 300, 264, 13199, 307, 6434, 1080, 565, 322, 337, 300, 6889, 11, 33384, 300, 666, 257, 4471, 295, 51240], "temperature": 0.0, "avg_logprob": -0.13330784051314645, "compression_ratio": 1.6828193832599119, "no_speech_prob": 0.001955646090209484}, {"id": 26, "seek": 15228, "start": 169.8, "end": 178.08, "text": " categories to counts, and yeah, do that for all the samples. And we can see here at the root node,", "tokens": [51240, 10479, 281, 14893, 11, 293, 1338, 11, 360, 300, 337, 439, 264, 10938, 13, 400, 321, 393, 536, 510, 412, 264, 5593, 9984, 11, 51654], "temperature": 0.0, "avg_logprob": -0.13330784051314645, "compression_ratio": 1.6828193832599119, "no_speech_prob": 0.001955646090209484}, {"id": 27, "seek": 17808, "start": 178.16000000000003, "end": 185.64000000000001, "text": " we have about 500,000 samples in this profile. So what I didn't tell you is this is actually the", "tokens": [50368, 321, 362, 466, 5923, 11, 1360, 10938, 294, 341, 7964, 13, 407, 437, 286, 994, 380, 980, 291, 307, 341, 307, 767, 264, 50742], "temperature": 0.0, "avg_logprob": -0.17999136447906494, "compression_ratio": 1.4846938775510203, "no_speech_prob": 0.0030690853018313646}, {"id": 28, "seek": 17808, "start": 185.64000000000001, "end": 195.8, "text": " version from last July. And I fixed this performance problem here. So this is what's live now on", "tokens": [50742, 3037, 490, 1036, 7370, 13, 400, 286, 6806, 341, 3389, 1154, 510, 13, 407, 341, 307, 437, 311, 1621, 586, 322, 51250], "temperature": 0.0, "avg_logprob": -0.17999136447906494, "compression_ratio": 1.4846938775510203, "no_speech_prob": 0.0030690853018313646}, {"id": 29, "seek": 17808, "start": 195.8, "end": 202.60000000000002, "text": " profile.farfax.com. Hovering these boxes is no instant. And it's still doing the work. It's still", "tokens": [51250, 7964, 13, 21196, 69, 2797, 13, 1112, 13, 389, 3570, 278, 613, 9002, 307, 572, 9836, 13, 400, 309, 311, 920, 884, 264, 589, 13, 467, 311, 920, 51590], "temperature": 0.0, "avg_logprob": -0.17999136447906494, "compression_ratio": 1.4846938775510203, "no_speech_prob": 0.0030690853018313646}, {"id": 30, "seek": 20260, "start": 202.64, "end": 208.35999999999999, "text": " going through all 500,000 samples every time you move your mouse. So I want to talk a bit about", "tokens": [50366, 516, 807, 439, 5923, 11, 1360, 10938, 633, 565, 291, 1286, 428, 9719, 13, 407, 286, 528, 281, 751, 257, 857, 466, 50652], "temperature": 0.0, "avg_logprob": -0.13786362312935493, "compression_ratio": 1.4870466321243523, "no_speech_prob": 0.0011681346222758293}, {"id": 31, "seek": 20260, "start": 208.35999999999999, "end": 218.24, "text": " how we can crunch through all that data in in very short time. Wrong direction. So yeah, even with", "tokens": [50652, 577, 321, 393, 13386, 807, 439, 300, 1412, 294, 294, 588, 2099, 565, 13, 28150, 3513, 13, 407, 1338, 11, 754, 365, 51146], "temperature": 0.0, "avg_logprob": -0.13786362312935493, "compression_ratio": 1.4870466321243523, "no_speech_prob": 0.0011681346222758293}, {"id": 32, "seek": 20260, "start": 218.24, "end": 226.12, "text": " lots of samples, we can now have a fast UI. And I made an example project just for this talk", "tokens": [51146, 3195, 295, 10938, 11, 321, 393, 586, 362, 257, 2370, 15682, 13, 400, 286, 1027, 364, 1365, 1716, 445, 337, 341, 751, 51540], "temperature": 0.0, "avg_logprob": -0.13786362312935493, "compression_ratio": 1.4870466321243523, "no_speech_prob": 0.0011681346222758293}, {"id": 33, "seek": 22612, "start": 226.88, "end": 232.92000000000002, "text": " called mini profiler. It is on GitHub. It's also live on Netlify. You can try it out in your browser", "tokens": [50402, 1219, 8382, 1740, 5441, 13, 467, 307, 322, 23331, 13, 467, 311, 611, 1621, 322, 6188, 75, 2505, 13, 509, 393, 853, 309, 484, 294, 428, 11185, 50704], "temperature": 0.0, "avg_logprob": -0.1463521039938625, "compression_ratio": 1.4924623115577889, "no_speech_prob": 0.005128472112119198}, {"id": 34, "seek": 22612, "start": 232.92000000000002, "end": 242.64000000000001, "text": " if you want to. And this is what it looks like. It has a very reduced feature set, but it also has", "tokens": [50704, 498, 291, 528, 281, 13, 400, 341, 307, 437, 309, 1542, 411, 13, 467, 575, 257, 588, 9212, 4111, 992, 11, 457, 309, 611, 575, 51190], "temperature": 0.0, "avg_logprob": -0.1463521039938625, "compression_ratio": 1.4924623115577889, "no_speech_prob": 0.005128472112119198}, {"id": 35, "seek": 22612, "start": 242.64000000000001, "end": 249.36, "text": " this timeline. You can select parts of the timeline and it calculates this category breakdown. So", "tokens": [51190, 341, 12933, 13, 509, 393, 3048, 3166, 295, 264, 12933, 293, 309, 4322, 1024, 341, 7719, 18188, 13, 407, 51526], "temperature": 0.0, "avg_logprob": -0.1463521039938625, "compression_ratio": 1.4924623115577889, "no_speech_prob": 0.005128472112119198}, {"id": 36, "seek": 24936, "start": 250.32000000000002, "end": 258.64, "text": " yeah, let's say here, we spent 30% in Ion Monkey Jitter JavaScript code. At the same time, it also", "tokens": [50412, 1338, 11, 718, 311, 584, 510, 11, 321, 4418, 2217, 4, 294, 286, 266, 34862, 508, 3904, 15778, 3089, 13, 1711, 264, 912, 565, 11, 309, 611, 50828], "temperature": 0.0, "avg_logprob": -0.25422774420844185, "compression_ratio": 1.510204081632653, "no_speech_prob": 0.0007301372243091464}, {"id": 37, "seek": 24936, "start": 258.64, "end": 265.68, "text": " calculates the heaviest stack. The heaviest stack is the stack that we spend the most samples in.", "tokens": [50828, 4322, 1024, 264, 3577, 6495, 8630, 13, 440, 3577, 6495, 8630, 307, 264, 8630, 300, 321, 3496, 264, 881, 10938, 294, 13, 51180], "temperature": 0.0, "avg_logprob": -0.25422774420844185, "compression_ratio": 1.510204081632653, "no_speech_prob": 0.0007301372243091464}, {"id": 38, "seek": 24936, "start": 265.68, "end": 276.24, "text": " All right. So yeah, mini profiler features. There's only two features. You select the range, and it", "tokens": [51180, 1057, 558, 13, 407, 1338, 11, 8382, 1740, 5441, 4122, 13, 821, 311, 787, 732, 4122, 13, 509, 3048, 264, 3613, 11, 293, 309, 51708], "temperature": 0.0, "avg_logprob": -0.25422774420844185, "compression_ratio": 1.510204081632653, "no_speech_prob": 0.0007301372243091464}, {"id": 39, "seek": 27624, "start": 276.32, "end": 282.56, "text": " gives you a category breakdown and a heaviest stack. So how does it calculate that? We have an input", "tokens": [50368, 2709, 291, 257, 7719, 18188, 293, 257, 3577, 6495, 8630, 13, 407, 577, 775, 309, 8873, 300, 30, 492, 362, 364, 4846, 50680], "temperature": 0.0, "avg_logprob": -0.13514159707462087, "compression_ratio": 1.6796536796536796, "no_speech_prob": 0.0020794798620045185}, {"id": 40, "seek": 27624, "start": 282.56, "end": 289.2, "text": " JSON, which describes the profile contents. The JSON is a list of samples. Every sample has a", "tokens": [50680, 31828, 11, 597, 15626, 264, 7964, 15768, 13, 440, 31828, 307, 257, 1329, 295, 10938, 13, 2048, 6889, 575, 257, 51012], "temperature": 0.0, "avg_logprob": -0.13514159707462087, "compression_ratio": 1.6796536796536796, "no_speech_prob": 0.0020794798620045185}, {"id": 41, "seek": 27624, "start": 289.2, "end": 292.40000000000003, "text": " time, a weight, and a stack. Every stack is an array of frames. Every frame has a name and a", "tokens": [51012, 565, 11, 257, 3364, 11, 293, 257, 8630, 13, 2048, 8630, 307, 364, 10225, 295, 12083, 13, 2048, 3920, 575, 257, 1315, 293, 257, 51172], "temperature": 0.0, "avg_logprob": -0.13514159707462087, "compression_ratio": 1.6796536796536796, "no_speech_prob": 0.0020794798620045185}, {"id": 42, "seek": 27624, "start": 292.40000000000003, "end": 301.76, "text": " category. I'll show you that here in an example. So as I said, a list of samples, every sample has a", "tokens": [51172, 7719, 13, 286, 603, 855, 291, 300, 510, 294, 364, 1365, 13, 407, 382, 286, 848, 11, 257, 1329, 295, 10938, 11, 633, 6889, 575, 257, 51640], "temperature": 0.0, "avg_logprob": -0.13514159707462087, "compression_ratio": 1.6796536796536796, "no_speech_prob": 0.0020794798620045185}, {"id": 43, "seek": 30176, "start": 301.76, "end": 307.84, "text": " time property, a stack property, a weight property. The stack is an array. Each stack frame has a name", "tokens": [50364, 565, 4707, 11, 257, 8630, 4707, 11, 257, 3364, 4707, 13, 440, 8630, 307, 364, 10225, 13, 6947, 8630, 3920, 575, 257, 1315, 50668], "temperature": 0.0, "avg_logprob": -0.07737983976091657, "compression_ratio": 1.7401129943502824, "no_speech_prob": 0.00043037557043135166}, {"id": 44, "seek": 30176, "start": 307.84, "end": 319.52, "text": " and a category. To calculate the category breakdown, we take in the profile. We take in a range of the", "tokens": [50668, 293, 257, 7719, 13, 1407, 8873, 264, 7719, 18188, 11, 321, 747, 294, 264, 7964, 13, 492, 747, 294, 257, 3613, 295, 264, 51252], "temperature": 0.0, "avg_logprob": -0.07737983976091657, "compression_ratio": 1.7401129943502824, "no_speech_prob": 0.00043037557043135166}, {"id": 45, "seek": 30176, "start": 319.52, "end": 326.08, "text": " indexes of the samples that are in the selection. Then we iterate over this range. We get each sample.", "tokens": [51252, 8186, 279, 295, 264, 10938, 300, 366, 294, 264, 9450, 13, 1396, 321, 44497, 670, 341, 3613, 13, 492, 483, 1184, 6889, 13, 51580], "temperature": 0.0, "avg_logprob": -0.07737983976091657, "compression_ratio": 1.7401129943502824, "no_speech_prob": 0.00043037557043135166}, {"id": 46, "seek": 32608, "start": 326.64, "end": 332.24, "text": " Whoops. We get its stack and its weight. We get the top frame from the stack. We get the category", "tokens": [50392, 45263, 13, 492, 483, 1080, 8630, 293, 1080, 3364, 13, 492, 483, 264, 1192, 3920, 490, 264, 8630, 13, 492, 483, 264, 7719, 50672], "temperature": 0.0, "avg_logprob": -0.10502951485770089, "compression_ratio": 1.6685393258426966, "no_speech_prob": 0.0066873617470264435}, {"id": 47, "seek": 32608, "start": 332.24, "end": 339.59999999999997, "text": " from the frame. And then we check. Does our map have this category already? If so, get the current", "tokens": [50672, 490, 264, 3920, 13, 400, 550, 321, 1520, 13, 4402, 527, 4471, 362, 341, 7719, 1217, 30, 759, 370, 11, 483, 264, 2190, 51040], "temperature": 0.0, "avg_logprob": -0.10502951485770089, "compression_ratio": 1.6685393258426966, "no_speech_prob": 0.0066873617470264435}, {"id": 48, "seek": 32608, "start": 339.59999999999997, "end": 346.47999999999996, "text": " value. Otherwise, default to zero. We add the weight of the current sample. We put the sum back into", "tokens": [51040, 2158, 13, 10328, 11, 7576, 281, 4018, 13, 492, 909, 264, 3364, 295, 264, 2190, 6889, 13, 492, 829, 264, 2408, 646, 666, 51384], "temperature": 0.0, "avg_logprob": -0.10502951485770089, "compression_ratio": 1.6685393258426966, "no_speech_prob": 0.0066873617470264435}, {"id": 49, "seek": 34648, "start": 346.48, "end": 356.48, "text": " the map. And then this map is what gets used by this spelt component. For the heaviest stack, it's", "tokens": [50364, 264, 4471, 13, 400, 550, 341, 4471, 307, 437, 2170, 1143, 538, 341, 637, 2018, 6542, 13, 1171, 264, 3577, 6495, 8630, 11, 309, 311, 50864], "temperature": 0.0, "avg_logprob": -0.08880610723753234, "compression_ratio": 1.6145251396648044, "no_speech_prob": 0.0035344490315765142}, {"id": 50, "seek": 34648, "start": 356.48, "end": 363.20000000000005, "text": " somewhat similar. We again iterate over all the samples in the selected range. For each sample,", "tokens": [50864, 8344, 2531, 13, 492, 797, 44497, 670, 439, 264, 10938, 294, 264, 8209, 3613, 13, 1171, 1184, 6889, 11, 51200], "temperature": 0.0, "avg_logprob": -0.08880610723753234, "compression_ratio": 1.6145251396648044, "no_speech_prob": 0.0035344490315765142}, {"id": 51, "seek": 34648, "start": 363.20000000000005, "end": 370.32, "text": " we again get the stack and the weight. And now we need to check if this stack has been used by", "tokens": [51200, 321, 797, 483, 264, 8630, 293, 264, 3364, 13, 400, 586, 321, 643, 281, 1520, 498, 341, 8630, 575, 668, 1143, 538, 51556], "temperature": 0.0, "avg_logprob": -0.08880610723753234, "compression_ratio": 1.6145251396648044, "no_speech_prob": 0.0035344490315765142}, {"id": 52, "seek": 37032, "start": 370.32, "end": 377.76, "text": " multiple samples. And how do we find two samples with the same stack? Well, the stack is an array,", "tokens": [50364, 3866, 10938, 13, 400, 577, 360, 321, 915, 732, 10938, 365, 264, 912, 8630, 30, 1042, 11, 264, 8630, 307, 364, 10225, 11, 50736], "temperature": 0.0, "avg_logprob": -0.09456516802310944, "compression_ratio": 1.696551724137931, "no_speech_prob": 0.0028427427168935537}, {"id": 53, "seek": 37032, "start": 377.76, "end": 382.4, "text": " and you can't really check them for equality easily. So what I'm doing here is I'm stringifying the", "tokens": [50736, 293, 291, 393, 380, 534, 1520, 552, 337, 14949, 3612, 13, 407, 437, 286, 478, 884, 510, 307, 286, 478, 6798, 5489, 264, 50968], "temperature": 0.0, "avg_logprob": -0.09456516802310944, "compression_ratio": 1.696551724137931, "no_speech_prob": 0.0028427427168935537}, {"id": 54, "seek": 37032, "start": 382.4, "end": 388.64, "text": " stack into a JSON string. I'm using that as the map key. And then here is a similar issue to what", "tokens": [50968, 8630, 666, 257, 31828, 6798, 13, 286, 478, 1228, 300, 382, 264, 4471, 2141, 13, 400, 550, 510, 307, 257, 2531, 2734, 281, 437, 51280], "temperature": 0.0, "avg_logprob": -0.09456516802310944, "compression_ratio": 1.696551724137931, "no_speech_prob": 0.0028427427168935537}, {"id": 55, "seek": 37032, "start": 388.64, "end": 393.68, "text": " we had with the category breakdown. We check. Do we have an entry in the map for this stack?", "tokens": [51280, 321, 632, 365, 264, 7719, 18188, 13, 492, 1520, 13, 1144, 321, 362, 364, 8729, 294, 264, 4471, 337, 341, 8630, 30, 51532], "temperature": 0.0, "avg_logprob": -0.09456516802310944, "compression_ratio": 1.696551724137931, "no_speech_prob": 0.0028427427168935537}, {"id": 56, "seek": 37032, "start": 393.68, "end": 399.44, "text": " If so, take its current value. Otherwise, default to zero. Add the weight. Put that back into the map.", "tokens": [51532, 759, 370, 11, 747, 1080, 2190, 2158, 13, 10328, 11, 7576, 281, 4018, 13, 5349, 264, 3364, 13, 4935, 300, 646, 666, 264, 4471, 13, 51820], "temperature": 0.0, "avg_logprob": -0.09456516802310944, "compression_ratio": 1.696551724137931, "no_speech_prob": 0.0028427427168935537}, {"id": 57, "seek": 40032, "start": 400.88, "end": 407.52, "text": " And if this stack is the heaviest that we've seen so far, we remember it, and then at the end,", "tokens": [50392, 400, 498, 341, 8630, 307, 264, 3577, 6495, 300, 321, 600, 1612, 370, 1400, 11, 321, 1604, 309, 11, 293, 550, 412, 264, 917, 11, 50724], "temperature": 0.0, "avg_logprob": -0.08656875610351562, "compression_ratio": 1.5905172413793103, "no_speech_prob": 0.00022325408644974232}, {"id": 58, "seek": 40032, "start": 407.52, "end": 413.6, "text": " we return it. So these are the two main algorithms in this mini-profiler. Category breakdown,", "tokens": [50724, 321, 2736, 309, 13, 407, 613, 366, 264, 732, 2135, 14642, 294, 341, 8382, 12, 29175, 5441, 13, 383, 48701, 18188, 11, 51028], "temperature": 0.0, "avg_logprob": -0.08656875610351562, "compression_ratio": 1.5905172413793103, "no_speech_prob": 0.00022325408644974232}, {"id": 59, "seek": 40032, "start": 413.6, "end": 420.56, "text": " heaviest stack. Both of them have to iterate over all the samples. So how fast is it?", "tokens": [51028, 3577, 6495, 8630, 13, 6767, 295, 552, 362, 281, 44497, 670, 439, 264, 10938, 13, 407, 577, 2370, 307, 309, 30, 51376], "temperature": 0.0, "avg_logprob": -0.08656875610351562, "compression_ratio": 1.5905172413793103, "no_speech_prob": 0.00022325408644974232}, {"id": 60, "seek": 40032, "start": 422.8, "end": 427.84, "text": " So if I select here, it's reasonably fast. If I make the selection bigger, it starts getting a", "tokens": [51488, 407, 498, 286, 3048, 510, 11, 309, 311, 23551, 2370, 13, 759, 286, 652, 264, 9450, 3801, 11, 309, 3719, 1242, 257, 51740], "temperature": 0.0, "avg_logprob": -0.08656875610351562, "compression_ratio": 1.5905172413793103, "no_speech_prob": 0.00022325408644974232}, {"id": 61, "seek": 42784, "start": 427.84, "end": 435.44, "text": " little janky. I'm computing some throughputs down here. So 100 nanoseconds per sample is how", "tokens": [50364, 707, 361, 657, 88, 13, 286, 478, 15866, 512, 44629, 82, 760, 510, 13, 407, 2319, 14067, 541, 28750, 680, 6889, 307, 577, 50744], "temperature": 0.0, "avg_logprob": -0.09702113523321637, "compression_ratio": 1.6931407942238268, "no_speech_prob": 0.0010306000476703048}, {"id": 62, "seek": 42784, "start": 435.44, "end": 442.0, "text": " long the algorithm for the category breakdown takes. And 30,000 something nanoseconds per sample", "tokens": [50744, 938, 264, 9284, 337, 264, 7719, 18188, 2516, 13, 400, 2217, 11, 1360, 746, 14067, 541, 28750, 680, 6889, 51072], "temperature": 0.0, "avg_logprob": -0.09702113523321637, "compression_ratio": 1.6931407942238268, "no_speech_prob": 0.0010306000476703048}, {"id": 63, "seek": 42784, "start": 442.0, "end": 445.76, "text": " for computing the heaviest stack. Because, yeah, we saw the heaviest stack algorithm,", "tokens": [51072, 337, 15866, 264, 3577, 6495, 8630, 13, 1436, 11, 1338, 11, 321, 1866, 264, 3577, 6495, 8630, 9284, 11, 51260], "temperature": 0.0, "avg_logprob": -0.09702113523321637, "compression_ratio": 1.6931407942238268, "no_speech_prob": 0.0010306000476703048}, {"id": 64, "seek": 42784, "start": 445.76, "end": 451.59999999999997, "text": " it was really inefficient. It used JSON stringify. It looked up this gigantic string in a map.", "tokens": [51260, 309, 390, 534, 43495, 13, 467, 1143, 31828, 6798, 2505, 13, 467, 2956, 493, 341, 26800, 6798, 294, 257, 4471, 13, 51552], "temperature": 0.0, "avg_logprob": -0.09702113523321637, "compression_ratio": 1.6931407942238268, "no_speech_prob": 0.0010306000476703048}, {"id": 65, "seek": 42784, "start": 451.59999999999997, "end": 456.64, "text": " It needs to hash the entire big string and so on. So this is obviously not the way to go. But this", "tokens": [51552, 467, 2203, 281, 22019, 264, 2302, 955, 6798, 293, 370, 322, 13, 407, 341, 307, 2745, 406, 264, 636, 281, 352, 13, 583, 341, 51804], "temperature": 0.0, "avg_logprob": -0.09702113523321637, "compression_ratio": 1.6931407942238268, "no_speech_prob": 0.0010306000476703048}, {"id": 66, "seek": 45664, "start": 456.64, "end": 465.2, "text": " is just a place to start so that we understand what's going on. So this is the throughput here.", "tokens": [50364, 307, 445, 257, 1081, 281, 722, 370, 300, 321, 1223, 437, 311, 516, 322, 13, 407, 341, 307, 264, 44629, 510, 13, 50792], "temperature": 0.0, "avg_logprob": -0.0805698299407959, "compression_ratio": 1.5875, "no_speech_prob": 0.0009087504586204886}, {"id": 67, "seek": 45664, "start": 466.4, "end": 472.71999999999997, "text": " The nanoseconds per sample might not tell you much. But what you can think about is, how does it", "tokens": [50852, 440, 14067, 541, 28750, 680, 6889, 1062, 406, 980, 291, 709, 13, 583, 437, 291, 393, 519, 466, 307, 11, 577, 775, 309, 51168], "temperature": 0.0, "avg_logprob": -0.0805698299407959, "compression_ratio": 1.5875, "no_speech_prob": 0.0009087504586204886}, {"id": 68, "seek": 45664, "start": 472.71999999999997, "end": 477.59999999999997, "text": " limit the size that you can handle while still being responsive? So let's say you have 100,000", "tokens": [51168, 4948, 264, 2744, 300, 291, 393, 4813, 1339, 920, 885, 21826, 30, 407, 718, 311, 584, 291, 362, 2319, 11, 1360, 51412], "temperature": 0.0, "avg_logprob": -0.0805698299407959, "compression_ratio": 1.5875, "no_speech_prob": 0.0009087504586204886}, {"id": 69, "seek": 45664, "start": 477.59999999999997, "end": 484.64, "text": " samples. In this example here, we just had 1,600 something samples. What if you have 100,000?", "tokens": [51412, 10938, 13, 682, 341, 1365, 510, 11, 321, 445, 632, 502, 11, 15707, 746, 10938, 13, 708, 498, 291, 362, 2319, 11, 1360, 30, 51764], "temperature": 0.0, "avg_logprob": -0.0805698299407959, "compression_ratio": 1.5875, "no_speech_prob": 0.0009087504586204886}, {"id": 70, "seek": 48464, "start": 484.64, "end": 489.12, "text": " Then you get 10 milliseconds for computing the category breakdown and 3.6 seconds for computing", "tokens": [50364, 1396, 291, 483, 1266, 34184, 337, 15866, 264, 7719, 18188, 293, 805, 13, 21, 3949, 337, 15866, 50588], "temperature": 0.0, "avg_logprob": -0.08875592549641927, "compression_ratio": 1.6043478260869566, "no_speech_prob": 0.00032994785578921437}, {"id": 71, "seek": 48464, "start": 489.12, "end": 494.8, "text": " the heaviest stack. 3.6 seconds per update, that's not acceptable. So we need to do something.", "tokens": [50588, 264, 3577, 6495, 8630, 13, 805, 13, 21, 3949, 680, 5623, 11, 300, 311, 406, 15513, 13, 407, 321, 643, 281, 360, 746, 13, 50872], "temperature": 0.0, "avg_logprob": -0.08875592549641927, "compression_ratio": 1.6043478260869566, "no_speech_prob": 0.00032994785578921437}, {"id": 72, "seek": 48464, "start": 496.0, "end": 501.28, "text": " And also the JSON file, because it has all those repeated stacks, it's just massive.", "tokens": [50932, 400, 611, 264, 31828, 3991, 11, 570, 309, 575, 439, 729, 10477, 30792, 11, 309, 311, 445, 5994, 13, 51196], "temperature": 0.0, "avg_logprob": -0.08875592549641927, "compression_ratio": 1.6043478260869566, "no_speech_prob": 0.00032994785578921437}, {"id": 73, "seek": 48464, "start": 502.96, "end": 510.32, "text": " So let's use a different format, different JSON format. Here I made a V2 format. It still has", "tokens": [51280, 407, 718, 311, 764, 257, 819, 7877, 11, 819, 31828, 7877, 13, 1692, 286, 1027, 257, 691, 17, 7877, 13, 467, 920, 575, 51648], "temperature": 0.0, "avg_logprob": -0.08875592549641927, "compression_ratio": 1.6043478260869566, "no_speech_prob": 0.00032994785578921437}, {"id": 74, "seek": 51032, "start": 510.32, "end": 515.52, "text": " samples, but instead of having the stacks right in the sample, it just has an index. And this", "tokens": [50364, 10938, 11, 457, 2602, 295, 1419, 264, 30792, 558, 294, 264, 6889, 11, 309, 445, 575, 364, 8186, 13, 400, 341, 50624], "temperature": 0.0, "avg_logprob": -0.07956708337842804, "compression_ratio": 1.8725490196078431, "no_speech_prob": 0.004131695255637169}, {"id": 75, "seek": 51032, "start": 515.52, "end": 523.52, "text": " index now goes into a stack list. Each element in the stack list has a frame index, which goes", "tokens": [50624, 8186, 586, 1709, 666, 257, 8630, 1329, 13, 6947, 4478, 294, 264, 8630, 1329, 575, 257, 3920, 8186, 11, 597, 1709, 51024], "temperature": 0.0, "avg_logprob": -0.07956708337842804, "compression_ratio": 1.8725490196078431, "no_speech_prob": 0.004131695255637169}, {"id": 76, "seek": 51032, "start": 523.52, "end": 528.88, "text": " into the frame list. Each frame has a name and a category index, which goes into the category list.", "tokens": [51024, 666, 264, 3920, 1329, 13, 6947, 3920, 575, 257, 1315, 293, 257, 7719, 8186, 11, 597, 1709, 666, 264, 7719, 1329, 13, 51292], "temperature": 0.0, "avg_logprob": -0.07956708337842804, "compression_ratio": 1.8725490196078431, "no_speech_prob": 0.004131695255637169}, {"id": 77, "seek": 51032, "start": 530.4, "end": 534.4, "text": " So I hope that's not too overwhelming. We just have a bunch of indexes now. Instead of nested", "tokens": [51368, 407, 286, 1454, 300, 311, 406, 886, 13373, 13, 492, 445, 362, 257, 3840, 295, 8186, 279, 586, 13, 7156, 295, 15646, 292, 51568], "temperature": 0.0, "avg_logprob": -0.07956708337842804, "compression_ratio": 1.8725490196078431, "no_speech_prob": 0.004131695255637169}, {"id": 78, "seek": 53440, "start": 534.4, "end": 541.28, "text": " objects, we just have some side-by-side lists and we index into them. And also here the stacks", "tokens": [50364, 6565, 11, 321, 445, 362, 512, 1252, 12, 2322, 12, 1812, 14511, 293, 321, 8186, 666, 552, 13, 400, 611, 510, 264, 30792, 50708], "temperature": 0.0, "avg_logprob": -0.09216601305668896, "compression_ratio": 1.7990654205607477, "no_speech_prob": 0.00446435296908021}, {"id": 79, "seek": 53440, "start": 541.28, "end": 547.04, "text": " are a little special because of this parent stack index here. So if, for example, a sample", "tokens": [50708, 366, 257, 707, 2121, 570, 295, 341, 2596, 8630, 8186, 510, 13, 407, 498, 11, 337, 1365, 11, 257, 6889, 50996], "temperature": 0.0, "avg_logprob": -0.09216601305668896, "compression_ratio": 1.7990654205607477, "no_speech_prob": 0.00446435296908021}, {"id": 80, "seek": 53440, "start": 547.04, "end": 553.52, "text": " refers to stack number two, then this is the frame at the top of the stack. Then we go to the parent", "tokens": [50996, 14942, 281, 8630, 1230, 732, 11, 550, 341, 307, 264, 3920, 412, 264, 1192, 295, 264, 8630, 13, 1396, 321, 352, 281, 264, 2596, 51320], "temperature": 0.0, "avg_logprob": -0.09216601305668896, "compression_ratio": 1.7990654205607477, "no_speech_prob": 0.00446435296908021}, {"id": 81, "seek": 53440, "start": 553.52, "end": 560.8, "text": " stack, find this frame, that's the next frame on the stack, find this stack, put this frame on the", "tokens": [51320, 8630, 11, 915, 341, 3920, 11, 300, 311, 264, 958, 3920, 322, 264, 8630, 11, 915, 341, 8630, 11, 829, 341, 3920, 322, 264, 51684], "temperature": 0.0, "avg_logprob": -0.09216601305668896, "compression_ratio": 1.7990654205607477, "no_speech_prob": 0.00446435296908021}, {"id": 82, "seek": 56080, "start": 560.8, "end": 563.92, "text": " stack, and then the parent here is null. So that means we're at the end of the stack.", "tokens": [50364, 8630, 11, 293, 550, 264, 2596, 510, 307, 18184, 13, 407, 300, 1355, 321, 434, 412, 264, 917, 295, 264, 8630, 13, 50520], "temperature": 0.0, "avg_logprob": -0.10517192609382398, "compression_ratio": 1.6711111111111112, "no_speech_prob": 0.0003051133535336703}, {"id": 83, "seek": 56080, "start": 567.28, "end": 574.56, "text": " Hope I haven't lost anyone yet. So let's go back to the compute-heavy stack algorithm. So we were", "tokens": [50688, 6483, 286, 2378, 380, 2731, 2878, 1939, 13, 407, 718, 311, 352, 646, 281, 264, 14722, 12, 37157, 8630, 9284, 13, 407, 321, 645, 51052], "temperature": 0.0, "avg_logprob": -0.10517192609382398, "compression_ratio": 1.6711111111111112, "no_speech_prob": 0.0003051133535336703}, {"id": 84, "seek": 56080, "start": 574.56, "end": 581.5999999999999, "text": " iterating over the samples. We were stringifying the stack arrays and we were checking the JSON", "tokens": [51052, 17138, 990, 670, 264, 10938, 13, 492, 645, 6798, 5489, 264, 8630, 41011, 293, 321, 645, 8568, 264, 31828, 51404], "temperature": 0.0, "avg_logprob": -0.10517192609382398, "compression_ratio": 1.6711111111111112, "no_speech_prob": 0.0003051133535336703}, {"id": 85, "seek": 56080, "start": 581.5999999999999, "end": 587.3599999999999, "text": " string. Now we don't need to do that anymore. Now we have an index. If two samples have the same", "tokens": [51404, 6798, 13, 823, 321, 500, 380, 643, 281, 360, 300, 3602, 13, 823, 321, 362, 364, 8186, 13, 759, 732, 10938, 362, 264, 912, 51692], "temperature": 0.0, "avg_logprob": -0.10517192609382398, "compression_ratio": 1.6711111111111112, "no_speech_prob": 0.0003051133535336703}, {"id": 86, "seek": 58736, "start": 587.36, "end": 592.32, "text": " stack index, that means they have the same stack. So we just use the stack index now here and we", "tokens": [50364, 8630, 8186, 11, 300, 1355, 436, 362, 264, 912, 8630, 13, 407, 321, 445, 764, 264, 8630, 8186, 586, 510, 293, 321, 50612], "temperature": 0.0, "avg_logprob": -0.11254317037175211, "compression_ratio": 1.559670781893004, "no_speech_prob": 0.0005109620979055762}, {"id": 87, "seek": 58736, "start": 592.32, "end": 596.88, "text": " don't need the JSONification. We don't look up big strings. And this is like a massive performance", "tokens": [50612, 500, 380, 643, 264, 31828, 3774, 13, 492, 500, 380, 574, 493, 955, 13985, 13, 400, 341, 307, 411, 257, 5994, 3389, 50840], "temperature": 0.0, "avg_logprob": -0.11254317037175211, "compression_ratio": 1.559670781893004, "no_speech_prob": 0.0005109620979055762}, {"id": 88, "seek": 58736, "start": 596.88, "end": 606.08, "text": " improvement. So 300 times faster. The category breakdown is also affected by the new format", "tokens": [50840, 10444, 13, 407, 6641, 1413, 4663, 13, 440, 7719, 18188, 307, 611, 8028, 538, 264, 777, 7877, 51300], "temperature": 0.0, "avg_logprob": -0.11254317037175211, "compression_ratio": 1.559670781893004, "no_speech_prob": 0.0005109620979055762}, {"id": 89, "seek": 58736, "start": 606.08, "end": 613.44, "text": " changes. So now instead of getting the stack and the frame directly from inside the sample,", "tokens": [51300, 2962, 13, 407, 586, 2602, 295, 1242, 264, 8630, 293, 264, 3920, 3838, 490, 1854, 264, 6889, 11, 51668], "temperature": 0.0, "avg_logprob": -0.11254317037175211, "compression_ratio": 1.559670781893004, "no_speech_prob": 0.0005109620979055762}, {"id": 90, "seek": 61344, "start": 614.08, "end": 617.44, "text": " we instead get a stack index. We look up the stack index in the stack array,", "tokens": [50396, 321, 2602, 483, 257, 8630, 8186, 13, 492, 574, 493, 264, 8630, 8186, 294, 264, 8630, 10225, 11, 50564], "temperature": 0.0, "avg_logprob": -0.11721477713636173, "compression_ratio": 1.8829787234042554, "no_speech_prob": 0.0005030151223763824}, {"id": 91, "seek": 61344, "start": 618.08, "end": 622.32, "text": " which gives us a frame index. We look that up again, get the category index, look that up again,", "tokens": [50596, 597, 2709, 505, 257, 3920, 8186, 13, 492, 574, 300, 493, 797, 11, 483, 264, 7719, 8186, 11, 574, 300, 493, 797, 11, 50808], "temperature": 0.0, "avg_logprob": -0.11721477713636173, "compression_ratio": 1.8829787234042554, "no_speech_prob": 0.0005030151223763824}, {"id": 92, "seek": 61344, "start": 622.32, "end": 627.84, "text": " get a category name. This is a string. Put that in the map or add up the weight.", "tokens": [50808, 483, 257, 7719, 1315, 13, 639, 307, 257, 6798, 13, 4935, 300, 294, 264, 4471, 420, 909, 493, 264, 3364, 13, 51084], "temperature": 0.0, "avg_logprob": -0.11721477713636173, "compression_ratio": 1.8829787234042554, "no_speech_prob": 0.0005030151223763824}, {"id": 93, "seek": 61344, "start": 632.1600000000001, "end": 638.8000000000001, "text": " This string here, this is kind of unnecessary. We know if two samples have the same category index,", "tokens": [51300, 639, 6798, 510, 11, 341, 307, 733, 295, 19350, 13, 492, 458, 498, 732, 10938, 362, 264, 912, 7719, 8186, 11, 51632], "temperature": 0.0, "avg_logprob": -0.11721477713636173, "compression_ratio": 1.8829787234042554, "no_speech_prob": 0.0005030151223763824}, {"id": 94, "seek": 63880, "start": 638.88, "end": 644.9599999999999, "text": " we can use that as the key. So I made an optimization here to remove this name lookup.", "tokens": [50368, 321, 393, 764, 300, 382, 264, 2141, 13, 407, 286, 1027, 364, 19618, 510, 281, 4159, 341, 1315, 574, 1010, 13, 50672], "temperature": 0.0, "avg_logprob": -0.1373507109555331, "compression_ratio": 1.5541125541125542, "no_speech_prob": 0.0010304787429049611}, {"id": 95, "seek": 63880, "start": 644.9599999999999, "end": 650.7199999999999, "text": " And now we're just accumulating category index weights in this map here. There needs to be", "tokens": [50672, 400, 586, 321, 434, 445, 12989, 12162, 7719, 8186, 17443, 294, 341, 4471, 510, 13, 821, 2203, 281, 312, 50960], "temperature": 0.0, "avg_logprob": -0.1373507109555331, "compression_ratio": 1.5541125541125542, "no_speech_prob": 0.0010304787429049611}, {"id": 96, "seek": 63880, "start": 650.7199999999999, "end": 657.76, "text": " some process, post-processing afterwards to make sure we get these names here in the category", "tokens": [50960, 512, 1399, 11, 2183, 12, 41075, 278, 10543, 281, 652, 988, 321, 483, 613, 5288, 510, 294, 264, 7719, 51312], "temperature": 0.0, "avg_logprob": -0.1373507109555331, "compression_ratio": 1.5541125541125542, "no_speech_prob": 0.0010304787429049611}, {"id": 97, "seek": 63880, "start": 657.76, "end": 665.4399999999999, "text": " breakdown again. But that's outside of our algorithm. All right. So here I had selected", "tokens": [51312, 18188, 797, 13, 583, 300, 311, 2380, 295, 527, 9284, 13, 1057, 558, 13, 407, 510, 286, 632, 8209, 51696], "temperature": 0.0, "avg_logprob": -0.1373507109555331, "compression_ratio": 1.5541125541125542, "no_speech_prob": 0.0010304787429049611}, {"id": 98, "seek": 66544, "start": 665.44, "end": 673.2, "text": " the small profile for the format version one. Let's switch to the same profile in format version two", "tokens": [50364, 264, 1359, 7964, 337, 264, 7877, 3037, 472, 13, 961, 311, 3679, 281, 264, 912, 7964, 294, 7877, 3037, 732, 50752], "temperature": 0.0, "avg_logprob": -0.10885288360271048, "compression_ratio": 1.6396396396396395, "no_speech_prob": 0.0013634515926241875}, {"id": 99, "seek": 66544, "start": 674.48, "end": 680.72, "text": " and do the selection again. And now we can see, we can select to the full width and it's still", "tokens": [50816, 293, 360, 264, 9450, 797, 13, 400, 586, 321, 393, 536, 11, 321, 393, 3048, 281, 264, 1577, 11402, 293, 309, 311, 920, 51128], "temperature": 0.0, "avg_logprob": -0.10885288360271048, "compression_ratio": 1.6396396396396395, "no_speech_prob": 0.0013634515926241875}, {"id": 100, "seek": 66544, "start": 680.72, "end": 688.8000000000001, "text": " very responsive. So here's our throughputs. So how fast is it now? 47.1 nanoseconds per", "tokens": [51128, 588, 21826, 13, 407, 510, 311, 527, 44629, 82, 13, 407, 577, 2370, 307, 309, 586, 30, 16953, 13, 16, 14067, 541, 28750, 680, 51532], "temperature": 0.0, "avg_logprob": -0.10885288360271048, "compression_ratio": 1.6396396396396395, "no_speech_prob": 0.0013634515926241875}, {"id": 101, "seek": 66544, "start": 688.8000000000001, "end": 693.0400000000001, "text": " sample for the category breakdown is what I measured, 51 for the heaviest stack.", "tokens": [51532, 6889, 337, 264, 7719, 18188, 307, 437, 286, 12690, 11, 18485, 337, 264, 3577, 6495, 8630, 13, 51744], "temperature": 0.0, "avg_logprob": -0.10885288360271048, "compression_ratio": 1.6396396396396395, "no_speech_prob": 0.0013634515926241875}, {"id": 102, "seek": 69304, "start": 693.52, "end": 701.92, "text": " Okay. So that's much better. Let's see how far we can go. We want to see if there's more we can do", "tokens": [50388, 1033, 13, 407, 300, 311, 709, 1101, 13, 961, 311, 536, 577, 1400, 321, 393, 352, 13, 492, 528, 281, 536, 498, 456, 311, 544, 321, 393, 360, 50808], "temperature": 0.0, "avg_logprob": -0.19584766301241788, "compression_ratio": 1.580110497237569, "no_speech_prob": 0.0015933741815388203}, {"id": 103, "seek": 69304, "start": 701.92, "end": 709.12, "text": " here. So we use a profiler. I am going to start the profiler. Oh, what I didn't show you is how to", "tokens": [50808, 510, 13, 407, 321, 764, 257, 1740, 5441, 13, 286, 669, 516, 281, 722, 264, 1740, 5441, 13, 876, 11, 437, 286, 994, 380, 855, 291, 307, 577, 281, 51168], "temperature": 0.0, "avg_logprob": -0.19584766301241788, "compression_ratio": 1.580110497237569, "no_speech_prob": 0.0015933741815388203}, {"id": 104, "seek": 69304, "start": 709.12, "end": 720.24, "text": " use the profiler. Well, let me do that really quick. So if you use Firefox and you go to", "tokens": [51168, 764, 264, 1740, 5441, 13, 1042, 11, 718, 385, 360, 300, 534, 1702, 13, 407, 498, 291, 764, 46613, 293, 291, 352, 281, 51724], "temperature": 0.0, "avg_logprob": -0.19584766301241788, "compression_ratio": 1.580110497237569, "no_speech_prob": 0.0015933741815388203}, {"id": 105, "seek": 72024, "start": 721.2, "end": 726.08, "text": " profiler.firefox.com, you can click this big button here, which gives you a toolbar button.", "tokens": [50412, 1740, 5441, 13, 12037, 38416, 13, 1112, 11, 291, 393, 2052, 341, 955, 2960, 510, 11, 597, 2709, 291, 257, 47715, 2960, 13, 50656], "temperature": 0.0, "avg_logprob": -0.14289531253633045, "compression_ratio": 1.5820895522388059, "no_speech_prob": 0.008828023448586464}, {"id": 106, "seek": 72024, "start": 726.96, "end": 733.44, "text": " And then if you click that toolbar button, it starts recording. So let's record our current", "tokens": [50700, 400, 550, 498, 291, 2052, 300, 47715, 2960, 11, 309, 3719, 6613, 13, 407, 718, 311, 2136, 527, 2190, 51024], "temperature": 0.0, "avg_logprob": -0.14289531253633045, "compression_ratio": 1.5820895522388059, "no_speech_prob": 0.008828023448586464}, {"id": 107, "seek": 72024, "start": 733.44, "end": 739.44, "text": " implementation. Do a little bit of this, capture a profile and see where the time is spent.", "tokens": [51024, 11420, 13, 1144, 257, 707, 857, 295, 341, 11, 7983, 257, 7964, 293, 536, 689, 264, 565, 307, 4418, 13, 51324], "temperature": 0.0, "avg_logprob": -0.14289531253633045, "compression_ratio": 1.5820895522388059, "no_speech_prob": 0.008828023448586464}, {"id": 108, "seek": 72024, "start": 742.08, "end": 743.44, "text": " Well, where is the time spent?", "tokens": [51456, 1042, 11, 689, 307, 264, 565, 4418, 30, 51524], "temperature": 0.0, "avg_logprob": -0.14289531253633045, "compression_ratio": 1.5820895522388059, "no_speech_prob": 0.008828023448586464}, {"id": 109, "seek": 72024, "start": 746.8, "end": 747.44, "text": " One second.", "tokens": [51692, 1485, 1150, 13, 51724], "temperature": 0.0, "avg_logprob": -0.14289531253633045, "compression_ratio": 1.5820895522388059, "no_speech_prob": 0.008828023448586464}, {"id": 110, "seek": 75024, "start": 750.24, "end": 755.84, "text": " Let's try that again.", "tokens": [50364, 961, 311, 853, 300, 797, 13, 50644], "temperature": 0.0, "avg_logprob": -0.577850341796875, "compression_ratio": 0.8703703703703703, "no_speech_prob": 0.003577546216547489}, {"id": 111, "seek": 75024, "start": 770.0, "end": 771.44, "text": " Let me refresh this page.", "tokens": [51352, 961, 385, 15134, 341, 3028, 13, 51424], "temperature": 0.0, "avg_logprob": -0.577850341796875, "compression_ratio": 0.8703703703703703, "no_speech_prob": 0.003577546216547489}, {"id": 112, "seek": 78024, "start": 781.12, "end": 791.52, "text": " Ah, I can tell you for this time spent. It is so fast that it barely shows up in the profiler", "tokens": [50408, 2438, 11, 286, 393, 980, 291, 337, 341, 565, 4418, 13, 467, 307, 370, 2370, 300, 309, 10268, 3110, 493, 294, 264, 1740, 5441, 50928], "temperature": 0.0, "avg_logprob": -0.1861686559823843, "compression_ratio": 1.4216867469879517, "no_speech_prob": 0.0020770649425685406}, {"id": 113, "seek": 78024, "start": 793.6, "end": 797.92, "text": " because we are still using the small profile size. So let's do that again.", "tokens": [51032, 570, 321, 366, 920, 1228, 264, 1359, 7964, 2744, 13, 407, 718, 311, 360, 300, 797, 13, 51248], "temperature": 0.0, "avg_logprob": -0.1861686559823843, "compression_ratio": 1.4216867469879517, "no_speech_prob": 0.0020770649425685406}, {"id": 114, "seek": 78024, "start": 799.6800000000001, "end": 805.92, "text": " Capture profile. The local host here, there's barely any CPU usage.", "tokens": [51336, 9480, 540, 7964, 13, 440, 2654, 3975, 510, 11, 456, 311, 10268, 604, 13199, 14924, 13, 51648], "temperature": 0.0, "avg_logprob": -0.1861686559823843, "compression_ratio": 1.4216867469879517, "no_speech_prob": 0.0020770649425685406}, {"id": 115, "seek": 80592, "start": 806.0, "end": 812.8, "text": " You would see more yellow in here. So let's switch to a bigger profile. We still have just the", "tokens": [50368, 509, 576, 536, 544, 5566, 294, 510, 13, 407, 718, 311, 3679, 281, 257, 3801, 7964, 13, 492, 920, 362, 445, 264, 50708], "temperature": 0.0, "avg_logprob": -0.16192113199541647, "compression_ratio": 1.6037735849056605, "no_speech_prob": 0.0013037505559623241}, {"id": 116, "seek": 80592, "start": 813.36, "end": 822.24, "text": " 1600 samples. Let's switch to the medium profile. So here, yeah, it still works okay.", "tokens": [50736, 36885, 10938, 13, 961, 311, 3679, 281, 264, 6399, 7964, 13, 407, 510, 11, 1338, 11, 309, 920, 1985, 1392, 13, 51180], "temperature": 0.0, "avg_logprob": -0.16192113199541647, "compression_ratio": 1.6037735849056605, "no_speech_prob": 0.0013037505559623241}, {"id": 117, "seek": 80592, "start": 823.04, "end": 828.88, "text": " It gets a little bit janky towards the edge here. So again, we're going to start the profiler,", "tokens": [51220, 467, 2170, 257, 707, 857, 361, 657, 88, 3030, 264, 4691, 510, 13, 407, 797, 11, 321, 434, 516, 281, 722, 264, 1740, 5441, 11, 51512], "temperature": 0.0, "avg_logprob": -0.16192113199541647, "compression_ratio": 1.6037735849056605, "no_speech_prob": 0.0013037505559623241}, {"id": 118, "seek": 80592, "start": 829.52, "end": 832.64, "text": " select, play around a little bit so that we get lots of samples.", "tokens": [51544, 3048, 11, 862, 926, 257, 707, 857, 370, 300, 321, 483, 3195, 295, 10938, 13, 51700], "temperature": 0.0, "avg_logprob": -0.16192113199541647, "compression_ratio": 1.6037735849056605, "no_speech_prob": 0.0013037505559623241}, {"id": 119, "seek": 83264, "start": 833.6, "end": 839.92, "text": " Capture the profile. And there we go. This is what I was expecting. So now we have lots of yellow", "tokens": [50412, 9480, 540, 264, 7964, 13, 400, 456, 321, 352, 13, 639, 307, 437, 286, 390, 9650, 13, 407, 586, 321, 362, 3195, 295, 5566, 50728], "temperature": 0.0, "avg_logprob": -0.1005320407376431, "compression_ratio": 1.7280701754385965, "no_speech_prob": 0.00843753945082426}, {"id": 120, "seek": 83264, "start": 839.92, "end": 845.36, "text": " in here. I'm going to show just this thread. I'm going to switch to JavaScript only. I'm going to", "tokens": [50728, 294, 510, 13, 286, 478, 516, 281, 855, 445, 341, 7207, 13, 286, 478, 516, 281, 3679, 281, 15778, 787, 13, 286, 478, 516, 281, 51000], "temperature": 0.0, "avg_logprob": -0.1005320407376431, "compression_ratio": 1.7280701754385965, "no_speech_prob": 0.00843753945082426}, {"id": 121, "seek": 83264, "start": 845.36, "end": 850.56, "text": " switch to the flame graph. And now what we can see here is we are spending time in compute category", "tokens": [51000, 3679, 281, 264, 13287, 4295, 13, 400, 586, 437, 321, 393, 536, 510, 307, 321, 366, 6434, 565, 294, 14722, 7719, 51260], "temperature": 0.0, "avg_logprob": -0.1005320407376431, "compression_ratio": 1.7280701754385965, "no_speech_prob": 0.00843753945082426}, {"id": 122, "seek": 83264, "start": 850.56, "end": 857.4399999999999, "text": " breakdown with string key map and compute heaviest stack with map. And what we see here is that we", "tokens": [51260, 18188, 365, 6798, 2141, 4471, 293, 14722, 3577, 6495, 8630, 365, 4471, 13, 400, 437, 321, 536, 510, 307, 300, 321, 51604], "temperature": 0.0, "avg_logprob": -0.1005320407376431, "compression_ratio": 1.7280701754385965, "no_speech_prob": 0.00843753945082426}, {"id": 123, "seek": 85744, "start": 857.44, "end": 863.0400000000001, "text": " are spending some time in map.prototype.set, both over here and over there. That makes sense. We're", "tokens": [50364, 366, 6434, 512, 565, 294, 4471, 13, 33629, 13108, 13, 3854, 11, 1293, 670, 510, 293, 670, 456, 13, 663, 1669, 2020, 13, 492, 434, 50644], "temperature": 0.0, "avg_logprob": -0.10213838442407473, "compression_ratio": 1.7345132743362832, "no_speech_prob": 0.001409360789693892}, {"id": 124, "seek": 85744, "start": 863.0400000000001, "end": 871.36, "text": " assigning things to a map. So can we not use a map? Wrong direction here. So we're seeing the time", "tokens": [50644, 49602, 721, 281, 257, 4471, 13, 407, 393, 321, 406, 764, 257, 4471, 30, 28150, 3513, 510, 13, 407, 321, 434, 2577, 264, 565, 51060], "temperature": 0.0, "avg_logprob": -0.10213838442407473, "compression_ratio": 1.7345132743362832, "no_speech_prob": 0.001409360789693892}, {"id": 125, "seek": 85744, "start": 871.36, "end": 877.9200000000001, "text": " in map prototype set. We have the map here. For the category breakdown computation, we're getting", "tokens": [51060, 294, 4471, 19475, 992, 13, 492, 362, 264, 4471, 510, 13, 1171, 264, 7719, 18188, 24903, 11, 321, 434, 1242, 51388], "temperature": 0.0, "avg_logprob": -0.10213838442407473, "compression_ratio": 1.7345132743362832, "no_speech_prob": 0.001409360789693892}, {"id": 126, "seek": 85744, "start": 877.9200000000001, "end": 883.0400000000001, "text": " the category index out and putting it back in. But we know these are integers. They're integers", "tokens": [51388, 264, 7719, 8186, 484, 293, 3372, 309, 646, 294, 13, 583, 321, 458, 613, 366, 41674, 13, 814, 434, 41674, 51644], "temperature": 0.0, "avg_logprob": -0.10213838442407473, "compression_ratio": 1.7345132743362832, "no_speech_prob": 0.001409360789693892}, {"id": 127, "seek": 88304, "start": 883.04, "end": 887.52, "text": " into the category list. The category list doesn't have lots of elements. We can just use an array", "tokens": [50364, 666, 264, 7719, 1329, 13, 440, 7719, 1329, 1177, 380, 362, 3195, 295, 4959, 13, 492, 393, 445, 764, 364, 10225, 50588], "temperature": 0.0, "avg_logprob": -0.07527985060510557, "compression_ratio": 1.7640449438202248, "no_speech_prob": 0.02707875706255436}, {"id": 128, "seek": 88304, "start": 887.52, "end": 893.04, "text": " here instead. I'm going to use a float 64 array here. Because the weights are floats,", "tokens": [50588, 510, 2602, 13, 286, 478, 516, 281, 764, 257, 15706, 12145, 10225, 510, 13, 1436, 264, 17443, 366, 37878, 11, 50864], "temperature": 0.0, "avg_logprob": -0.07527985060510557, "compression_ratio": 1.7640449438202248, "no_speech_prob": 0.02707875706255436}, {"id": 129, "seek": 88304, "start": 894.48, "end": 899.76, "text": " using a typed array means I know that the maximum number of elements is already preallocated. It's", "tokens": [50936, 1228, 257, 33941, 10225, 1355, 286, 458, 300, 264, 6674, 1230, 295, 4959, 307, 1217, 659, 336, 905, 770, 13, 467, 311, 51200], "temperature": 0.0, "avg_logprob": -0.07527985060510557, "compression_ratio": 1.7640449438202248, "no_speech_prob": 0.02707875706255436}, {"id": 130, "seek": 88304, "start": 899.76, "end": 904.7199999999999, "text": " initialized to zero. I don't need to check if there's something in it already. I know that it", "tokens": [51200, 5883, 1602, 281, 4018, 13, 286, 500, 380, 643, 281, 1520, 498, 456, 311, 746, 294, 309, 1217, 13, 286, 458, 300, 309, 51448], "temperature": 0.0, "avg_logprob": -0.07527985060510557, "compression_ratio": 1.7640449438202248, "no_speech_prob": 0.02707875706255436}, {"id": 131, "seek": 88304, "start": 904.7199999999999, "end": 912.24, "text": " starts with zero. I can just add the weight. And that's it. We can do the same modification to", "tokens": [51448, 3719, 365, 4018, 13, 286, 393, 445, 909, 264, 3364, 13, 400, 300, 311, 309, 13, 492, 393, 360, 264, 912, 26747, 281, 51824], "temperature": 0.0, "avg_logprob": -0.07527985060510557, "compression_ratio": 1.7640449438202248, "no_speech_prob": 0.02707875706255436}, {"id": 132, "seek": 91224, "start": 912.24, "end": 918.32, "text": " getting the heavier stack, the seriously compute heavy stack algorithm. It was also using a map.", "tokens": [50364, 1242, 264, 18279, 8630, 11, 264, 6638, 14722, 4676, 8630, 9284, 13, 467, 390, 611, 1228, 257, 4471, 13, 50668], "temperature": 0.0, "avg_logprob": -0.13893540700276694, "compression_ratio": 1.6872246696035242, "no_speech_prob": 0.0025082428473979235}, {"id": 133, "seek": 91224, "start": 919.04, "end": 923.44, "text": " We can use a float 64 array because we know how many stacks there are. Here the key is the", "tokens": [50704, 492, 393, 764, 257, 15706, 12145, 10225, 570, 321, 458, 577, 867, 30792, 456, 366, 13, 1692, 264, 2141, 307, 264, 50924], "temperature": 0.0, "avg_logprob": -0.13893540700276694, "compression_ratio": 1.6872246696035242, "no_speech_prob": 0.0025082428473979235}, {"id": 134, "seek": 91224, "start": 924.0, "end": 931.92, "text": " index into the stacks array. We use that key as our index into the map array. And then it should", "tokens": [50952, 8186, 666, 264, 30792, 10225, 13, 492, 764, 300, 2141, 382, 527, 8186, 666, 264, 4471, 10225, 13, 400, 550, 309, 820, 51348], "temperature": 0.0, "avg_logprob": -0.13893540700276694, "compression_ratio": 1.6872246696035242, "no_speech_prob": 0.0025082428473979235}, {"id": 135, "seek": 91224, "start": 931.92, "end": 937.44, "text": " work as before. And what we see down here, it is three times faster to skip the map to use a typed", "tokens": [51348, 589, 382, 949, 13, 400, 437, 321, 536, 760, 510, 11, 309, 307, 1045, 1413, 4663, 281, 10023, 264, 4471, 281, 764, 257, 33941, 51624], "temperature": 0.0, "avg_logprob": -0.13893540700276694, "compression_ratio": 1.6872246696035242, "no_speech_prob": 0.0025082428473979235}, {"id": 136, "seek": 93744, "start": 937.5200000000001, "end": 943.7600000000001, "text": " array instead. Let's try that out. Here I'm going to switch from the basic implementation to the", "tokens": [50368, 10225, 2602, 13, 961, 311, 853, 300, 484, 13, 1692, 286, 478, 516, 281, 3679, 490, 264, 3875, 11420, 281, 264, 50680], "temperature": 0.0, "avg_logprob": -0.15367023150126138, "compression_ratio": 1.641350210970464, "no_speech_prob": 0.0025079732295125723}, {"id": 137, "seek": 93744, "start": 943.7600000000001, "end": 951.2800000000001, "text": " integer keys for category breakdown. No, sorry, to the typed arrays instead of maps implementation.", "tokens": [50680, 24922, 9317, 337, 7719, 18188, 13, 883, 11, 2597, 11, 281, 264, 33941, 41011, 2602, 295, 11317, 11420, 13, 51056], "temperature": 0.0, "avg_logprob": -0.15367023150126138, "compression_ratio": 1.641350210970464, "no_speech_prob": 0.0025079732295125723}, {"id": 138, "seek": 93744, "start": 951.84, "end": 959.6, "text": " And now I'm going to select, and it's very smooth through the entire profile. And we have 500,000", "tokens": [51084, 400, 586, 286, 478, 516, 281, 3048, 11, 293, 309, 311, 588, 5508, 807, 264, 2302, 7964, 13, 400, 321, 362, 5923, 11, 1360, 51472], "temperature": 0.0, "avg_logprob": -0.15367023150126138, "compression_ratio": 1.641350210970464, "no_speech_prob": 0.0025079732295125723}, {"id": 139, "seek": 93744, "start": 959.6, "end": 966.08, "text": " samples now here. And we are still responsive. And let's see if we get an even bigger profile.", "tokens": [51472, 10938, 586, 510, 13, 400, 321, 366, 920, 21826, 13, 400, 718, 311, 536, 498, 321, 483, 364, 754, 3801, 7964, 13, 51796], "temperature": 0.0, "avg_logprob": -0.15367023150126138, "compression_ratio": 1.641350210970464, "no_speech_prob": 0.0025079732295125723}, {"id": 140, "seek": 96608, "start": 966.08, "end": 972.64, "text": " This one here has two million samples. How responsive are we? It's okay. It gets a little", "tokens": [50364, 639, 472, 510, 575, 732, 2459, 10938, 13, 1012, 21826, 366, 321, 30, 467, 311, 1392, 13, 467, 2170, 257, 707, 50692], "temperature": 0.0, "avg_logprob": -0.13769362144863484, "compression_ratio": 1.5833333333333333, "no_speech_prob": 0.0005187895731069148}, {"id": 141, "seek": 96608, "start": 972.64, "end": 982.5600000000001, "text": " janky towards the end here. It's mostly okay. So where are we now? Let's just take some,", "tokens": [50692, 361, 657, 88, 3030, 264, 917, 510, 13, 467, 311, 5240, 1392, 13, 407, 689, 366, 321, 586, 30, 961, 311, 445, 747, 512, 11, 51188], "temperature": 0.0, "avg_logprob": -0.13769362144863484, "compression_ratio": 1.5833333333333333, "no_speech_prob": 0.0005187895731069148}, {"id": 142, "seek": 96608, "start": 983.6800000000001, "end": 988.1600000000001, "text": " take some recap. We've addressed the obvious load ons. We've done what the profile told us.", "tokens": [51244, 747, 512, 20928, 13, 492, 600, 13847, 264, 6322, 3677, 18818, 13, 492, 600, 1096, 437, 264, 7964, 1907, 505, 13, 51468], "temperature": 0.0, "avg_logprob": -0.13769362144863484, "compression_ratio": 1.5833333333333333, "no_speech_prob": 0.0005187895731069148}, {"id": 143, "seek": 96608, "start": 988.1600000000001, "end": 993.6800000000001, "text": " We fixed the hotspots. We changed the format so that comparing stacks is cheap, we changed", "tokens": [51468, 492, 6806, 264, 36121, 79, 1971, 13, 492, 3105, 264, 7877, 370, 300, 15763, 30792, 307, 7084, 11, 321, 3105, 51744], "temperature": 0.0, "avg_logprob": -0.13769362144863484, "compression_ratio": 1.5833333333333333, "no_speech_prob": 0.0005187895731069148}, {"id": 144, "seek": 99368, "start": 993.68, "end": 999.92, "text": " two maps into typed arrays. Got us a 3x perf boost. In the heaviest stack case,", "tokens": [50364, 732, 11317, 666, 33941, 41011, 13, 5803, 505, 257, 805, 87, 13826, 9194, 13, 682, 264, 3577, 6495, 8630, 1389, 11, 50676], "temperature": 0.0, "avg_logprob": -0.12335938992707626, "compression_ratio": 1.6367713004484306, "no_speech_prob": 0.0007536351913586259}, {"id": 145, "seek": 99368, "start": 1001.3599999999999, "end": 1007.8399999999999, "text": " the map or the amount of memory we're using might be a bit bigger now because we're allocating an", "tokens": [50748, 264, 4471, 420, 264, 2372, 295, 4675, 321, 434, 1228, 1062, 312, 257, 857, 3801, 586, 570, 321, 434, 12660, 990, 364, 51072], "temperature": 0.0, "avg_logprob": -0.12335938992707626, "compression_ratio": 1.6367713004484306, "no_speech_prob": 0.0007536351913586259}, {"id": 146, "seek": 99368, "start": 1007.8399999999999, "end": 1013.1999999999999, "text": " array where we have an element for every single stack index, even if no sample references that", "tokens": [51072, 10225, 689, 321, 362, 364, 4478, 337, 633, 2167, 8630, 8186, 11, 754, 498, 572, 6889, 15400, 300, 51340], "temperature": 0.0, "avg_logprob": -0.12335938992707626, "compression_ratio": 1.6367713004484306, "no_speech_prob": 0.0007536351913586259}, {"id": 147, "seek": 99368, "start": 1013.1999999999999, "end": 1021.52, "text": " stack index. So maybe some extra memory, but we have a performance boost. And so we have the", "tokens": [51340, 8630, 8186, 13, 407, 1310, 512, 2857, 4675, 11, 457, 321, 362, 257, 3389, 9194, 13, 400, 370, 321, 362, 264, 51756], "temperature": 0.0, "avg_logprob": -0.12335938992707626, "compression_ratio": 1.6367713004484306, "no_speech_prob": 0.0007536351913586259}, {"id": 148, "seek": 102152, "start": 1021.6, "end": 1030.24, "text": " throughput here. Yeah. So for the medium profile, our throughput is like 16 nanoseconds. Or", "tokens": [50368, 44629, 510, 13, 865, 13, 407, 337, 264, 6399, 7964, 11, 527, 44629, 307, 411, 3165, 14067, 541, 28750, 13, 1610, 50800], "temperature": 0.0, "avg_logprob": -0.12609897273601872, "compression_ratio": 1.6455696202531647, "no_speech_prob": 0.0013649885077029467}, {"id": 149, "seek": 102152, "start": 1030.96, "end": 1036.48, "text": " let's see, sometimes it goes up and down a little bit. Yeah, let's say 16 nanoseconds for the category", "tokens": [50836, 718, 311, 536, 11, 2171, 309, 1709, 493, 293, 760, 257, 707, 857, 13, 865, 11, 718, 311, 584, 3165, 14067, 541, 28750, 337, 264, 7719, 51112], "temperature": 0.0, "avg_logprob": -0.12609897273601872, "compression_ratio": 1.6455696202531647, "no_speech_prob": 0.0013649885077029467}, {"id": 150, "seek": 102152, "start": 1036.48, "end": 1041.44, "text": " break down, 40 nanoseconds for the heaviest stack. I was seeing some other numbers when I was trying", "tokens": [51112, 1821, 760, 11, 3356, 14067, 541, 28750, 337, 264, 3577, 6495, 8630, 13, 286, 390, 2577, 512, 661, 3547, 562, 286, 390, 1382, 51360], "temperature": 0.0, "avg_logprob": -0.12609897273601872, "compression_ratio": 1.6455696202531647, "no_speech_prob": 0.0013649885077029467}, {"id": 151, "seek": 102152, "start": 1041.44, "end": 1048.8, "text": " this at home. So it's pretty impressive. Modern computers are pretty fast, but maybe we can do", "tokens": [51360, 341, 412, 1280, 13, 407, 309, 311, 1238, 8992, 13, 19814, 10807, 366, 1238, 2370, 11, 457, 1310, 321, 393, 360, 51728], "temperature": 0.0, "avg_logprob": -0.12609897273601872, "compression_ratio": 1.6455696202531647, "no_speech_prob": 0.0013649885077029467}, {"id": 152, "seek": 104880, "start": 1048.8, "end": 1057.68, "text": " even better. So let's try better. Let's go back to the category breakdown algorithm. We are taking", "tokens": [50364, 754, 1101, 13, 407, 718, 311, 853, 1101, 13, 961, 311, 352, 646, 281, 264, 7719, 18188, 9284, 13, 492, 366, 1940, 50808], "temperature": 0.0, "avg_logprob": -0.0666044737163343, "compression_ratio": 1.6495726495726495, "no_speech_prob": 0.0004042995860800147}, {"id": 153, "seek": 104880, "start": 1057.68, "end": 1063.2, "text": " these two values out of every sample. The sample is an object. It has three properties. We're", "tokens": [50808, 613, 732, 4190, 484, 295, 633, 6889, 13, 440, 6889, 307, 364, 2657, 13, 467, 575, 1045, 7221, 13, 492, 434, 51084], "temperature": 0.0, "avg_logprob": -0.0666044737163343, "compression_ratio": 1.6495726495726495, "no_speech_prob": 0.0004042995860800147}, {"id": 154, "seek": 104880, "start": 1063.2, "end": 1067.76, "text": " ignoring the time property. We're getting these two properties out. So what does that mean at a byte", "tokens": [51084, 26258, 264, 565, 4707, 13, 492, 434, 1242, 613, 732, 7221, 484, 13, 407, 437, 775, 300, 914, 412, 257, 40846, 51312], "temperature": 0.0, "avg_logprob": -0.0666044737163343, "compression_ratio": 1.6495726495726495, "no_speech_prob": 0.0004042995860800147}, {"id": 155, "seek": 104880, "start": 1067.76, "end": 1077.2, "text": " level? So how are arrays of objects stored in memory? Well, it depends a little bit on which", "tokens": [51312, 1496, 30, 407, 577, 366, 41011, 295, 6565, 12187, 294, 4675, 30, 1042, 11, 309, 5946, 257, 707, 857, 322, 597, 51784], "temperature": 0.0, "avg_logprob": -0.0666044737163343, "compression_ratio": 1.6495726495726495, "no_speech_prob": 0.0004042995860800147}, {"id": 156, "seek": 107720, "start": 1077.2, "end": 1083.68, "text": " JS engine you're using, how you're allocating the object, if you happen to be on a fast path or not.", "tokens": [50364, 33063, 2848, 291, 434, 1228, 11, 577, 291, 434, 12660, 990, 264, 2657, 11, 498, 291, 1051, 281, 312, 322, 257, 2370, 3100, 420, 406, 13, 50688], "temperature": 0.0, "avg_logprob": -0.12185553969623887, "compression_ratio": 1.5870445344129556, "no_speech_prob": 0.0011143824085593224}, {"id": 157, "seek": 107720, "start": 1084.32, "end": 1090.88, "text": " But in SpiderMonkey, this is what you might expect. So we have a samples array, which is backed just", "tokens": [50720, 583, 294, 17733, 32498, 4119, 11, 341, 307, 437, 291, 1062, 2066, 13, 407, 321, 362, 257, 10938, 10225, 11, 597, 307, 20391, 445, 51048], "temperature": 0.0, "avg_logprob": -0.12185553969623887, "compression_ratio": 1.5870445344129556, "no_speech_prob": 0.0011143824085593224}, {"id": 158, "seek": 107720, "start": 1090.88, "end": 1098.32, "text": " by a list of pointers. Every pointer takes up 8 bytes on a 64-bit system, and it points to a JS", "tokens": [51048, 538, 257, 1329, 295, 44548, 13, 2048, 23918, 2516, 493, 1649, 36088, 322, 257, 12145, 12, 5260, 1185, 11, 293, 309, 2793, 281, 257, 33063, 51420], "temperature": 0.0, "avg_logprob": -0.12185553969623887, "compression_ratio": 1.5870445344129556, "no_speech_prob": 0.0011143824085593224}, {"id": 159, "seek": 107720, "start": 1098.32, "end": 1104.64, "text": " object. So let's say here, the first entry in our samples array points to this JS object here.", "tokens": [51420, 2657, 13, 407, 718, 311, 584, 510, 11, 264, 700, 8729, 294, 527, 10938, 10225, 2793, 281, 341, 33063, 2657, 510, 13, 51736], "temperature": 0.0, "avg_logprob": -0.12185553969623887, "compression_ratio": 1.5870445344129556, "no_speech_prob": 0.0011143824085593224}, {"id": 160, "seek": 110464, "start": 1105.2800000000002, "end": 1111.68, "text": " The JS object starts with a header. SpiderMonkey takes up 24 bytes on a 64-bit machine.", "tokens": [50396, 440, 33063, 2657, 3719, 365, 257, 23117, 13, 17733, 32498, 4119, 2516, 493, 4022, 36088, 322, 257, 12145, 12, 5260, 3479, 13, 50716], "temperature": 0.0, "avg_logprob": -0.1167227301267114, "compression_ratio": 1.597457627118644, "no_speech_prob": 0.0009527923539280891}, {"id": 161, "seek": 110464, "start": 1112.4, "end": 1118.24, "text": " Then if we're lucky, we have the fields inline just after the header. We might not be lucky,", "tokens": [50752, 1396, 498, 321, 434, 6356, 11, 321, 362, 264, 7909, 294, 1889, 445, 934, 264, 23117, 13, 492, 1062, 406, 312, 6356, 11, 51044], "temperature": 0.0, "avg_logprob": -0.1167227301267114, "compression_ratio": 1.597457627118644, "no_speech_prob": 0.0009527923539280891}, {"id": 162, "seek": 110464, "start": 1118.24, "end": 1123.1200000000001, "text": " but let's say we're lucky. We might also have a bit of padding here at the end, because the inline", "tokens": [51044, 457, 718, 311, 584, 321, 434, 6356, 13, 492, 1062, 611, 362, 257, 857, 295, 39562, 510, 412, 264, 917, 11, 570, 264, 294, 1889, 51288], "temperature": 0.0, "avg_logprob": -0.1167227301267114, "compression_ratio": 1.597457627118644, "no_speech_prob": 0.0009527923539280891}, {"id": 163, "seek": 110464, "start": 1123.68, "end": 1128.5600000000002, "text": " slots might be only sized to four or eight, and we're using three properties here, so there might", "tokens": [51316, 24266, 1062, 312, 787, 20004, 281, 1451, 420, 3180, 11, 293, 321, 434, 1228, 1045, 7221, 510, 11, 370, 456, 1062, 51560], "temperature": 0.0, "avg_logprob": -0.1167227301267114, "compression_ratio": 1.597457627118644, "no_speech_prob": 0.0009527923539280891}, {"id": 164, "seek": 112856, "start": 1128.56, "end": 1135.12, "text": " be a bit of extra memory used up by that. So this is just one representation that we could have.", "tokens": [50364, 312, 257, 857, 295, 2857, 4675, 1143, 493, 538, 300, 13, 407, 341, 307, 445, 472, 10290, 300, 321, 727, 362, 13, 50692], "temperature": 0.0, "avg_logprob": -0.07948961170441514, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.0012828005710616708}, {"id": 165, "seek": 112856, "start": 1135.12, "end": 1140.8, "text": " It varies a lot by engine. For example, Chrome has pointer compression, so these things here might", "tokens": [50692, 467, 21716, 257, 688, 538, 2848, 13, 1171, 1365, 11, 15327, 575, 23918, 19355, 11, 370, 613, 721, 510, 1062, 50976], "temperature": 0.0, "avg_logprob": -0.07948961170441514, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.0012828005710616708}, {"id": 166, "seek": 112856, "start": 1140.8, "end": 1146.56, "text": " be four bytes each, but then the time field might be an extra pointer, because in Chrome,", "tokens": [50976, 312, 1451, 36088, 1184, 11, 457, 550, 264, 565, 2519, 1062, 312, 364, 2857, 23918, 11, 570, 294, 15327, 11, 51264], "temperature": 0.0, "avg_logprob": -0.07948961170441514, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.0012828005710616708}, {"id": 167, "seek": 112856, "start": 1146.56, "end": 1152.56, "text": " sometimes the floating point values are a separate heap allocation. The padding could vary, the", "tokens": [51264, 2171, 264, 12607, 935, 4190, 366, 257, 4994, 33591, 27599, 13, 440, 39562, 727, 10559, 11, 264, 51564], "temperature": 0.0, "avg_logprob": -0.07948961170441514, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.0012828005710616708}, {"id": 168, "seek": 112856, "start": 1152.56, "end": 1157.12, "text": " object header size could vary. These fields here could be behind another pointer if they're stored", "tokens": [51564, 2657, 23117, 2744, 727, 10559, 13, 1981, 7909, 510, 727, 312, 2261, 1071, 23918, 498, 436, 434, 12187, 51792], "temperature": 0.0, "avg_logprob": -0.07948961170441514, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.0012828005710616708}, {"id": 169, "seek": 115712, "start": 1157.12, "end": 1163.28, "text": " out of line, and so on. But anyway, what it comes down to is we wanted to get these two fields here,", "tokens": [50364, 484, 295, 1622, 11, 293, 370, 322, 13, 583, 4033, 11, 437, 309, 1487, 760, 281, 307, 321, 1415, 281, 483, 613, 732, 7909, 510, 11, 50672], "temperature": 0.0, "avg_logprob": -0.102447509765625, "compression_ratio": 1.4816753926701571, "no_speech_prob": 0.001063901698216796}, {"id": 170, "seek": 115712, "start": 1164.7199999999998, "end": 1171.52, "text": " 16 bytes in total, but what we ended up with is all of these other not-so-useful bytes", "tokens": [50744, 3165, 36088, 294, 3217, 11, 457, 437, 321, 4590, 493, 365, 307, 439, 295, 613, 661, 406, 12, 539, 12, 438, 906, 36088, 51084], "temperature": 0.0, "avg_logprob": -0.102447509765625, "compression_ratio": 1.4816753926701571, "no_speech_prob": 0.001063901698216796}, {"id": 171, "seek": 115712, "start": 1172.32, "end": 1178.6399999999999, "text": " clogging up our cache. So when the CPU wants to get those bytes, it gets them in 64-bit chunks.", "tokens": [51124, 34455, 3249, 493, 527, 19459, 13, 407, 562, 264, 13199, 2738, 281, 483, 729, 36088, 11, 309, 2170, 552, 294, 12145, 12, 5260, 24004, 13, 51440], "temperature": 0.0, "avg_logprob": -0.102447509765625, "compression_ratio": 1.4816753926701571, "no_speech_prob": 0.001063901698216796}, {"id": 172, "seek": 117864, "start": 1178.72, "end": 1189.8400000000001, "text": " Cache line is 64 bytes. So if you're getting this value here, you're getting the other bytes that", "tokens": [50368, 383, 6000, 1622, 307, 12145, 36088, 13, 407, 498, 291, 434, 1242, 341, 2158, 510, 11, 291, 434, 1242, 264, 661, 36088, 300, 50924], "temperature": 0.0, "avg_logprob": -0.11965319189694848, "compression_ratio": 1.658008658008658, "no_speech_prob": 0.005128803662955761}, {"id": 173, "seek": 117864, "start": 1189.8400000000001, "end": 1194.48, "text": " are in the vicinity, even if you don't need them. Well, here we do need the JS object header,", "tokens": [50924, 366, 294, 264, 42387, 11, 754, 498, 291, 500, 380, 643, 552, 13, 1042, 11, 510, 321, 360, 643, 264, 33063, 2657, 23117, 11, 51156], "temperature": 0.0, "avg_logprob": -0.11965319189694848, "compression_ratio": 1.658008658008658, "no_speech_prob": 0.005128803662955761}, {"id": 174, "seek": 117864, "start": 1194.48, "end": 1199.3600000000001, "text": " because the JIT needs to check that the object is of the right shape, and so on. But we really just", "tokens": [51156, 570, 264, 508, 3927, 2203, 281, 1520, 300, 264, 2657, 307, 295, 264, 558, 3909, 11, 293, 370, 322, 13, 583, 321, 534, 445, 51400], "temperature": 0.0, "avg_logprob": -0.11965319189694848, "compression_ratio": 1.658008658008658, "no_speech_prob": 0.005128803662955761}, {"id": 175, "seek": 117864, "start": 1199.3600000000001, "end": 1207.44, "text": " want those values here. So can we do anything about that? We want to improve our cache line", "tokens": [51400, 528, 729, 4190, 510, 13, 407, 393, 321, 360, 1340, 466, 300, 30, 492, 528, 281, 3470, 527, 19459, 1622, 51804], "temperature": 0.0, "avg_logprob": -0.11965319189694848, "compression_ratio": 1.658008658008658, "no_speech_prob": 0.005128803662955761}, {"id": 176, "seek": 120744, "start": 1207.44, "end": 1214.56, "text": " utilization, and we want to reduce the indirection. Maybe we can. Let's do something radical.", "tokens": [50364, 37074, 11, 293, 321, 528, 281, 5407, 264, 1016, 621, 882, 13, 2704, 321, 393, 13, 961, 311, 360, 746, 12001, 13, 50720], "temperature": 0.0, "avg_logprob": -0.09564413922898313, "compression_ratio": 1.7403846153846154, "no_speech_prob": 0.0018090337980538607}, {"id": 177, "seek": 120744, "start": 1215.3600000000001, "end": 1222.56, "text": " Let's turn everything on the side. So we have this array of objects. What we could do instead", "tokens": [50760, 961, 311, 1261, 1203, 322, 264, 1252, 13, 407, 321, 362, 341, 10225, 295, 6565, 13, 708, 321, 727, 360, 2602, 51120], "temperature": 0.0, "avg_logprob": -0.09564413922898313, "compression_ratio": 1.7403846153846154, "no_speech_prob": 0.0018090337980538607}, {"id": 178, "seek": 120744, "start": 1222.56, "end": 1227.76, "text": " is to have an object of arrays, or struct of arrays, where we have a column,", "tokens": [51120, 307, 281, 362, 364, 2657, 295, 41011, 11, 420, 6594, 295, 41011, 11, 689, 321, 362, 257, 7738, 11, 51380], "temperature": 0.0, "avg_logprob": -0.09564413922898313, "compression_ratio": 1.7403846153846154, "no_speech_prob": 0.0018090337980538607}, {"id": 179, "seek": 120744, "start": 1228.88, "end": 1235.28, "text": " or where we have just one key for the time column with a big array that has just the time values,", "tokens": [51436, 420, 689, 321, 362, 445, 472, 2141, 337, 264, 565, 7738, 365, 257, 955, 10225, 300, 575, 445, 264, 565, 4190, 11, 51756], "temperature": 0.0, "avg_logprob": -0.09564413922898313, "compression_ratio": 1.7403846153846154, "no_speech_prob": 0.0018090337980538607}, {"id": 180, "seek": 123528, "start": 1235.28, "end": 1239.92, "text": " one for the stack index, just the stack index values, the weight, just the weight values,", "tokens": [50364, 472, 337, 264, 8630, 8186, 11, 445, 264, 8630, 8186, 4190, 11, 264, 3364, 11, 445, 264, 3364, 4190, 11, 50596], "temperature": 0.0, "avg_logprob": -0.12220269390660474, "compression_ratio": 1.751004016064257, "no_speech_prob": 0.0002491757331881672}, {"id": 181, "seek": 123528, "start": 1240.48, "end": 1244.3999999999999, "text": " and a length stored on the side. These arrays must all have the same length.", "tokens": [50624, 293, 257, 4641, 12187, 322, 264, 1252, 13, 1981, 41011, 1633, 439, 362, 264, 912, 4641, 13, 50820], "temperature": 0.0, "avg_logprob": -0.12220269390660474, "compression_ratio": 1.751004016064257, "no_speech_prob": 0.0002491757331881672}, {"id": 182, "seek": 123528, "start": 1246.8799999999999, "end": 1252.72, "text": " So now everything's backwards. If we want to access the weight in the past, we had samples i.weight.", "tokens": [50944, 407, 586, 1203, 311, 12204, 13, 759, 321, 528, 281, 2105, 264, 3364, 294, 264, 1791, 11, 321, 632, 10938, 741, 13, 12329, 13, 51236], "temperature": 0.0, "avg_logprob": -0.12220269390660474, "compression_ratio": 1.751004016064257, "no_speech_prob": 0.0002491757331881672}, {"id": 183, "seek": 123528, "start": 1252.72, "end": 1256.0, "text": " Now it looks a bit weird, because we have the sample table.weight column,", "tokens": [51236, 823, 309, 1542, 257, 857, 3657, 11, 570, 321, 362, 264, 6889, 3199, 13, 12329, 7738, 11, 51400], "temperature": 0.0, "avg_logprob": -0.12220269390660474, "compression_ratio": 1.751004016064257, "no_speech_prob": 0.0002491757331881672}, {"id": 184, "seek": 123528, "start": 1256.56, "end": 1263.52, "text": " and then we get the ith element of that. But let's do it. Let's see where it goes. And so what", "tokens": [51428, 293, 550, 321, 483, 264, 309, 71, 4478, 295, 300, 13, 583, 718, 311, 360, 309, 13, 961, 311, 536, 689, 309, 1709, 13, 400, 370, 437, 51776], "temperature": 0.0, "avg_logprob": -0.12220269390660474, "compression_ratio": 1.751004016064257, "no_speech_prob": 0.0002491757331881672}, {"id": 185, "seek": 126352, "start": 1263.6, "end": 1268.72, "text": " we end up with here is a new profile format again. Now we have a sample table, a stack table, a frame", "tokens": [50368, 321, 917, 493, 365, 510, 307, 257, 777, 7964, 7877, 797, 13, 823, 321, 362, 257, 6889, 3199, 11, 257, 8630, 3199, 11, 257, 3920, 50624], "temperature": 0.0, "avg_logprob": -0.07657818567185175, "compression_ratio": 1.7317073170731707, "no_speech_prob": 0.00024529750226065516}, {"id": 186, "seek": 126352, "start": 1268.72, "end": 1275.84, "text": " table. The calories are still a list, because it's just some strings. And same thing as before,", "tokens": [50624, 3199, 13, 440, 14904, 366, 920, 257, 1329, 11, 570, 309, 311, 445, 512, 13985, 13, 400, 912, 551, 382, 949, 11, 50980], "temperature": 0.0, "avg_logprob": -0.07657818567185175, "compression_ratio": 1.7317073170731707, "no_speech_prob": 0.00024529750226065516}, {"id": 187, "seek": 126352, "start": 1275.84, "end": 1279.36, "text": " the stack index goes into the stack table, the frame index goes into the frame table.", "tokens": [50980, 264, 8630, 8186, 1709, 666, 264, 8630, 3199, 11, 264, 3920, 8186, 1709, 666, 264, 3920, 3199, 13, 51156], "temperature": 0.0, "avg_logprob": -0.07657818567185175, "compression_ratio": 1.7317073170731707, "no_speech_prob": 0.00024529750226065516}, {"id": 188, "seek": 126352, "start": 1279.92, "end": 1282.32, "text": " We just need to access the properties differently.", "tokens": [51184, 492, 445, 643, 281, 2105, 264, 7221, 7614, 13, 51304], "temperature": 0.0, "avg_logprob": -0.07657818567185175, "compression_ratio": 1.7317073170731707, "no_speech_prob": 0.00024529750226065516}, {"id": 189, "seek": 126352, "start": 1284.8799999999999, "end": 1290.96, "text": " So what does it do for the computation of the heavier stack? Here we were getting the stack", "tokens": [51432, 407, 437, 775, 309, 360, 337, 264, 24903, 295, 264, 18279, 8630, 30, 1692, 321, 645, 1242, 264, 8630, 51736], "temperature": 0.0, "avg_logprob": -0.07657818567185175, "compression_ratio": 1.7317073170731707, "no_speech_prob": 0.00024529750226065516}, {"id": 190, "seek": 129096, "start": 1290.96, "end": 1294.8, "text": " index and the weight property from an object. Now we just get them from separate columns.", "tokens": [50364, 8186, 293, 264, 3364, 4707, 490, 364, 2657, 13, 823, 321, 445, 483, 552, 490, 4994, 13766, 13, 50556], "temperature": 0.0, "avg_logprob": -0.090169947321822, "compression_ratio": 1.518181818181818, "no_speech_prob": 0.00060656649293378}, {"id": 191, "seek": 129096, "start": 1295.68, "end": 1299.52, "text": " And already we're seeing a 2x performance improvement.", "tokens": [50600, 400, 1217, 321, 434, 2577, 257, 568, 87, 3389, 10444, 13, 50792], "temperature": 0.0, "avg_logprob": -0.090169947321822, "compression_ratio": 1.518181818181818, "no_speech_prob": 0.00060656649293378}, {"id": 192, "seek": 129096, "start": 1301.3600000000001, "end": 1305.44, "text": " For the category breakdown, similar story. Instead of getting the properties from objects,", "tokens": [50884, 1171, 264, 7719, 18188, 11, 2531, 1657, 13, 7156, 295, 1242, 264, 7221, 490, 6565, 11, 51088], "temperature": 0.0, "avg_logprob": -0.090169947321822, "compression_ratio": 1.518181818181818, "no_speech_prob": 0.00060656649293378}, {"id": 193, "seek": 129096, "start": 1306.0, "end": 1313.44, "text": " we get the column first, access the ith element, and get that. This here is even faster, like 3.5x", "tokens": [51116, 321, 483, 264, 7738, 700, 11, 2105, 264, 309, 71, 4478, 11, 293, 483, 300, 13, 639, 510, 307, 754, 4663, 11, 411, 805, 13, 20, 87, 51488], "temperature": 0.0, "avg_logprob": -0.090169947321822, "compression_ratio": 1.518181818181818, "no_speech_prob": 0.00060656649293378}, {"id": 194, "seek": 131344, "start": 1313.44, "end": 1321.3600000000001, "text": " faster. Let's see that in practice. So we're switching to format v3 now, struct of arrays.", "tokens": [50364, 4663, 13, 961, 311, 536, 300, 294, 3124, 13, 407, 321, 434, 16493, 281, 7877, 371, 18, 586, 11, 6594, 295, 41011, 13, 50760], "temperature": 0.0, "avg_logprob": -0.1309665804323943, "compression_ratio": 1.5391705069124424, "no_speech_prob": 0.0065816184505820274}, {"id": 195, "seek": 131344, "start": 1322.0800000000002, "end": 1329.44, "text": " Let's get the medium, medium sized profile. And now it just flies. It's just responsive all the way.", "tokens": [50796, 961, 311, 483, 264, 6399, 11, 6399, 20004, 7964, 13, 400, 586, 309, 445, 17414, 13, 467, 311, 445, 21826, 439, 264, 636, 13, 51164], "temperature": 0.0, "avg_logprob": -0.1309665804323943, "compression_ratio": 1.5391705069124424, "no_speech_prob": 0.0065816184505820274}, {"id": 196, "seek": 131344, "start": 1330.16, "end": 1334.24, "text": " 4.5 nanoseconds per sample, that's really not a lot of time. This is super fast now.", "tokens": [51200, 1017, 13, 20, 14067, 541, 28750, 680, 6889, 11, 300, 311, 534, 406, 257, 688, 295, 565, 13, 639, 307, 1687, 2370, 586, 13, 51404], "temperature": 0.0, "avg_logprob": -0.1309665804323943, "compression_ratio": 1.5391705069124424, "no_speech_prob": 0.0065816184505820274}, {"id": 197, "seek": 131344, "start": 1334.96, "end": 1339.1200000000001, "text": " Let's get an even bigger profile. Still super responsive.", "tokens": [51440, 961, 311, 483, 364, 754, 3801, 7964, 13, 8291, 1687, 21826, 13, 51648], "temperature": 0.0, "avg_logprob": -0.1309665804323943, "compression_ratio": 1.5391705069124424, "no_speech_prob": 0.0065816184505820274}, {"id": 198, "seek": 134344, "start": 1344.16, "end": 1352.3200000000002, "text": " So when we think about the memory model, or the memory, how it is represented in memory again.", "tokens": [50400, 407, 562, 321, 519, 466, 264, 4675, 2316, 11, 420, 264, 4675, 11, 577, 309, 307, 10379, 294, 4675, 797, 13, 50808], "temperature": 0.0, "avg_logprob": -0.1406860828399658, "compression_ratio": 1.613861386138614, "no_speech_prob": 0.0006354556535370648}, {"id": 199, "seek": 134344, "start": 1353.04, "end": 1355.8400000000001, "text": " We're accessing these columns now. We're accessing them in order.", "tokens": [50844, 492, 434, 26440, 613, 13766, 586, 13, 492, 434, 26440, 552, 294, 1668, 13, 50984], "temperature": 0.0, "avg_logprob": -0.1406860828399658, "compression_ratio": 1.613861386138614, "no_speech_prob": 0.0006354556535370648}, {"id": 200, "seek": 134344, "start": 1356.72, "end": 1363.2, "text": " And what happens is that our cache lines are now fully utilized. We don't have object headers", "tokens": [51028, 400, 437, 2314, 307, 300, 527, 19459, 3876, 366, 586, 4498, 28158, 13, 492, 500, 380, 362, 2657, 45101, 51352], "temperature": 0.0, "avg_logprob": -0.1406860828399658, "compression_ratio": 1.613861386138614, "no_speech_prob": 0.0006354556535370648}, {"id": 201, "seek": 134344, "start": 1363.2, "end": 1366.4, "text": " clogging up our cache anymore. We just have the numbers that we wanted.", "tokens": [51352, 34455, 3249, 493, 527, 19459, 3602, 13, 492, 445, 362, 264, 3547, 300, 321, 1415, 13, 51512], "temperature": 0.0, "avg_logprob": -0.1406860828399658, "compression_ratio": 1.613861386138614, "no_speech_prob": 0.0006354556535370648}, {"id": 202, "seek": 136640, "start": 1366.64, "end": 1373.3600000000001, "text": " But yeah, it's just super efficient now. We get all the stack indexes, we got all the weights.", "tokens": [50376, 583, 1338, 11, 309, 311, 445, 1687, 7148, 586, 13, 492, 483, 439, 264, 8630, 8186, 279, 11, 321, 658, 439, 264, 17443, 13, 50712], "temperature": 0.0, "avg_logprob": -0.15315587897049754, "compression_ratio": 1.5316455696202531, "no_speech_prob": 0.0007204290013760328}, {"id": 203, "seek": 136640, "start": 1374.0800000000002, "end": 1378.16, "text": " The time column is now pretty much irrelevant. It was clogging up our cache before,", "tokens": [50748, 440, 565, 7738, 307, 586, 1238, 709, 28682, 13, 467, 390, 34455, 3249, 493, 527, 19459, 949, 11, 50952], "temperature": 0.0, "avg_logprob": -0.15315587897049754, "compression_ratio": 1.5316455696202531, "no_speech_prob": 0.0007204290013760328}, {"id": 204, "seek": 136640, "start": 1378.16, "end": 1382.48, "text": " but now we're not accessing the time column at all. So it just doesn't bother us anymore.", "tokens": [50952, 457, 586, 321, 434, 406, 26440, 264, 565, 7738, 412, 439, 13, 407, 309, 445, 1177, 380, 8677, 505, 3602, 13, 51168], "temperature": 0.0, "avg_logprob": -0.15315587897049754, "compression_ratio": 1.5316455696202531, "no_speech_prob": 0.0007204290013760328}, {"id": 205, "seek": 136640, "start": 1386.3200000000002, "end": 1392.0800000000002, "text": " Okay, so let's recap quickly. We have a struct of arrays. Some people call it parallel arrays,", "tokens": [51360, 1033, 11, 370, 718, 311, 20928, 2661, 13, 492, 362, 257, 6594, 295, 41011, 13, 2188, 561, 818, 309, 8952, 41011, 11, 51648], "temperature": 0.0, "avg_logprob": -0.15315587897049754, "compression_ratio": 1.5316455696202531, "no_speech_prob": 0.0007204290013760328}, {"id": 206, "seek": 139208, "start": 1393.04, "end": 1399.6799999999998, "text": " commonly used in game engines, databases, and so on. It has a few drawbacks. It looks a bit", "tokens": [50412, 12719, 1143, 294, 1216, 12982, 11, 22380, 11, 293, 370, 322, 13, 467, 575, 257, 1326, 2642, 17758, 13, 467, 1542, 257, 857, 50744], "temperature": 0.0, "avg_logprob": -0.1473250687122345, "compression_ratio": 1.597457627118644, "no_speech_prob": 0.0019254253711551428}, {"id": 207, "seek": 139208, "start": 1399.6799999999998, "end": 1403.76, "text": " backwards if you read it. Sometimes when you want to pass around an object, you need to manually", "tokens": [50744, 12204, 498, 291, 1401, 309, 13, 4803, 562, 291, 528, 281, 1320, 926, 364, 2657, 11, 291, 643, 281, 16945, 50948], "temperature": 0.0, "avg_logprob": -0.1473250687122345, "compression_ratio": 1.597457627118644, "no_speech_prob": 0.0019254253711551428}, {"id": 208, "seek": 139208, "start": 1403.76, "end": 1410.8799999999999, "text": " materialize it because you don't just want to pass around an index. But it also means that the", "tokens": [50948, 2527, 1125, 309, 570, 291, 500, 380, 445, 528, 281, 1320, 926, 364, 8186, 13, 583, 309, 611, 1355, 300, 264, 51304], "temperature": 0.0, "avg_logprob": -0.1473250687122345, "compression_ratio": 1.597457627118644, "no_speech_prob": 0.0019254253711551428}, {"id": 209, "seek": 139208, "start": 1410.8799999999999, "end": 1415.12, "text": " type system, at least in TypeScript, is now less of a help. We can introduce mistakes that it", "tokens": [51304, 2010, 1185, 11, 412, 1935, 294, 15576, 14237, 11, 307, 586, 1570, 295, 257, 854, 13, 492, 393, 5366, 8038, 300, 309, 51516], "temperature": 0.0, "avg_logprob": -0.1473250687122345, "compression_ratio": 1.597457627118644, "no_speech_prob": 0.0019254253711551428}, {"id": 210, "seek": 141512, "start": 1416.0, "end": 1424.0, "text": " wouldn't catch. So for example, if we build up our arrays and we end up not putting our values in", "tokens": [50408, 2759, 380, 3745, 13, 407, 337, 1365, 11, 498, 321, 1322, 493, 527, 41011, 293, 321, 917, 493, 406, 3372, 527, 4190, 294, 50808], "temperature": 0.0, "avg_logprob": -0.10389312356710434, "compression_ratio": 1.6725352112676057, "no_speech_prob": 0.01853020116686821}, {"id": 211, "seek": 141512, "start": 1424.0, "end": 1430.3999999999999, "text": " every one of the columns, we end up with mismatched lengths, and that is hard to catch at the type", "tokens": [50808, 633, 472, 295, 264, 13766, 11, 321, 917, 493, 365, 23220, 24102, 26329, 11, 293, 300, 307, 1152, 281, 3745, 412, 264, 2010, 51128], "temperature": 0.0, "avg_logprob": -0.10389312356710434, "compression_ratio": 1.6725352112676057, "no_speech_prob": 0.01853020116686821}, {"id": 212, "seek": 141512, "start": 1430.3999999999999, "end": 1435.36, "text": " level. Also, when we pass around indexes, sometimes, yeah, you get a number, you don't really know,", "tokens": [51128, 1496, 13, 2743, 11, 562, 321, 1320, 926, 8186, 279, 11, 2171, 11, 1338, 11, 291, 483, 257, 1230, 11, 291, 500, 380, 534, 458, 11, 51376], "temperature": 0.0, "avg_logprob": -0.10389312356710434, "compression_ratio": 1.6725352112676057, "no_speech_prob": 0.01853020116686821}, {"id": 213, "seek": 141512, "start": 1435.36, "end": 1439.36, "text": " is this an index into the stack table, into the frame table? I don't know. The type system,", "tokens": [51376, 307, 341, 364, 8186, 666, 264, 8630, 3199, 11, 666, 264, 3920, 3199, 30, 286, 500, 380, 458, 13, 440, 2010, 1185, 11, 51576], "temperature": 0.0, "avg_logprob": -0.10389312356710434, "compression_ratio": 1.6725352112676057, "no_speech_prob": 0.01853020116686821}, {"id": 214, "seek": 141512, "start": 1439.36, "end": 1442.9599999999998, "text": " at least in TypeScript, I don't think is well set up to catch these kinds of mistakes.", "tokens": [51576, 412, 1935, 294, 15576, 14237, 11, 286, 500, 380, 519, 307, 731, 992, 493, 281, 3745, 613, 3685, 295, 8038, 13, 51756], "temperature": 0.0, "avg_logprob": -0.10389312356710434, "compression_ratio": 1.6725352112676057, "no_speech_prob": 0.01853020116686821}, {"id": 215, "seek": 144296, "start": 1443.6000000000001, "end": 1447.52, "text": " But it's much more cache efficient. It's easier on the garbage collector. You need to traverse", "tokens": [50396, 583, 309, 311, 709, 544, 19459, 7148, 13, 467, 311, 3571, 322, 264, 14150, 23960, 13, 509, 643, 281, 45674, 50592], "temperature": 0.0, "avg_logprob": -0.10930857488087245, "compression_ratio": 1.6620689655172414, "no_speech_prob": 0.001807080116122961}, {"id": 216, "seek": 144296, "start": 1447.52, "end": 1453.04, "text": " fewer objects. Some engines skip the contents of arrays and numbers, so it should speed up that too.", "tokens": [50592, 13366, 6565, 13, 2188, 12982, 10023, 264, 15768, 295, 41011, 293, 3547, 11, 370, 309, 820, 3073, 493, 300, 886, 13, 50868], "temperature": 0.0, "avg_logprob": -0.10930857488087245, "compression_ratio": 1.6620689655172414, "no_speech_prob": 0.001807080116122961}, {"id": 217, "seek": 144296, "start": 1453.04, "end": 1460.72, "text": " Less memory overhead from object headers and padding. And we can just treat columns separately.", "tokens": [50868, 18649, 4675, 19922, 490, 2657, 45101, 293, 39562, 13, 400, 321, 393, 445, 2387, 13766, 14759, 13, 51252], "temperature": 0.0, "avg_logprob": -0.10930857488087245, "compression_ratio": 1.6620689655172414, "no_speech_prob": 0.001807080116122961}, {"id": 218, "seek": 144296, "start": 1460.72, "end": 1466.0, "text": " Like sometimes we want to make a change to one column. Let's say we want to shift the entire", "tokens": [51252, 1743, 2171, 321, 528, 281, 652, 257, 1319, 281, 472, 7738, 13, 961, 311, 584, 321, 528, 281, 5513, 264, 2302, 51516], "temperature": 0.0, "avg_logprob": -0.10930857488087245, "compression_ratio": 1.6620689655172414, "no_speech_prob": 0.001807080116122961}, {"id": 219, "seek": 144296, "start": 1466.0, "end": 1471.76, "text": " profile by some time delta. We can change just the time column. The other columns stay untouched.", "tokens": [51516, 7964, 538, 512, 565, 8289, 13, 492, 393, 1319, 445, 264, 565, 7738, 13, 440, 661, 13766, 1754, 1701, 36740, 13, 51804], "temperature": 0.0, "avg_logprob": -0.10930857488087245, "compression_ratio": 1.6620689655172414, "no_speech_prob": 0.001807080116122961}, {"id": 220, "seek": 147176, "start": 1471.76, "end": 1479.84, "text": " We don't need to recreate any objects. And it also gives us a little more control over sizes and how", "tokens": [50364, 492, 500, 380, 643, 281, 25833, 604, 6565, 13, 400, 309, 611, 2709, 505, 257, 707, 544, 1969, 670, 11602, 293, 577, 50768], "temperature": 0.0, "avg_logprob": -0.10706152967227403, "compression_ratio": 1.6651785714285714, "no_speech_prob": 0.0008936120430007577}, {"id": 221, "seek": 147176, "start": 1479.84, "end": 1484.96, "text": " compact our integers or our numbers are stored. We can pick with our typed array. We could pick", "tokens": [50768, 14679, 527, 41674, 420, 527, 3547, 366, 12187, 13, 492, 393, 1888, 365, 527, 33941, 10225, 13, 492, 727, 1888, 51024], "temperature": 0.0, "avg_logprob": -0.10706152967227403, "compression_ratio": 1.6651785714285714, "no_speech_prob": 0.0008936120430007577}, {"id": 222, "seek": 147176, "start": 1484.96, "end": 1490.56, "text": " an int32 array. We could pick an int16 array. If we know what the domain of our values are,", "tokens": [51024, 364, 560, 11440, 10225, 13, 492, 727, 1888, 364, 560, 6866, 10225, 13, 759, 321, 458, 437, 264, 9274, 295, 527, 4190, 366, 11, 51304], "temperature": 0.0, "avg_logprob": -0.10706152967227403, "compression_ratio": 1.6651785714285714, "no_speech_prob": 0.0008936120430007577}, {"id": 223, "seek": 147176, "start": 1490.56, "end": 1496.72, "text": " we can store things more compactly and we get back in control of the representation.", "tokens": [51304, 321, 393, 3531, 721, 544, 14679, 356, 293, 321, 483, 646, 294, 1969, 295, 264, 10290, 13, 51612], "temperature": 0.0, "avg_logprob": -0.10706152967227403, "compression_ratio": 1.6651785714285714, "no_speech_prob": 0.0008936120430007577}, {"id": 224, "seek": 149672, "start": 1497.68, "end": 1504.0, "text": " Okay. I want to make it even faster. So if we look back at our category breakdown,", "tokens": [50412, 1033, 13, 286, 528, 281, 652, 309, 754, 4663, 13, 407, 498, 321, 574, 646, 412, 527, 7719, 18188, 11, 50728], "temperature": 0.0, "avg_logprob": -0.16255135095420004, "compression_ratio": 1.9617021276595745, "no_speech_prob": 0.0028876177966594696}, {"id": 225, "seek": 149672, "start": 1504.0, "end": 1507.52, "text": " we're getting the stack index, we're getting the frame index, but it's all just to look up the", "tokens": [50728, 321, 434, 1242, 264, 8630, 8186, 11, 321, 434, 1242, 264, 3920, 8186, 11, 457, 309, 311, 439, 445, 281, 574, 493, 264, 50904], "temperature": 0.0, "avg_logprob": -0.16255135095420004, "compression_ratio": 1.9617021276595745, "no_speech_prob": 0.0028876177966594696}, {"id": 226, "seek": 149672, "start": 1507.52, "end": 1511.04, "text": " category from the frame table. We're not really interested in the stack of the frame. We just", "tokens": [50904, 7719, 490, 264, 3920, 3199, 13, 492, 434, 406, 534, 3102, 294, 264, 8630, 295, 264, 3920, 13, 492, 445, 51080], "temperature": 0.0, "avg_logprob": -0.16255135095420004, "compression_ratio": 1.9617021276595745, "no_speech_prob": 0.0028876177966594696}, {"id": 227, "seek": 149672, "start": 1511.04, "end": 1517.92, "text": " want the category for a sample table, for a sample. So what if we just got the categories for", "tokens": [51080, 528, 264, 7719, 337, 257, 6889, 3199, 11, 337, 257, 6889, 13, 407, 437, 498, 321, 445, 658, 264, 10479, 337, 51424], "temperature": 0.0, "avg_logprob": -0.16255135095420004, "compression_ratio": 1.9617021276595745, "no_speech_prob": 0.0028876177966594696}, {"id": 228, "seek": 149672, "start": 1517.92, "end": 1524.72, "text": " each sample and use that instead of here, stack, frame, category, just go category, boom. Well,", "tokens": [51424, 1184, 6889, 293, 764, 300, 2602, 295, 510, 11, 8630, 11, 3920, 11, 7719, 11, 445, 352, 7719, 11, 9351, 13, 1042, 11, 51764], "temperature": 0.0, "avg_logprob": -0.16255135095420004, "compression_ratio": 1.9617021276595745, "no_speech_prob": 0.0028876177966594696}, {"id": 229, "seek": 152472, "start": 1525.3600000000001, "end": 1529.3600000000001, "text": " it would be great if we had this column. Where does it come from? Well, we can compute it here", "tokens": [50396, 309, 576, 312, 869, 498, 321, 632, 341, 7738, 13, 2305, 775, 309, 808, 490, 30, 1042, 11, 321, 393, 14722, 309, 510, 50596], "temperature": 0.0, "avg_logprob": -0.09924834401983963, "compression_ratio": 1.7276785714285714, "no_speech_prob": 0.00013128410500939935}, {"id": 230, "seek": 152472, "start": 1529.3600000000001, "end": 1537.76, "text": " with the get sample categories method. We iterate over all the samples. We do the stack frame category", "tokens": [50596, 365, 264, 483, 6889, 10479, 3170, 13, 492, 44497, 670, 439, 264, 10938, 13, 492, 360, 264, 8630, 3920, 7719, 51016], "temperature": 0.0, "avg_logprob": -0.09924834401983963, "compression_ratio": 1.7276785714285714, "no_speech_prob": 0.00013128410500939935}, {"id": 231, "seek": 152472, "start": 1537.76, "end": 1543.44, "text": " conversion here. We cache that in the sample categories column. We pass that to our existing", "tokens": [51016, 14298, 510, 13, 492, 19459, 300, 294, 264, 6889, 10479, 7738, 13, 492, 1320, 300, 281, 527, 6741, 51300], "temperature": 0.0, "avg_logprob": -0.09924834401983963, "compression_ratio": 1.7276785714285714, "no_speech_prob": 0.00013128410500939935}, {"id": 232, "seek": 152472, "start": 1543.44, "end": 1549.44, "text": " function, but we only want to do this once, not on every call. So we need to cache it somewhere.", "tokens": [51300, 2445, 11, 457, 321, 787, 528, 281, 360, 341, 1564, 11, 406, 322, 633, 818, 13, 407, 321, 643, 281, 19459, 309, 4079, 13, 51600], "temperature": 0.0, "avg_logprob": -0.09924834401983963, "compression_ratio": 1.7276785714285714, "no_speech_prob": 0.00013128410500939935}, {"id": 233, "seek": 154944, "start": 1549.44, "end": 1555.04, "text": " We can use memorization for that. So here's a memorized call. We get the profile. We only run", "tokens": [50364, 492, 393, 764, 10560, 2144, 337, 300, 13, 407, 510, 311, 257, 46677, 818, 13, 492, 483, 264, 7964, 13, 492, 787, 1190, 50644], "temperature": 0.0, "avg_logprob": -0.12130172436053936, "compression_ratio": 1.7876447876447876, "no_speech_prob": 0.0007908872794359922}, {"id": 234, "seek": 154944, "start": 1555.04, "end": 1560.0, "text": " this once. So if we call this multiple times with the same profile, let's say our profile is immutable,", "tokens": [50644, 341, 1564, 13, 407, 498, 321, 818, 341, 3866, 1413, 365, 264, 912, 7964, 11, 718, 311, 584, 527, 7964, 307, 3397, 32148, 11, 50892], "temperature": 0.0, "avg_logprob": -0.12130172436053936, "compression_ratio": 1.7876447876447876, "no_speech_prob": 0.0007908872794359922}, {"id": 235, "seek": 154944, "start": 1560.0, "end": 1564.0800000000002, "text": " we have it cached from last time. And we can make the caching even more precise.", "tokens": [50892, 321, 362, 309, 269, 15095, 490, 1036, 565, 13, 400, 321, 393, 652, 264, 269, 2834, 754, 544, 13600, 13, 51096], "temperature": 0.0, "avg_logprob": -0.12130172436053936, "compression_ratio": 1.7876447876447876, "no_speech_prob": 0.0007908872794359922}, {"id": 236, "seek": 154944, "start": 1564.8, "end": 1570.8, "text": " If we memorize a function which takes just the columns that we need, then we get it. We wrap", "tokens": [51132, 759, 321, 27478, 257, 2445, 597, 2516, 445, 264, 13766, 300, 321, 643, 11, 550, 321, 483, 309, 13, 492, 7019, 51432], "temperature": 0.0, "avg_logprob": -0.12130172436053936, "compression_ratio": 1.7876447876447876, "no_speech_prob": 0.0007908872794359922}, {"id": 237, "seek": 154944, "start": 1570.8, "end": 1575.3600000000001, "text": " this into the existing get sample categories function, which takes the profile, but then it", "tokens": [51432, 341, 666, 264, 6741, 483, 6889, 10479, 2445, 11, 597, 2516, 264, 7964, 11, 457, 550, 309, 51660], "temperature": 0.0, "avg_logprob": -0.12130172436053936, "compression_ratio": 1.7876447876447876, "no_speech_prob": 0.0007908872794359922}, {"id": 238, "seek": 157536, "start": 1575.36, "end": 1580.6399999999999, "text": " takes out the categories. Sorry, it takes out the columns we want, passes those separately to the", "tokens": [50364, 2516, 484, 264, 10479, 13, 4919, 11, 309, 2516, 484, 264, 13766, 321, 528, 11, 11335, 729, 14759, 281, 264, 50628], "temperature": 0.0, "avg_logprob": -0.130193385672062, "compression_ratio": 1.6217391304347826, "no_speech_prob": 0.0005188467330299318}, {"id": 239, "seek": 157536, "start": 1580.6399999999999, "end": 1588.6399999999999, "text": " memorized function, and that makes the caching even more or even tighter. If you touch a column", "tokens": [50628, 46677, 2445, 11, 293, 300, 1669, 264, 269, 2834, 754, 544, 420, 754, 30443, 13, 759, 291, 2557, 257, 7738, 51028], "temperature": 0.0, "avg_logprob": -0.130193385672062, "compression_ratio": 1.6217391304347826, "no_speech_prob": 0.0005188467330299318}, {"id": 240, "seek": 157536, "start": 1588.6399999999999, "end": 1596.32, "text": " that is not involved, you don't invalidate your cache. And did it work? Yes, it did. Oops,", "tokens": [51028, 300, 307, 406, 3288, 11, 291, 500, 380, 34702, 473, 428, 19459, 13, 400, 630, 309, 589, 30, 1079, 11, 309, 630, 13, 21726, 11, 51412], "temperature": 0.0, "avg_logprob": -0.130193385672062, "compression_ratio": 1.6217391304347826, "no_speech_prob": 0.0005188467330299318}, {"id": 241, "seek": 157536, "start": 1596.32, "end": 1604.32, "text": " wrong direction again. Memorized sample categories. We're now down to three nanoseconds.", "tokens": [51412, 2085, 3513, 797, 13, 8731, 284, 1602, 6889, 10479, 13, 492, 434, 586, 760, 281, 1045, 14067, 541, 28750, 13, 51812], "temperature": 0.0, "avg_logprob": -0.130193385672062, "compression_ratio": 1.6217391304347826, "no_speech_prob": 0.0005188467330299318}, {"id": 242, "seek": 160536, "start": 1605.4399999999998, "end": 1616.3999999999999, "text": " So I'm basically done with the talk. Let's just look at the graph here at the end. This V1 graph", "tokens": [50368, 407, 286, 478, 1936, 1096, 365, 264, 751, 13, 961, 311, 445, 574, 412, 264, 4295, 510, 412, 264, 917, 13, 639, 691, 16, 4295, 50916], "temperature": 0.0, "avg_logprob": -0.13083044070641972, "compression_ratio": 1.5991735537190082, "no_speech_prob": 0.0007782625034451485}, {"id": 243, "seek": 160536, "start": 1616.3999999999999, "end": 1621.36, "text": " is off the charts like this. It's way higher than this. But we made it faster with every change here.", "tokens": [50916, 307, 766, 264, 17767, 411, 341, 13, 467, 311, 636, 2946, 813, 341, 13, 583, 321, 1027, 309, 4663, 365, 633, 1319, 510, 13, 51164], "temperature": 0.0, "avg_logprob": -0.13083044070641972, "compression_ratio": 1.5991735537190082, "no_speech_prob": 0.0007782625034451485}, {"id": 244, "seek": 160536, "start": 1622.32, "end": 1628.32, "text": " And this last step of caching the sample, the categories for each sample, it looks like it's", "tokens": [51212, 400, 341, 1036, 1823, 295, 269, 2834, 264, 6889, 11, 264, 10479, 337, 1184, 6889, 11, 309, 1542, 411, 309, 311, 51512], "temperature": 0.0, "avg_logprob": -0.13083044070641972, "compression_ratio": 1.5991735537190082, "no_speech_prob": 0.0007782625034451485}, {"id": 245, "seek": 160536, "start": 1628.32, "end": 1634.8799999999999, "text": " not much, like 25% on these nanoseconds. But what it actually means is we can handle more data.", "tokens": [51512, 406, 709, 11, 411, 3552, 4, 322, 613, 14067, 541, 28750, 13, 583, 437, 309, 767, 1355, 307, 321, 393, 4813, 544, 1412, 13, 51840], "temperature": 0.0, "avg_logprob": -0.13083044070641972, "compression_ratio": 1.5991735537190082, "no_speech_prob": 0.0007782625034451485}, {"id": 246, "seek": 163536, "start": 1635.36, "end": 1642.6399999999999, "text": " We can handle a higher count of samples in, let's say, a 16 millisecond interval. And like 25%", "tokens": [50364, 492, 393, 4813, 257, 2946, 1207, 295, 10938, 294, 11, 718, 311, 584, 11, 257, 3165, 27940, 18882, 15035, 13, 400, 411, 3552, 4, 50728], "temperature": 0.0, "avg_logprob": -0.12145328521728516, "compression_ratio": 1.5591836734693878, "no_speech_prob": 0.00042978773126378655}, {"id": 247, "seek": 163536, "start": 1642.6399999999999, "end": 1653.6, "text": " more data, that's massive. Okay, I want to say really quick, what is data-oriented design? It's", "tokens": [50728, 544, 1412, 11, 300, 311, 5994, 13, 1033, 11, 286, 528, 281, 584, 534, 1702, 11, 437, 307, 1412, 12, 27414, 1715, 30, 467, 311, 51276], "temperature": 0.0, "avg_logprob": -0.12145328521728516, "compression_ratio": 1.5591836734693878, "no_speech_prob": 0.00042978773126378655}, {"id": 248, "seek": 163536, "start": 1653.6, "end": 1658.4799999999998, "text": " a mindset and it's a collection of techniques. The main technique here is structure of arrays.", "tokens": [51276, 257, 12543, 293, 309, 311, 257, 5765, 295, 7512, 13, 440, 2135, 6532, 510, 307, 3877, 295, 41011, 13, 51520], "temperature": 0.0, "avg_logprob": -0.12145328521728516, "compression_ratio": 1.5591836734693878, "no_speech_prob": 0.00042978773126378655}, {"id": 249, "seek": 163536, "start": 1659.4399999999998, "end": 1664.32, "text": " The mindset is more about how you think about it. The shape of the data determines the algorithm", "tokens": [51568, 440, 12543, 307, 544, 466, 577, 291, 519, 466, 309, 13, 440, 3909, 295, 264, 1412, 24799, 264, 9284, 51812], "temperature": 0.0, "avg_logprob": -0.12145328521728516, "compression_ratio": 1.5591836734693878, "no_speech_prob": 0.00042978773126378655}, {"id": 250, "seek": 166432, "start": 1664.32, "end": 1669.52, "text": " and its performance. You need to know which things are small, which things are big. We might have", "tokens": [50364, 293, 1080, 3389, 13, 509, 643, 281, 458, 597, 721, 366, 1359, 11, 597, 721, 366, 955, 13, 492, 1062, 362, 50624], "temperature": 0.0, "avg_logprob": -0.1057336785820093, "compression_ratio": 1.6157407407407407, "no_speech_prob": 0.001297697308473289}, {"id": 251, "seek": 166432, "start": 1669.52, "end": 1673.9199999999998, "text": " seven elements in this array and 100,000 in that array. If you keep that in mind, you're better", "tokens": [50624, 3407, 4959, 294, 341, 10225, 293, 2319, 11, 1360, 294, 300, 10225, 13, 759, 291, 1066, 300, 294, 1575, 11, 291, 434, 1101, 50844], "temperature": 0.0, "avg_logprob": -0.1057336785820093, "compression_ratio": 1.6157407407407407, "no_speech_prob": 0.001297697308473289}, {"id": 252, "seek": 166432, "start": 1673.9199999999998, "end": 1679.2, "text": " set up to write fast code. And if you also think about cache line utilization, you're even better", "tokens": [50844, 992, 493, 281, 2464, 2370, 3089, 13, 400, 498, 291, 611, 519, 466, 19459, 1622, 37074, 11, 291, 434, 754, 1101, 51108], "temperature": 0.0, "avg_logprob": -0.1057336785820093, "compression_ratio": 1.6157407407407407, "no_speech_prob": 0.001297697308473289}, {"id": 253, "seek": 166432, "start": 1679.2, "end": 1685.12, "text": " set up. The rest is not that important. Thanks, everyone.", "tokens": [51108, 992, 493, 13, 440, 1472, 307, 406, 300, 1021, 13, 2561, 11, 1518, 13, 51404], "temperature": 0.0, "avg_logprob": -0.1057336785820093, "compression_ratio": 1.6157407407407407, "no_speech_prob": 0.001297697308473289}, {"id": 254, "seek": 168512, "start": 1685.12, "end": 1702.8799999999999, "text": " You can find me in the Firefox Profiler channel. You can check the Firefox Profiler online. Happy profiling!", "tokens": [50404, 509, 393, 915, 385, 294, 264, 46613, 6039, 5441, 2269, 13, 509, 393, 1520, 264, 46613, 6039, 5441, 2950, 13, 8277, 1740, 4883, 0, 51252], "temperature": 0.0, "avg_logprob": -0.25490847340336553, "compression_ratio": 1.2705882352941176, "no_speech_prob": 0.34720009565353394}], "language": "en"}