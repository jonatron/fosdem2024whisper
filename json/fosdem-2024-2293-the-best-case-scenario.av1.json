{"text": " you you yes sorry so let's talk about case which is a keyword that hopefully most of you have used, if you haven't, it's okay, we're gonna go through it. And we're gonna figure out how we can use it, how it works, how we can use it better, and what the latest versions of Ruby have given us to play with this operator more. So yeah, that's more as what I'm talking about. So just in case we're gonna go through what case is, what the different syntaxes are, how you usually use it, and then we're gonna look at how it's implemented, which is terrifying, and we're gonna have a small dive into how the Ruby VM works and the instructions and stuff like that. After that we're gonna go through several use cases, some of them are pretty basic, some of them I think are pretty cool on a Ruby standpoint. And finally we're gonna take a look at pattern matching, which has been coming to Ruby since 2.7 and is mainly operated right now using the case keyword. So let's start. What's a case? So does anyone not know what a case is, or has anyone not used it? Cool. So that will go fast. So basically a case is more or less a big if-else, that's usually how people think about it. So you have your case, you have your different branches, and then you match each branch against your case. And depending on the branch that matches, you go to a different path. So in this case we can assume that, I don't know, status is something you get back from an API, you match it against different cases, and then if you have a success you proceed, otherwise you want to fail depending on what you have. If you want to, you could be even more compact by moving the stuff up a line and using then, and if you want it to be even more compact, you could even add more things to a branch. So if you wanted different conditions to go to the same branch, you can separate them with a comma. So that's basic case. One interesting use case that I don't think I've ever seen before, I don't know if it's useful, but it's still cool to look at, is you can write a case without anything at the top, just an empty case, and then it behaves exactly like an if-else if, so you have to use usual predicates, the same way you would an if-else. So I'm honestly not sure that has much interest, but it's cool. So how does case work? And in general, I kind of also wanted to take the opportunity to talk about a bit about how anything works in Ruby and how you can, when you're debugging something and trying to figure out how something works, how you can go deeper into your code or someone else's code. So if you're, for example, if you have a method that you've written or someone else has written and you don't know where it is, so let's say you're in a big code base and you have 20 methods called, I don't know, count or show, and you don't know which one is being resolved. In Ruby, everything's an object, as you might have heard before. So, so are methods. And you can, on any instance of anything, call dot method, capture your method, and then you have access to two methods that are pretty cool. One is called source location, which will tell you in which file it is. So interesting when you don't know which method is being resolved. And another one is just dot source, which will print out the source in your terminal. Just plain up. So that's interesting also. If you're looking for something more lower level, so a Ruby method, like array.last or integer.next, and you don't know how it works and you don't know where to go, you're kind of stuck. You're going to have to go read the fabulous manual of Ruby to figure out where it is. But in our case, we're kind of one level deeper because we're not looking at a Ruby method, we're looking at a Ruby keyword. So you, if you go to the documentation, you're going to find how it behaves, but you're not really going to be able to see the source code per se. So in this case, one way that I've used to figure out how the internals of case work is to go look at the Ruby VM instructions. So big-ish caveat for the next couple of slides. That's the very limit of what I'm trying to understand this year. I'm kind of in that phase in my Ruby journey when I want to understand how things work. So if I say something outrageous, stop me. So from my understanding, the Ruby code that you write goes through a journey before it is compiled and interpreted. So your Ruby code first gets turned into tokens. So for example, you can imagine that your entire program gets turned into a big array of syntactically relevant stuff. So that could be depth, for example, or an open parenthesis or a space or part of a string. So everything gets turned into a token. And then those token get organized into something called an AST, which is an abstract syntax tree, which is really hard to say. And basically what an AST is, is that big array, but formatted into something that is more understandable. So if anyone has ever played with RuboCop before, that's probably where you've seen something like that, because you have to play with syntax tree, which you want to write your own cops. So the tree is composed of a lot of nodes, and each node has a name. So you have a class node or a method node or a begin node. And then inside the node, you have all relevant information for that specific class or method or begin block or anything. And then all of those, all that tree gets turned into virtual machine instructions. So that's the part where I think this, what I'm going to talk about probably only work on C Ruby. I'm not sure this applies to other implementations of Ruby, like Truffle or JRuby. It probably works a bit differently. So if we look at the case that we're looking at before, and in the Ruby console, you have a class called RubyVM, which gives you access to any tool you might want to, to turn your code into either the tokens or the tree or the instructions. You can end up with all of this, which we're going to try and go through in some kind. So first of all, in case you've never used it, the Ruby virtual machine, the one from C Ruby is a stack based VM. So interact, everything in the VM is a stack. So you end up, you have a lot of instruction here that just interact with the stack. Like the put object over there just puts an object on the stack, the top end finds an object and then moves it to the top of the stack. And you have a lot of things like that. So in our case, if we look in detail, we can see a few things. So first of all, here we're mainly preparing the stack and here we have something, here we can find the status that we have over there. So this is basically calling status to fetch the value that we want to match against. And under this, you have a Ruby optimization, a Ruby VM optimization called case dispatch. What this does is in some cases, if you're using a simple case with simple objects inside of it, like strings or integers or symbols or stuff like that, what it will do is it will create a hash where the keys are basically this and this and the values are the number of the line in your VM structure that you need to jump to. So what that means, at least the way I understand it, is if you have a lot of if, else if, else if, else if, it will be usually faster to build a case because you're losing some time here to build your hash. But then whatever case you want to go to, it's just a hash access. Whereas if you're doing a bunch of if and else if you have to go through each of them to see does this work or does this work or does this work, etc. If we go a bit below, we can see what that would look like technically if we would need it to go through each of the branches to see which one works. So here we have our success symbol, which was our first branch. And what this does is it going to compare it to the status using the triple equal method. And that's the cool part of case. That's technically what's doing the heavy lifting behind. And if that equal works, then it's going to jump to instruction 28 below. If it doesn't work, then it's going to keep going. So second branch is error. So we're going to take error, put it on the stack, compare it to status. And if it doesn't, if it works, we go to 33. If none of those work, if you remember the case, then that means we're in our error case or like our else, which is over there. So if none of those work, so we keep going down our instruction and we end up here called the fail harder and then leave, which is instruction 28. And then under that, then you have the lines that you would have jumped to if anything worked before. So the 28 here, which will call the proceed and the 33, which will call the fail. So that's more or less the instruction patterns of a case. So that turned our question before, answers our question before, right, of how a case works. And the simplest answer that I can give it, it works thanks to triple equal. That's what it's going to use to match everything against everything. So if we wanted to push case to the limit, the question that we want to answer now is what does implement triple equal? And in Ruby, that's a bunch of classes. And the interesting thing and the main reason I wanted to do that presentation is that depending on what you're calling triple equal on, it will behave differently. So the simplest example that we've all used is all the base classes. So string strings, integers, float, arrays, hashes, anything you want. And in this case, it checks for equality. So that's the thing we've seen before. You might have seen that code. You get a param that has a response and then you don't know what the fuck the other person in the API has done, whether it's a string or a 200 or a success or a string or a true or true as a string or anything. So you do your case and you match it against whatever and try to figure out. So in this case, it's always going to check for equality. So here with the come out that we've seen before, it's one or the other or the other. And then you have arrays, you have hashes. Otherwise, yes, you can give up. Another thing that implements triple equal with another behavior are classes and modules. On classes and on modules, triple equal checks for, I don't really know how to say it in one word, checks for type, for ancestry. It's a bit like the is a method of Ruby. So when you have an object and you call is my dog an animal, it's not only going to check the class, it's going to check a bit above to see if animal is included in it if you're going composition way or if it inherits from animal, if you're going the inheritance way. And that's more or less what we can do here, for example, with errors. So I say you have your code and you've defined a bunch of different types of errors. And you've tagged some of them maybe as ignorable. So if it returns any errors that's in that type, then I want to ignore them. If it returns those two different errors, I want to return a not found. If someone forgot about safe navigation, I want to tell them. And then a lot of errors, for example, in Rails, and I'm assuming in Ruby, not entirely sure, don't put me on that, inherit from standard error. And so those maybe you want to raise, but if you have something else, then that's probably a lower level, maybe a PG error if you're dealing with a database, and then you want to do something else. So that's it for classes and modules. Another class, another type of classes that implement triple equal or ranges that I'm assuming most of most of us have already used that check for inclusion. So for example, if you have an integer at the top, then you can check that it's included in this range or this range. And it works with the endless ranges of Ruby. So you can be very, I mean, this might as well use an if else if and just check that it's greater or lower than, but it's good to have options. You never know. And one thing that I found, if you're working in networking, that could be cool, IP address works the exact same way. So you can define IP addresses with their masks and everything, and then have them act as ranges, and then check that your IP address belongs to one or the other. This one we've all probably used is also is reg X. So this one checks for just a match. It's the exact same equivalent as if you wanted to match your against string. So that's a kind of real use case that I have from the company that I'm working for where we manage a lot of messages between clients and providers. And so we want to check in those messages that they're not trying to bypass us, for example, by sending an address and trying to meet somewhere, or they're not sending sensitive information or sometimes people can keep their dick in their pants. So we have to be careful about that also. Stuff like this, right? So this one checks for match. Probably one of the most interesting example, but yet the one that have the most trouble coming up with a good example for are prox and lambdas. On prox and on lambdas, triple equal calls the lambda and gives it the object that you're matching with. So for example, here we can define, let's say we want to define simple prox or lambdas that just delegate to another method. So for example, unknown host will take an element and then check if the host is included in the list of something. Oh shit, yeah, I've done it again. In case this is just, it's the new way of writing the old thing here with the pipe pipe and you enter a variable, this does the exact same thing. It just takes the first one. So underscore one would be the first variable that you enter here, underscore two, the second one, underscore three, et cetera, et cetera, et cetera. So let's say that we've defined a simple list of hosts. So when we get, in this case, probably a request, we could delegate to one of those to see if it whitelisted or if something went wrong. And then we can, if it goes there, yes, we can take a request, let's say a web book for example, and write our case on it and say, okay, when it's whitelisted, then I want to do something. If the host is unknown, I want to do something else. If the action is unknown, it's going to do something else. And what this is going to do behind the curtain is it's going to call whitelisted and give it web book as a first parameter. So it's a more, again, more compact way and allows you to put that code somewhere else instead of having to copy paste it into three ifs. And the last one, we're in Ruby, thankfully. So for every other class, we got duck typing. We can just implement the triple equal method and have it work for more or less anything that we want. So bear with me because that's going to take a little bit of time. So in this case, same, still sticking with my response example that we've been following the entire presentation. So here I can define in my response class or module or whatever different classes that implement the triple equal and that do anything that I want. And then I can, if I do this and I call them, this is going to do what we've seen before in the VM instructions, right? It's going to take the response called triple equal with this and then see if the answer is true or not. So with this, you can basically create as many matches as you want, especially on custom class that can be pretty interesting. If you have one example that came to mind also is payments, for example, if you're managing payments, then you can in your payment class define different subclasses that could be success or canceled or processing that just calls your payment API and checks if it works. And so all that code is it's in own place and then you instantiate your object here and you can use case to easily delegate where you're going. Another example that we've kind of used is a wrapper for services. So basically you define new classes for your service and your service answer a class that's either a success or an error and then you can use this to do some kind of early, early days pattern matching. So speaking of pattern matching, how does it work? So just in, again, just in case, we're going to go quickly through what it is and what it works, how it works, sorry. So the whole idea of pattern matching is that you define as the naming price, you define a pattern, then you try and match it against something and see what sticks. So here my pattern is going to be a hash with a status key, a body key inside of which I'll have a user with a name and an age and whatever is in here, if I can match it, I want to store it in the variable and then once you have your pattern, you can try and match it against any collection of stuff. So in this case, it's going to work because we had the same status and the form that we're trying to match against was the same and what it's going to do is it's going to assign the name variable to whatever was there and the age variable to whatever was there. If you want to match it against something that looks very different, so this hash for example is not going to work because either status and body are here, this value is not going to match against that one, right? So if you try and do this, then it doesn't work, so you're going to get an error. In Ruby at least, this is going to, sorry, this is going to raise an error that just tells you I wasn't able to match it and in Ruby that was implemented using case. So the way it works is if you have a response or literally anything, you want to create your different patterns that you're going to want to match it against and one thing to note is that it's no longer, you know, to make the difference, you no longer use case when, using case in because in is going to be the keyword that's going to be mainly used for pattern matching even out of cases. So in this case, if the response that I get has a status success, I'm going to take whatever is in the body and put it there and otherwise if it's an error, I'm going to fail and put it over there. So it's, again, it kind of does the same. You could do the whole counterpoint to this presentation is I could do it with an if, else if. You always can, but I do think this is a bit more verbose and makes it more clear what you're trying to do because you can see the entire pattern. Whereas if you wanted to do an if, you would have to open response and do if the status is success, then I want to look at the body. For this example looks the same, but if you're dealing with big jasons from APIs where everything is nested like four times and you have response body value and then you take the first element and then the address and then whatever this starts to become more interesting. Another thing that we get with pattern matching that we can do with case when is we get access to guard closes. So whatever that allows us to do is I want response to match with this only if I'm not in maintenance. So this gives us a bit more control over whether or not we want the pattern to match because sometimes you might want to put patterns that are very similar, but you want to condition them to something different. Another example and another thing that we can do with pattern matching, so let's look at a more complex pattern. We have access to a lot of new tools. So for example, here, what this thing here means is that I want to match this pattern where the ID is whatever I put on top. If I didn't put it, then it would act as the one we store before and store it into the variable ID, but by doing this I can tell it no, no, no, use the value that's already there and match one that has 69 as an ID. I don't want anything else. And we also have access to splat operators, kind of. So simple splat for arrays, double splat for hashes, the same as with method arguments. So what this allows me to do is I want to take user and if the user is in an array with some elements at the beginning, some elements at the end, and then somewhere in the middle, an element with ID 69, I want to store the value of admin. So this is kind of equivalent to take my entire array and do a detect where ID 69 and then print admin. So this kind of does the same thing, but in a more flexible way because I can then kind of keep putting more patterns underneath to filter out more stuff or try to find more elements. So how does it work? I kind of, at this point in the talk, I kind of wanted to go through the same journey with pattern matching as I did with a simple case. So try to open it up and look at the VM instructions and see how it works and try and figure out what's underneath. The problem is that pattern matching is kind of new. So in the Ruby VM, that is a lot of instructions to go through. So I ain't going to go through everything. But there are a few things that we can see here. So for example here, we have the same response. So that's the beginning of our case. So this calls the thing that's going to go in the case that we're going to try and pattern match against the same. We're looking at pattern matching. So of course, the thing called check match, we kind of kind of assume that it's going to match or pattern against something. So the way, at least the way I understand it is that all of this is going to build or pattern and then it's going to match it to continue. And if we look at the way it builds the pattern, we can find one method that is interesting, which is this one, which is deconstruct keys. And after looking at it a bit more and going to read out the documentation, this is what Ruby used to do, at least for now, to do pattern matching. So you have two methods. One is called deconstruct keys that is used on patterns that are hashes. And another one is called deconstruct, which is used on pattern that are arrays. That make sense? And so this does all of the deconstruction and then if the pattern that you're sending doesn't respond to the deconstruct keys or the deconstruct method, then it's just going to give up and tell you to implement it yourself so that it works. And after that, it's more of the same thing, right? So that's the second pattern that we have. It's still trying to deconstruct them. And then eventually, if it doesn't find anything, it's going to return a no match error. So the interesting thing then is how do we implement it ourselves? So if you have your class and you want it to be, you want to use pattern matching on it, then one thing that you can do is use, is implement the deconstruct keys method. So in this case, we have a location and we want to have a latitude and a longitude in the deconstruct keys. And then that allows us every time we have a location to use pattern matching on it, because it's going to deconstruct this, deconstruct this, and then see what matches. And so in this case, and interesting thing also is inside of our pattern, we have access to everything that we've been talking about earlier. So in your pattern, you can put classes, you can put reg X, you can put ranges in this case. And the only thing I think we haven't seen before is this little thing magic that just takes like, it wants to match it against this and then store it into the variable that we can then use for anything else. And I think that's it. I've tried to go through everything. I sped through that one, sorry. We have so much time. I didn't. You used a variable that was not declared before. Yeah, probably. Where? In the right address before? One? latitude. Did you declare length to be equal to new before? No, you don't have to declare it before. Basically what this does is it takes this and then store it. It takes whatever matches here. So that would be technically this and then store it into the latitude variables. You don't have to declare it before. And what's the scope of that variable? It's going to be a scope to whatever the case is in. Right? So if your case is defined in a method, then you have access to it in the entire method. This is in current? Yeah. I think this might be, this might have been implemented in Ruby three. And the first occurrence of pattern matching, the one with the case in, was experimental in 2.7 and then actually arrived in Ruby three. And they've been trying to push it a bit more in subsequent versions. So now, for example, you don't necessarily need to have case. If you want it, if you want to use pattern matching, then you can just write your variable in something and use it as a predicate to see if it matches or not. In your example where you're looking for an admin user in an array of users and you have those operations at the back, does that work if your admin user is the first or the last? Yeah, yeah, yeah, yeah. Then the, then the, Like it might not. Yeah, fair. Yeah, yeah, definitely fair. What this will do is it will put nil in here and nil in the other variable. Right? It's like there's nothing after, there's nothing before or there's nothing before. Yeah, that's the thing that I was a bit, if you about this, basically the, shit, I have to go through all the animations. Sorry, bear with me. It's going to scroll again on. Okay, sure, whatever, shit. The argument that it takes is in case you only want to deconstruct some keys. Right? So if that is, if you have a big object and you only want to deconstruct latitude, for example, you could work it this way. That's what it's supposed to do. In the example, I didn't go through the trouble of implementing all of it, because if I want to write code big, I can write too much code. And yeah, that's why. So it was deconstruct for arrays and deconstruct keys, though. Yeah. And you can define deconstruct as well. If you've got a class that implements an interval or something. Probably, yeah, yeah, I think so. Just to take how stable you think the syntax is. Do you think it's going to stay the same? Huh. Would you, would you, would you, would you want to do, for example, like the, the, the, the, the, the, the, the, the, the, the, the, I think it's going to stay the same. No, sorry. Yeah. I know I was thinking in my head, I think it's going to stay the same because it's the exact same syntax that Alexia uses, for example. Like they've probably been inspired from other languages and used it. And so I'm expecting it to stay the same. But then again, I don't know. I think right now I'm still, I'm trying, I tried to push for it in very simple use cases. So usually in a, if we get, if we have to make an API call, that's probably the best, like, foot in the door to get it working in your code basis. Like, because that's the thing that seems the most obvious, right? I get an answer and then I can, not only fetch the status, but assign everything in the answer and then give it to another method. I think that's a bit, not a frontend dev. So don't quote me on this at all. But it looks a bit like the object deconstruction thing from JavaScript. Or you can get an object and then assign all the variables into it. In this use case, I think it's a good first step to implement it in a code base. I wouldn't go all out and start putting deconstruct keys in every class. That would be really, I really hope that, I really hope they put it in Ruby at some point. I don't think that's in the plans right now. I think the idea, the main idea behind was, like, when they put it in Ruby at all, pattern matching in 2.7, it was kind of touch and go. People were discussing a lot about do we want this in our code base because pattern matching in the collective brain is usually more functional than object oriented. But now that it's there and it's past the experimental and it's now stable, I think they're eventually going to do it. It'd be a shame not to, right? Do you think some of this stuff is going to end up in the Ruby style guy? And be something like Ruby cop goes and says, no, no, you don't want to do that. You don't want to do that. You want to use this instead. Probably not in the near future. Because I think people are still very much like trying to figure out what the good style is. Even when I was preparing this, I couldn't find a lot of examples. So I kind of came up with what I think would look the best. But I don't think for now, at least, there are a lot of established guidelines. We good? Cool. Nice.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 2.06, "text": " you", "tokens": [50364, 291, 50467], "temperature": 0.0, "avg_logprob": -0.5557519793510437, "compression_ratio": 0.2727272727272727, "no_speech_prob": 0.9433980584144592}, {"id": 1, "seek": 3000, "start": 30.0, "end": 32.06, "text": " you", "tokens": [50364, 291, 50467], "temperature": 0.0, "avg_logprob": -0.825688362121582, "compression_ratio": 0.2727272727272727, "no_speech_prob": 0.8379196524620056}, {"id": 2, "seek": 6000, "start": 60.0, "end": 89.0, "text": " yes sorry so let's talk about case which is a keyword that hopefully most of you have", "tokens": [50364, 2086, 2597, 370, 718, 311, 751, 466, 1389, 597, 307, 257, 20428, 300, 4696, 881, 295, 291, 362, 51814], "temperature": 0.6, "avg_logprob": -0.3649758425625888, "compression_ratio": 1.1333333333333333, "no_speech_prob": 0.08728567510843277}, {"id": 3, "seek": 8900, "start": 89.0, "end": 94.12, "text": " used, if you haven't, it's okay, we're gonna go through it. And we're gonna figure out", "tokens": [50364, 1143, 11, 498, 291, 2378, 380, 11, 309, 311, 1392, 11, 321, 434, 799, 352, 807, 309, 13, 400, 321, 434, 799, 2573, 484, 50620], "temperature": 0.0, "avg_logprob": -0.17769249698571993, "compression_ratio": 1.7586206896551724, "no_speech_prob": 0.19078664481639862}, {"id": 4, "seek": 8900, "start": 94.12, "end": 99.4, "text": " how we can use it, how it works, how we can use it better, and what the latest", "tokens": [50620, 577, 321, 393, 764, 309, 11, 577, 309, 1985, 11, 577, 321, 393, 764, 309, 1101, 11, 293, 437, 264, 6792, 50884], "temperature": 0.0, "avg_logprob": -0.17769249698571993, "compression_ratio": 1.7586206896551724, "no_speech_prob": 0.19078664481639862}, {"id": 5, "seek": 8900, "start": 99.4, "end": 107.0, "text": " versions of Ruby have given us to play with this operator more. So yeah, that's", "tokens": [50884, 9606, 295, 19907, 362, 2212, 505, 281, 862, 365, 341, 12973, 544, 13, 407, 1338, 11, 300, 311, 51264], "temperature": 0.0, "avg_logprob": -0.17769249698571993, "compression_ratio": 1.7586206896551724, "no_speech_prob": 0.19078664481639862}, {"id": 6, "seek": 8900, "start": 107.0, "end": 110.56, "text": " more as what I'm talking about. So just in case we're gonna go through what case", "tokens": [51264, 544, 382, 437, 286, 478, 1417, 466, 13, 407, 445, 294, 1389, 321, 434, 799, 352, 807, 437, 1389, 51442], "temperature": 0.0, "avg_logprob": -0.17769249698571993, "compression_ratio": 1.7586206896551724, "no_speech_prob": 0.19078664481639862}, {"id": 7, "seek": 8900, "start": 110.56, "end": 116.24000000000001, "text": " is, what the different syntaxes are, how you usually use it, and then we're gonna", "tokens": [51442, 307, 11, 437, 264, 819, 28431, 279, 366, 11, 577, 291, 2673, 764, 309, 11, 293, 550, 321, 434, 799, 51726], "temperature": 0.0, "avg_logprob": -0.17769249698571993, "compression_ratio": 1.7586206896551724, "no_speech_prob": 0.19078664481639862}, {"id": 8, "seek": 11624, "start": 116.28, "end": 120.64, "text": " look at how it's implemented, which is terrifying, and we're gonna have a small", "tokens": [50366, 574, 412, 577, 309, 311, 12270, 11, 597, 307, 18106, 11, 293, 321, 434, 799, 362, 257, 1359, 50584], "temperature": 0.0, "avg_logprob": -0.1426858227662366, "compression_ratio": 1.6473029045643153, "no_speech_prob": 0.03726242482662201}, {"id": 9, "seek": 11624, "start": 120.64, "end": 126.52, "text": " dive into how the Ruby VM works and the instructions and stuff like that. After", "tokens": [50584, 9192, 666, 577, 264, 19907, 18038, 1985, 293, 264, 9415, 293, 1507, 411, 300, 13, 2381, 50878], "temperature": 0.0, "avg_logprob": -0.1426858227662366, "compression_ratio": 1.6473029045643153, "no_speech_prob": 0.03726242482662201}, {"id": 10, "seek": 11624, "start": 126.52, "end": 131.2, "text": " that we're gonna go through several use cases, some of them are pretty basic, some", "tokens": [50878, 300, 321, 434, 799, 352, 807, 2940, 764, 3331, 11, 512, 295, 552, 366, 1238, 3875, 11, 512, 51112], "temperature": 0.0, "avg_logprob": -0.1426858227662366, "compression_ratio": 1.6473029045643153, "no_speech_prob": 0.03726242482662201}, {"id": 11, "seek": 11624, "start": 131.2, "end": 136.04, "text": " of them I think are pretty cool on a Ruby standpoint. And finally we're gonna", "tokens": [51112, 295, 552, 286, 519, 366, 1238, 1627, 322, 257, 19907, 15827, 13, 400, 2721, 321, 434, 799, 51354], "temperature": 0.0, "avg_logprob": -0.1426858227662366, "compression_ratio": 1.6473029045643153, "no_speech_prob": 0.03726242482662201}, {"id": 12, "seek": 11624, "start": 136.04, "end": 140.95999999999998, "text": " take a look at pattern matching, which has been coming to Ruby since 2.7 and", "tokens": [51354, 747, 257, 574, 412, 5102, 14324, 11, 597, 575, 668, 1348, 281, 19907, 1670, 568, 13, 22, 293, 51600], "temperature": 0.0, "avg_logprob": -0.1426858227662366, "compression_ratio": 1.6473029045643153, "no_speech_prob": 0.03726242482662201}, {"id": 13, "seek": 14096, "start": 141.08, "end": 147.48000000000002, "text": " is mainly operated right now using the case keyword. So let's start. What's a", "tokens": [50370, 307, 8704, 20826, 558, 586, 1228, 264, 1389, 20428, 13, 407, 718, 311, 722, 13, 708, 311, 257, 50690], "temperature": 0.0, "avg_logprob": -0.177290178694815, "compression_ratio": 1.6764705882352942, "no_speech_prob": 0.009555451571941376}, {"id": 14, "seek": 14096, "start": 147.48000000000002, "end": 156.92000000000002, "text": " case? So does anyone not know what a case is, or has anyone not used it? Cool. So", "tokens": [50690, 1389, 30, 407, 775, 2878, 406, 458, 437, 257, 1389, 307, 11, 420, 575, 2878, 406, 1143, 309, 30, 8561, 13, 407, 51162], "temperature": 0.0, "avg_logprob": -0.177290178694815, "compression_ratio": 1.6764705882352942, "no_speech_prob": 0.009555451571941376}, {"id": 15, "seek": 14096, "start": 156.92000000000002, "end": 161.28, "text": " that will go fast. So basically a case is more or less a big if-else, that's", "tokens": [51162, 300, 486, 352, 2370, 13, 407, 1936, 257, 1389, 307, 544, 420, 1570, 257, 955, 498, 12, 44408, 11, 300, 311, 51380], "temperature": 0.0, "avg_logprob": -0.177290178694815, "compression_ratio": 1.6764705882352942, "no_speech_prob": 0.009555451571941376}, {"id": 16, "seek": 14096, "start": 161.28, "end": 164.8, "text": " usually how people think about it. So you have your case, you have your different", "tokens": [51380, 2673, 577, 561, 519, 466, 309, 13, 407, 291, 362, 428, 1389, 11, 291, 362, 428, 819, 51556], "temperature": 0.0, "avg_logprob": -0.177290178694815, "compression_ratio": 1.6764705882352942, "no_speech_prob": 0.009555451571941376}, {"id": 17, "seek": 14096, "start": 164.8, "end": 170.60000000000002, "text": " branches, and then you match each branch against your case. And depending on the", "tokens": [51556, 14770, 11, 293, 550, 291, 2995, 1184, 9819, 1970, 428, 1389, 13, 400, 5413, 322, 264, 51846], "temperature": 0.0, "avg_logprob": -0.177290178694815, "compression_ratio": 1.6764705882352942, "no_speech_prob": 0.009555451571941376}, {"id": 18, "seek": 17060, "start": 170.64, "end": 175.88, "text": " branch that matches, you go to a different path. So in this case we can assume", "tokens": [50366, 9819, 300, 10676, 11, 291, 352, 281, 257, 819, 3100, 13, 407, 294, 341, 1389, 321, 393, 6552, 50628], "temperature": 0.0, "avg_logprob": -0.1489271040885679, "compression_ratio": 1.8282442748091603, "no_speech_prob": 0.0061897761188447475}, {"id": 19, "seek": 17060, "start": 175.88, "end": 179.2, "text": " that, I don't know, status is something you get back from an API, you match it", "tokens": [50628, 300, 11, 286, 500, 380, 458, 11, 6558, 307, 746, 291, 483, 646, 490, 364, 9362, 11, 291, 2995, 309, 50794], "temperature": 0.0, "avg_logprob": -0.1489271040885679, "compression_ratio": 1.8282442748091603, "no_speech_prob": 0.0061897761188447475}, {"id": 20, "seek": 17060, "start": 179.2, "end": 183.2, "text": " against different cases, and then if you have a success you proceed, otherwise you", "tokens": [50794, 1970, 819, 3331, 11, 293, 550, 498, 291, 362, 257, 2245, 291, 8991, 11, 5911, 291, 50994], "temperature": 0.0, "avg_logprob": -0.1489271040885679, "compression_ratio": 1.8282442748091603, "no_speech_prob": 0.0061897761188447475}, {"id": 21, "seek": 17060, "start": 183.2, "end": 189.51999999999998, "text": " want to fail depending on what you have. If you want to, you could be even more", "tokens": [50994, 528, 281, 3061, 5413, 322, 437, 291, 362, 13, 759, 291, 528, 281, 11, 291, 727, 312, 754, 544, 51310], "temperature": 0.0, "avg_logprob": -0.1489271040885679, "compression_ratio": 1.8282442748091603, "no_speech_prob": 0.0061897761188447475}, {"id": 22, "seek": 17060, "start": 190.04, "end": 195.28, "text": " compact by moving the stuff up a line and using then, and if you want it to be", "tokens": [51336, 14679, 538, 2684, 264, 1507, 493, 257, 1622, 293, 1228, 550, 11, 293, 498, 291, 528, 309, 281, 312, 51598], "temperature": 0.0, "avg_logprob": -0.1489271040885679, "compression_ratio": 1.8282442748091603, "no_speech_prob": 0.0061897761188447475}, {"id": 23, "seek": 17060, "start": 195.28, "end": 200.07999999999998, "text": " even more compact, you could even add more things to a branch. So if you wanted", "tokens": [51598, 754, 544, 14679, 11, 291, 727, 754, 909, 544, 721, 281, 257, 9819, 13, 407, 498, 291, 1415, 51838], "temperature": 0.0, "avg_logprob": -0.1489271040885679, "compression_ratio": 1.8282442748091603, "no_speech_prob": 0.0061897761188447475}, {"id": 24, "seek": 20008, "start": 200.12, "end": 203.8, "text": " different conditions to go to the same branch, you can separate them with a", "tokens": [50366, 819, 4487, 281, 352, 281, 264, 912, 9819, 11, 291, 393, 4994, 552, 365, 257, 50550], "temperature": 0.0, "avg_logprob": -0.13305960061415187, "compression_ratio": 1.598360655737705, "no_speech_prob": 0.012423870153725147}, {"id": 25, "seek": 20008, "start": 203.8, "end": 210.36, "text": " comma. So that's basic case. One interesting use case that I don't think I've", "tokens": [50550, 22117, 13, 407, 300, 311, 3875, 1389, 13, 1485, 1880, 764, 1389, 300, 286, 500, 380, 519, 286, 600, 50878], "temperature": 0.0, "avg_logprob": -0.13305960061415187, "compression_ratio": 1.598360655737705, "no_speech_prob": 0.012423870153725147}, {"id": 26, "seek": 20008, "start": 210.36, "end": 214.32000000000002, "text": " ever seen before, I don't know if it's useful, but it's still cool to look at,", "tokens": [50878, 1562, 1612, 949, 11, 286, 500, 380, 458, 498, 309, 311, 4420, 11, 457, 309, 311, 920, 1627, 281, 574, 412, 11, 51076], "temperature": 0.0, "avg_logprob": -0.13305960061415187, "compression_ratio": 1.598360655737705, "no_speech_prob": 0.012423870153725147}, {"id": 27, "seek": 20008, "start": 214.92000000000002, "end": 219.72000000000003, "text": " is you can write a case without anything at the top, just an empty case, and then", "tokens": [51106, 307, 291, 393, 2464, 257, 1389, 1553, 1340, 412, 264, 1192, 11, 445, 364, 6707, 1389, 11, 293, 550, 51346], "temperature": 0.0, "avg_logprob": -0.13305960061415187, "compression_ratio": 1.598360655737705, "no_speech_prob": 0.012423870153725147}, {"id": 28, "seek": 20008, "start": 219.72000000000003, "end": 225.56, "text": " it behaves exactly like an if-else if, so you have to use usual predicates,", "tokens": [51346, 309, 36896, 2293, 411, 364, 498, 12, 44408, 498, 11, 370, 291, 362, 281, 764, 7713, 47336, 1024, 11, 51638], "temperature": 0.0, "avg_logprob": -0.13305960061415187, "compression_ratio": 1.598360655737705, "no_speech_prob": 0.012423870153725147}, {"id": 29, "seek": 22556, "start": 225.8, "end": 232.68, "text": " the same way you would an if-else. So I'm honestly not sure that has much", "tokens": [50376, 264, 912, 636, 291, 576, 364, 498, 12, 44408, 13, 407, 286, 478, 6095, 406, 988, 300, 575, 709, 50720], "temperature": 0.0, "avg_logprob": -0.12749253860627763, "compression_ratio": 1.6355932203389831, "no_speech_prob": 0.027981139719486237}, {"id": 30, "seek": 22556, "start": 232.68, "end": 240.92000000000002, "text": " interest, but it's cool. So how does case work? And in general, I kind of also", "tokens": [50720, 1179, 11, 457, 309, 311, 1627, 13, 407, 577, 775, 1389, 589, 30, 400, 294, 2674, 11, 286, 733, 295, 611, 51132], "temperature": 0.0, "avg_logprob": -0.12749253860627763, "compression_ratio": 1.6355932203389831, "no_speech_prob": 0.027981139719486237}, {"id": 31, "seek": 22556, "start": 240.92000000000002, "end": 245.56, "text": " wanted to take the opportunity to talk about a bit about how anything works in", "tokens": [51132, 1415, 281, 747, 264, 2650, 281, 751, 466, 257, 857, 466, 577, 1340, 1985, 294, 51364], "temperature": 0.0, "avg_logprob": -0.12749253860627763, "compression_ratio": 1.6355932203389831, "no_speech_prob": 0.027981139719486237}, {"id": 32, "seek": 22556, "start": 245.56, "end": 249.12, "text": " Ruby and how you can, when you're debugging something and trying to figure", "tokens": [51364, 19907, 293, 577, 291, 393, 11, 562, 291, 434, 45592, 746, 293, 1382, 281, 2573, 51542], "temperature": 0.0, "avg_logprob": -0.12749253860627763, "compression_ratio": 1.6355932203389831, "no_speech_prob": 0.027981139719486237}, {"id": 33, "seek": 22556, "start": 249.12, "end": 253.2, "text": " out how something works, how you can go deeper into your code or someone else's", "tokens": [51542, 484, 577, 746, 1985, 11, 577, 291, 393, 352, 7731, 666, 428, 3089, 420, 1580, 1646, 311, 51746], "temperature": 0.0, "avg_logprob": -0.12749253860627763, "compression_ratio": 1.6355932203389831, "no_speech_prob": 0.027981139719486237}, {"id": 34, "seek": 25320, "start": 253.23999999999998, "end": 258.12, "text": " code. So if you're, for example, if you have a method that you've written or", "tokens": [50366, 3089, 13, 407, 498, 291, 434, 11, 337, 1365, 11, 498, 291, 362, 257, 3170, 300, 291, 600, 3720, 420, 50610], "temperature": 0.0, "avg_logprob": -0.1412543223454402, "compression_ratio": 1.781954887218045, "no_speech_prob": 0.021577974781394005}, {"id": 35, "seek": 25320, "start": 258.12, "end": 261.84, "text": " someone else has written and you don't know where it is, so let's say you're in", "tokens": [50610, 1580, 1646, 575, 3720, 293, 291, 500, 380, 458, 689, 309, 307, 11, 370, 718, 311, 584, 291, 434, 294, 50796], "temperature": 0.0, "avg_logprob": -0.1412543223454402, "compression_ratio": 1.781954887218045, "no_speech_prob": 0.021577974781394005}, {"id": 36, "seek": 25320, "start": 261.84, "end": 267.71999999999997, "text": " a big code base and you have 20 methods called, I don't know, count or show, and", "tokens": [50796, 257, 955, 3089, 3096, 293, 291, 362, 945, 7150, 1219, 11, 286, 500, 380, 458, 11, 1207, 420, 855, 11, 293, 51090], "temperature": 0.0, "avg_logprob": -0.1412543223454402, "compression_ratio": 1.781954887218045, "no_speech_prob": 0.021577974781394005}, {"id": 37, "seek": 25320, "start": 267.71999999999997, "end": 272.32, "text": " you don't know which one is being resolved. In Ruby, everything's an object,", "tokens": [51090, 291, 500, 380, 458, 597, 472, 307, 885, 20772, 13, 682, 19907, 11, 1203, 311, 364, 2657, 11, 51320], "temperature": 0.0, "avg_logprob": -0.1412543223454402, "compression_ratio": 1.781954887218045, "no_speech_prob": 0.021577974781394005}, {"id": 38, "seek": 25320, "start": 272.44, "end": 277.4, "text": " as you might have heard before. So, so are methods. And you can, on any instance", "tokens": [51326, 382, 291, 1062, 362, 2198, 949, 13, 407, 11, 370, 366, 7150, 13, 400, 291, 393, 11, 322, 604, 5197, 51574], "temperature": 0.0, "avg_logprob": -0.1412543223454402, "compression_ratio": 1.781954887218045, "no_speech_prob": 0.021577974781394005}, {"id": 39, "seek": 25320, "start": 277.4, "end": 282.32, "text": " of anything, call dot method, capture your method, and then you have access to", "tokens": [51574, 295, 1340, 11, 818, 5893, 3170, 11, 7983, 428, 3170, 11, 293, 550, 291, 362, 2105, 281, 51820], "temperature": 0.0, "avg_logprob": -0.1412543223454402, "compression_ratio": 1.781954887218045, "no_speech_prob": 0.021577974781394005}, {"id": 40, "seek": 28232, "start": 282.36, "end": 286.68, "text": " two methods that are pretty cool. One is called source location, which will tell", "tokens": [50366, 732, 7150, 300, 366, 1238, 1627, 13, 1485, 307, 1219, 4009, 4914, 11, 597, 486, 980, 50582], "temperature": 0.0, "avg_logprob": -0.1543572425842285, "compression_ratio": 1.7518796992481203, "no_speech_prob": 0.005639124661684036}, {"id": 41, "seek": 28232, "start": 286.68, "end": 290.71999999999997, "text": " you in which file it is. So interesting when you don't know which method is", "tokens": [50582, 291, 294, 597, 3991, 309, 307, 13, 407, 1880, 562, 291, 500, 380, 458, 597, 3170, 307, 50784], "temperature": 0.0, "avg_logprob": -0.1543572425842285, "compression_ratio": 1.7518796992481203, "no_speech_prob": 0.005639124661684036}, {"id": 42, "seek": 28232, "start": 290.71999999999997, "end": 295.24, "text": " being resolved. And another one is just dot source, which will print out the", "tokens": [50784, 885, 20772, 13, 400, 1071, 472, 307, 445, 5893, 4009, 11, 597, 486, 4482, 484, 264, 51010], "temperature": 0.0, "avg_logprob": -0.1543572425842285, "compression_ratio": 1.7518796992481203, "no_speech_prob": 0.005639124661684036}, {"id": 43, "seek": 28232, "start": 295.24, "end": 301.24, "text": " source in your terminal. Just plain up. So that's interesting also. If you're", "tokens": [51010, 4009, 294, 428, 14709, 13, 1449, 11121, 493, 13, 407, 300, 311, 1880, 611, 13, 759, 291, 434, 51310], "temperature": 0.0, "avg_logprob": -0.1543572425842285, "compression_ratio": 1.7518796992481203, "no_speech_prob": 0.005639124661684036}, {"id": 44, "seek": 28232, "start": 301.24, "end": 306.88, "text": " looking for something more lower level, so a Ruby method, like array.last or", "tokens": [51310, 1237, 337, 746, 544, 3126, 1496, 11, 370, 257, 19907, 3170, 11, 411, 10225, 13, 15459, 420, 51592], "temperature": 0.0, "avg_logprob": -0.1543572425842285, "compression_ratio": 1.7518796992481203, "no_speech_prob": 0.005639124661684036}, {"id": 45, "seek": 28232, "start": 307.08, "end": 310.88, "text": " integer.next, and you don't know how it works and you don't know where to go,", "tokens": [51602, 24922, 13, 716, 734, 11, 293, 291, 500, 380, 458, 577, 309, 1985, 293, 291, 500, 380, 458, 689, 281, 352, 11, 51792], "temperature": 0.0, "avg_logprob": -0.1543572425842285, "compression_ratio": 1.7518796992481203, "no_speech_prob": 0.005639124661684036}, {"id": 46, "seek": 31088, "start": 311.84, "end": 315.76, "text": " you're kind of stuck. You're going to have to go read the fabulous manual of", "tokens": [50412, 291, 434, 733, 295, 5541, 13, 509, 434, 516, 281, 362, 281, 352, 1401, 264, 17692, 9688, 295, 50608], "temperature": 0.0, "avg_logprob": -0.1926924504271341, "compression_ratio": 1.7336244541484715, "no_speech_prob": 0.003271479159593582}, {"id": 47, "seek": 31088, "start": 315.76, "end": 322.48, "text": " Ruby to figure out where it is. But in our case, we're kind of one level deeper", "tokens": [50608, 19907, 281, 2573, 484, 689, 309, 307, 13, 583, 294, 527, 1389, 11, 321, 434, 733, 295, 472, 1496, 7731, 50944], "temperature": 0.0, "avg_logprob": -0.1926924504271341, "compression_ratio": 1.7336244541484715, "no_speech_prob": 0.003271479159593582}, {"id": 48, "seek": 31088, "start": 322.48, "end": 327.36, "text": " because we're not looking at a Ruby method, we're looking at a Ruby keyword. So", "tokens": [50944, 570, 321, 434, 406, 1237, 412, 257, 19907, 3170, 11, 321, 434, 1237, 412, 257, 19907, 20428, 13, 407, 51188], "temperature": 0.0, "avg_logprob": -0.1926924504271341, "compression_ratio": 1.7336244541484715, "no_speech_prob": 0.003271479159593582}, {"id": 49, "seek": 31088, "start": 327.36, "end": 331.92, "text": " you, if you go to the documentation, you're going to find how it behaves, but", "tokens": [51188, 291, 11, 498, 291, 352, 281, 264, 14333, 11, 291, 434, 516, 281, 915, 577, 309, 36896, 11, 457, 51416], "temperature": 0.0, "avg_logprob": -0.1926924504271341, "compression_ratio": 1.7336244541484715, "no_speech_prob": 0.003271479159593582}, {"id": 50, "seek": 31088, "start": 331.92, "end": 337.32, "text": " you're not really going to be able to see the source code per se. So in this case,", "tokens": [51416, 291, 434, 406, 534, 516, 281, 312, 1075, 281, 536, 264, 4009, 3089, 680, 369, 13, 407, 294, 341, 1389, 11, 51686], "temperature": 0.0, "avg_logprob": -0.1926924504271341, "compression_ratio": 1.7336244541484715, "no_speech_prob": 0.003271479159593582}, {"id": 51, "seek": 33732, "start": 337.56, "end": 343.92, "text": " one way that I've used to figure out how the internals of case work is to go", "tokens": [50376, 472, 636, 300, 286, 600, 1143, 281, 2573, 484, 577, 264, 2154, 1124, 295, 1389, 589, 307, 281, 352, 50694], "temperature": 0.0, "avg_logprob": -0.10303147004382444, "compression_ratio": 1.6218487394957983, "no_speech_prob": 0.021930327638983727}, {"id": 52, "seek": 33732, "start": 343.92, "end": 350.44, "text": " look at the Ruby VM instructions. So big-ish caveat for the next couple of", "tokens": [50694, 574, 412, 264, 19907, 18038, 9415, 13, 407, 955, 12, 742, 43012, 337, 264, 958, 1916, 295, 51020], "temperature": 0.0, "avg_logprob": -0.10303147004382444, "compression_ratio": 1.6218487394957983, "no_speech_prob": 0.021930327638983727}, {"id": 53, "seek": 33732, "start": 350.44, "end": 354.71999999999997, "text": " slides. That's the very limit of what I'm trying to understand this year. I'm", "tokens": [51020, 9788, 13, 663, 311, 264, 588, 4948, 295, 437, 286, 478, 1382, 281, 1223, 341, 1064, 13, 286, 478, 51234], "temperature": 0.0, "avg_logprob": -0.10303147004382444, "compression_ratio": 1.6218487394957983, "no_speech_prob": 0.021930327638983727}, {"id": 54, "seek": 33732, "start": 354.71999999999997, "end": 359.08, "text": " kind of in that phase in my Ruby journey when I want to understand how things", "tokens": [51234, 733, 295, 294, 300, 5574, 294, 452, 19907, 4671, 562, 286, 528, 281, 1223, 577, 721, 51452], "temperature": 0.0, "avg_logprob": -0.10303147004382444, "compression_ratio": 1.6218487394957983, "no_speech_prob": 0.021930327638983727}, {"id": 55, "seek": 33732, "start": 359.08, "end": 366.96, "text": " work. So if I say something outrageous, stop me. So from my understanding, the", "tokens": [51452, 589, 13, 407, 498, 286, 584, 746, 38685, 11, 1590, 385, 13, 407, 490, 452, 3701, 11, 264, 51846], "temperature": 0.0, "avg_logprob": -0.10303147004382444, "compression_ratio": 1.6218487394957983, "no_speech_prob": 0.021930327638983727}, {"id": 56, "seek": 36696, "start": 367.0, "end": 371.71999999999997, "text": " Ruby code that you write goes through a journey before it is compiled and", "tokens": [50366, 19907, 3089, 300, 291, 2464, 1709, 807, 257, 4671, 949, 309, 307, 36548, 293, 50602], "temperature": 0.0, "avg_logprob": -0.1283702254295349, "compression_ratio": 1.7434782608695651, "no_speech_prob": 0.0035363328643143177}, {"id": 57, "seek": 36696, "start": 371.71999999999997, "end": 377.2, "text": " interpreted. So your Ruby code first gets turned into tokens. So for example, you", "tokens": [50602, 26749, 13, 407, 428, 19907, 3089, 700, 2170, 3574, 666, 22667, 13, 407, 337, 1365, 11, 291, 50876], "temperature": 0.0, "avg_logprob": -0.1283702254295349, "compression_ratio": 1.7434782608695651, "no_speech_prob": 0.0035363328643143177}, {"id": 58, "seek": 36696, "start": 377.2, "end": 384.47999999999996, "text": " can imagine that your entire program gets turned into a big array of syntactically", "tokens": [50876, 393, 3811, 300, 428, 2302, 1461, 2170, 3574, 666, 257, 955, 10225, 295, 23980, 578, 984, 51240], "temperature": 0.0, "avg_logprob": -0.1283702254295349, "compression_ratio": 1.7434782608695651, "no_speech_prob": 0.0035363328643143177}, {"id": 59, "seek": 36696, "start": 384.47999999999996, "end": 388.84, "text": " relevant stuff. So that could be depth, for example, or an open parenthesis or a", "tokens": [51240, 7340, 1507, 13, 407, 300, 727, 312, 7161, 11, 337, 1365, 11, 420, 364, 1269, 23350, 9374, 420, 257, 51458], "temperature": 0.0, "avg_logprob": -0.1283702254295349, "compression_ratio": 1.7434782608695651, "no_speech_prob": 0.0035363328643143177}, {"id": 60, "seek": 36696, "start": 388.84, "end": 394.79999999999995, "text": " space or part of a string. So everything gets turned into a token. And then those", "tokens": [51458, 1901, 420, 644, 295, 257, 6798, 13, 407, 1203, 2170, 3574, 666, 257, 14862, 13, 400, 550, 729, 51756], "temperature": 0.0, "avg_logprob": -0.1283702254295349, "compression_ratio": 1.7434782608695651, "no_speech_prob": 0.0035363328643143177}, {"id": 61, "seek": 39480, "start": 394.84000000000003, "end": 399.52000000000004, "text": " token get organized into something called an AST, which is an abstract syntax", "tokens": [50366, 14862, 483, 9983, 666, 746, 1219, 364, 316, 6840, 11, 597, 307, 364, 12649, 28431, 50600], "temperature": 0.0, "avg_logprob": -0.15720742647765112, "compression_ratio": 1.750915750915751, "no_speech_prob": 0.020313793793320656}, {"id": 62, "seek": 39480, "start": 399.52000000000004, "end": 404.68, "text": " tree, which is really hard to say. And basically what an AST is, is that big", "tokens": [50600, 4230, 11, 597, 307, 534, 1152, 281, 584, 13, 400, 1936, 437, 364, 316, 6840, 307, 11, 307, 300, 955, 50858], "temperature": 0.0, "avg_logprob": -0.15720742647765112, "compression_ratio": 1.750915750915751, "no_speech_prob": 0.020313793793320656}, {"id": 63, "seek": 39480, "start": 404.68, "end": 409.84000000000003, "text": " array, but formatted into something that is more understandable. So if anyone has", "tokens": [50858, 10225, 11, 457, 1254, 32509, 666, 746, 300, 307, 544, 25648, 13, 407, 498, 2878, 575, 51116], "temperature": 0.0, "avg_logprob": -0.15720742647765112, "compression_ratio": 1.750915750915751, "no_speech_prob": 0.020313793793320656}, {"id": 64, "seek": 39480, "start": 409.84000000000003, "end": 415.16, "text": " ever played with RuboCop before, that's probably where you've seen something", "tokens": [51116, 1562, 3737, 365, 10518, 78, 34, 404, 949, 11, 300, 311, 1391, 689, 291, 600, 1612, 746, 51382], "temperature": 0.0, "avg_logprob": -0.15720742647765112, "compression_ratio": 1.750915750915751, "no_speech_prob": 0.020313793793320656}, {"id": 65, "seek": 39480, "start": 415.16, "end": 418.52, "text": " like that, because you have to play with syntax tree, which you want to write your", "tokens": [51382, 411, 300, 11, 570, 291, 362, 281, 862, 365, 28431, 4230, 11, 597, 291, 528, 281, 2464, 428, 51550], "temperature": 0.0, "avg_logprob": -0.15720742647765112, "compression_ratio": 1.750915750915751, "no_speech_prob": 0.020313793793320656}, {"id": 66, "seek": 39480, "start": 418.52, "end": 424.04, "text": " own cops. So the tree is composed of a lot of nodes, and each node has a name. So", "tokens": [51550, 1065, 19012, 13, 407, 264, 4230, 307, 18204, 295, 257, 688, 295, 13891, 11, 293, 1184, 9984, 575, 257, 1315, 13, 407, 51826], "temperature": 0.0, "avg_logprob": -0.15720742647765112, "compression_ratio": 1.750915750915751, "no_speech_prob": 0.020313793793320656}, {"id": 67, "seek": 42404, "start": 424.08000000000004, "end": 428.88, "text": " you have a class node or a method node or a begin node. And then inside the node,", "tokens": [50366, 291, 362, 257, 1508, 9984, 420, 257, 3170, 9984, 420, 257, 1841, 9984, 13, 400, 550, 1854, 264, 9984, 11, 50606], "temperature": 0.0, "avg_logprob": -0.11937273163156412, "compression_ratio": 1.6624472573839661, "no_speech_prob": 0.001867196406237781}, {"id": 68, "seek": 42404, "start": 428.88, "end": 432.64000000000004, "text": " you have all relevant information for that specific class or method or begin", "tokens": [50606, 291, 362, 439, 7340, 1589, 337, 300, 2685, 1508, 420, 3170, 420, 1841, 50794], "temperature": 0.0, "avg_logprob": -0.11937273163156412, "compression_ratio": 1.6624472573839661, "no_speech_prob": 0.001867196406237781}, {"id": 69, "seek": 42404, "start": 432.64000000000004, "end": 440.76, "text": " block or anything. And then all of those, all that tree gets turned into virtual", "tokens": [50794, 3461, 420, 1340, 13, 400, 550, 439, 295, 729, 11, 439, 300, 4230, 2170, 3574, 666, 6374, 51200], "temperature": 0.0, "avg_logprob": -0.11937273163156412, "compression_ratio": 1.6624472573839661, "no_speech_prob": 0.001867196406237781}, {"id": 70, "seek": 42404, "start": 440.76, "end": 445.16, "text": " machine instructions. So that's the part where I think this, what I'm going to", "tokens": [51200, 3479, 9415, 13, 407, 300, 311, 264, 644, 689, 286, 519, 341, 11, 437, 286, 478, 516, 281, 51420], "temperature": 0.0, "avg_logprob": -0.11937273163156412, "compression_ratio": 1.6624472573839661, "no_speech_prob": 0.001867196406237781}, {"id": 71, "seek": 42404, "start": 445.16, "end": 451.20000000000005, "text": " talk about probably only work on C Ruby. I'm not sure this applies to other", "tokens": [51420, 751, 466, 1391, 787, 589, 322, 383, 19907, 13, 286, 478, 406, 988, 341, 13165, 281, 661, 51722], "temperature": 0.0, "avg_logprob": -0.11937273163156412, "compression_ratio": 1.6624472573839661, "no_speech_prob": 0.001867196406237781}, {"id": 72, "seek": 45120, "start": 451.24, "end": 456.0, "text": " implementations of Ruby, like Truffle or JRuby. It probably works a bit", "tokens": [50366, 4445, 763, 295, 19907, 11, 411, 21388, 602, 306, 420, 32849, 836, 88, 13, 467, 1391, 1985, 257, 857, 50604], "temperature": 0.0, "avg_logprob": -0.15852953966926125, "compression_ratio": 1.5245098039215685, "no_speech_prob": 0.001781770959496498}, {"id": 73, "seek": 45120, "start": 456.0, "end": 464.76, "text": " differently. So if we look at the case that we're looking at before, and in the", "tokens": [50604, 7614, 13, 407, 498, 321, 574, 412, 264, 1389, 300, 321, 434, 1237, 412, 949, 11, 293, 294, 264, 51042], "temperature": 0.0, "avg_logprob": -0.15852953966926125, "compression_ratio": 1.5245098039215685, "no_speech_prob": 0.001781770959496498}, {"id": 74, "seek": 45120, "start": 464.76, "end": 469.68, "text": " Ruby console, you have a class called RubyVM, which gives you access to any tool", "tokens": [51042, 19907, 11076, 11, 291, 362, 257, 1508, 1219, 19907, 53, 44, 11, 597, 2709, 291, 2105, 281, 604, 2290, 51288], "temperature": 0.0, "avg_logprob": -0.15852953966926125, "compression_ratio": 1.5245098039215685, "no_speech_prob": 0.001781770959496498}, {"id": 75, "seek": 45120, "start": 469.68, "end": 474.15999999999997, "text": " you might want to, to turn your code into either the tokens or the tree or the", "tokens": [51288, 291, 1062, 528, 281, 11, 281, 1261, 428, 3089, 666, 2139, 264, 22667, 420, 264, 4230, 420, 264, 51512], "temperature": 0.0, "avg_logprob": -0.15852953966926125, "compression_ratio": 1.5245098039215685, "no_speech_prob": 0.001781770959496498}, {"id": 76, "seek": 47416, "start": 474.16, "end": 481.40000000000003, "text": " instructions. You can end up with all of this, which we're going to try and go", "tokens": [50364, 9415, 13, 509, 393, 917, 493, 365, 439, 295, 341, 11, 597, 321, 434, 516, 281, 853, 293, 352, 50726], "temperature": 0.0, "avg_logprob": -0.1890541472524967, "compression_ratio": 1.6556016597510372, "no_speech_prob": 0.11111720651388168}, {"id": 77, "seek": 47416, "start": 481.40000000000003, "end": 488.12, "text": " through in some kind. So first of all, in case you've never used it, the Ruby", "tokens": [50726, 807, 294, 512, 733, 13, 407, 700, 295, 439, 11, 294, 1389, 291, 600, 1128, 1143, 309, 11, 264, 19907, 51062], "temperature": 0.0, "avg_logprob": -0.1890541472524967, "compression_ratio": 1.6556016597510372, "no_speech_prob": 0.11111720651388168}, {"id": 78, "seek": 47416, "start": 488.12, "end": 493.92, "text": " virtual machine, the one from C Ruby is a stack based VM. So interact, everything", "tokens": [51062, 6374, 3479, 11, 264, 472, 490, 383, 19907, 307, 257, 8630, 2361, 18038, 13, 407, 4648, 11, 1203, 51352], "temperature": 0.0, "avg_logprob": -0.1890541472524967, "compression_ratio": 1.6556016597510372, "no_speech_prob": 0.11111720651388168}, {"id": 79, "seek": 47416, "start": 493.92, "end": 498.72, "text": " in the VM is a stack. So you end up, you have a lot of instruction here that just", "tokens": [51352, 294, 264, 18038, 307, 257, 8630, 13, 407, 291, 917, 493, 11, 291, 362, 257, 688, 295, 10951, 510, 300, 445, 51592], "temperature": 0.0, "avg_logprob": -0.1890541472524967, "compression_ratio": 1.6556016597510372, "no_speech_prob": 0.11111720651388168}, {"id": 80, "seek": 47416, "start": 498.72, "end": 502.84000000000003, "text": " interact with the stack. Like the put object over there just puts an object on", "tokens": [51592, 4648, 365, 264, 8630, 13, 1743, 264, 829, 2657, 670, 456, 445, 8137, 364, 2657, 322, 51798], "temperature": 0.0, "avg_logprob": -0.1890541472524967, "compression_ratio": 1.6556016597510372, "no_speech_prob": 0.11111720651388168}, {"id": 81, "seek": 50284, "start": 502.88, "end": 507.11999999999995, "text": " the stack, the top end finds an object and then moves it to the top of the stack.", "tokens": [50366, 264, 8630, 11, 264, 1192, 917, 10704, 364, 2657, 293, 550, 6067, 309, 281, 264, 1192, 295, 264, 8630, 13, 50578], "temperature": 0.0, "avg_logprob": -0.15309488205682664, "compression_ratio": 1.8045454545454545, "no_speech_prob": 0.006484874524176121}, {"id": 82, "seek": 50284, "start": 507.11999999999995, "end": 513.64, "text": " And you have a lot of things like that. So in our case, if we look in detail, we", "tokens": [50578, 400, 291, 362, 257, 688, 295, 721, 411, 300, 13, 407, 294, 527, 1389, 11, 498, 321, 574, 294, 2607, 11, 321, 50904], "temperature": 0.0, "avg_logprob": -0.15309488205682664, "compression_ratio": 1.8045454545454545, "no_speech_prob": 0.006484874524176121}, {"id": 83, "seek": 50284, "start": 513.64, "end": 519.4399999999999, "text": " can see a few things. So first of all, here we're mainly preparing the stack and", "tokens": [50904, 393, 536, 257, 1326, 721, 13, 407, 700, 295, 439, 11, 510, 321, 434, 8704, 10075, 264, 8630, 293, 51194], "temperature": 0.0, "avg_logprob": -0.15309488205682664, "compression_ratio": 1.8045454545454545, "no_speech_prob": 0.006484874524176121}, {"id": 84, "seek": 50284, "start": 519.4399999999999, "end": 523.36, "text": " here we have something, here we can find the status that we have over there. So", "tokens": [51194, 510, 321, 362, 746, 11, 510, 321, 393, 915, 264, 6558, 300, 321, 362, 670, 456, 13, 407, 51390], "temperature": 0.0, "avg_logprob": -0.15309488205682664, "compression_ratio": 1.8045454545454545, "no_speech_prob": 0.006484874524176121}, {"id": 85, "seek": 50284, "start": 523.36, "end": 527.28, "text": " this is basically calling status to fetch the value that we want to match", "tokens": [51390, 341, 307, 1936, 5141, 6558, 281, 23673, 264, 2158, 300, 321, 528, 281, 2995, 51586], "temperature": 0.0, "avg_logprob": -0.15309488205682664, "compression_ratio": 1.8045454545454545, "no_speech_prob": 0.006484874524176121}, {"id": 86, "seek": 52728, "start": 527.28, "end": 532.88, "text": " against. And under this, you have a Ruby optimization, a Ruby VM optimization", "tokens": [50364, 1970, 13, 400, 833, 341, 11, 291, 362, 257, 19907, 19618, 11, 257, 19907, 18038, 19618, 50644], "temperature": 0.0, "avg_logprob": -0.18675233941329153, "compression_ratio": 1.6695278969957081, "no_speech_prob": 0.028422342613339424}, {"id": 87, "seek": 52728, "start": 532.88, "end": 538.8399999999999, "text": " called case dispatch. What this does is in some cases, if you're using a simple", "tokens": [50644, 1219, 1389, 36729, 13, 708, 341, 775, 307, 294, 512, 3331, 11, 498, 291, 434, 1228, 257, 2199, 50942], "temperature": 0.0, "avg_logprob": -0.18675233941329153, "compression_ratio": 1.6695278969957081, "no_speech_prob": 0.028422342613339424}, {"id": 88, "seek": 52728, "start": 539.12, "end": 544.0799999999999, "text": " case with simple objects inside of it, like strings or integers or symbols or", "tokens": [50956, 1389, 365, 2199, 6565, 1854, 295, 309, 11, 411, 13985, 420, 41674, 420, 16944, 420, 51204], "temperature": 0.0, "avg_logprob": -0.18675233941329153, "compression_ratio": 1.6695278969957081, "no_speech_prob": 0.028422342613339424}, {"id": 89, "seek": 52728, "start": 544.0799999999999, "end": 549.28, "text": " stuff like that, what it will do is it will create a hash where the keys are", "tokens": [51204, 1507, 411, 300, 11, 437, 309, 486, 360, 307, 309, 486, 1884, 257, 22019, 689, 264, 9317, 366, 51464], "temperature": 0.0, "avg_logprob": -0.18675233941329153, "compression_ratio": 1.6695278969957081, "no_speech_prob": 0.028422342613339424}, {"id": 90, "seek": 52728, "start": 550.0799999999999, "end": 555.64, "text": " basically this and this and the values are the number of the line in your VM", "tokens": [51504, 1936, 341, 293, 341, 293, 264, 4190, 366, 264, 1230, 295, 264, 1622, 294, 428, 18038, 51782], "temperature": 0.0, "avg_logprob": -0.18675233941329153, "compression_ratio": 1.6695278969957081, "no_speech_prob": 0.028422342613339424}, {"id": 91, "seek": 55564, "start": 555.64, "end": 560.68, "text": " structure that you need to jump to. So what that means, at least the way I", "tokens": [50364, 3877, 300, 291, 643, 281, 3012, 281, 13, 407, 437, 300, 1355, 11, 412, 1935, 264, 636, 286, 50616], "temperature": 0.0, "avg_logprob": -0.17305830707700234, "compression_ratio": 1.8548387096774193, "no_speech_prob": 0.01824735291302204}, {"id": 92, "seek": 55564, "start": 560.68, "end": 565.88, "text": " understand it, is if you have a lot of if, else if, else if, else if, it will be", "tokens": [50616, 1223, 309, 11, 307, 498, 291, 362, 257, 688, 295, 498, 11, 1646, 498, 11, 1646, 498, 11, 1646, 498, 11, 309, 486, 312, 50876], "temperature": 0.0, "avg_logprob": -0.17305830707700234, "compression_ratio": 1.8548387096774193, "no_speech_prob": 0.01824735291302204}, {"id": 93, "seek": 55564, "start": 566.28, "end": 569.64, "text": " usually faster to build a case because you're losing some time here to build", "tokens": [50896, 2673, 4663, 281, 1322, 257, 1389, 570, 291, 434, 7027, 512, 565, 510, 281, 1322, 51064], "temperature": 0.0, "avg_logprob": -0.17305830707700234, "compression_ratio": 1.8548387096774193, "no_speech_prob": 0.01824735291302204}, {"id": 94, "seek": 55564, "start": 569.64, "end": 575.96, "text": " your hash. But then whatever case you want to go to, it's just a hash access.", "tokens": [51064, 428, 22019, 13, 583, 550, 2035, 1389, 291, 528, 281, 352, 281, 11, 309, 311, 445, 257, 22019, 2105, 13, 51380], "temperature": 0.0, "avg_logprob": -0.17305830707700234, "compression_ratio": 1.8548387096774193, "no_speech_prob": 0.01824735291302204}, {"id": 95, "seek": 55564, "start": 576.52, "end": 580.2, "text": " Whereas if you're doing a bunch of if and else if you have to go through each of", "tokens": [51408, 13813, 498, 291, 434, 884, 257, 3840, 295, 498, 293, 1646, 498, 291, 362, 281, 352, 807, 1184, 295, 51592], "temperature": 0.0, "avg_logprob": -0.17305830707700234, "compression_ratio": 1.8548387096774193, "no_speech_prob": 0.01824735291302204}, {"id": 96, "seek": 55564, "start": 580.2, "end": 583.3199999999999, "text": " them to see does this work or does this work or does this work, etc.", "tokens": [51592, 552, 281, 536, 775, 341, 589, 420, 775, 341, 589, 420, 775, 341, 589, 11, 5183, 13, 51748], "temperature": 0.0, "avg_logprob": -0.17305830707700234, "compression_ratio": 1.8548387096774193, "no_speech_prob": 0.01824735291302204}, {"id": 97, "seek": 58332, "start": 584.2800000000001, "end": 589.0, "text": " If we go a bit below, we can see what that would look like technically if we", "tokens": [50412, 759, 321, 352, 257, 857, 2507, 11, 321, 393, 536, 437, 300, 576, 574, 411, 12120, 498, 321, 50648], "temperature": 0.0, "avg_logprob": -0.14300307842216106, "compression_ratio": 1.6808510638297873, "no_speech_prob": 0.0006067981594242156}, {"id": 98, "seek": 58332, "start": 589.0, "end": 595.08, "text": " would need it to go through each of the branches to see which one works. So here", "tokens": [50648, 576, 643, 309, 281, 352, 807, 1184, 295, 264, 14770, 281, 536, 597, 472, 1985, 13, 407, 510, 50952], "temperature": 0.0, "avg_logprob": -0.14300307842216106, "compression_ratio": 1.6808510638297873, "no_speech_prob": 0.0006067981594242156}, {"id": 99, "seek": 58332, "start": 595.24, "end": 600.2800000000001, "text": " we have our success symbol, which was our first branch. And what this does is it", "tokens": [50960, 321, 362, 527, 2245, 5986, 11, 597, 390, 527, 700, 9819, 13, 400, 437, 341, 775, 307, 309, 51212], "temperature": 0.0, "avg_logprob": -0.14300307842216106, "compression_ratio": 1.6808510638297873, "no_speech_prob": 0.0006067981594242156}, {"id": 100, "seek": 58332, "start": 600.2800000000001, "end": 604.44, "text": " going to compare it to the status using the triple equal method. And that's the", "tokens": [51212, 516, 281, 6794, 309, 281, 264, 6558, 1228, 264, 15508, 2681, 3170, 13, 400, 300, 311, 264, 51420], "temperature": 0.0, "avg_logprob": -0.14300307842216106, "compression_ratio": 1.6808510638297873, "no_speech_prob": 0.0006067981594242156}, {"id": 101, "seek": 58332, "start": 604.44, "end": 607.8000000000001, "text": " cool part of case. That's technically what's doing the heavy lifting behind.", "tokens": [51420, 1627, 644, 295, 1389, 13, 663, 311, 12120, 437, 311, 884, 264, 4676, 15798, 2261, 13, 51588], "temperature": 0.0, "avg_logprob": -0.14300307842216106, "compression_ratio": 1.6808510638297873, "no_speech_prob": 0.0006067981594242156}, {"id": 102, "seek": 60780, "start": 608.5999999999999, "end": 614.92, "text": " And if that equal works, then it's going to jump to instruction 28 below. If it", "tokens": [50404, 400, 498, 300, 2681, 1985, 11, 550, 309, 311, 516, 281, 3012, 281, 10951, 7562, 2507, 13, 759, 309, 50720], "temperature": 0.0, "avg_logprob": -0.09637945089767229, "compression_ratio": 1.9123505976095618, "no_speech_prob": 0.033565815538167953}, {"id": 103, "seek": 60780, "start": 614.92, "end": 618.3599999999999, "text": " doesn't work, then it's going to keep going. So second branch is error. So we're", "tokens": [50720, 1177, 380, 589, 11, 550, 309, 311, 516, 281, 1066, 516, 13, 407, 1150, 9819, 307, 6713, 13, 407, 321, 434, 50892], "temperature": 0.0, "avg_logprob": -0.09637945089767229, "compression_ratio": 1.9123505976095618, "no_speech_prob": 0.033565815538167953}, {"id": 104, "seek": 60780, "start": 618.3599999999999, "end": 622.04, "text": " going to take error, put it on the stack, compare it to status. And if it doesn't,", "tokens": [50892, 516, 281, 747, 6713, 11, 829, 309, 322, 264, 8630, 11, 6794, 309, 281, 6558, 13, 400, 498, 309, 1177, 380, 11, 51076], "temperature": 0.0, "avg_logprob": -0.09637945089767229, "compression_ratio": 1.9123505976095618, "no_speech_prob": 0.033565815538167953}, {"id": 105, "seek": 60780, "start": 622.04, "end": 627.56, "text": " if it works, we go to 33. If none of those work, if you remember the case,", "tokens": [51076, 498, 309, 1985, 11, 321, 352, 281, 11816, 13, 759, 6022, 295, 729, 589, 11, 498, 291, 1604, 264, 1389, 11, 51352], "temperature": 0.0, "avg_logprob": -0.09637945089767229, "compression_ratio": 1.9123505976095618, "no_speech_prob": 0.033565815538167953}, {"id": 106, "seek": 60780, "start": 627.56, "end": 633.56, "text": " then that means we're in our error case or like our else, which is over there. So if", "tokens": [51352, 550, 300, 1355, 321, 434, 294, 527, 6713, 1389, 420, 411, 527, 1646, 11, 597, 307, 670, 456, 13, 407, 498, 51652], "temperature": 0.0, "avg_logprob": -0.09637945089767229, "compression_ratio": 1.9123505976095618, "no_speech_prob": 0.033565815538167953}, {"id": 107, "seek": 60780, "start": 633.56, "end": 637.4, "text": " none of those work, so we keep going down our instruction and we end up here", "tokens": [51652, 6022, 295, 729, 589, 11, 370, 321, 1066, 516, 760, 527, 10951, 293, 321, 917, 493, 510, 51844], "temperature": 0.0, "avg_logprob": -0.09637945089767229, "compression_ratio": 1.9123505976095618, "no_speech_prob": 0.033565815538167953}, {"id": 108, "seek": 63780, "start": 637.88, "end": 642.76, "text": " called the fail harder and then leave, which is instruction 28. And then under that,", "tokens": [50368, 1219, 264, 3061, 6081, 293, 550, 1856, 11, 597, 307, 10951, 7562, 13, 400, 550, 833, 300, 11, 50612], "temperature": 0.0, "avg_logprob": -0.11249076195482938, "compression_ratio": 1.878787878787879, "no_speech_prob": 0.0011334047885611653}, {"id": 109, "seek": 63780, "start": 642.76, "end": 648.1999999999999, "text": " then you have the lines that you would have jumped to if anything worked before. So the", "tokens": [50612, 550, 291, 362, 264, 3876, 300, 291, 576, 362, 13864, 281, 498, 1340, 2732, 949, 13, 407, 264, 50884], "temperature": 0.0, "avg_logprob": -0.11249076195482938, "compression_ratio": 1.878787878787879, "no_speech_prob": 0.0011334047885611653}, {"id": 110, "seek": 63780, "start": 648.1999999999999, "end": 653.3199999999999, "text": " 28 here, which will call the proceed and the 33, which will call the fail. So that's", "tokens": [50884, 7562, 510, 11, 597, 486, 818, 264, 8991, 293, 264, 11816, 11, 597, 486, 818, 264, 3061, 13, 407, 300, 311, 51140], "temperature": 0.0, "avg_logprob": -0.11249076195482938, "compression_ratio": 1.878787878787879, "no_speech_prob": 0.0011334047885611653}, {"id": 111, "seek": 63780, "start": 653.3199999999999, "end": 660.4399999999999, "text": " more or less the instruction patterns of a case. So that turned our question before,", "tokens": [51140, 544, 420, 1570, 264, 10951, 8294, 295, 257, 1389, 13, 407, 300, 3574, 527, 1168, 949, 11, 51496], "temperature": 0.0, "avg_logprob": -0.11249076195482938, "compression_ratio": 1.878787878787879, "no_speech_prob": 0.0011334047885611653}, {"id": 112, "seek": 63780, "start": 660.4399999999999, "end": 665.4799999999999, "text": " answers our question before, right, of how a case works. And the simplest answer that I can", "tokens": [51496, 6338, 527, 1168, 949, 11, 558, 11, 295, 577, 257, 1389, 1985, 13, 400, 264, 22811, 1867, 300, 286, 393, 51748], "temperature": 0.0, "avg_logprob": -0.11249076195482938, "compression_ratio": 1.878787878787879, "no_speech_prob": 0.0011334047885611653}, {"id": 113, "seek": 66548, "start": 665.48, "end": 669.5600000000001, "text": " give it, it works thanks to triple equal. That's what it's going to use to match everything", "tokens": [50364, 976, 309, 11, 309, 1985, 3231, 281, 15508, 2681, 13, 663, 311, 437, 309, 311, 516, 281, 764, 281, 2995, 1203, 50568], "temperature": 0.0, "avg_logprob": -0.07632990141172667, "compression_ratio": 1.7706766917293233, "no_speech_prob": 0.02840925008058548}, {"id": 114, "seek": 66548, "start": 669.5600000000001, "end": 675.88, "text": " against everything. So if we wanted to push case to the limit, the question that we want to answer", "tokens": [50568, 1970, 1203, 13, 407, 498, 321, 1415, 281, 2944, 1389, 281, 264, 4948, 11, 264, 1168, 300, 321, 528, 281, 1867, 50884], "temperature": 0.0, "avg_logprob": -0.07632990141172667, "compression_ratio": 1.7706766917293233, "no_speech_prob": 0.02840925008058548}, {"id": 115, "seek": 66548, "start": 675.88, "end": 683.4, "text": " now is what does implement triple equal? And in Ruby, that's a bunch of classes. And the", "tokens": [50884, 586, 307, 437, 775, 4445, 15508, 2681, 30, 400, 294, 19907, 11, 300, 311, 257, 3840, 295, 5359, 13, 400, 264, 51260], "temperature": 0.0, "avg_logprob": -0.07632990141172667, "compression_ratio": 1.7706766917293233, "no_speech_prob": 0.02840925008058548}, {"id": 116, "seek": 66548, "start": 683.4, "end": 687.48, "text": " interesting thing and the main reason I wanted to do that presentation is that depending on what", "tokens": [51260, 1880, 551, 293, 264, 2135, 1778, 286, 1415, 281, 360, 300, 5860, 307, 300, 5413, 322, 437, 51464], "temperature": 0.0, "avg_logprob": -0.07632990141172667, "compression_ratio": 1.7706766917293233, "no_speech_prob": 0.02840925008058548}, {"id": 117, "seek": 66548, "start": 687.48, "end": 694.36, "text": " you're calling triple equal on, it will behave differently. So the simplest example that we've", "tokens": [51464, 291, 434, 5141, 15508, 2681, 322, 11, 309, 486, 15158, 7614, 13, 407, 264, 22811, 1365, 300, 321, 600, 51808], "temperature": 0.0, "avg_logprob": -0.07632990141172667, "compression_ratio": 1.7706766917293233, "no_speech_prob": 0.02840925008058548}, {"id": 118, "seek": 69436, "start": 694.44, "end": 701.16, "text": " all used is all the base classes. So string strings, integers, float, arrays, hashes,", "tokens": [50368, 439, 1143, 307, 439, 264, 3096, 5359, 13, 407, 6798, 13985, 11, 41674, 11, 15706, 11, 41011, 11, 575, 8076, 11, 50704], "temperature": 0.0, "avg_logprob": -0.11083154289089904, "compression_ratio": 1.5964912280701755, "no_speech_prob": 0.006384334526956081}, {"id": 119, "seek": 69436, "start": 701.72, "end": 707.5600000000001, "text": " anything you want. And in this case, it checks for equality. So that's the thing we've seen", "tokens": [50732, 1340, 291, 528, 13, 400, 294, 341, 1389, 11, 309, 13834, 337, 14949, 13, 407, 300, 311, 264, 551, 321, 600, 1612, 51024], "temperature": 0.0, "avg_logprob": -0.11083154289089904, "compression_ratio": 1.5964912280701755, "no_speech_prob": 0.006384334526956081}, {"id": 120, "seek": 69436, "start": 707.5600000000001, "end": 715.8000000000001, "text": " before. You might have seen that code. You get a param that has a response and then you don't", "tokens": [51024, 949, 13, 509, 1062, 362, 1612, 300, 3089, 13, 509, 483, 257, 6220, 300, 575, 257, 4134, 293, 550, 291, 500, 380, 51436], "temperature": 0.0, "avg_logprob": -0.11083154289089904, "compression_ratio": 1.5964912280701755, "no_speech_prob": 0.006384334526956081}, {"id": 121, "seek": 69436, "start": 715.8000000000001, "end": 720.52, "text": " know what the fuck the other person in the API has done, whether it's a string or a 200 or a", "tokens": [51436, 458, 437, 264, 3275, 264, 661, 954, 294, 264, 9362, 575, 1096, 11, 1968, 309, 311, 257, 6798, 420, 257, 2331, 420, 257, 51672], "temperature": 0.0, "avg_logprob": -0.11083154289089904, "compression_ratio": 1.5964912280701755, "no_speech_prob": 0.006384334526956081}, {"id": 122, "seek": 72052, "start": 720.52, "end": 726.1999999999999, "text": " success or a string or a true or true as a string or anything. So you do your case and you match it", "tokens": [50364, 2245, 420, 257, 6798, 420, 257, 2074, 420, 2074, 382, 257, 6798, 420, 1340, 13, 407, 291, 360, 428, 1389, 293, 291, 2995, 309, 50648], "temperature": 0.0, "avg_logprob": -0.07551827706581304, "compression_ratio": 1.8521400778210118, "no_speech_prob": 0.006486631464213133}, {"id": 123, "seek": 72052, "start": 726.1999999999999, "end": 731.64, "text": " against whatever and try to figure out. So in this case, it's always going to check for equality.", "tokens": [50648, 1970, 2035, 293, 853, 281, 2573, 484, 13, 407, 294, 341, 1389, 11, 309, 311, 1009, 516, 281, 1520, 337, 14949, 13, 50920], "temperature": 0.0, "avg_logprob": -0.07551827706581304, "compression_ratio": 1.8521400778210118, "no_speech_prob": 0.006486631464213133}, {"id": 124, "seek": 72052, "start": 731.64, "end": 735.48, "text": " So here with the come out that we've seen before, it's one or the other or the other.", "tokens": [50920, 407, 510, 365, 264, 808, 484, 300, 321, 600, 1612, 949, 11, 309, 311, 472, 420, 264, 661, 420, 264, 661, 13, 51112], "temperature": 0.0, "avg_logprob": -0.07551827706581304, "compression_ratio": 1.8521400778210118, "no_speech_prob": 0.006486631464213133}, {"id": 125, "seek": 72052, "start": 736.52, "end": 743.48, "text": " And then you have arrays, you have hashes. Otherwise, yes, you can give up. Another thing", "tokens": [51164, 400, 550, 291, 362, 41011, 11, 291, 362, 575, 8076, 13, 10328, 11, 2086, 11, 291, 393, 976, 493, 13, 3996, 551, 51512], "temperature": 0.0, "avg_logprob": -0.07551827706581304, "compression_ratio": 1.8521400778210118, "no_speech_prob": 0.006486631464213133}, {"id": 126, "seek": 72052, "start": 743.48, "end": 749.0, "text": " that implements triple equal with another behavior are classes and modules. On classes and on modules,", "tokens": [51512, 300, 704, 17988, 15508, 2681, 365, 1071, 5223, 366, 5359, 293, 16679, 13, 1282, 5359, 293, 322, 16679, 11, 51788], "temperature": 0.0, "avg_logprob": -0.07551827706581304, "compression_ratio": 1.8521400778210118, "no_speech_prob": 0.006486631464213133}, {"id": 127, "seek": 74900, "start": 749.56, "end": 755.4, "text": " triple equal checks for, I don't really know how to say it in one word, checks for type,", "tokens": [50392, 15508, 2681, 13834, 337, 11, 286, 500, 380, 534, 458, 577, 281, 584, 309, 294, 472, 1349, 11, 13834, 337, 2010, 11, 50684], "temperature": 0.0, "avg_logprob": -0.10138733203594501, "compression_ratio": 1.7275985663082438, "no_speech_prob": 0.0037063881754875183}, {"id": 128, "seek": 74900, "start": 755.4, "end": 761.32, "text": " for ancestry. It's a bit like the is a method of Ruby. So when you have an object and you call is", "tokens": [50684, 337, 44729, 13, 467, 311, 257, 857, 411, 264, 307, 257, 3170, 295, 19907, 13, 407, 562, 291, 362, 364, 2657, 293, 291, 818, 307, 50980], "temperature": 0.0, "avg_logprob": -0.10138733203594501, "compression_ratio": 1.7275985663082438, "no_speech_prob": 0.0037063881754875183}, {"id": 129, "seek": 74900, "start": 762.2, "end": 766.84, "text": " my dog an animal, it's not only going to check the class, it's going to check a bit above to see if", "tokens": [51024, 452, 3000, 364, 5496, 11, 309, 311, 406, 787, 516, 281, 1520, 264, 1508, 11, 309, 311, 516, 281, 1520, 257, 857, 3673, 281, 536, 498, 51256], "temperature": 0.0, "avg_logprob": -0.10138733203594501, "compression_ratio": 1.7275985663082438, "no_speech_prob": 0.0037063881754875183}, {"id": 130, "seek": 74900, "start": 766.84, "end": 771.8, "text": " animal is included in it if you're going composition way or if it inherits from animal, if you're", "tokens": [51256, 5496, 307, 5556, 294, 309, 498, 291, 434, 516, 12686, 636, 420, 498, 309, 9484, 1208, 490, 5496, 11, 498, 291, 434, 51504], "temperature": 0.0, "avg_logprob": -0.10138733203594501, "compression_ratio": 1.7275985663082438, "no_speech_prob": 0.0037063881754875183}, {"id": 131, "seek": 74900, "start": 771.8, "end": 777.16, "text": " going the inheritance way. And that's more or less what we can do here, for example, with errors.", "tokens": [51504, 516, 264, 32122, 636, 13, 400, 300, 311, 544, 420, 1570, 437, 321, 393, 360, 510, 11, 337, 1365, 11, 365, 13603, 13, 51772], "temperature": 0.0, "avg_logprob": -0.10138733203594501, "compression_ratio": 1.7275985663082438, "no_speech_prob": 0.0037063881754875183}, {"id": 132, "seek": 77716, "start": 777.16, "end": 783.88, "text": " So I say you have your code and you've defined a bunch of different types of errors. And you've", "tokens": [50364, 407, 286, 584, 291, 362, 428, 3089, 293, 291, 600, 7642, 257, 3840, 295, 819, 3467, 295, 13603, 13, 400, 291, 600, 50700], "temperature": 0.0, "avg_logprob": -0.12364085775906922, "compression_ratio": 1.7769230769230768, "no_speech_prob": 0.0015726132551208138}, {"id": 133, "seek": 77716, "start": 783.88, "end": 789.4, "text": " tagged some of them maybe as ignorable. So if it returns any errors that's in that type, then I", "tokens": [50700, 40239, 512, 295, 552, 1310, 382, 14698, 712, 13, 407, 498, 309, 11247, 604, 13603, 300, 311, 294, 300, 2010, 11, 550, 286, 50976], "temperature": 0.0, "avg_logprob": -0.12364085775906922, "compression_ratio": 1.7769230769230768, "no_speech_prob": 0.0015726132551208138}, {"id": 134, "seek": 77716, "start": 789.4, "end": 795.64, "text": " want to ignore them. If it returns those two different errors, I want to return a not found.", "tokens": [50976, 528, 281, 11200, 552, 13, 759, 309, 11247, 729, 732, 819, 13603, 11, 286, 528, 281, 2736, 257, 406, 1352, 13, 51288], "temperature": 0.0, "avg_logprob": -0.12364085775906922, "compression_ratio": 1.7769230769230768, "no_speech_prob": 0.0015726132551208138}, {"id": 135, "seek": 77716, "start": 795.64, "end": 802.04, "text": " If someone forgot about safe navigation, I want to tell them. And then a lot of errors, for example,", "tokens": [51288, 759, 1580, 5298, 466, 3273, 17346, 11, 286, 528, 281, 980, 552, 13, 400, 550, 257, 688, 295, 13603, 11, 337, 1365, 11, 51608], "temperature": 0.0, "avg_logprob": -0.12364085775906922, "compression_ratio": 1.7769230769230768, "no_speech_prob": 0.0015726132551208138}, {"id": 136, "seek": 77716, "start": 802.04, "end": 805.56, "text": " in Rails, and I'm assuming in Ruby, not entirely sure, don't put me on that,", "tokens": [51608, 294, 48526, 11, 293, 286, 478, 11926, 294, 19907, 11, 406, 7696, 988, 11, 500, 380, 829, 385, 322, 300, 11, 51784], "temperature": 0.0, "avg_logprob": -0.12364085775906922, "compression_ratio": 1.7769230769230768, "no_speech_prob": 0.0015726132551208138}, {"id": 137, "seek": 80556, "start": 806.3599999999999, "end": 811.64, "text": " inherit from standard error. And so those maybe you want to raise, but if you have something else,", "tokens": [50404, 21389, 490, 3832, 6713, 13, 400, 370, 729, 1310, 291, 528, 281, 5300, 11, 457, 498, 291, 362, 746, 1646, 11, 50668], "temperature": 0.0, "avg_logprob": -0.142835487018932, "compression_ratio": 1.6912442396313363, "no_speech_prob": 0.0009696169872768223}, {"id": 138, "seek": 80556, "start": 812.3599999999999, "end": 816.76, "text": " then that's probably a lower level, maybe a PG error if you're dealing with a database,", "tokens": [50704, 550, 300, 311, 1391, 257, 3126, 1496, 11, 1310, 257, 40975, 6713, 498, 291, 434, 6260, 365, 257, 8149, 11, 50924], "temperature": 0.0, "avg_logprob": -0.142835487018932, "compression_ratio": 1.6912442396313363, "no_speech_prob": 0.0009696169872768223}, {"id": 139, "seek": 80556, "start": 816.76, "end": 822.3599999999999, "text": " and then you want to do something else. So that's it for classes and modules. Another", "tokens": [50924, 293, 550, 291, 528, 281, 360, 746, 1646, 13, 407, 300, 311, 309, 337, 5359, 293, 16679, 13, 3996, 51204], "temperature": 0.0, "avg_logprob": -0.142835487018932, "compression_ratio": 1.6912442396313363, "no_speech_prob": 0.0009696169872768223}, {"id": 140, "seek": 80556, "start": 823.64, "end": 829.4799999999999, "text": " class, another type of classes that implement triple equal or ranges that I'm assuming most of", "tokens": [51268, 1508, 11, 1071, 2010, 295, 5359, 300, 4445, 15508, 2681, 420, 22526, 300, 286, 478, 11926, 881, 295, 51560], "temperature": 0.0, "avg_logprob": -0.142835487018932, "compression_ratio": 1.6912442396313363, "no_speech_prob": 0.0009696169872768223}, {"id": 141, "seek": 82948, "start": 830.28, "end": 835.88, "text": " most of us have already used that check for inclusion. So for example, if you have", "tokens": [50404, 881, 295, 505, 362, 1217, 1143, 300, 1520, 337, 15874, 13, 407, 337, 1365, 11, 498, 291, 362, 50684], "temperature": 0.0, "avg_logprob": -0.1321675181388855, "compression_ratio": 1.6682027649769586, "no_speech_prob": 0.010980036109685898}, {"id": 142, "seek": 82948, "start": 836.6, "end": 841.16, "text": " an integer at the top, then you can check that it's included in this range or this range. And it", "tokens": [50720, 364, 24922, 412, 264, 1192, 11, 550, 291, 393, 1520, 300, 309, 311, 5556, 294, 341, 3613, 420, 341, 3613, 13, 400, 309, 50948], "temperature": 0.0, "avg_logprob": -0.1321675181388855, "compression_ratio": 1.6682027649769586, "no_speech_prob": 0.010980036109685898}, {"id": 143, "seek": 82948, "start": 841.16, "end": 848.28, "text": " works with the endless ranges of Ruby. So you can be very, I mean, this might as well use an if", "tokens": [50948, 1985, 365, 264, 16144, 22526, 295, 19907, 13, 407, 291, 393, 312, 588, 11, 286, 914, 11, 341, 1062, 382, 731, 764, 364, 498, 51304], "temperature": 0.0, "avg_logprob": -0.1321675181388855, "compression_ratio": 1.6682027649769586, "no_speech_prob": 0.010980036109685898}, {"id": 144, "seek": 82948, "start": 848.28, "end": 852.12, "text": " else if and just check that it's greater or lower than, but it's good to have options.", "tokens": [51304, 1646, 498, 293, 445, 1520, 300, 309, 311, 5044, 420, 3126, 813, 11, 457, 309, 311, 665, 281, 362, 3956, 13, 51496], "temperature": 0.0, "avg_logprob": -0.1321675181388855, "compression_ratio": 1.6682027649769586, "no_speech_prob": 0.010980036109685898}, {"id": 145, "seek": 85212, "start": 853.08, "end": 860.44, "text": " You never know. And one thing that I found, if you're working in networking, that could be cool,", "tokens": [50412, 509, 1128, 458, 13, 400, 472, 551, 300, 286, 1352, 11, 498, 291, 434, 1364, 294, 17985, 11, 300, 727, 312, 1627, 11, 50780], "temperature": 0.0, "avg_logprob": -0.21179838180541993, "compression_ratio": 1.6443514644351465, "no_speech_prob": 0.005468678195029497}, {"id": 146, "seek": 85212, "start": 860.44, "end": 866.44, "text": " IP address works the exact same way. So you can define IP addresses with their masks and everything,", "tokens": [50780, 8671, 2985, 1985, 264, 1900, 912, 636, 13, 407, 291, 393, 6964, 8671, 16862, 365, 641, 11830, 293, 1203, 11, 51080], "temperature": 0.0, "avg_logprob": -0.21179838180541993, "compression_ratio": 1.6443514644351465, "no_speech_prob": 0.005468678195029497}, {"id": 147, "seek": 85212, "start": 866.44, "end": 871.08, "text": " and then have them act as ranges, and then check that your IP address belongs to one or the other.", "tokens": [51080, 293, 550, 362, 552, 605, 382, 22526, 11, 293, 550, 1520, 300, 428, 8671, 2985, 12953, 281, 472, 420, 264, 661, 13, 51312], "temperature": 0.0, "avg_logprob": -0.21179838180541993, "compression_ratio": 1.6443514644351465, "no_speech_prob": 0.005468678195029497}, {"id": 148, "seek": 85212, "start": 874.2, "end": 881.0, "text": " This one we've all probably used is also is reg X. So this one checks for just a match. It's the", "tokens": [51468, 639, 472, 321, 600, 439, 1391, 1143, 307, 611, 307, 1121, 1783, 13, 407, 341, 472, 13834, 337, 445, 257, 2995, 13, 467, 311, 264, 51808], "temperature": 0.0, "avg_logprob": -0.21179838180541993, "compression_ratio": 1.6443514644351465, "no_speech_prob": 0.005468678195029497}, {"id": 149, "seek": 88100, "start": 881.0, "end": 887.88, "text": " exact same equivalent as if you wanted to match your against string. So that's a kind of real", "tokens": [50364, 1900, 912, 10344, 382, 498, 291, 1415, 281, 2995, 428, 1970, 6798, 13, 407, 300, 311, 257, 733, 295, 957, 50708], "temperature": 0.0, "avg_logprob": -0.12492902929132635, "compression_ratio": 1.7035714285714285, "no_speech_prob": 0.005465070251375437}, {"id": 150, "seek": 88100, "start": 887.88, "end": 891.72, "text": " use case that I have from the company that I'm working for where we manage a lot of messages", "tokens": [50708, 764, 1389, 300, 286, 362, 490, 264, 2237, 300, 286, 478, 1364, 337, 689, 321, 3067, 257, 688, 295, 7897, 50900], "temperature": 0.0, "avg_logprob": -0.12492902929132635, "compression_ratio": 1.7035714285714285, "no_speech_prob": 0.005465070251375437}, {"id": 151, "seek": 88100, "start": 891.72, "end": 897.0, "text": " between clients and providers. And so we want to check in those messages that they're not trying", "tokens": [50900, 1296, 6982, 293, 11330, 13, 400, 370, 321, 528, 281, 1520, 294, 729, 7897, 300, 436, 434, 406, 1382, 51164], "temperature": 0.0, "avg_logprob": -0.12492902929132635, "compression_ratio": 1.7035714285714285, "no_speech_prob": 0.005465070251375437}, {"id": 152, "seek": 88100, "start": 897.0, "end": 901.16, "text": " to bypass us, for example, by sending an address and trying to meet somewhere, or they're not", "tokens": [51164, 281, 24996, 505, 11, 337, 1365, 11, 538, 7750, 364, 2985, 293, 1382, 281, 1677, 4079, 11, 420, 436, 434, 406, 51372], "temperature": 0.0, "avg_logprob": -0.12492902929132635, "compression_ratio": 1.7035714285714285, "no_speech_prob": 0.005465070251375437}, {"id": 153, "seek": 88100, "start": 901.16, "end": 906.76, "text": " sending sensitive information or sometimes people can keep their dick in their pants. So we have to", "tokens": [51372, 7750, 9477, 1589, 420, 2171, 561, 393, 1066, 641, 18659, 294, 641, 10082, 13, 407, 321, 362, 281, 51652], "temperature": 0.0, "avg_logprob": -0.12492902929132635, "compression_ratio": 1.7035714285714285, "no_speech_prob": 0.005465070251375437}, {"id": 154, "seek": 90676, "start": 906.76, "end": 914.68, "text": " be careful about that also. Stuff like this, right? So this one checks for match. Probably one of the", "tokens": [50364, 312, 5026, 466, 300, 611, 13, 31347, 411, 341, 11, 558, 30, 407, 341, 472, 13834, 337, 2995, 13, 9210, 472, 295, 264, 50760], "temperature": 0.0, "avg_logprob": -0.12124411582946777, "compression_ratio": 1.6808510638297873, "no_speech_prob": 0.007117548957467079}, {"id": 155, "seek": 90676, "start": 915.56, "end": 920.12, "text": " most interesting example, but yet the one that have the most trouble coming up with a good example", "tokens": [50804, 881, 1880, 1365, 11, 457, 1939, 264, 472, 300, 362, 264, 881, 5253, 1348, 493, 365, 257, 665, 1365, 51032], "temperature": 0.0, "avg_logprob": -0.12124411582946777, "compression_ratio": 1.6808510638297873, "no_speech_prob": 0.007117548957467079}, {"id": 156, "seek": 90676, "start": 920.12, "end": 928.52, "text": " for are prox and lambdas. On prox and on lambdas, triple equal calls the lambda and gives it the", "tokens": [51032, 337, 366, 447, 87, 293, 10097, 27476, 13, 1282, 447, 87, 293, 322, 10097, 27476, 11, 15508, 2681, 5498, 264, 13607, 293, 2709, 309, 264, 51452], "temperature": 0.0, "avg_logprob": -0.12124411582946777, "compression_ratio": 1.6808510638297873, "no_speech_prob": 0.007117548957467079}, {"id": 157, "seek": 90676, "start": 928.52, "end": 935.24, "text": " object that you're matching with. So for example, here we can define, let's say we want to define", "tokens": [51452, 2657, 300, 291, 434, 14324, 365, 13, 407, 337, 1365, 11, 510, 321, 393, 6964, 11, 718, 311, 584, 321, 528, 281, 6964, 51788], "temperature": 0.0, "avg_logprob": -0.12124411582946777, "compression_ratio": 1.6808510638297873, "no_speech_prob": 0.007117548957467079}, {"id": 158, "seek": 93524, "start": 935.24, "end": 943.72, "text": " simple prox or lambdas that just delegate to another method. So for example, unknown host will take", "tokens": [50364, 2199, 447, 87, 420, 10097, 27476, 300, 445, 40999, 281, 1071, 3170, 13, 407, 337, 1365, 11, 9841, 3975, 486, 747, 50788], "temperature": 0.0, "avg_logprob": -0.1279253363609314, "compression_ratio": 1.6120689655172413, "no_speech_prob": 0.0034816835541278124}, {"id": 159, "seek": 93524, "start": 945.24, "end": 949.48, "text": " an element and then check if the host is included in the list of something.", "tokens": [50864, 364, 4478, 293, 550, 1520, 498, 264, 3975, 307, 5556, 294, 264, 1329, 295, 746, 13, 51076], "temperature": 0.0, "avg_logprob": -0.1279253363609314, "compression_ratio": 1.6120689655172413, "no_speech_prob": 0.0034816835541278124}, {"id": 160, "seek": 93524, "start": 951.48, "end": 958.2, "text": " Oh shit, yeah, I've done it again. In case this is just, it's the new way of writing the old thing", "tokens": [51176, 876, 4611, 11, 1338, 11, 286, 600, 1096, 309, 797, 13, 682, 1389, 341, 307, 445, 11, 309, 311, 264, 777, 636, 295, 3579, 264, 1331, 551, 51512], "temperature": 0.0, "avg_logprob": -0.1279253363609314, "compression_ratio": 1.6120689655172413, "no_speech_prob": 0.0034816835541278124}, {"id": 161, "seek": 93524, "start": 958.2, "end": 963.64, "text": " here with the pipe pipe and you enter a variable, this does the exact same thing. It just takes the", "tokens": [51512, 510, 365, 264, 11240, 11240, 293, 291, 3242, 257, 7006, 11, 341, 775, 264, 1900, 912, 551, 13, 467, 445, 2516, 264, 51784], "temperature": 0.0, "avg_logprob": -0.1279253363609314, "compression_ratio": 1.6120689655172413, "no_speech_prob": 0.0034816835541278124}, {"id": 162, "seek": 96364, "start": 963.64, "end": 967.4, "text": " first one. So underscore one would be the first variable that you enter here, underscore two,", "tokens": [50364, 700, 472, 13, 407, 37556, 472, 576, 312, 264, 700, 7006, 300, 291, 3242, 510, 11, 37556, 732, 11, 50552], "temperature": 0.0, "avg_logprob": -0.12962419672529826, "compression_ratio": 1.8403041825095057, "no_speech_prob": 0.003763190470635891}, {"id": 163, "seek": 96364, "start": 967.4, "end": 971.48, "text": " the second one, underscore three, et cetera, et cetera, et cetera. So let's say that we've defined", "tokens": [50552, 264, 1150, 472, 11, 37556, 1045, 11, 1030, 11458, 11, 1030, 11458, 11, 1030, 11458, 13, 407, 718, 311, 584, 300, 321, 600, 7642, 50756], "temperature": 0.0, "avg_logprob": -0.12962419672529826, "compression_ratio": 1.8403041825095057, "no_speech_prob": 0.003763190470635891}, {"id": 164, "seek": 96364, "start": 971.48, "end": 978.36, "text": " a simple list of hosts. So when we get, in this case, probably a request, we could delegate to", "tokens": [50756, 257, 2199, 1329, 295, 21573, 13, 407, 562, 321, 483, 11, 294, 341, 1389, 11, 1391, 257, 5308, 11, 321, 727, 40999, 281, 51100], "temperature": 0.0, "avg_logprob": -0.12962419672529826, "compression_ratio": 1.8403041825095057, "no_speech_prob": 0.003763190470635891}, {"id": 165, "seek": 96364, "start": 978.36, "end": 985.4, "text": " one of those to see if it whitelisted or if something went wrong. And then we can, if it goes", "tokens": [51100, 472, 295, 729, 281, 536, 498, 309, 2418, 34890, 420, 498, 746, 1437, 2085, 13, 400, 550, 321, 393, 11, 498, 309, 1709, 51452], "temperature": 0.0, "avg_logprob": -0.12962419672529826, "compression_ratio": 1.8403041825095057, "no_speech_prob": 0.003763190470635891}, {"id": 166, "seek": 96364, "start": 985.4, "end": 991.56, "text": " there, yes, we can take a request, let's say a web book for example, and write our case on it and say,", "tokens": [51452, 456, 11, 2086, 11, 321, 393, 747, 257, 5308, 11, 718, 311, 584, 257, 3670, 1446, 337, 1365, 11, 293, 2464, 527, 1389, 322, 309, 293, 584, 11, 51760], "temperature": 0.0, "avg_logprob": -0.12962419672529826, "compression_ratio": 1.8403041825095057, "no_speech_prob": 0.003763190470635891}, {"id": 167, "seek": 99156, "start": 991.56, "end": 997.0799999999999, "text": " okay, when it's whitelisted, then I want to do something. If the host is unknown, I want to", "tokens": [50364, 1392, 11, 562, 309, 311, 2418, 34890, 11, 550, 286, 528, 281, 360, 746, 13, 759, 264, 3975, 307, 9841, 11, 286, 528, 281, 50640], "temperature": 0.0, "avg_logprob": -0.099490327835083, "compression_ratio": 1.8676470588235294, "no_speech_prob": 0.007341757882386446}, {"id": 168, "seek": 99156, "start": 997.0799999999999, "end": 1001.0799999999999, "text": " do something else. If the action is unknown, it's going to do something else. And what this is going", "tokens": [50640, 360, 746, 1646, 13, 759, 264, 3069, 307, 9841, 11, 309, 311, 516, 281, 360, 746, 1646, 13, 400, 437, 341, 307, 516, 50840], "temperature": 0.0, "avg_logprob": -0.099490327835083, "compression_ratio": 1.8676470588235294, "no_speech_prob": 0.007341757882386446}, {"id": 169, "seek": 99156, "start": 1001.0799999999999, "end": 1008.28, "text": " to do behind the curtain is it's going to call whitelisted and give it web book as a first parameter.", "tokens": [50840, 281, 360, 2261, 264, 26789, 307, 309, 311, 516, 281, 818, 2418, 34890, 293, 976, 309, 3670, 1446, 382, 257, 700, 13075, 13, 51200], "temperature": 0.0, "avg_logprob": -0.099490327835083, "compression_ratio": 1.8676470588235294, "no_speech_prob": 0.007341757882386446}, {"id": 170, "seek": 99156, "start": 1010.92, "end": 1016.3599999999999, "text": " So it's a more, again, more compact way and allows you to put that code somewhere else", "tokens": [51332, 407, 309, 311, 257, 544, 11, 797, 11, 544, 14679, 636, 293, 4045, 291, 281, 829, 300, 3089, 4079, 1646, 51604], "temperature": 0.0, "avg_logprob": -0.099490327835083, "compression_ratio": 1.8676470588235294, "no_speech_prob": 0.007341757882386446}, {"id": 171, "seek": 101636, "start": 1016.36, "end": 1025.48, "text": " instead of having to copy paste it into three ifs. And the last one, we're in Ruby, thankfully.", "tokens": [50364, 2602, 295, 1419, 281, 5055, 9163, 309, 666, 1045, 498, 82, 13, 400, 264, 1036, 472, 11, 321, 434, 294, 19907, 11, 27352, 13, 50820], "temperature": 0.0, "avg_logprob": -0.1012805530003139, "compression_ratio": 1.5778688524590163, "no_speech_prob": 0.0014776826137676835}, {"id": 172, "seek": 101636, "start": 1025.48, "end": 1031.72, "text": " So for every other class, we got duck typing. We can just implement the triple equal method and", "tokens": [50820, 407, 337, 633, 661, 1508, 11, 321, 658, 12482, 18444, 13, 492, 393, 445, 4445, 264, 15508, 2681, 3170, 293, 51132], "temperature": 0.0, "avg_logprob": -0.1012805530003139, "compression_ratio": 1.5778688524590163, "no_speech_prob": 0.0014776826137676835}, {"id": 173, "seek": 101636, "start": 1031.72, "end": 1039.4, "text": " have it work for more or less anything that we want. So bear with me because that's going to take", "tokens": [51132, 362, 309, 589, 337, 544, 420, 1570, 1340, 300, 321, 528, 13, 407, 6155, 365, 385, 570, 300, 311, 516, 281, 747, 51516], "temperature": 0.0, "avg_logprob": -0.1012805530003139, "compression_ratio": 1.5778688524590163, "no_speech_prob": 0.0014776826137676835}, {"id": 174, "seek": 101636, "start": 1039.4, "end": 1046.28, "text": " a little bit of time. So in this case, same, still sticking with my response example that we've", "tokens": [51516, 257, 707, 857, 295, 565, 13, 407, 294, 341, 1389, 11, 912, 11, 920, 13465, 365, 452, 4134, 1365, 300, 321, 600, 51860], "temperature": 0.0, "avg_logprob": -0.1012805530003139, "compression_ratio": 1.5778688524590163, "no_speech_prob": 0.0014776826137676835}, {"id": 175, "seek": 104628, "start": 1046.28, "end": 1053.16, "text": " been following the entire presentation. So here I can define in my response class or module or", "tokens": [50364, 668, 3480, 264, 2302, 5860, 13, 407, 510, 286, 393, 6964, 294, 452, 4134, 1508, 420, 10088, 420, 50708], "temperature": 0.0, "avg_logprob": -0.0889764802645793, "compression_ratio": 1.7490774907749078, "no_speech_prob": 0.0016999412328004837}, {"id": 176, "seek": 104628, "start": 1053.16, "end": 1058.84, "text": " whatever different classes that implement the triple equal and that do anything that I want.", "tokens": [50708, 2035, 819, 5359, 300, 4445, 264, 15508, 2681, 293, 300, 360, 1340, 300, 286, 528, 13, 50992], "temperature": 0.0, "avg_logprob": -0.0889764802645793, "compression_ratio": 1.7490774907749078, "no_speech_prob": 0.0016999412328004837}, {"id": 177, "seek": 104628, "start": 1059.3999999999999, "end": 1064.52, "text": " And then I can, if I do this and I call them, this is going to do what we've seen before in the", "tokens": [51020, 400, 550, 286, 393, 11, 498, 286, 360, 341, 293, 286, 818, 552, 11, 341, 307, 516, 281, 360, 437, 321, 600, 1612, 949, 294, 264, 51276], "temperature": 0.0, "avg_logprob": -0.0889764802645793, "compression_ratio": 1.7490774907749078, "no_speech_prob": 0.0016999412328004837}, {"id": 178, "seek": 104628, "start": 1065.16, "end": 1070.2, "text": " VM instructions, right? It's going to take the response called triple equal with this and then", "tokens": [51308, 18038, 9415, 11, 558, 30, 467, 311, 516, 281, 747, 264, 4134, 1219, 15508, 2681, 365, 341, 293, 550, 51560], "temperature": 0.0, "avg_logprob": -0.0889764802645793, "compression_ratio": 1.7490774907749078, "no_speech_prob": 0.0016999412328004837}, {"id": 179, "seek": 104628, "start": 1070.2, "end": 1076.04, "text": " see if the answer is true or not. So with this, you can basically create as many matches as you", "tokens": [51560, 536, 498, 264, 1867, 307, 2074, 420, 406, 13, 407, 365, 341, 11, 291, 393, 1936, 1884, 382, 867, 10676, 382, 291, 51852], "temperature": 0.0, "avg_logprob": -0.0889764802645793, "compression_ratio": 1.7490774907749078, "no_speech_prob": 0.0016999412328004837}, {"id": 180, "seek": 107604, "start": 1076.04, "end": 1081.3999999999999, "text": " want, especially on custom class that can be pretty interesting. If you have one example that came", "tokens": [50364, 528, 11, 2318, 322, 2375, 1508, 300, 393, 312, 1238, 1880, 13, 759, 291, 362, 472, 1365, 300, 1361, 50632], "temperature": 0.0, "avg_logprob": -0.08868627548217774, "compression_ratio": 1.7769516728624535, "no_speech_prob": 0.004197063855826855}, {"id": 181, "seek": 107604, "start": 1081.3999999999999, "end": 1085.32, "text": " to mind also is payments, for example, if you're managing payments, then you can in your payment", "tokens": [50632, 281, 1575, 611, 307, 14348, 11, 337, 1365, 11, 498, 291, 434, 11642, 14348, 11, 550, 291, 393, 294, 428, 10224, 50828], "temperature": 0.0, "avg_logprob": -0.08868627548217774, "compression_ratio": 1.7769516728624535, "no_speech_prob": 0.004197063855826855}, {"id": 182, "seek": 107604, "start": 1085.32, "end": 1091.32, "text": " class define different subclasses that could be success or canceled or processing that just", "tokens": [50828, 1508, 6964, 819, 1422, 11665, 279, 300, 727, 312, 2245, 420, 24839, 420, 9007, 300, 445, 51128], "temperature": 0.0, "avg_logprob": -0.08868627548217774, "compression_ratio": 1.7769516728624535, "no_speech_prob": 0.004197063855826855}, {"id": 183, "seek": 107604, "start": 1091.32, "end": 1095.8, "text": " calls your payment API and checks if it works. And so all that code is it's in own place and then", "tokens": [51128, 5498, 428, 10224, 9362, 293, 13834, 498, 309, 1985, 13, 400, 370, 439, 300, 3089, 307, 309, 311, 294, 1065, 1081, 293, 550, 51352], "temperature": 0.0, "avg_logprob": -0.08868627548217774, "compression_ratio": 1.7769516728624535, "no_speech_prob": 0.004197063855826855}, {"id": 184, "seek": 107604, "start": 1095.8, "end": 1100.44, "text": " you instantiate your object here and you can use case to easily delegate where you're going.", "tokens": [51352, 291, 9836, 13024, 428, 2657, 510, 293, 291, 393, 764, 1389, 281, 3612, 40999, 689, 291, 434, 516, 13, 51584], "temperature": 0.0, "avg_logprob": -0.08868627548217774, "compression_ratio": 1.7769516728624535, "no_speech_prob": 0.004197063855826855}, {"id": 185, "seek": 110044, "start": 1100.68, "end": 1110.28, "text": " Another example that we've kind of used is a wrapper for services. So basically you define", "tokens": [50376, 3996, 1365, 300, 321, 600, 733, 295, 1143, 307, 257, 46906, 337, 3328, 13, 407, 1936, 291, 6964, 50856], "temperature": 0.0, "avg_logprob": -0.2268844870633857, "compression_ratio": 1.6842105263157894, "no_speech_prob": 0.004398551303893328}, {"id": 186, "seek": 110044, "start": 1110.8400000000001, "end": 1115.48, "text": " new classes for your service and your service answer a class that's either a success or an error", "tokens": [50884, 777, 5359, 337, 428, 2643, 293, 428, 2643, 1867, 257, 1508, 300, 311, 2139, 257, 2245, 420, 364, 6713, 51116], "temperature": 0.0, "avg_logprob": -0.2268844870633857, "compression_ratio": 1.6842105263157894, "no_speech_prob": 0.004398551303893328}, {"id": 187, "seek": 110044, "start": 1115.48, "end": 1120.8400000000001, "text": " and then you can use this to do some kind of early, early days pattern matching.", "tokens": [51116, 293, 550, 291, 393, 764, 341, 281, 360, 512, 733, 295, 2440, 11, 2440, 1708, 5102, 14324, 13, 51384], "temperature": 0.0, "avg_logprob": -0.2268844870633857, "compression_ratio": 1.6842105263157894, "no_speech_prob": 0.004398551303893328}, {"id": 188, "seek": 110044, "start": 1122.52, "end": 1129.0800000000002, "text": " So speaking of pattern matching, how does it work? So just in, again, just in case,", "tokens": [51468, 407, 4124, 295, 5102, 14324, 11, 577, 775, 309, 589, 30, 407, 445, 294, 11, 797, 11, 445, 294, 1389, 11, 51796], "temperature": 0.0, "avg_logprob": -0.2268844870633857, "compression_ratio": 1.6842105263157894, "no_speech_prob": 0.004398551303893328}, {"id": 189, "seek": 112908, "start": 1129.32, "end": 1135.24, "text": " we're going to go quickly through what it is and what it works, how it works, sorry.", "tokens": [50376, 321, 434, 516, 281, 352, 2661, 807, 437, 309, 307, 293, 437, 309, 1985, 11, 577, 309, 1985, 11, 2597, 13, 50672], "temperature": 0.0, "avg_logprob": -0.21565291807823575, "compression_ratio": 1.7327188940092166, "no_speech_prob": 0.0037641162052750587}, {"id": 190, "seek": 112908, "start": 1136.52, "end": 1143.1599999999999, "text": " So the whole idea of pattern matching is that you define as the naming price, you define a pattern,", "tokens": [50736, 407, 264, 1379, 1558, 295, 5102, 14324, 307, 300, 291, 6964, 382, 264, 25290, 3218, 11, 291, 6964, 257, 5102, 11, 51068], "temperature": 0.0, "avg_logprob": -0.21565291807823575, "compression_ratio": 1.7327188940092166, "no_speech_prob": 0.0037641162052750587}, {"id": 191, "seek": 112908, "start": 1143.6399999999999, "end": 1150.04, "text": " then you try and match it against something and see what sticks. So here my pattern is going to be a", "tokens": [51092, 550, 291, 853, 293, 2995, 309, 1970, 746, 293, 536, 437, 12518, 13, 407, 510, 452, 5102, 307, 516, 281, 312, 257, 51412], "temperature": 0.0, "avg_logprob": -0.21565291807823575, "compression_ratio": 1.7327188940092166, "no_speech_prob": 0.0037641162052750587}, {"id": 192, "seek": 112908, "start": 1150.04, "end": 1155.3999999999999, "text": " hash with a status key, a body key inside of which I'll have a user with a name and an age", "tokens": [51412, 22019, 365, 257, 6558, 2141, 11, 257, 1772, 2141, 1854, 295, 597, 286, 603, 362, 257, 4195, 365, 257, 1315, 293, 364, 3205, 51680], "temperature": 0.0, "avg_logprob": -0.21565291807823575, "compression_ratio": 1.7327188940092166, "no_speech_prob": 0.0037641162052750587}, {"id": 193, "seek": 115540, "start": 1155.8000000000002, "end": 1160.68, "text": " and whatever is in here, if I can match it, I want to store it in the variable and then once you", "tokens": [50384, 293, 2035, 307, 294, 510, 11, 498, 286, 393, 2995, 309, 11, 286, 528, 281, 3531, 309, 294, 264, 7006, 293, 550, 1564, 291, 50628], "temperature": 0.0, "avg_logprob": -0.1516631791571609, "compression_ratio": 2.0083333333333333, "no_speech_prob": 0.0076930830255150795}, {"id": 194, "seek": 115540, "start": 1160.68, "end": 1166.44, "text": " have your pattern, you can try and match it against any collection of stuff. So in this case,", "tokens": [50628, 362, 428, 5102, 11, 291, 393, 853, 293, 2995, 309, 1970, 604, 5765, 295, 1507, 13, 407, 294, 341, 1389, 11, 50916], "temperature": 0.0, "avg_logprob": -0.1516631791571609, "compression_ratio": 2.0083333333333333, "no_speech_prob": 0.0076930830255150795}, {"id": 195, "seek": 115540, "start": 1167.16, "end": 1171.8000000000002, "text": " it's going to work because we had the same status and the form that we're trying to match against", "tokens": [50952, 309, 311, 516, 281, 589, 570, 321, 632, 264, 912, 6558, 293, 264, 1254, 300, 321, 434, 1382, 281, 2995, 1970, 51184], "temperature": 0.0, "avg_logprob": -0.1516631791571609, "compression_ratio": 2.0083333333333333, "no_speech_prob": 0.0076930830255150795}, {"id": 196, "seek": 115540, "start": 1171.8000000000002, "end": 1176.92, "text": " was the same and what it's going to do is it's going to assign the name variable to whatever was", "tokens": [51184, 390, 264, 912, 293, 437, 309, 311, 516, 281, 360, 307, 309, 311, 516, 281, 6269, 264, 1315, 7006, 281, 2035, 390, 51440], "temperature": 0.0, "avg_logprob": -0.1516631791571609, "compression_ratio": 2.0083333333333333, "no_speech_prob": 0.0076930830255150795}, {"id": 197, "seek": 115540, "start": 1176.92, "end": 1182.44, "text": " there and the age variable to whatever was there. If you want to match it against something that", "tokens": [51440, 456, 293, 264, 3205, 7006, 281, 2035, 390, 456, 13, 759, 291, 528, 281, 2995, 309, 1970, 746, 300, 51716], "temperature": 0.0, "avg_logprob": -0.1516631791571609, "compression_ratio": 2.0083333333333333, "no_speech_prob": 0.0076930830255150795}, {"id": 198, "seek": 118244, "start": 1182.52, "end": 1188.1200000000001, "text": " looks very different, so this hash for example is not going to work because either status and body", "tokens": [50368, 1542, 588, 819, 11, 370, 341, 22019, 337, 1365, 307, 406, 516, 281, 589, 570, 2139, 6558, 293, 1772, 50648], "temperature": 0.0, "avg_logprob": -0.2098235717186561, "compression_ratio": 1.7787610619469028, "no_speech_prob": 0.003944374155253172}, {"id": 199, "seek": 118244, "start": 1188.1200000000001, "end": 1193.3200000000002, "text": " are here, this value is not going to match against that one, right? So if you try and do this, then", "tokens": [50648, 366, 510, 11, 341, 2158, 307, 406, 516, 281, 2995, 1970, 300, 472, 11, 558, 30, 407, 498, 291, 853, 293, 360, 341, 11, 550, 50908], "temperature": 0.0, "avg_logprob": -0.2098235717186561, "compression_ratio": 1.7787610619469028, "no_speech_prob": 0.003944374155253172}, {"id": 200, "seek": 118244, "start": 1194.76, "end": 1200.52, "text": " it doesn't work, so you're going to get an error. In Ruby at least, this is going to, sorry, this is", "tokens": [50980, 309, 1177, 380, 589, 11, 370, 291, 434, 516, 281, 483, 364, 6713, 13, 682, 19907, 412, 1935, 11, 341, 307, 516, 281, 11, 2597, 11, 341, 307, 51268], "temperature": 0.0, "avg_logprob": -0.2098235717186561, "compression_ratio": 1.7787610619469028, "no_speech_prob": 0.003944374155253172}, {"id": 201, "seek": 118244, "start": 1200.52, "end": 1208.76, "text": " going to raise an error that just tells you I wasn't able to match it and in Ruby that was implemented", "tokens": [51268, 516, 281, 5300, 364, 6713, 300, 445, 5112, 291, 286, 2067, 380, 1075, 281, 2995, 309, 293, 294, 19907, 300, 390, 12270, 51680], "temperature": 0.0, "avg_logprob": -0.2098235717186561, "compression_ratio": 1.7787610619469028, "no_speech_prob": 0.003944374155253172}, {"id": 202, "seek": 120876, "start": 1209.64, "end": 1220.12, "text": " using case. So the way it works is if you have a response or literally anything, you want to create", "tokens": [50408, 1228, 1389, 13, 407, 264, 636, 309, 1985, 307, 498, 291, 362, 257, 4134, 420, 3736, 1340, 11, 291, 528, 281, 1884, 50932], "temperature": 0.0, "avg_logprob": -0.14817217418125697, "compression_ratio": 1.7901785714285714, "no_speech_prob": 0.007689679507166147}, {"id": 203, "seek": 120876, "start": 1220.12, "end": 1226.28, "text": " your different patterns that you're going to want to match it against and one thing to note is that", "tokens": [50932, 428, 819, 8294, 300, 291, 434, 516, 281, 528, 281, 2995, 309, 1970, 293, 472, 551, 281, 3637, 307, 300, 51240], "temperature": 0.0, "avg_logprob": -0.14817217418125697, "compression_ratio": 1.7901785714285714, "no_speech_prob": 0.007689679507166147}, {"id": 204, "seek": 120876, "start": 1226.28, "end": 1231.72, "text": " it's no longer, you know, to make the difference, you no longer use case when, using case in because", "tokens": [51240, 309, 311, 572, 2854, 11, 291, 458, 11, 281, 652, 264, 2649, 11, 291, 572, 2854, 764, 1389, 562, 11, 1228, 1389, 294, 570, 51512], "temperature": 0.0, "avg_logprob": -0.14817217418125697, "compression_ratio": 1.7901785714285714, "no_speech_prob": 0.007689679507166147}, {"id": 205, "seek": 120876, "start": 1231.72, "end": 1236.6, "text": " in is going to be the keyword that's going to be mainly used for pattern matching even out of cases.", "tokens": [51512, 294, 307, 516, 281, 312, 264, 20428, 300, 311, 516, 281, 312, 8704, 1143, 337, 5102, 14324, 754, 484, 295, 3331, 13, 51756], "temperature": 0.0, "avg_logprob": -0.14817217418125697, "compression_ratio": 1.7901785714285714, "no_speech_prob": 0.007689679507166147}, {"id": 206, "seek": 123660, "start": 1237.56, "end": 1244.4399999999998, "text": " So in this case, if the response that I get has a status success, I'm going to take whatever is in", "tokens": [50412, 407, 294, 341, 1389, 11, 498, 264, 4134, 300, 286, 483, 575, 257, 6558, 2245, 11, 286, 478, 516, 281, 747, 2035, 307, 294, 50756], "temperature": 0.0, "avg_logprob": -0.13088837536898526, "compression_ratio": 1.706896551724138, "no_speech_prob": 0.0032724752090871334}, {"id": 207, "seek": 123660, "start": 1244.4399999999998, "end": 1250.36, "text": " the body and put it there and otherwise if it's an error, I'm going to fail and put it over there.", "tokens": [50756, 264, 1772, 293, 829, 309, 456, 293, 5911, 498, 309, 311, 364, 6713, 11, 286, 478, 516, 281, 3061, 293, 829, 309, 670, 456, 13, 51052], "temperature": 0.0, "avg_logprob": -0.13088837536898526, "compression_ratio": 1.706896551724138, "no_speech_prob": 0.0032724752090871334}, {"id": 208, "seek": 123660, "start": 1250.36, "end": 1257.9599999999998, "text": " So it's, again, it kind of does the same. You could do the whole counterpoint to this presentation", "tokens": [51052, 407, 309, 311, 11, 797, 11, 309, 733, 295, 775, 264, 912, 13, 509, 727, 360, 264, 1379, 5682, 6053, 281, 341, 5860, 51432], "temperature": 0.0, "avg_logprob": -0.13088837536898526, "compression_ratio": 1.706896551724138, "no_speech_prob": 0.0032724752090871334}, {"id": 209, "seek": 123660, "start": 1257.9599999999998, "end": 1264.6799999999998, "text": " is I could do it with an if, else if. You always can, but I do think this is a bit more verbose and", "tokens": [51432, 307, 286, 727, 360, 309, 365, 364, 498, 11, 1646, 498, 13, 509, 1009, 393, 11, 457, 286, 360, 519, 341, 307, 257, 857, 544, 9595, 541, 293, 51768], "temperature": 0.0, "avg_logprob": -0.13088837536898526, "compression_ratio": 1.706896551724138, "no_speech_prob": 0.0032724752090871334}, {"id": 210, "seek": 126468, "start": 1264.68, "end": 1269.0, "text": " makes it more clear what you're trying to do because you can see the entire pattern. Whereas if you", "tokens": [50364, 1669, 309, 544, 1850, 437, 291, 434, 1382, 281, 360, 570, 291, 393, 536, 264, 2302, 5102, 13, 13813, 498, 291, 50580], "temperature": 0.0, "avg_logprob": -0.12142433498216712, "compression_ratio": 1.7157894736842105, "no_speech_prob": 0.013011752627789974}, {"id": 211, "seek": 126468, "start": 1269.0, "end": 1273.4, "text": " wanted to do an if, you would have to open response and do if the status is success, then I want to", "tokens": [50580, 1415, 281, 360, 364, 498, 11, 291, 576, 362, 281, 1269, 4134, 293, 360, 498, 264, 6558, 307, 2245, 11, 550, 286, 528, 281, 50800], "temperature": 0.0, "avg_logprob": -0.12142433498216712, "compression_ratio": 1.7157894736842105, "no_speech_prob": 0.013011752627789974}, {"id": 212, "seek": 126468, "start": 1273.4, "end": 1280.6000000000001, "text": " look at the body. For this example looks the same, but if you're dealing with big jasons from APIs", "tokens": [50800, 574, 412, 264, 1772, 13, 1171, 341, 1365, 1542, 264, 912, 11, 457, 498, 291, 434, 6260, 365, 955, 361, 3646, 490, 21445, 51160], "temperature": 0.0, "avg_logprob": -0.12142433498216712, "compression_ratio": 1.7157894736842105, "no_speech_prob": 0.013011752627789974}, {"id": 213, "seek": 126468, "start": 1280.6000000000001, "end": 1285.88, "text": " where everything is nested like four times and you have response body value and then you take the", "tokens": [51160, 689, 1203, 307, 15646, 292, 411, 1451, 1413, 293, 291, 362, 4134, 1772, 2158, 293, 550, 291, 747, 264, 51424], "temperature": 0.0, "avg_logprob": -0.12142433498216712, "compression_ratio": 1.7157894736842105, "no_speech_prob": 0.013011752627789974}, {"id": 214, "seek": 126468, "start": 1285.88, "end": 1290.52, "text": " first element and then the address and then whatever this starts to become more interesting.", "tokens": [51424, 700, 4478, 293, 550, 264, 2985, 293, 550, 2035, 341, 3719, 281, 1813, 544, 1880, 13, 51656], "temperature": 0.0, "avg_logprob": -0.12142433498216712, "compression_ratio": 1.7157894736842105, "no_speech_prob": 0.013011752627789974}, {"id": 215, "seek": 129052, "start": 1291.08, "end": 1298.84, "text": " Another thing that we get with pattern matching that we can do with case when is we get access to", "tokens": [50392, 3996, 551, 300, 321, 483, 365, 5102, 14324, 300, 321, 393, 360, 365, 1389, 562, 307, 321, 483, 2105, 281, 50780], "temperature": 0.0, "avg_logprob": -0.1591515126435653, "compression_ratio": 1.7566371681415929, "no_speech_prob": 0.008184470236301422}, {"id": 216, "seek": 129052, "start": 1298.84, "end": 1305.8799999999999, "text": " guard closes. So whatever that allows us to do is I want response to match with this only if I'm not", "tokens": [50780, 6290, 24157, 13, 407, 2035, 300, 4045, 505, 281, 360, 307, 286, 528, 4134, 281, 2995, 365, 341, 787, 498, 286, 478, 406, 51132], "temperature": 0.0, "avg_logprob": -0.1591515126435653, "compression_ratio": 1.7566371681415929, "no_speech_prob": 0.008184470236301422}, {"id": 217, "seek": 129052, "start": 1305.8799999999999, "end": 1311.72, "text": " in maintenance. So this gives us a bit more control over whether or not we want the pattern to match", "tokens": [51132, 294, 11258, 13, 407, 341, 2709, 505, 257, 857, 544, 1969, 670, 1968, 420, 406, 321, 528, 264, 5102, 281, 2995, 51424], "temperature": 0.0, "avg_logprob": -0.1591515126435653, "compression_ratio": 1.7566371681415929, "no_speech_prob": 0.008184470236301422}, {"id": 218, "seek": 129052, "start": 1311.72, "end": 1317.8799999999999, "text": " because sometimes you might want to put patterns that are very similar, but you want to condition", "tokens": [51424, 570, 2171, 291, 1062, 528, 281, 829, 8294, 300, 366, 588, 2531, 11, 457, 291, 528, 281, 4188, 51732], "temperature": 0.0, "avg_logprob": -0.1591515126435653, "compression_ratio": 1.7566371681415929, "no_speech_prob": 0.008184470236301422}, {"id": 219, "seek": 131788, "start": 1318.3600000000001, "end": 1326.3600000000001, "text": " them to something different. Another example and another thing that we can do with pattern matching,", "tokens": [50388, 552, 281, 746, 819, 13, 3996, 1365, 293, 1071, 551, 300, 321, 393, 360, 365, 5102, 14324, 11, 50788], "temperature": 0.0, "avg_logprob": -0.2775537109375, "compression_ratio": 1.425531914893617, "no_speech_prob": 0.002541241468861699}, {"id": 220, "seek": 131788, "start": 1326.3600000000001, "end": 1339.16, "text": " so let's look at a more complex pattern. We have access to a lot of new tools. So for example, here,", "tokens": [50788, 370, 718, 311, 574, 412, 257, 544, 3997, 5102, 13, 492, 362, 2105, 281, 257, 688, 295, 777, 3873, 13, 407, 337, 1365, 11, 510, 11, 51428], "temperature": 0.0, "avg_logprob": -0.2775537109375, "compression_ratio": 1.425531914893617, "no_speech_prob": 0.002541241468861699}, {"id": 221, "seek": 133916, "start": 1339.96, "end": 1347.5600000000002, "text": " what this thing here means is that I want to match this pattern where the ID is whatever I put on", "tokens": [50404, 437, 341, 551, 510, 1355, 307, 300, 286, 528, 281, 2995, 341, 5102, 689, 264, 7348, 307, 2035, 286, 829, 322, 50784], "temperature": 0.0, "avg_logprob": -0.16476584380527712, "compression_ratio": 1.6553191489361703, "no_speech_prob": 0.10489019006490707}, {"id": 222, "seek": 133916, "start": 1347.5600000000002, "end": 1353.24, "text": " top. If I didn't put it, then it would act as the one we store before and store it into the", "tokens": [50784, 1192, 13, 759, 286, 994, 380, 829, 309, 11, 550, 309, 576, 605, 382, 264, 472, 321, 3531, 949, 293, 3531, 309, 666, 264, 51068], "temperature": 0.0, "avg_logprob": -0.16476584380527712, "compression_ratio": 1.6553191489361703, "no_speech_prob": 0.10489019006490707}, {"id": 223, "seek": 133916, "start": 1353.24, "end": 1358.6000000000001, "text": " variable ID, but by doing this I can tell it no, no, no, use the value that's already there and match", "tokens": [51068, 7006, 7348, 11, 457, 538, 884, 341, 286, 393, 980, 309, 572, 11, 572, 11, 572, 11, 764, 264, 2158, 300, 311, 1217, 456, 293, 2995, 51336], "temperature": 0.0, "avg_logprob": -0.16476584380527712, "compression_ratio": 1.6553191489361703, "no_speech_prob": 0.10489019006490707}, {"id": 224, "seek": 133916, "start": 1358.6000000000001, "end": 1366.68, "text": " one that has 69 as an ID. I don't want anything else. And we also have access to splat operators,", "tokens": [51336, 472, 300, 575, 28267, 382, 364, 7348, 13, 286, 500, 380, 528, 1340, 1646, 13, 400, 321, 611, 362, 2105, 281, 4732, 267, 19077, 11, 51740], "temperature": 0.0, "avg_logprob": -0.16476584380527712, "compression_ratio": 1.6553191489361703, "no_speech_prob": 0.10489019006490707}, {"id": 225, "seek": 136668, "start": 1367.64, "end": 1374.04, "text": " kind of. So simple splat for arrays, double splat for hashes, the same as with method arguments.", "tokens": [50412, 733, 295, 13, 407, 2199, 4732, 267, 337, 41011, 11, 3834, 4732, 267, 337, 575, 8076, 11, 264, 912, 382, 365, 3170, 12869, 13, 50732], "temperature": 0.0, "avg_logprob": -0.08437569287358498, "compression_ratio": 1.776190476190476, "no_speech_prob": 0.007453664671629667}, {"id": 226, "seek": 136668, "start": 1374.04, "end": 1380.8400000000001, "text": " So what this allows me to do is I want to take user and if the user is in an array with some", "tokens": [50732, 407, 437, 341, 4045, 385, 281, 360, 307, 286, 528, 281, 747, 4195, 293, 498, 264, 4195, 307, 294, 364, 10225, 365, 512, 51072], "temperature": 0.0, "avg_logprob": -0.08437569287358498, "compression_ratio": 1.776190476190476, "no_speech_prob": 0.007453664671629667}, {"id": 227, "seek": 136668, "start": 1380.8400000000001, "end": 1385.16, "text": " elements at the beginning, some elements at the end, and then somewhere in the middle,", "tokens": [51072, 4959, 412, 264, 2863, 11, 512, 4959, 412, 264, 917, 11, 293, 550, 4079, 294, 264, 2808, 11, 51288], "temperature": 0.0, "avg_logprob": -0.08437569287358498, "compression_ratio": 1.776190476190476, "no_speech_prob": 0.007453664671629667}, {"id": 228, "seek": 136668, "start": 1385.16, "end": 1392.52, "text": " an element with ID 69, I want to store the value of admin. So this is kind of equivalent to take", "tokens": [51288, 364, 4478, 365, 7348, 28267, 11, 286, 528, 281, 3531, 264, 2158, 295, 24236, 13, 407, 341, 307, 733, 295, 10344, 281, 747, 51656], "temperature": 0.0, "avg_logprob": -0.08437569287358498, "compression_ratio": 1.776190476190476, "no_speech_prob": 0.007453664671629667}, {"id": 229, "seek": 139252, "start": 1392.52, "end": 1400.2, "text": " my entire array and do a detect where ID 69 and then print admin. So this kind of does the same", "tokens": [50364, 452, 2302, 10225, 293, 360, 257, 5531, 689, 7348, 28267, 293, 550, 4482, 24236, 13, 407, 341, 733, 295, 775, 264, 912, 50748], "temperature": 0.0, "avg_logprob": -0.11673321136056561, "compression_ratio": 1.529100529100529, "no_speech_prob": 0.0012838131515309215}, {"id": 230, "seek": 139252, "start": 1400.2, "end": 1406.36, "text": " thing, but in a more flexible way because I can then kind of keep putting more patterns underneath", "tokens": [50748, 551, 11, 457, 294, 257, 544, 11358, 636, 570, 286, 393, 550, 733, 295, 1066, 3372, 544, 8294, 7223, 51056], "temperature": 0.0, "avg_logprob": -0.11673321136056561, "compression_ratio": 1.529100529100529, "no_speech_prob": 0.0012838131515309215}, {"id": 231, "seek": 139252, "start": 1406.36, "end": 1419.96, "text": " to filter out more stuff or try to find more elements. So how does it work? I kind of, at this", "tokens": [51056, 281, 6608, 484, 544, 1507, 420, 853, 281, 915, 544, 4959, 13, 407, 577, 775, 309, 589, 30, 286, 733, 295, 11, 412, 341, 51736], "temperature": 0.0, "avg_logprob": -0.11673321136056561, "compression_ratio": 1.529100529100529, "no_speech_prob": 0.0012838131515309215}, {"id": 232, "seek": 141996, "start": 1419.96, "end": 1425.24, "text": " point in the talk, I kind of wanted to go through the same journey with pattern matching as I did", "tokens": [50364, 935, 294, 264, 751, 11, 286, 733, 295, 1415, 281, 352, 807, 264, 912, 4671, 365, 5102, 14324, 382, 286, 630, 50628], "temperature": 0.0, "avg_logprob": -0.07610619188559176, "compression_ratio": 1.7161572052401746, "no_speech_prob": 0.019682684913277626}, {"id": 233, "seek": 141996, "start": 1425.24, "end": 1430.92, "text": " with a simple case. So try to open it up and look at the VM instructions and see how it works and", "tokens": [50628, 365, 257, 2199, 1389, 13, 407, 853, 281, 1269, 309, 493, 293, 574, 412, 264, 18038, 9415, 293, 536, 577, 309, 1985, 293, 50912], "temperature": 0.0, "avg_logprob": -0.07610619188559176, "compression_ratio": 1.7161572052401746, "no_speech_prob": 0.019682684913277626}, {"id": 234, "seek": 141996, "start": 1430.92, "end": 1437.16, "text": " try and figure out what's underneath. The problem is that pattern matching is kind of new. So in the", "tokens": [50912, 853, 293, 2573, 484, 437, 311, 7223, 13, 440, 1154, 307, 300, 5102, 14324, 307, 733, 295, 777, 13, 407, 294, 264, 51224], "temperature": 0.0, "avg_logprob": -0.07610619188559176, "compression_ratio": 1.7161572052401746, "no_speech_prob": 0.019682684913277626}, {"id": 235, "seek": 141996, "start": 1437.16, "end": 1442.92, "text": " Ruby VM, that is a lot of instructions to go through. So I ain't going to go through everything.", "tokens": [51224, 19907, 18038, 11, 300, 307, 257, 688, 295, 9415, 281, 352, 807, 13, 407, 286, 7862, 380, 516, 281, 352, 807, 1203, 13, 51512], "temperature": 0.0, "avg_logprob": -0.07610619188559176, "compression_ratio": 1.7161572052401746, "no_speech_prob": 0.019682684913277626}, {"id": 236, "seek": 144292, "start": 1443.0800000000002, "end": 1453.4, "text": " But there are a few things that we can see here. So for example here, we have the same response.", "tokens": [50372, 583, 456, 366, 257, 1326, 721, 300, 321, 393, 536, 510, 13, 407, 337, 1365, 510, 11, 321, 362, 264, 912, 4134, 13, 50888], "temperature": 0.0, "avg_logprob": -0.11073411770952427, "compression_ratio": 1.9715447154471544, "no_speech_prob": 0.068490169942379}, {"id": 237, "seek": 144292, "start": 1453.4, "end": 1457.16, "text": " So that's the beginning of our case. So this calls the thing that's going to go in the case that we're", "tokens": [50888, 407, 300, 311, 264, 2863, 295, 527, 1389, 13, 407, 341, 5498, 264, 551, 300, 311, 516, 281, 352, 294, 264, 1389, 300, 321, 434, 51076], "temperature": 0.0, "avg_logprob": -0.11073411770952427, "compression_ratio": 1.9715447154471544, "no_speech_prob": 0.068490169942379}, {"id": 238, "seek": 144292, "start": 1457.16, "end": 1462.28, "text": " going to try and pattern match against the same. We're looking at pattern matching. So of course,", "tokens": [51076, 516, 281, 853, 293, 5102, 2995, 1970, 264, 912, 13, 492, 434, 1237, 412, 5102, 14324, 13, 407, 295, 1164, 11, 51332], "temperature": 0.0, "avg_logprob": -0.11073411770952427, "compression_ratio": 1.9715447154471544, "no_speech_prob": 0.068490169942379}, {"id": 239, "seek": 144292, "start": 1462.28, "end": 1467.0, "text": " the thing called check match, we kind of kind of assume that it's going to match or pattern", "tokens": [51332, 264, 551, 1219, 1520, 2995, 11, 321, 733, 295, 733, 295, 6552, 300, 309, 311, 516, 281, 2995, 420, 5102, 51568], "temperature": 0.0, "avg_logprob": -0.11073411770952427, "compression_ratio": 1.9715447154471544, "no_speech_prob": 0.068490169942379}, {"id": 240, "seek": 144292, "start": 1467.0, "end": 1471.88, "text": " against something. So the way, at least the way I understand it is that all of this is going to", "tokens": [51568, 1970, 746, 13, 407, 264, 636, 11, 412, 1935, 264, 636, 286, 1223, 309, 307, 300, 439, 295, 341, 307, 516, 281, 51812], "temperature": 0.0, "avg_logprob": -0.11073411770952427, "compression_ratio": 1.9715447154471544, "no_speech_prob": 0.068490169942379}, {"id": 241, "seek": 147188, "start": 1471.88, "end": 1477.24, "text": " build or pattern and then it's going to match it to continue. And if we look at the way it builds", "tokens": [50364, 1322, 420, 5102, 293, 550, 309, 311, 516, 281, 2995, 309, 281, 2354, 13, 400, 498, 321, 574, 412, 264, 636, 309, 15182, 50632], "temperature": 0.0, "avg_logprob": -0.09884340112859552, "compression_ratio": 1.668103448275862, "no_speech_prob": 0.0032723823096603155}, {"id": 242, "seek": 147188, "start": 1477.24, "end": 1485.3200000000002, "text": " the pattern, we can find one method that is interesting, which is this one, which is deconstruct", "tokens": [50632, 264, 5102, 11, 321, 393, 915, 472, 3170, 300, 307, 1880, 11, 597, 307, 341, 472, 11, 597, 307, 49473, 1757, 51036], "temperature": 0.0, "avg_logprob": -0.09884340112859552, "compression_ratio": 1.668103448275862, "no_speech_prob": 0.0032723823096603155}, {"id": 243, "seek": 147188, "start": 1485.3200000000002, "end": 1491.0800000000002, "text": " keys. And after looking at it a bit more and going to read out the documentation, this is what", "tokens": [51036, 9317, 13, 400, 934, 1237, 412, 309, 257, 857, 544, 293, 516, 281, 1401, 484, 264, 14333, 11, 341, 307, 437, 51324], "temperature": 0.0, "avg_logprob": -0.09884340112859552, "compression_ratio": 1.668103448275862, "no_speech_prob": 0.0032723823096603155}, {"id": 244, "seek": 147188, "start": 1491.8000000000002, "end": 1497.3200000000002, "text": " Ruby used to do, at least for now, to do pattern matching. So you have two methods. One is called", "tokens": [51360, 19907, 1143, 281, 360, 11, 412, 1935, 337, 586, 11, 281, 360, 5102, 14324, 13, 407, 291, 362, 732, 7150, 13, 1485, 307, 1219, 51636], "temperature": 0.0, "avg_logprob": -0.09884340112859552, "compression_ratio": 1.668103448275862, "no_speech_prob": 0.0032723823096603155}, {"id": 245, "seek": 149732, "start": 1497.32, "end": 1504.52, "text": " deconstruct keys that is used on patterns that are hashes. And another one is called deconstruct,", "tokens": [50364, 49473, 1757, 9317, 300, 307, 1143, 322, 8294, 300, 366, 575, 8076, 13, 400, 1071, 472, 307, 1219, 49473, 1757, 11, 50724], "temperature": 0.0, "avg_logprob": -0.10871472358703613, "compression_ratio": 1.8238993710691824, "no_speech_prob": 0.0027569516096264124}, {"id": 246, "seek": 149732, "start": 1504.52, "end": 1514.84, "text": " which is used on pattern that are arrays. That make sense? And so this does all of the deconstruction", "tokens": [50724, 597, 307, 1143, 322, 5102, 300, 366, 41011, 13, 663, 652, 2020, 30, 400, 370, 341, 775, 439, 295, 264, 49473, 3826, 51240], "temperature": 0.0, "avg_logprob": -0.10871472358703613, "compression_ratio": 1.8238993710691824, "no_speech_prob": 0.0027569516096264124}, {"id": 247, "seek": 149732, "start": 1514.84, "end": 1522.36, "text": " and then if the pattern that you're sending doesn't respond to the deconstruct keys or the", "tokens": [51240, 293, 550, 498, 264, 5102, 300, 291, 434, 7750, 1177, 380, 4196, 281, 264, 49473, 1757, 9317, 420, 264, 51616], "temperature": 0.0, "avg_logprob": -0.10871472358703613, "compression_ratio": 1.8238993710691824, "no_speech_prob": 0.0027569516096264124}, {"id": 248, "seek": 152236, "start": 1522.4399999999998, "end": 1527.0, "text": " deconstruct method, then it's just going to give up and tell you to implement it yourself", "tokens": [50368, 49473, 1757, 3170, 11, 550, 309, 311, 445, 516, 281, 976, 493, 293, 980, 291, 281, 4445, 309, 1803, 50596], "temperature": 0.0, "avg_logprob": -0.09294848088864927, "compression_ratio": 1.7302904564315353, "no_speech_prob": 0.01384470984339714}, {"id": 249, "seek": 152236, "start": 1527.0, "end": 1533.1599999999999, "text": " so that it works. And after that, it's more of the same thing, right? So that's the second", "tokens": [50596, 370, 300, 309, 1985, 13, 400, 934, 300, 11, 309, 311, 544, 295, 264, 912, 551, 11, 558, 30, 407, 300, 311, 264, 1150, 50904], "temperature": 0.0, "avg_logprob": -0.09294848088864927, "compression_ratio": 1.7302904564315353, "no_speech_prob": 0.01384470984339714}, {"id": 250, "seek": 152236, "start": 1535.3999999999999, "end": 1538.76, "text": " pattern that we have. It's still trying to deconstruct them. And then eventually,", "tokens": [51016, 5102, 300, 321, 362, 13, 467, 311, 920, 1382, 281, 49473, 1757, 552, 13, 400, 550, 4728, 11, 51184], "temperature": 0.0, "avg_logprob": -0.09294848088864927, "compression_ratio": 1.7302904564315353, "no_speech_prob": 0.01384470984339714}, {"id": 251, "seek": 152236, "start": 1538.76, "end": 1542.4399999999998, "text": " if it doesn't find anything, it's going to return a no match error.", "tokens": [51184, 498, 309, 1177, 380, 915, 1340, 11, 309, 311, 516, 281, 2736, 257, 572, 2995, 6713, 13, 51368], "temperature": 0.0, "avg_logprob": -0.09294848088864927, "compression_ratio": 1.7302904564315353, "no_speech_prob": 0.01384470984339714}, {"id": 252, "seek": 152236, "start": 1545.3999999999999, "end": 1551.32, "text": " So the interesting thing then is how do we implement it ourselves? So if you have your", "tokens": [51516, 407, 264, 1880, 551, 550, 307, 577, 360, 321, 4445, 309, 4175, 30, 407, 498, 291, 362, 428, 51812], "temperature": 0.0, "avg_logprob": -0.09294848088864927, "compression_ratio": 1.7302904564315353, "no_speech_prob": 0.01384470984339714}, {"id": 253, "seek": 155132, "start": 1551.32, "end": 1557.72, "text": " class and you want it to be, you want to use pattern matching on it, then one thing that you can do", "tokens": [50364, 1508, 293, 291, 528, 309, 281, 312, 11, 291, 528, 281, 764, 5102, 14324, 322, 309, 11, 550, 472, 551, 300, 291, 393, 360, 50684], "temperature": 0.0, "avg_logprob": -0.10678038305165816, "compression_ratio": 1.9292929292929293, "no_speech_prob": 0.009998618625104427}, {"id": 254, "seek": 155132, "start": 1557.72, "end": 1565.0, "text": " is use, is implement the deconstruct keys method. So in this case, we have a location and we want", "tokens": [50684, 307, 764, 11, 307, 4445, 264, 49473, 1757, 9317, 3170, 13, 407, 294, 341, 1389, 11, 321, 362, 257, 4914, 293, 321, 528, 51048], "temperature": 0.0, "avg_logprob": -0.10678038305165816, "compression_ratio": 1.9292929292929293, "no_speech_prob": 0.009998618625104427}, {"id": 255, "seek": 155132, "start": 1565.0, "end": 1570.12, "text": " to have a latitude and a longitude in the deconstruct keys. And then that allows us every time we", "tokens": [51048, 281, 362, 257, 45436, 293, 257, 938, 4377, 294, 264, 49473, 1757, 9317, 13, 400, 550, 300, 4045, 505, 633, 565, 321, 51304], "temperature": 0.0, "avg_logprob": -0.10678038305165816, "compression_ratio": 1.9292929292929293, "no_speech_prob": 0.009998618625104427}, {"id": 256, "seek": 155132, "start": 1570.12, "end": 1574.84, "text": " have a location to use pattern matching on it, because it's going to deconstruct this,", "tokens": [51304, 362, 257, 4914, 281, 764, 5102, 14324, 322, 309, 11, 570, 309, 311, 516, 281, 49473, 1757, 341, 11, 51540], "temperature": 0.0, "avg_logprob": -0.10678038305165816, "compression_ratio": 1.9292929292929293, "no_speech_prob": 0.009998618625104427}, {"id": 257, "seek": 157484, "start": 1575.32, "end": 1582.4399999999998, "text": " deconstruct this, and then see what matches. And so in this case, and interesting thing also is", "tokens": [50388, 49473, 1757, 341, 11, 293, 550, 536, 437, 10676, 13, 400, 370, 294, 341, 1389, 11, 293, 1880, 551, 611, 307, 50744], "temperature": 0.0, "avg_logprob": -0.11933496263292101, "compression_ratio": 1.789237668161435, "no_speech_prob": 0.040819987654685974}, {"id": 258, "seek": 157484, "start": 1582.4399999999998, "end": 1588.4399999999998, "text": " inside of our pattern, we have access to everything that we've been talking about earlier. So in your", "tokens": [50744, 1854, 295, 527, 5102, 11, 321, 362, 2105, 281, 1203, 300, 321, 600, 668, 1417, 466, 3071, 13, 407, 294, 428, 51044], "temperature": 0.0, "avg_logprob": -0.11933496263292101, "compression_ratio": 1.789237668161435, "no_speech_prob": 0.040819987654685974}, {"id": 259, "seek": 157484, "start": 1588.4399999999998, "end": 1595.8, "text": " pattern, you can put classes, you can put reg X, you can put ranges in this case. And the only thing", "tokens": [51044, 5102, 11, 291, 393, 829, 5359, 11, 291, 393, 829, 1121, 1783, 11, 291, 393, 829, 22526, 294, 341, 1389, 13, 400, 264, 787, 551, 51412], "temperature": 0.0, "avg_logprob": -0.11933496263292101, "compression_ratio": 1.789237668161435, "no_speech_prob": 0.040819987654685974}, {"id": 260, "seek": 157484, "start": 1595.8, "end": 1601.8799999999999, "text": " I think we haven't seen before is this little thing magic that just takes like, it wants to match it", "tokens": [51412, 286, 519, 321, 2378, 380, 1612, 949, 307, 341, 707, 551, 5585, 300, 445, 2516, 411, 11, 309, 2738, 281, 2995, 309, 51716], "temperature": 0.0, "avg_logprob": -0.11933496263292101, "compression_ratio": 1.789237668161435, "no_speech_prob": 0.040819987654685974}, {"id": 261, "seek": 160188, "start": 1601.88, "end": 1607.24, "text": " against this and then store it into the variable that we can then use for anything else.", "tokens": [50364, 1970, 341, 293, 550, 3531, 309, 666, 264, 7006, 300, 321, 393, 550, 764, 337, 1340, 1646, 13, 50632], "temperature": 0.0, "avg_logprob": -0.17413117592794852, "compression_ratio": 1.4326241134751774, "no_speech_prob": 0.0015727686695754528}, {"id": 262, "seek": 160188, "start": 1609.16, "end": 1613.16, "text": " And I think that's it. I've tried to go through everything.", "tokens": [50728, 400, 286, 519, 300, 311, 309, 13, 286, 600, 3031, 281, 352, 807, 1203, 13, 50928], "temperature": 0.0, "avg_logprob": -0.17413117592794852, "compression_ratio": 1.4326241134751774, "no_speech_prob": 0.0015727686695754528}, {"id": 263, "seek": 160188, "start": 1621.8000000000002, "end": 1623.4, "text": " I sped through that one, sorry.", "tokens": [51360, 286, 637, 292, 807, 300, 472, 11, 2597, 13, 51440], "temperature": 0.0, "avg_logprob": -0.17413117592794852, "compression_ratio": 1.4326241134751774, "no_speech_prob": 0.0015727686695754528}, {"id": 264, "seek": 160188, "start": 1627.8000000000002, "end": 1628.7600000000002, "text": " We have so much time.", "tokens": [51660, 492, 362, 370, 709, 565, 13, 51708], "temperature": 0.0, "avg_logprob": -0.17413117592794852, "compression_ratio": 1.4326241134751774, "no_speech_prob": 0.0015727686695754528}, {"id": 265, "seek": 163188, "start": 1632.8400000000001, "end": 1633.8000000000002, "text": " I didn't.", "tokens": [50412, 286, 994, 380, 13, 50460], "temperature": 0.0, "avg_logprob": -0.38665365870994856, "compression_ratio": 1.5108695652173914, "no_speech_prob": 0.0017801171634346247}, {"id": 266, "seek": 163188, "start": 1635.16, "end": 1637.96, "text": " You used a variable that was not declared before.", "tokens": [50528, 509, 1143, 257, 7006, 300, 390, 406, 15489, 949, 13, 50668], "temperature": 0.0, "avg_logprob": -0.38665365870994856, "compression_ratio": 1.5108695652173914, "no_speech_prob": 0.0017801171634346247}, {"id": 267, "seek": 163188, "start": 1638.6000000000001, "end": 1643.3200000000002, "text": " Yeah, probably. Where? In the right address before?", "tokens": [50700, 865, 11, 1391, 13, 2305, 30, 682, 264, 558, 2985, 949, 30, 50936], "temperature": 0.0, "avg_logprob": -0.38665365870994856, "compression_ratio": 1.5108695652173914, "no_speech_prob": 0.0017801171634346247}, {"id": 268, "seek": 163188, "start": 1649.3200000000002, "end": 1649.8000000000002, "text": " One?", "tokens": [51236, 1485, 30, 51260], "temperature": 0.0, "avg_logprob": -0.38665365870994856, "compression_ratio": 1.5108695652173914, "no_speech_prob": 0.0017801171634346247}, {"id": 269, "seek": 163188, "start": 1649.8000000000002, "end": 1652.92, "text": " latitude. Did you declare length to be equal to new before?", "tokens": [51260, 45436, 13, 2589, 291, 19710, 4641, 281, 312, 2681, 281, 777, 949, 30, 51416], "temperature": 0.0, "avg_logprob": -0.38665365870994856, "compression_ratio": 1.5108695652173914, "no_speech_prob": 0.0017801171634346247}, {"id": 270, "seek": 163188, "start": 1652.92, "end": 1657.48, "text": " No, you don't have to declare it before. Basically what this does is it takes this and then store it.", "tokens": [51416, 883, 11, 291, 500, 380, 362, 281, 19710, 309, 949, 13, 8537, 437, 341, 775, 307, 309, 2516, 341, 293, 550, 3531, 309, 13, 51644], "temperature": 0.0, "avg_logprob": -0.38665365870994856, "compression_ratio": 1.5108695652173914, "no_speech_prob": 0.0017801171634346247}, {"id": 271, "seek": 165748, "start": 1657.48, "end": 1663.4, "text": " It takes whatever matches here. So that would be technically this and then store it into the", "tokens": [50364, 467, 2516, 2035, 10676, 510, 13, 407, 300, 576, 312, 12120, 341, 293, 550, 3531, 309, 666, 264, 50660], "temperature": 0.0, "avg_logprob": -0.15259377499844165, "compression_ratio": 1.6205357142857142, "no_speech_prob": 0.0012636508326977491}, {"id": 272, "seek": 165748, "start": 1663.4, "end": 1667.8, "text": " latitude variables. You don't have to declare it before. And what's the scope of that variable?", "tokens": [50660, 45436, 9102, 13, 509, 500, 380, 362, 281, 19710, 309, 949, 13, 400, 437, 311, 264, 11923, 295, 300, 7006, 30, 50880], "temperature": 0.0, "avg_logprob": -0.15259377499844165, "compression_ratio": 1.6205357142857142, "no_speech_prob": 0.0012636508326977491}, {"id": 273, "seek": 165748, "start": 1668.44, "end": 1673.8, "text": " It's going to be a scope to whatever the case is in. Right? So if your case is defined in a method,", "tokens": [50912, 467, 311, 516, 281, 312, 257, 11923, 281, 2035, 264, 1389, 307, 294, 13, 1779, 30, 407, 498, 428, 1389, 307, 7642, 294, 257, 3170, 11, 51180], "temperature": 0.0, "avg_logprob": -0.15259377499844165, "compression_ratio": 1.6205357142857142, "no_speech_prob": 0.0012636508326977491}, {"id": 274, "seek": 165748, "start": 1673.8, "end": 1675.8, "text": " then you have access to it in the entire method.", "tokens": [51180, 550, 291, 362, 2105, 281, 309, 294, 264, 2302, 3170, 13, 51280], "temperature": 0.0, "avg_logprob": -0.15259377499844165, "compression_ratio": 1.6205357142857142, "no_speech_prob": 0.0012636508326977491}, {"id": 275, "seek": 165748, "start": 1683.64, "end": 1685.64, "text": " This is in current? Yeah.", "tokens": [51672, 639, 307, 294, 2190, 30, 865, 13, 51772], "temperature": 0.0, "avg_logprob": -0.15259377499844165, "compression_ratio": 1.6205357142857142, "no_speech_prob": 0.0012636508326977491}, {"id": 276, "seek": 168748, "start": 1687.88, "end": 1693.64, "text": " I think this might be, this might have been implemented in Ruby three.", "tokens": [50384, 286, 519, 341, 1062, 312, 11, 341, 1062, 362, 668, 12270, 294, 19907, 1045, 13, 50672], "temperature": 0.0, "avg_logprob": -0.16000012601359506, "compression_ratio": 1.5919282511210762, "no_speech_prob": 0.0028875060379505157}, {"id": 277, "seek": 168748, "start": 1694.92, "end": 1701.0, "text": " And the first occurrence of pattern matching, the one with the case in, was experimental in 2.7", "tokens": [50736, 400, 264, 700, 36122, 295, 5102, 14324, 11, 264, 472, 365, 264, 1389, 294, 11, 390, 17069, 294, 568, 13, 22, 51040], "temperature": 0.0, "avg_logprob": -0.16000012601359506, "compression_ratio": 1.5919282511210762, "no_speech_prob": 0.0028875060379505157}, {"id": 278, "seek": 168748, "start": 1701.0, "end": 1708.52, "text": " and then actually arrived in Ruby three. And they've been trying to push it a bit more in", "tokens": [51040, 293, 550, 767, 6678, 294, 19907, 1045, 13, 400, 436, 600, 668, 1382, 281, 2944, 309, 257, 857, 544, 294, 51416], "temperature": 0.0, "avg_logprob": -0.16000012601359506, "compression_ratio": 1.5919282511210762, "no_speech_prob": 0.0028875060379505157}, {"id": 279, "seek": 168748, "start": 1708.52, "end": 1714.84, "text": " subsequent versions. So now, for example, you don't necessarily need to have case. If you want it,", "tokens": [51416, 19962, 9606, 13, 407, 586, 11, 337, 1365, 11, 291, 500, 380, 4725, 643, 281, 362, 1389, 13, 759, 291, 528, 309, 11, 51732], "temperature": 0.0, "avg_logprob": -0.16000012601359506, "compression_ratio": 1.5919282511210762, "no_speech_prob": 0.0028875060379505157}, {"id": 280, "seek": 171484, "start": 1714.84, "end": 1720.1999999999998, "text": " if you want to use pattern matching, then you can just write your variable in something and", "tokens": [50364, 498, 291, 528, 281, 764, 5102, 14324, 11, 550, 291, 393, 445, 2464, 428, 7006, 294, 746, 293, 50632], "temperature": 0.0, "avg_logprob": -0.2811534920918573, "compression_ratio": 1.6590909090909092, "no_speech_prob": 0.00790778361260891}, {"id": 281, "seek": 171484, "start": 1720.1999999999998, "end": 1722.1999999999998, "text": " use it as a predicate to see if it matches or not.", "tokens": [50632, 764, 309, 382, 257, 3852, 8700, 281, 536, 498, 309, 10676, 420, 406, 13, 50732], "temperature": 0.0, "avg_logprob": -0.2811534920918573, "compression_ratio": 1.6590909090909092, "no_speech_prob": 0.00790778361260891}, {"id": 282, "seek": 171484, "start": 1725.24, "end": 1730.84, "text": " In your example where you're looking for an admin user in an array of users and you have those", "tokens": [50884, 682, 428, 1365, 689, 291, 434, 1237, 337, 364, 24236, 4195, 294, 364, 10225, 295, 5022, 293, 291, 362, 729, 51164], "temperature": 0.0, "avg_logprob": -0.2811534920918573, "compression_ratio": 1.6590909090909092, "no_speech_prob": 0.00790778361260891}, {"id": 283, "seek": 171484, "start": 1730.84, "end": 1737.9599999999998, "text": " operations at the back, does that work if your admin user is the first or the last?", "tokens": [51164, 7705, 412, 264, 646, 11, 775, 300, 589, 498, 428, 24236, 4195, 307, 264, 700, 420, 264, 1036, 30, 51520], "temperature": 0.0, "avg_logprob": -0.2811534920918573, "compression_ratio": 1.6590909090909092, "no_speech_prob": 0.00790778361260891}, {"id": 284, "seek": 171484, "start": 1738.84, "end": 1740.84, "text": " Yeah, yeah, yeah, yeah. Then the, then the,", "tokens": [51564, 865, 11, 1338, 11, 1338, 11, 1338, 13, 1396, 264, 11, 550, 264, 11, 51664], "temperature": 0.0, "avg_logprob": -0.2811534920918573, "compression_ratio": 1.6590909090909092, "no_speech_prob": 0.00790778361260891}, {"id": 285, "seek": 174084, "start": 1741.08, "end": 1744.52, "text": " Like it might not. Yeah, fair. Yeah, yeah, definitely fair.", "tokens": [50376, 1743, 309, 1062, 406, 13, 865, 11, 3143, 13, 865, 11, 1338, 11, 2138, 3143, 13, 50548], "temperature": 0.0, "avg_logprob": -0.22287628449589372, "compression_ratio": 1.6964285714285714, "no_speech_prob": 0.008760220371186733}, {"id": 286, "seek": 174084, "start": 1745.56, "end": 1750.04, "text": " What this will do is it will put nil in here and nil in the other variable.", "tokens": [50600, 708, 341, 486, 360, 307, 309, 486, 829, 297, 388, 294, 510, 293, 297, 388, 294, 264, 661, 7006, 13, 50824], "temperature": 0.0, "avg_logprob": -0.22287628449589372, "compression_ratio": 1.6964285714285714, "no_speech_prob": 0.008760220371186733}, {"id": 287, "seek": 174084, "start": 1750.04, "end": 1753.48, "text": " Right? It's like there's nothing after, there's nothing before or there's nothing before.", "tokens": [50824, 1779, 30, 467, 311, 411, 456, 311, 1825, 934, 11, 456, 311, 1825, 949, 420, 456, 311, 1825, 949, 13, 50996], "temperature": 0.0, "avg_logprob": -0.22287628449589372, "compression_ratio": 1.6964285714285714, "no_speech_prob": 0.008760220371186733}, {"id": 288, "seek": 174084, "start": 1765.48, "end": 1768.9199999999998, "text": " Yeah, that's the thing that I was a bit, if you about this,", "tokens": [51596, 865, 11, 300, 311, 264, 551, 300, 286, 390, 257, 857, 11, 498, 291, 466, 341, 11, 51768], "temperature": 0.0, "avg_logprob": -0.22287628449589372, "compression_ratio": 1.6964285714285714, "no_speech_prob": 0.008760220371186733}, {"id": 289, "seek": 176892, "start": 1769.8000000000002, "end": 1773.4, "text": " basically the, shit, I have to go through all the animations. Sorry, bear with me.", "tokens": [50408, 1936, 264, 11, 4611, 11, 286, 362, 281, 352, 807, 439, 264, 22868, 13, 4919, 11, 6155, 365, 385, 13, 50588], "temperature": 0.0, "avg_logprob": -0.1551118166941517, "compression_ratio": 1.602510460251046, "no_speech_prob": 0.00955165270715952}, {"id": 290, "seek": 176892, "start": 1774.68, "end": 1778.68, "text": " It's going to scroll again on. Okay, sure, whatever, shit.", "tokens": [50652, 467, 311, 516, 281, 11369, 797, 322, 13, 1033, 11, 988, 11, 2035, 11, 4611, 13, 50852], "temperature": 0.0, "avg_logprob": -0.1551118166941517, "compression_ratio": 1.602510460251046, "no_speech_prob": 0.00955165270715952}, {"id": 291, "seek": 176892, "start": 1780.68, "end": 1785.64, "text": " The argument that it takes is in case you only want to deconstruct some keys.", "tokens": [50952, 440, 6770, 300, 309, 2516, 307, 294, 1389, 291, 787, 528, 281, 49473, 1757, 512, 9317, 13, 51200], "temperature": 0.0, "avg_logprob": -0.1551118166941517, "compression_ratio": 1.602510460251046, "no_speech_prob": 0.00955165270715952}, {"id": 292, "seek": 176892, "start": 1786.68, "end": 1790.76, "text": " Right? So if that is, if you have a big object and you only want to deconstruct latitude,", "tokens": [51252, 1779, 30, 407, 498, 300, 307, 11, 498, 291, 362, 257, 955, 2657, 293, 291, 787, 528, 281, 49473, 1757, 45436, 11, 51456], "temperature": 0.0, "avg_logprob": -0.1551118166941517, "compression_ratio": 1.602510460251046, "no_speech_prob": 0.00955165270715952}, {"id": 293, "seek": 176892, "start": 1790.76, "end": 1794.6000000000001, "text": " for example, you could work it this way. That's what it's supposed to do.", "tokens": [51456, 337, 1365, 11, 291, 727, 589, 309, 341, 636, 13, 663, 311, 437, 309, 311, 3442, 281, 360, 13, 51648], "temperature": 0.0, "avg_logprob": -0.1551118166941517, "compression_ratio": 1.602510460251046, "no_speech_prob": 0.00955165270715952}, {"id": 294, "seek": 179460, "start": 1795.1599999999999, "end": 1798.1999999999998, "text": " In the example, I didn't go through the trouble of implementing all of it,", "tokens": [50392, 682, 264, 1365, 11, 286, 994, 380, 352, 807, 264, 5253, 295, 18114, 439, 295, 309, 11, 50544], "temperature": 0.0, "avg_logprob": -0.29703672499883743, "compression_ratio": 1.6167400881057268, "no_speech_prob": 0.004746759310364723}, {"id": 295, "seek": 179460, "start": 1798.1999999999998, "end": 1800.84, "text": " because if I want to write code big, I can write too much code.", "tokens": [50544, 570, 498, 286, 528, 281, 2464, 3089, 955, 11, 286, 393, 2464, 886, 709, 3089, 13, 50676], "temperature": 0.0, "avg_logprob": -0.29703672499883743, "compression_ratio": 1.6167400881057268, "no_speech_prob": 0.004746759310364723}, {"id": 296, "seek": 179460, "start": 1803.24, "end": 1803.9599999999998, "text": " And yeah, that's why.", "tokens": [50796, 400, 1338, 11, 300, 311, 983, 13, 50832], "temperature": 0.0, "avg_logprob": -0.29703672499883743, "compression_ratio": 1.6167400881057268, "no_speech_prob": 0.004746759310364723}, {"id": 297, "seek": 179460, "start": 1806.9199999999998, "end": 1809.48, "text": " So it was deconstruct for arrays and deconstruct keys, though.", "tokens": [50980, 407, 309, 390, 49473, 1757, 337, 41011, 293, 49473, 1757, 9317, 11, 1673, 13, 51108], "temperature": 0.0, "avg_logprob": -0.29703672499883743, "compression_ratio": 1.6167400881057268, "no_speech_prob": 0.004746759310364723}, {"id": 298, "seek": 179460, "start": 1809.48, "end": 1809.9599999999998, "text": " Yeah.", "tokens": [51108, 865, 13, 51132], "temperature": 0.0, "avg_logprob": -0.29703672499883743, "compression_ratio": 1.6167400881057268, "no_speech_prob": 0.004746759310364723}, {"id": 299, "seek": 179460, "start": 1809.9599999999998, "end": 1814.1999999999998, "text": " And you can define deconstruct as well. If you've got a class that implements an interval or something.", "tokens": [51132, 400, 291, 393, 6964, 49473, 1757, 382, 731, 13, 759, 291, 600, 658, 257, 1508, 300, 704, 17988, 364, 15035, 420, 746, 13, 51344], "temperature": 0.0, "avg_logprob": -0.29703672499883743, "compression_ratio": 1.6167400881057268, "no_speech_prob": 0.004746759310364723}, {"id": 300, "seek": 179460, "start": 1814.1999999999998, "end": 1816.12, "text": " Probably, yeah, yeah, I think so.", "tokens": [51344, 9210, 11, 1338, 11, 1338, 11, 286, 519, 370, 13, 51440], "temperature": 0.0, "avg_logprob": -0.29703672499883743, "compression_ratio": 1.6167400881057268, "no_speech_prob": 0.004746759310364723}, {"id": 301, "seek": 181612, "start": 1816.12, "end": 1825.56, "text": " Just to take how stable you think the syntax is. Do you think it's going to stay the same?", "tokens": [50364, 1449, 281, 747, 577, 8351, 291, 519, 264, 28431, 307, 13, 1144, 291, 519, 309, 311, 516, 281, 1754, 264, 912, 30, 50836], "temperature": 0.4, "avg_logprob": -0.47780328734308225, "compression_ratio": 2.1964285714285716, "no_speech_prob": 0.029721196740865707}, {"id": 302, "seek": 181612, "start": 1825.56, "end": 1826.52, "text": " Huh.", "tokens": [50836, 8063, 13, 50884], "temperature": 0.4, "avg_logprob": -0.47780328734308225, "compression_ratio": 2.1964285714285716, "no_speech_prob": 0.029721196740865707}, {"id": 303, "seek": 181612, "start": 1827.56, "end": 1830.36, "text": " Would you, would you, would you, would you want to do, for example, like the, the, the, the, the,", "tokens": [50936, 6068, 291, 11, 576, 291, 11, 576, 291, 11, 576, 291, 528, 281, 360, 11, 337, 1365, 11, 411, 264, 11, 264, 11, 264, 11, 264, 11, 264, 11, 51076], "temperature": 0.4, "avg_logprob": -0.47780328734308225, "compression_ratio": 2.1964285714285716, "no_speech_prob": 0.029721196740865707}, {"id": 304, "seek": 181612, "start": 1830.36, "end": 1839.0, "text": " the, the, the, the, the, the, the, I think it's going to stay the same. No, sorry.", "tokens": [51076, 264, 11, 264, 11, 264, 11, 264, 11, 264, 11, 264, 11, 264, 11, 286, 519, 309, 311, 516, 281, 1754, 264, 912, 13, 883, 11, 2597, 13, 51508], "temperature": 0.4, "avg_logprob": -0.47780328734308225, "compression_ratio": 2.1964285714285716, "no_speech_prob": 0.029721196740865707}, {"id": 305, "seek": 181612, "start": 1839.0, "end": 1842.52, "text": " Yeah. I know I was thinking in my head, I think it's going to stay the same because it's the", "tokens": [51508, 865, 13, 286, 458, 286, 390, 1953, 294, 452, 1378, 11, 286, 519, 309, 311, 516, 281, 1754, 264, 912, 570, 309, 311, 264, 51684], "temperature": 0.4, "avg_logprob": -0.47780328734308225, "compression_ratio": 2.1964285714285716, "no_speech_prob": 0.029721196740865707}, {"id": 306, "seek": 184252, "start": 1842.52, "end": 1847.48, "text": " exact same syntax that Alexia uses, for example. Like they've probably been inspired from other", "tokens": [50364, 1900, 912, 28431, 300, 5202, 654, 4960, 11, 337, 1365, 13, 1743, 436, 600, 1391, 668, 7547, 490, 661, 50612], "temperature": 0.0, "avg_logprob": -0.16540750704313578, "compression_ratio": 1.4583333333333333, "no_speech_prob": 0.011494098231196404}, {"id": 307, "seek": 184252, "start": 1847.48, "end": 1852.44, "text": " languages and used it. And so I'm expecting it to stay the same. But then again, I don't know.", "tokens": [50612, 8650, 293, 1143, 309, 13, 400, 370, 286, 478, 9650, 309, 281, 1754, 264, 912, 13, 583, 550, 797, 11, 286, 500, 380, 458, 13, 50860], "temperature": 0.0, "avg_logprob": -0.16540750704313578, "compression_ratio": 1.4583333333333333, "no_speech_prob": 0.011494098231196404}, {"id": 308, "seek": 184252, "start": 1864.6, "end": 1871.48, "text": " I think right now I'm still, I'm trying, I tried to push for it in very simple use cases.", "tokens": [51468, 286, 519, 558, 586, 286, 478, 920, 11, 286, 478, 1382, 11, 286, 3031, 281, 2944, 337, 309, 294, 588, 2199, 764, 3331, 13, 51812], "temperature": 0.0, "avg_logprob": -0.16540750704313578, "compression_ratio": 1.4583333333333333, "no_speech_prob": 0.011494098231196404}, {"id": 309, "seek": 187148, "start": 1872.1200000000001, "end": 1878.68, "text": " So usually in a, if we get, if we have to make an API call, that's probably the best,", "tokens": [50396, 407, 2673, 294, 257, 11, 498, 321, 483, 11, 498, 321, 362, 281, 652, 364, 9362, 818, 11, 300, 311, 1391, 264, 1151, 11, 50724], "temperature": 0.0, "avg_logprob": -0.1552394079783606, "compression_ratio": 1.6727941176470589, "no_speech_prob": 0.03158546984195709}, {"id": 310, "seek": 187148, "start": 1878.68, "end": 1884.1200000000001, "text": " like, foot in the door to get it working in your code basis. Like, because that's the thing that", "tokens": [50724, 411, 11, 2671, 294, 264, 2853, 281, 483, 309, 1364, 294, 428, 3089, 5143, 13, 1743, 11, 570, 300, 311, 264, 551, 300, 50996], "temperature": 0.0, "avg_logprob": -0.1552394079783606, "compression_ratio": 1.6727941176470589, "no_speech_prob": 0.03158546984195709}, {"id": 311, "seek": 187148, "start": 1884.1200000000001, "end": 1889.08, "text": " seems the most obvious, right? I get an answer and then I can, not only fetch the status,", "tokens": [50996, 2544, 264, 881, 6322, 11, 558, 30, 286, 483, 364, 1867, 293, 550, 286, 393, 11, 406, 787, 23673, 264, 6558, 11, 51244], "temperature": 0.0, "avg_logprob": -0.1552394079783606, "compression_ratio": 1.6727941176470589, "no_speech_prob": 0.03158546984195709}, {"id": 312, "seek": 187148, "start": 1889.08, "end": 1895.64, "text": " but assign everything in the answer and then give it to another method. I think that's a bit,", "tokens": [51244, 457, 6269, 1203, 294, 264, 1867, 293, 550, 976, 309, 281, 1071, 3170, 13, 286, 519, 300, 311, 257, 857, 11, 51572], "temperature": 0.0, "avg_logprob": -0.1552394079783606, "compression_ratio": 1.6727941176470589, "no_speech_prob": 0.03158546984195709}, {"id": 313, "seek": 187148, "start": 1896.84, "end": 1901.32, "text": " not a frontend dev. So don't quote me on this at all. But it looks a bit like the object", "tokens": [51632, 406, 257, 1868, 521, 1905, 13, 407, 500, 380, 6513, 385, 322, 341, 412, 439, 13, 583, 309, 1542, 257, 857, 411, 264, 2657, 51856], "temperature": 0.0, "avg_logprob": -0.1552394079783606, "compression_ratio": 1.6727941176470589, "no_speech_prob": 0.03158546984195709}, {"id": 314, "seek": 190132, "start": 1901.32, "end": 1905.48, "text": " deconstruction thing from JavaScript. Or you can get an object and then assign all the variables", "tokens": [50364, 49473, 3826, 551, 490, 15778, 13, 1610, 291, 393, 483, 364, 2657, 293, 550, 6269, 439, 264, 9102, 50572], "temperature": 0.0, "avg_logprob": -0.11795322869413642, "compression_ratio": 1.6126126126126126, "no_speech_prob": 0.004824182949960232}, {"id": 315, "seek": 190132, "start": 1905.48, "end": 1909.8, "text": " into it. In this use case, I think it's a good first step to implement it in a code base. I", "tokens": [50572, 666, 309, 13, 682, 341, 764, 1389, 11, 286, 519, 309, 311, 257, 665, 700, 1823, 281, 4445, 309, 294, 257, 3089, 3096, 13, 286, 50788], "temperature": 0.0, "avg_logprob": -0.11795322869413642, "compression_ratio": 1.6126126126126126, "no_speech_prob": 0.004824182949960232}, {"id": 316, "seek": 190132, "start": 1909.8, "end": 1913.48, "text": " wouldn't go all out and start putting deconstruct keys in every class.", "tokens": [50788, 2759, 380, 352, 439, 484, 293, 722, 3372, 49473, 1757, 9317, 294, 633, 1508, 13, 50972], "temperature": 0.0, "avg_logprob": -0.11795322869413642, "compression_ratio": 1.6126126126126126, "no_speech_prob": 0.004824182949960232}, {"id": 317, "seek": 190132, "start": 1925.24, "end": 1930.36, "text": " That would be really, I really hope that, I really hope they put it in Ruby at some point. I don't", "tokens": [51560, 663, 576, 312, 534, 11, 286, 534, 1454, 300, 11, 286, 534, 1454, 436, 829, 309, 294, 19907, 412, 512, 935, 13, 286, 500, 380, 51816], "temperature": 0.0, "avg_logprob": -0.11795322869413642, "compression_ratio": 1.6126126126126126, "no_speech_prob": 0.004824182949960232}, {"id": 318, "seek": 193036, "start": 1930.36, "end": 1936.36, "text": " think that's in the plans right now. I think the idea, the main idea behind was, like, when they", "tokens": [50364, 519, 300, 311, 294, 264, 5482, 558, 586, 13, 286, 519, 264, 1558, 11, 264, 2135, 1558, 2261, 390, 11, 411, 11, 562, 436, 50664], "temperature": 0.0, "avg_logprob": -0.09501031574450042, "compression_ratio": 1.6111111111111112, "no_speech_prob": 0.010008370503783226}, {"id": 319, "seek": 193036, "start": 1936.36, "end": 1941.9599999999998, "text": " put it in Ruby at all, pattern matching in 2.7, it was kind of touch and go. People were discussing", "tokens": [50664, 829, 309, 294, 19907, 412, 439, 11, 5102, 14324, 294, 568, 13, 22, 11, 309, 390, 733, 295, 2557, 293, 352, 13, 3432, 645, 10850, 50944], "temperature": 0.0, "avg_logprob": -0.09501031574450042, "compression_ratio": 1.6111111111111112, "no_speech_prob": 0.010008370503783226}, {"id": 320, "seek": 193036, "start": 1941.9599999999998, "end": 1947.8799999999999, "text": " a lot about do we want this in our code base because pattern matching in the collective", "tokens": [50944, 257, 688, 466, 360, 321, 528, 341, 294, 527, 3089, 3096, 570, 5102, 14324, 294, 264, 12590, 51240], "temperature": 0.0, "avg_logprob": -0.09501031574450042, "compression_ratio": 1.6111111111111112, "no_speech_prob": 0.010008370503783226}, {"id": 321, "seek": 193036, "start": 1948.6, "end": 1955.3999999999999, "text": " brain is usually more functional than object oriented. But now that it's there and it's past", "tokens": [51276, 3567, 307, 2673, 544, 11745, 813, 2657, 21841, 13, 583, 586, 300, 309, 311, 456, 293, 309, 311, 1791, 51616], "temperature": 0.0, "avg_logprob": -0.09501031574450042, "compression_ratio": 1.6111111111111112, "no_speech_prob": 0.010008370503783226}, {"id": 322, "seek": 195540, "start": 1955.4, "end": 1961.48, "text": " the experimental and it's now stable, I think they're eventually going to do it. It'd be a shame not to, right?", "tokens": [50364, 264, 17069, 293, 309, 311, 586, 8351, 11, 286, 519, 436, 434, 4728, 516, 281, 360, 309, 13, 467, 1116, 312, 257, 10069, 406, 281, 11, 558, 30, 50668], "temperature": 0.0, "avg_logprob": -0.3100136724011651, "compression_ratio": 1.7044534412955465, "no_speech_prob": 0.025141142308712006}, {"id": 323, "seek": 195540, "start": 1966.68, "end": 1970.2, "text": " Do you think some of this stuff is going to end up in the Ruby style guy?", "tokens": [50928, 1144, 291, 519, 512, 295, 341, 1507, 307, 516, 281, 917, 493, 294, 264, 19907, 3758, 2146, 30, 51104], "temperature": 0.0, "avg_logprob": -0.3100136724011651, "compression_ratio": 1.7044534412955465, "no_speech_prob": 0.025141142308712006}, {"id": 324, "seek": 195540, "start": 1971.64, "end": 1975.0, "text": " And be something like Ruby cop goes and says, no, no, you don't want to do that.", "tokens": [51176, 400, 312, 746, 411, 19907, 2971, 1709, 293, 1619, 11, 572, 11, 572, 11, 291, 500, 380, 528, 281, 360, 300, 13, 51344], "temperature": 0.0, "avg_logprob": -0.3100136724011651, "compression_ratio": 1.7044534412955465, "no_speech_prob": 0.025141142308712006}, {"id": 325, "seek": 195540, "start": 1975.0, "end": 1976.0400000000002, "text": " You don't want to do that.", "tokens": [51344, 509, 500, 380, 528, 281, 360, 300, 13, 51396], "temperature": 0.0, "avg_logprob": -0.3100136724011651, "compression_ratio": 1.7044534412955465, "no_speech_prob": 0.025141142308712006}, {"id": 326, "seek": 195540, "start": 1976.0400000000002, "end": 1977.3200000000002, "text": " You want to use this instead.", "tokens": [51396, 509, 528, 281, 764, 341, 2602, 13, 51460], "temperature": 0.0, "avg_logprob": -0.3100136724011651, "compression_ratio": 1.7044534412955465, "no_speech_prob": 0.025141142308712006}, {"id": 327, "seek": 195540, "start": 1979.64, "end": 1984.68, "text": " Probably not in the near future. Because I think people are still very much like trying to figure", "tokens": [51576, 9210, 406, 294, 264, 2651, 2027, 13, 1436, 286, 519, 561, 366, 920, 588, 709, 411, 1382, 281, 2573, 51828], "temperature": 0.0, "avg_logprob": -0.3100136724011651, "compression_ratio": 1.7044534412955465, "no_speech_prob": 0.025141142308712006}, {"id": 328, "seek": 198468, "start": 1984.68, "end": 1990.6000000000001, "text": " out what the good style is. Even when I was preparing this, I couldn't find a lot of examples.", "tokens": [50364, 484, 437, 264, 665, 3758, 307, 13, 2754, 562, 286, 390, 10075, 341, 11, 286, 2809, 380, 915, 257, 688, 295, 5110, 13, 50660], "temperature": 0.0, "avg_logprob": -0.2092258834838867, "compression_ratio": 1.408839779005525, "no_speech_prob": 0.0018958782311528921}, {"id": 329, "seek": 198468, "start": 1990.6000000000001, "end": 1995.72, "text": " So I kind of came up with what I think would look the best. But I don't think for now, at least,", "tokens": [50660, 407, 286, 733, 295, 1361, 493, 365, 437, 286, 519, 576, 574, 264, 1151, 13, 583, 286, 500, 380, 519, 337, 586, 11, 412, 1935, 11, 50916], "temperature": 0.0, "avg_logprob": -0.2092258834838867, "compression_ratio": 1.408839779005525, "no_speech_prob": 0.0018958782311528921}, {"id": 330, "seek": 198468, "start": 1995.72, "end": 1999.4, "text": " there are a lot of established guidelines.", "tokens": [50916, 456, 366, 257, 688, 295, 7545, 12470, 13, 51100], "temperature": 0.0, "avg_logprob": -0.2092258834838867, "compression_ratio": 1.408839779005525, "no_speech_prob": 0.0018958782311528921}, {"id": 331, "seek": 198468, "start": 2004.52, "end": 2006.8400000000001, "text": " We good? Cool.", "tokens": [51356, 492, 665, 30, 8561, 13, 51472], "temperature": 0.0, "avg_logprob": -0.2092258834838867, "compression_ratio": 1.408839779005525, "no_speech_prob": 0.0018958782311528921}, {"id": 332, "seek": 198468, "start": 2009.72, "end": 2013.5600000000002, "text": " Nice.", "tokens": [51616, 5490, 13, 51808], "temperature": 0.0, "avg_logprob": -0.2092258834838867, "compression_ratio": 1.408839779005525, "no_speech_prob": 0.0018958782311528921}], "language": "en"}