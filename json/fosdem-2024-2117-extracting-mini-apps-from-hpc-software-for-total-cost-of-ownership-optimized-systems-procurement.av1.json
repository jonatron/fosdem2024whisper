{"text": " We want to stick to time. We've been doing very well. So we want to keep that up. The next talk is about, oh sorry, your name is on the slide. That doesn't help me. Tim, yeah, the next talk is about Tim, about extracting mini apps for HPC software. Then, thank you for having me back at Fostum. I am Tim. I'm by trade. I'm a compiler guy and I'm giving a talk to the HPC Dev Room and how that came to be. We'll be part of the talk extracting mini apps from HPC software for total cost of ownership, optimized system procurement. And I want to give a quick background about how this project came to be before I actually start to go into the technical details because this project is part of the NHR Association funded TCO, so total cost of ownership project. NHR stands for Nationales Hochleistungsregion. It's the German term for national high performance computing basically. And the NHR is an alliance of computing centers which all have different specialties, but all have a common admission process and have a so-called harmonized computing environment, which means basically that all the clusters at the different locations have very similar scheduling system, very similar file system. So if you manage to get your app work, your program working on one of the HPC systems, you probably will be able to get it working on the other systems as well. And this little blue dot is the is Darmstadt, which is where I'm from. And all those systems are procured at some point. And whenever you do hardware procurement, there are basically is basically the question, well, what hardware do you get? And the simple answer is you get the best of everything, right? So you get the most cores, the fastest RAM, the most efficient power delivering units, fastest most storage, but this is infeasible for all but the largest of HPC computing centers and even those usually struggle. So usually what you do is you go ahead and say, well, we want to get the best performance per dollar we spent. And for this, you need to figure out what's the performance is you get for the dollars. And so you usually use lin pack and stream, which are benchmarking. One is for basically stressing your floating point unit and turning your rack system into a space heater. And the other is memory. And then because you do not want to run only synthetic benchmarks, you use some of the spec HPC suite benchmark and run this and you figure out how much performance do you get basically. And recently there was this push to get more power efficient when you do HPC community. And so there the target to hit is performance per watt. And there again, you basically use lin pack. If you look at the green 500 list of HPC system, they all publish their lin pack score. But this is not actually representative of what the system will cost during its lifetime. It's usually just what's your one time investment cost in procuring the actual hardware. And what you really want to figure out, especially in the case of this distributed national high performance computing association, is the money we spend actually well invested for the use cases our users have. And this is where this total cost of ownership project came to be. Because you do not want to score your procurement only on performance, but you want to have it be a mix of different factors. Of course, you want to have the initial hard and software investment cost as part of this, but you also want to figure in cooling costs because this is one of the main cost drivers today. Put your power in and how to get the heat away that dissipate the heat that you generate. And usually want to have technical and administrative stuff for your HPC system to actually work properly. And then the last thing which is power consumption. And it's not power consumption of your idling system because that is reasonably low, but it's of the job mix you're running. And this job mix is very essential in this whole thing because the job mix is a very user dependent metric. It is what is the system actually being used for. So for example, and this is again referring back to these distributed and slightly specialized computing centers we have in HR. If you do physics simulation, your application might benefit more from faster CPUs with more core counts than compared to if you're using AI workloads where you probably can't get enough accelerator cards for your workload. And what you do is you monitor how your system is used, which is doable. For example, Slurm can do this. And then you figure out that your users are running lamps and grommets and open form your typical HPC software. And then you cannot really give that one to the vendors, can you? Because if you give a big grommet run to your hardware vendor and say, well, you have 48 hours to run this code through, then your vendor will probably not do it. And in an even more extreme case, you have this weird institute like the scientific computing institute where I'm from, which runs one weird A.out executable. They self-compiled with a custom build script. And you cannot give those to the vendors as well. But the problem is that all those HPC applications are large and complex and have different coding and software patterns. But they are the most representative thing you can get about what is actually running on your clusters. And so the idea is if you have some very big and complex HPC system like the one you see is simulated on the right, which has some kind of entry point and then does matrix multiplication and conditioning and heavy output preparation, the thing that actually spends most of the compute cycles is the one in gray. So the matrix conditioning matrix solving. And if you have a so-called mini-app, which is just the gray part and not all the other things around, you might be able to shrink this application significantly. And this mini-app approach was in one actually pioneered by Jan-Patrick Ler, which was the guy who gave the talk before me. So talk about coincidence. And the basic idea is you shrink the size of your application, but keep the computational characteristics. So the computational kernel where actually most of your compute cycles are spent stays the same. And then you just need to add some wrapper function that sets the kernel up. And then to finish, you just need to find some way to graceful terminator program because you can then have time measurements, power measurements on this little part of the actual big program. Great. And so this is why they needed the compiler guy to do this because they wanted in this total cost of ownership project the idea was to have a fully automatic extraction pipeline. And the basic idea for this pipeline was first you analyze the whole program. For this, we used the MetaCG framework. And those of you who happened to be there last year when I gave a completely different talk, we were using MetaCG as well. So it's a tool that's used at our institute quite heavily and allows you to have a representation of how do functions behave according to each other over the whole program. So you can get a whole program call graph. Once you know how all those functions relate to another, you can figure out what is the actual kernel. So where are my compute cycles spent? For this, the intention was to use Pira. The other idea is you just ask a domain expert what's the slow part of your program and they will probably tell you. So this is much more easy usually. And then the actual extraction of the kernel. And for this, we developed the Apex tool, so the app extraction tool. And it's a clang front and based compiler tool that does source code manipulation. And the basic idea is you query the so-called AST. You do not need to know how you get the AST, what an AST is. The only thing that you know an AST is a very, very condensed and information dense form and representation of a single CPP file. So if you have this CPP file on the right, which only contains the main function, you get the thing on the right. Admittedly, this is very much shortened. Where you can then find your record declaration, you find your structs, and you find your assignments, and you find your function calls. So what you then do is you can query this AST for your information to figure out how these function behave. So if you want to track the kernel, so you already know which part of the program you want to extract, you find all the functions that are used for this kernel. So your kernel might call some subroutines, you want to extract all those subroutines as well. And sadly, the AST is unable to provide us this information because we only can extract when we have the definition, so the body of the function. And as we are only limited to one CPP file with our AST information at a time, we only have to the declaration in this case, which was part of the header. So the print as function in our example is only declared, it's not defined, we have no body there. So if we have the whole body of a function, we get it as a whole text block. If we only have a definition, we remember that we need that one, and we extract it once we actually find the source file that contains the definition for this function. What we can do is we can find and extract all the used globals, because you usually rely on some kind of struct definition, you might even be using global state. And this is where the AST has the information. The whole definition of our struct S was inside the header files, and the header files are included by the preprocessor, though they are part when the AST is built. Great. So we just extract those as a text block, and then we need to find all include statements because include is the last colored thing in our example. And then we run into a little problem. Because remember how I told you that it's great that the preprocessor put the header files into our source code, well, include statements are also handled by the preprocessor. So everything that was specified in this include statement header is put physically in the AST once it's built, and we do not have the information anymore. So what we need to, and this is also true for defines and if and defs and pragmas, all those are resolved by the preprocessor, and we do not have any way to really figure this out once we get to the AST level. So we do not only need to hook into the AST, but we also need to hook into the preprocessor. Those of you who have actually worked with a preprocessor might know that the preprocessor is basically doing copy paste. So it's not context sensitive, it just takes include files, puts it where the include statement was. So we somehow need to map this context insensitive analysis results we get from our preprocessor hooks to figure out how do those relate to the context sensitive information that we get from our AST. And the only thing that those two share in common is source file locations. The preprocessor knows in which source file line it currently is when it does its copy pasting, and the AST can map back to the original source file. So what we do is if we now go to a more realistic example, this is an excerpt from the Lulish code, you do not, it's heavily shortened so there's no way to figure out what it does exactly, but we are mostly interested in the things colored yellow, which means it starts with an open MP, if open MP is available statement and then it includes the actual header and the preprocessor gives us all this information. Whenever it encounters one of these statements, we get a callback that tells us we found an if open MP, it goes from line one to line three, and then we found an include statement in line two, and then it's on us to figure out that line one to three fully encompasses the statement we found in line two, because again we're only doing text block extraction. So this is the conflicts that happen inside the preprocessor, but if we go on the preprocessor also tells us that it found an if open MP statement again in line six to 13, and seven to nine, and 15, but we also have the knowledge that there is a whole function going from line five to line 20, so we need to marry those two informations together as well, and this matching process was one of the challenges that we needed to overcome when we did the kernel extraction. So when we started this whole process, we had a very good idea how to do single translation unit C code, and we expanded on this to allow for multi-translation unit C code and C with C++ components like new and delete and classes, and we're currently working on getting codes that makes heavy use of templates working, because the problem once you come into templates is that if you think back about our analysis step, we only get information about functions and how those functions relate to another, and templates are in a compiler speaking sense not necessarily functions, they are descriptions of how functions will be generated at compile time, so our analysis is currently not offering us the information about the original template, but only about the instantiated templates as generated by the compiler, so we are currently working on getting templates to work, and if you think back about the global usage analysis we are doing, if you have complex class inheritance and polymorphism, we are currently not able to traverse all possible diamond inheritance hierarchical implementations that are possible in C++, and lastly the idea is to also allow for automatic check pointing, so the wrapper calls that need to be generated to set up the environment for the kernel to run, it is theoretically possible to fully automatically generate those wrapper calls, we just haven't looked into it, and lastly the thing we are very skeptical if we are ever able to do it is to just mini extract from every C++ code ever written ever, because there are so many things you can do in C++ that we can try to achieve this, but I am very skeptical if we ever will be able to do this, but I don't want to leave you on this kind of depressing note actually, even in a state like this where the tool cannot fully handle all templates, even in a state where the tool cannot handle most complex inheritance hierarchies, tool assisted mini abstraction can still be useful, for example if you are willing to include the templates manually, because your program won't compile with the templates, you can just copy paste them, then you can get mini abstraction to work right now, and if you are interested in doing pinpoint optimizations on your source code, you can extract only those small snippets of code that you actually intend to work on, optimize those, and then do manual optimization and reintegrate those easily, so there are uses even for a tool that is not able to handle every C++ code ever written, and if you know of any HPC code that you think has a kernel that is identifiable and maybe not using the most and the deepest inheritance hierarchies, let me know, because I am always interested in figuring out how well my tool performs on other codes, so with this, thank you for your attention, I hope it was kind of interesting and I am open for questions. Any questions? I am the author of a large sparse matrix library, do you have something similar already in your catalog or collection? So it would be interesting to apply this tool on a library, but usually when the thing we are doing is we have the whole HPC software and then you call into the library, so of course your library is probably doing the heavy lifting and therefore probably doing the kernel part of the program, but extracting this one, we can look into that, but extracting a call to a library is relatively speaking very easy, so programs whose basic structure is do some setup, call an HPC library, get input back, those are basically mini-apps in the sense that we are talking about because they are not doing most of the heavy computing themselves, but if your library has internal conditioning or matrix solving capabilities that you know of that your library struggles to do, then we are talking again, so just let me know the name of your library and I will try to look into it. Four questions? Alex was first. Hi. I was wondering your mini-apps seem to be focused on compute-intensive parts of the code, do you also construct mini-apps for storage-intensive applications or something else? So the automatic identification wire, the PIRRA tool, tries to figure out what is the compute- intensive part of the program, and this is the only kernel, so to speak, that we are able to automatically identify, but if you as a domain expert know that this is the part of our program where we are IO limited, then this is nothing PIRRA can identify, but if you say I want to extract starting from this function, our tool should in theory be able to extract the IO limited part of your code. So this is the point where you as a domain expert need to specify this is the part I want to extract, because the only thing that is very prominently identifiable is compute-limited parts of the program, but yeah, in theory it should work. And second question, I might allow, and do you have a library of mini-apps that are ready to use for others by third parties? So currently we're doing our benchmark, our benchmarks on already existing mini-apps, so we're doing mini-app extraction from mini-apps because I am profiting from the small size of those mini-apps to validate that my program actually runs, for example the Lulash example I showed is a mini-app in itself. If I remember correctly, it's a shock simulation in fluids, please don't quote me on that, but it's a great code and it's very easy to work with, so I'm using that for my evaluation, but the idea is to get it to work on larger codes, for example we're currently looking to the ISSM ice sheet and system model, which is a well ice melting simulation for large ice sheets, but yeah we're always looking for other codes, and if you have something that is IO bound then of course tell me. Thank you. Plenty of time for more questions, Chris. Sorry to be that guy, but how hard would it be to adapt this approach to Fortran? Fortran tooling in general is something that has been of interest at our institute for a long time, but the problem with Fortran tooling is that most of our knowledge is coming from the Klang front and so the C language front end, and I am not sure if Fortran, the current new Fortran LLVM front end, offers the same analysis and query capabilities as Klang, and the idea to move lower in the hierarchy towards the LLVM IR, which is more target agnostic, or language agnostic more really, is that as soon as you go down to IR it's very hard to go back to figure out what was the source code files that actually made up this IR. So yes we already have in the back of our mind that there are other languages that are used in HPC systems, and usually if I present this approach I'm getting asked, well we have some Fortran codes, we have some Python codes, how does your approach work, but we are sadly limited by the Klang front end's capabilities, so C++, Objective C, which we have never tried, I'm not saying that we are able to do Objective C, but C and C++ we have tried and are currently limited to because of our design choice. There is a Fortran front end for Klang. Yes, but this is a Fortran front end for the LLVM infrastructure. The C-Lang front end is the part of the LLVM project which takes C code and translates to the LLVM IR, so I'm not sure if we're talking about the same thing. There is a Fortran front end for LLVM, yes, but I would be very surprised if there is a way to translate Fortran code into something that Klang can understand, but I might be wrong, there is a myriad of interesting software repositories, but currently consider Miscoptic. Then you can use this small part of your code to stress the floating point unit only of linear hardware. Then this other part is very well vectorized, so we extract this one and suddenly you are able to use AVX 512 instructions. The idea is to extract every code intensive part into its own little package and then benchmark with those separate packages, so at the end you can get an idea about the whole performance of your as your individual kernel regions. This would be the approach I take. Maybe one more? In the back, okay. Great talk, thank you so much. A couple of questions, Chris. I believe there was a paper about a Fortran mini app extractor some time ago. I can dig that up and send it to you. If I remember that, if not, shoot me a message. Then the flank front end in the LLVM project currently is not compatible with Klang, so we do get different ASTs. This approach is actually working at the AST level, so if it were using the LLVM IR level and then somehow like magically map back dwarf, then it would work, but there was a different project that did that, it worked kind of okay. I would have a question about you for the complex inheritance hierarchies. Do you have any idea on how you could tackle that, approach that, represent this thing across the whole program or things so, I mean, did you have spent any time so far looking at that or did you say like okay, that's future me or future someone going to do that? So thank you for the question. So it's a mix of both. I spent some time thinking about it and decided it was for future me because I didn't assume it to be very easy, but you already mentioned the general idea that as soon as you go into more complex inheritance chains, you aren't able to extract everything from one header file per se, so you need to do the same opportunistic extraction idea that we do for functions, but now for classes, structs and all their possible inheritance parents. So this is something that we need to analyze on the whole program scale, so this is something that in the not near future, but in the foreseeable future, I intend to put as an analysis pass into the CG collector, which you probably are familiar with. So the idea is that this tool is then able to annotate all this information as metadata and then once we merge it, we get a very good, hopefully, impression of how those inheritance chains flow through the whole program. So the idea. Thanks. Okay, that's all we have time for. Thanks a lot, Tim.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 10.68, "text": " We want to stick to time. We've been doing very well. So we want to keep that up. The", "tokens": [50364, 492, 528, 281, 2897, 281, 565, 13, 492, 600, 668, 884, 588, 731, 13, 407, 321, 528, 281, 1066, 300, 493, 13, 440, 50898], "temperature": 0.0, "avg_logprob": -0.2889282490947459, "compression_ratio": 1.5674418604651164, "no_speech_prob": 0.5232093334197998}, {"id": 1, "seek": 0, "start": 10.68, "end": 16.56, "text": " next talk is about, oh sorry, your name is on the slide. That doesn't help me. Tim, yeah,", "tokens": [50898, 958, 751, 307, 466, 11, 1954, 2597, 11, 428, 1315, 307, 322, 264, 4137, 13, 663, 1177, 380, 854, 385, 13, 7172, 11, 1338, 11, 51192], "temperature": 0.0, "avg_logprob": -0.2889282490947459, "compression_ratio": 1.5674418604651164, "no_speech_prob": 0.5232093334197998}, {"id": 2, "seek": 0, "start": 16.56, "end": 21.92, "text": " the next talk is about Tim, about extracting mini apps for HPC software.", "tokens": [51192, 264, 958, 751, 307, 466, 7172, 11, 466, 49844, 8382, 7733, 337, 12557, 34, 4722, 13, 51460], "temperature": 0.0, "avg_logprob": -0.2889282490947459, "compression_ratio": 1.5674418604651164, "no_speech_prob": 0.5232093334197998}, {"id": 3, "seek": 0, "start": 21.92, "end": 27.68, "text": " Then, thank you for having me back at Fostum. I am Tim. I'm by trade. I'm a compiler guy", "tokens": [51460, 1396, 11, 1309, 291, 337, 1419, 385, 646, 412, 479, 555, 449, 13, 286, 669, 7172, 13, 286, 478, 538, 4923, 13, 286, 478, 257, 31958, 2146, 51748], "temperature": 0.0, "avg_logprob": -0.2889282490947459, "compression_ratio": 1.5674418604651164, "no_speech_prob": 0.5232093334197998}, {"id": 4, "seek": 2768, "start": 27.72, "end": 32.48, "text": " and I'm giving a talk to the HPC Dev Room and how that came to be. We'll be part of the talk", "tokens": [50366, 293, 286, 478, 2902, 257, 751, 281, 264, 12557, 34, 9096, 19190, 293, 577, 300, 1361, 281, 312, 13, 492, 603, 312, 644, 295, 264, 751, 50604], "temperature": 0.0, "avg_logprob": -0.2798593065379995, "compression_ratio": 1.6642857142857144, "no_speech_prob": 0.20927590131759644}, {"id": 5, "seek": 2768, "start": 32.48, "end": 37.44, "text": " extracting mini apps from HPC software for total cost of ownership, optimized system procurement.", "tokens": [50604, 49844, 8382, 7733, 490, 12557, 34, 4722, 337, 3217, 2063, 295, 15279, 11, 26941, 1185, 35183, 13, 50852], "temperature": 0.0, "avg_logprob": -0.2798593065379995, "compression_ratio": 1.6642857142857144, "no_speech_prob": 0.20927590131759644}, {"id": 6, "seek": 2768, "start": 37.44, "end": 43.24, "text": " And I want to give a quick background about how this project came to be before I actually", "tokens": [50852, 400, 286, 528, 281, 976, 257, 1702, 3678, 466, 577, 341, 1716, 1361, 281, 312, 949, 286, 767, 51142], "temperature": 0.0, "avg_logprob": -0.2798593065379995, "compression_ratio": 1.6642857142857144, "no_speech_prob": 0.20927590131759644}, {"id": 7, "seek": 2768, "start": 43.24, "end": 49.84, "text": " start to go into the technical details because this project is part of the NHR Association", "tokens": [51142, 722, 281, 352, 666, 264, 6191, 4365, 570, 341, 1716, 307, 644, 295, 264, 31118, 49, 10734, 51472], "temperature": 0.0, "avg_logprob": -0.2798593065379995, "compression_ratio": 1.6642857142857144, "no_speech_prob": 0.20927590131759644}, {"id": 8, "seek": 2768, "start": 49.84, "end": 56.08, "text": " funded TCO, so total cost of ownership project. NHR stands for Nationales Hochleistungsregion.", "tokens": [51472, 14385, 314, 12322, 11, 370, 3217, 2063, 295, 15279, 1716, 13, 31118, 49, 7382, 337, 4862, 279, 29193, 46820, 5846, 3375, 313, 13, 51784], "temperature": 0.0, "avg_logprob": -0.2798593065379995, "compression_ratio": 1.6642857142857144, "no_speech_prob": 0.20927590131759644}, {"id": 9, "seek": 5608, "start": 56.08, "end": 61.68, "text": " It's the German term for national high performance computing basically. And the NHR is an alliance", "tokens": [50364, 467, 311, 264, 6521, 1433, 337, 4048, 1090, 3389, 15866, 1936, 13, 400, 264, 31118, 49, 307, 364, 20995, 50644], "temperature": 0.0, "avg_logprob": -0.17382094439338236, "compression_ratio": 1.758364312267658, "no_speech_prob": 0.01800178922712803}, {"id": 10, "seek": 5608, "start": 61.68, "end": 67.6, "text": " of computing centers which all have different specialties, but all have a common admission", "tokens": [50644, 295, 15866, 10898, 597, 439, 362, 819, 2121, 6097, 11, 457, 439, 362, 257, 2689, 24668, 50940], "temperature": 0.0, "avg_logprob": -0.17382094439338236, "compression_ratio": 1.758364312267658, "no_speech_prob": 0.01800178922712803}, {"id": 11, "seek": 5608, "start": 67.6, "end": 72.72, "text": " process and have a so-called harmonized computing environment, which means basically that all the", "tokens": [50940, 1399, 293, 362, 257, 370, 12, 11880, 14750, 1602, 15866, 2823, 11, 597, 1355, 1936, 300, 439, 264, 51196], "temperature": 0.0, "avg_logprob": -0.17382094439338236, "compression_ratio": 1.758364312267658, "no_speech_prob": 0.01800178922712803}, {"id": 12, "seek": 5608, "start": 72.72, "end": 78.24, "text": " clusters at the different locations have very similar scheduling system, very similar file system.", "tokens": [51196, 23313, 412, 264, 819, 9253, 362, 588, 2531, 29055, 1185, 11, 588, 2531, 3991, 1185, 13, 51472], "temperature": 0.0, "avg_logprob": -0.17382094439338236, "compression_ratio": 1.758364312267658, "no_speech_prob": 0.01800178922712803}, {"id": 13, "seek": 5608, "start": 78.24, "end": 82.64, "text": " So if you manage to get your app work, your program working on one of the HPC systems,", "tokens": [51472, 407, 498, 291, 3067, 281, 483, 428, 724, 589, 11, 428, 1461, 1364, 322, 472, 295, 264, 12557, 34, 3652, 11, 51692], "temperature": 0.0, "avg_logprob": -0.17382094439338236, "compression_ratio": 1.758364312267658, "no_speech_prob": 0.01800178922712803}, {"id": 14, "seek": 8264, "start": 82.64, "end": 87.2, "text": " you probably will be able to get it working on the other systems as well. And this little blue", "tokens": [50364, 291, 1391, 486, 312, 1075, 281, 483, 309, 1364, 322, 264, 661, 3652, 382, 731, 13, 400, 341, 707, 3344, 50592], "temperature": 0.0, "avg_logprob": -0.12694660548506112, "compression_ratio": 1.7553956834532374, "no_speech_prob": 0.013720606453716755}, {"id": 15, "seek": 8264, "start": 87.2, "end": 95.76, "text": " dot is the is Darmstadt, which is where I'm from. And all those systems are procured at some point.", "tokens": [50592, 5893, 307, 264, 307, 413, 4452, 34511, 11, 597, 307, 689, 286, 478, 490, 13, 400, 439, 729, 3652, 366, 9510, 3831, 412, 512, 935, 13, 51020], "temperature": 0.0, "avg_logprob": -0.12694660548506112, "compression_ratio": 1.7553956834532374, "no_speech_prob": 0.013720606453716755}, {"id": 16, "seek": 8264, "start": 96.64, "end": 101.12, "text": " And whenever you do hardware procurement, there are basically is basically the question, well,", "tokens": [51064, 400, 5699, 291, 360, 8837, 35183, 11, 456, 366, 1936, 307, 1936, 264, 1168, 11, 731, 11, 51288], "temperature": 0.0, "avg_logprob": -0.12694660548506112, "compression_ratio": 1.7553956834532374, "no_speech_prob": 0.013720606453716755}, {"id": 17, "seek": 8264, "start": 101.12, "end": 106.0, "text": " what hardware do you get? And the simple answer is you get the best of everything, right? So you get", "tokens": [51288, 437, 8837, 360, 291, 483, 30, 400, 264, 2199, 1867, 307, 291, 483, 264, 1151, 295, 1203, 11, 558, 30, 407, 291, 483, 51532], "temperature": 0.0, "avg_logprob": -0.12694660548506112, "compression_ratio": 1.7553956834532374, "no_speech_prob": 0.013720606453716755}, {"id": 18, "seek": 8264, "start": 106.0, "end": 112.32, "text": " the most cores, the fastest RAM, the most efficient power delivering units, fastest most storage,", "tokens": [51532, 264, 881, 24826, 11, 264, 14573, 14561, 11, 264, 881, 7148, 1347, 14666, 6815, 11, 14573, 881, 6725, 11, 51848], "temperature": 0.0, "avg_logprob": -0.12694660548506112, "compression_ratio": 1.7553956834532374, "no_speech_prob": 0.013720606453716755}, {"id": 19, "seek": 11264, "start": 112.96, "end": 119.6, "text": " but this is infeasible for all but the largest of HPC computing centers and even those usually", "tokens": [50380, 457, 341, 307, 1536, 68, 296, 964, 337, 439, 457, 264, 6443, 295, 12557, 34, 15866, 10898, 293, 754, 729, 2673, 50712], "temperature": 0.0, "avg_logprob": -0.09961447473299706, "compression_ratio": 1.7411347517730495, "no_speech_prob": 0.0013619655510410666}, {"id": 20, "seek": 11264, "start": 119.6, "end": 125.6, "text": " struggle. So usually what you do is you go ahead and say, well, we want to get the best performance", "tokens": [50712, 7799, 13, 407, 2673, 437, 291, 360, 307, 291, 352, 2286, 293, 584, 11, 731, 11, 321, 528, 281, 483, 264, 1151, 3389, 51012], "temperature": 0.0, "avg_logprob": -0.09961447473299706, "compression_ratio": 1.7411347517730495, "no_speech_prob": 0.0013619655510410666}, {"id": 21, "seek": 11264, "start": 125.6, "end": 130.08, "text": " per dollar we spent. And for this, you need to figure out what's the performance is you get for", "tokens": [51012, 680, 7241, 321, 4418, 13, 400, 337, 341, 11, 291, 643, 281, 2573, 484, 437, 311, 264, 3389, 307, 291, 483, 337, 51236], "temperature": 0.0, "avg_logprob": -0.09961447473299706, "compression_ratio": 1.7411347517730495, "no_speech_prob": 0.0013619655510410666}, {"id": 22, "seek": 11264, "start": 130.08, "end": 136.08, "text": " the dollars. And so you usually use lin pack and stream, which are benchmarking. One is for basically", "tokens": [51236, 264, 3808, 13, 400, 370, 291, 2673, 764, 22896, 2844, 293, 4309, 11, 597, 366, 18927, 278, 13, 1485, 307, 337, 1936, 51536], "temperature": 0.0, "avg_logprob": -0.09961447473299706, "compression_ratio": 1.7411347517730495, "no_speech_prob": 0.0013619655510410666}, {"id": 23, "seek": 11264, "start": 136.08, "end": 140.48, "text": " stressing your floating point unit and turning your rack system into a space heater. And the other", "tokens": [51536, 48233, 428, 12607, 935, 4985, 293, 6246, 428, 14788, 1185, 666, 257, 1901, 30408, 13, 400, 264, 661, 51756], "temperature": 0.0, "avg_logprob": -0.09961447473299706, "compression_ratio": 1.7411347517730495, "no_speech_prob": 0.0013619655510410666}, {"id": 24, "seek": 14048, "start": 140.48, "end": 146.0, "text": " is memory. And then because you do not want to run only synthetic benchmarks, you use some of the", "tokens": [50364, 307, 4675, 13, 400, 550, 570, 291, 360, 406, 528, 281, 1190, 787, 23420, 43751, 11, 291, 764, 512, 295, 264, 50640], "temperature": 0.0, "avg_logprob": -0.10650315848729944, "compression_ratio": 1.708695652173913, "no_speech_prob": 0.005870605818927288}, {"id": 25, "seek": 14048, "start": 146.0, "end": 152.64, "text": " spec HPC suite benchmark and run this and you figure out how much performance do you get basically.", "tokens": [50640, 1608, 12557, 34, 14205, 18927, 293, 1190, 341, 293, 291, 2573, 484, 577, 709, 3389, 360, 291, 483, 1936, 13, 50972], "temperature": 0.0, "avg_logprob": -0.10650315848729944, "compression_ratio": 1.708695652173913, "no_speech_prob": 0.005870605818927288}, {"id": 26, "seek": 14048, "start": 153.35999999999999, "end": 159.44, "text": " And recently there was this push to get more power efficient when you do HPC community. And so there", "tokens": [51008, 400, 3938, 456, 390, 341, 2944, 281, 483, 544, 1347, 7148, 562, 291, 360, 12557, 34, 1768, 13, 400, 370, 456, 51312], "temperature": 0.0, "avg_logprob": -0.10650315848729944, "compression_ratio": 1.708695652173913, "no_speech_prob": 0.005870605818927288}, {"id": 27, "seek": 14048, "start": 159.44, "end": 164.79999999999998, "text": " the target to hit is performance per watt. And there again, you basically use lin pack. If you", "tokens": [51312, 264, 3779, 281, 2045, 307, 3389, 680, 31556, 13, 400, 456, 797, 11, 291, 1936, 764, 22896, 2844, 13, 759, 291, 51580], "temperature": 0.0, "avg_logprob": -0.10650315848729944, "compression_ratio": 1.708695652173913, "no_speech_prob": 0.005870605818927288}, {"id": 28, "seek": 16480, "start": 164.88000000000002, "end": 170.72, "text": " look at the green 500 list of HPC system, they all publish their lin pack score. But this is not", "tokens": [50368, 574, 412, 264, 3092, 5923, 1329, 295, 12557, 34, 1185, 11, 436, 439, 11374, 641, 22896, 2844, 6175, 13, 583, 341, 307, 406, 50660], "temperature": 0.0, "avg_logprob": -0.10259171066997207, "compression_ratio": 1.6885813148788926, "no_speech_prob": 0.010769987478852272}, {"id": 29, "seek": 16480, "start": 170.72, "end": 176.32000000000002, "text": " actually representative of what the system will cost during its lifetime. It's usually just what's", "tokens": [50660, 767, 12424, 295, 437, 264, 1185, 486, 2063, 1830, 1080, 11364, 13, 467, 311, 2673, 445, 437, 311, 50940], "temperature": 0.0, "avg_logprob": -0.10259171066997207, "compression_ratio": 1.6885813148788926, "no_speech_prob": 0.010769987478852272}, {"id": 30, "seek": 16480, "start": 176.32000000000002, "end": 182.32000000000002, "text": " your one time investment cost in procuring the actual hardware. And what you really want to figure", "tokens": [50940, 428, 472, 565, 6078, 2063, 294, 9510, 1345, 264, 3539, 8837, 13, 400, 437, 291, 534, 528, 281, 2573, 51240], "temperature": 0.0, "avg_logprob": -0.10259171066997207, "compression_ratio": 1.6885813148788926, "no_speech_prob": 0.010769987478852272}, {"id": 31, "seek": 16480, "start": 182.32000000000002, "end": 186.72000000000003, "text": " out, especially in the case of this distributed national high performance computing association,", "tokens": [51240, 484, 11, 2318, 294, 264, 1389, 295, 341, 12631, 4048, 1090, 3389, 15866, 14598, 11, 51460], "temperature": 0.0, "avg_logprob": -0.10259171066997207, "compression_ratio": 1.6885813148788926, "no_speech_prob": 0.010769987478852272}, {"id": 32, "seek": 16480, "start": 187.92000000000002, "end": 193.60000000000002, "text": " is the money we spend actually well invested for the use cases our users have. And this is where", "tokens": [51520, 307, 264, 1460, 321, 3496, 767, 731, 13104, 337, 264, 764, 3331, 527, 5022, 362, 13, 400, 341, 307, 689, 51804], "temperature": 0.0, "avg_logprob": -0.10259171066997207, "compression_ratio": 1.6885813148788926, "no_speech_prob": 0.010769987478852272}, {"id": 33, "seek": 19360, "start": 193.6, "end": 199.28, "text": " this total cost of ownership project came to be. Because you do not want to score your procurement", "tokens": [50364, 341, 3217, 2063, 295, 15279, 1716, 1361, 281, 312, 13, 1436, 291, 360, 406, 528, 281, 6175, 428, 35183, 50648], "temperature": 0.0, "avg_logprob": -0.08370451800591122, "compression_ratio": 1.7773722627737227, "no_speech_prob": 0.0031437138095498085}, {"id": 34, "seek": 19360, "start": 199.28, "end": 204.56, "text": " only on performance, but you want to have it be a mix of different factors. Of course, you want", "tokens": [50648, 787, 322, 3389, 11, 457, 291, 528, 281, 362, 309, 312, 257, 2890, 295, 819, 6771, 13, 2720, 1164, 11, 291, 528, 50912], "temperature": 0.0, "avg_logprob": -0.08370451800591122, "compression_ratio": 1.7773722627737227, "no_speech_prob": 0.0031437138095498085}, {"id": 35, "seek": 19360, "start": 204.56, "end": 209.12, "text": " to have the initial hard and software investment cost as part of this, but you also want to figure", "tokens": [50912, 281, 362, 264, 5883, 1152, 293, 4722, 6078, 2063, 382, 644, 295, 341, 11, 457, 291, 611, 528, 281, 2573, 51140], "temperature": 0.0, "avg_logprob": -0.08370451800591122, "compression_ratio": 1.7773722627737227, "no_speech_prob": 0.0031437138095498085}, {"id": 36, "seek": 19360, "start": 209.12, "end": 216.24, "text": " in cooling costs because this is one of the main cost drivers today. Put your power in and how to", "tokens": [51140, 294, 14785, 5497, 570, 341, 307, 472, 295, 264, 2135, 2063, 11590, 965, 13, 4935, 428, 1347, 294, 293, 577, 281, 51496], "temperature": 0.0, "avg_logprob": -0.08370451800591122, "compression_ratio": 1.7773722627737227, "no_speech_prob": 0.0031437138095498085}, {"id": 37, "seek": 19360, "start": 216.24, "end": 221.28, "text": " get the heat away that dissipate the heat that you generate. And usually want to have technical", "tokens": [51496, 483, 264, 3738, 1314, 300, 29544, 473, 264, 3738, 300, 291, 8460, 13, 400, 2673, 528, 281, 362, 6191, 51748], "temperature": 0.0, "avg_logprob": -0.08370451800591122, "compression_ratio": 1.7773722627737227, "no_speech_prob": 0.0031437138095498085}, {"id": 38, "seek": 22128, "start": 221.36, "end": 226.72, "text": " and administrative stuff for your HPC system to actually work properly. And then the last thing", "tokens": [50368, 293, 17900, 1507, 337, 428, 12557, 34, 1185, 281, 767, 589, 6108, 13, 400, 550, 264, 1036, 551, 50636], "temperature": 0.0, "avg_logprob": -0.08112787766890092, "compression_ratio": 1.7582417582417582, "no_speech_prob": 0.005771024618297815}, {"id": 39, "seek": 22128, "start": 226.72, "end": 232.16, "text": " which is power consumption. And it's not power consumption of your idling system because that", "tokens": [50636, 597, 307, 1347, 12126, 13, 400, 309, 311, 406, 1347, 12126, 295, 428, 4496, 1688, 1185, 570, 300, 50908], "temperature": 0.0, "avg_logprob": -0.08112787766890092, "compression_ratio": 1.7582417582417582, "no_speech_prob": 0.005771024618297815}, {"id": 40, "seek": 22128, "start": 232.16, "end": 238.32, "text": " is reasonably low, but it's of the job mix you're running. And this job mix is very essential in", "tokens": [50908, 307, 23551, 2295, 11, 457, 309, 311, 295, 264, 1691, 2890, 291, 434, 2614, 13, 400, 341, 1691, 2890, 307, 588, 7115, 294, 51216], "temperature": 0.0, "avg_logprob": -0.08112787766890092, "compression_ratio": 1.7582417582417582, "no_speech_prob": 0.005771024618297815}, {"id": 41, "seek": 22128, "start": 238.32, "end": 245.04, "text": " this whole thing because the job mix is a very user dependent metric. It is what is the system", "tokens": [51216, 341, 1379, 551, 570, 264, 1691, 2890, 307, 257, 588, 4195, 12334, 20678, 13, 467, 307, 437, 307, 264, 1185, 51552], "temperature": 0.0, "avg_logprob": -0.08112787766890092, "compression_ratio": 1.7582417582417582, "no_speech_prob": 0.005771024618297815}, {"id": 42, "seek": 22128, "start": 245.04, "end": 251.2, "text": " actually being used for. So for example, and this is again referring back to these distributed and", "tokens": [51552, 767, 885, 1143, 337, 13, 407, 337, 1365, 11, 293, 341, 307, 797, 13761, 646, 281, 613, 12631, 293, 51860], "temperature": 0.0, "avg_logprob": -0.08112787766890092, "compression_ratio": 1.7582417582417582, "no_speech_prob": 0.005771024618297815}, {"id": 43, "seek": 25120, "start": 251.51999999999998, "end": 257.36, "text": " slightly specialized computing centers we have in HR. If you do physics simulation, your application", "tokens": [50380, 4748, 19813, 15866, 10898, 321, 362, 294, 19460, 13, 759, 291, 360, 10649, 16575, 11, 428, 3861, 50672], "temperature": 0.0, "avg_logprob": -0.12484318742128177, "compression_ratio": 1.6332179930795847, "no_speech_prob": 0.0018350108293816447}, {"id": 44, "seek": 25120, "start": 257.36, "end": 262.56, "text": " might benefit more from faster CPUs with more core counts than compared to if you're using AI", "tokens": [50672, 1062, 5121, 544, 490, 4663, 13199, 82, 365, 544, 4965, 14893, 813, 5347, 281, 498, 291, 434, 1228, 7318, 50932], "temperature": 0.0, "avg_logprob": -0.12484318742128177, "compression_ratio": 1.6332179930795847, "no_speech_prob": 0.0018350108293816447}, {"id": 45, "seek": 25120, "start": 262.56, "end": 268.08, "text": " workloads where you probably can't get enough accelerator cards for your workload. And what", "tokens": [50932, 32452, 689, 291, 1391, 393, 380, 483, 1547, 39889, 5632, 337, 428, 20139, 13, 400, 437, 51208], "temperature": 0.0, "avg_logprob": -0.12484318742128177, "compression_ratio": 1.6332179930795847, "no_speech_prob": 0.0018350108293816447}, {"id": 46, "seek": 25120, "start": 268.08, "end": 273.76, "text": " you do is you monitor how your system is used, which is doable. For example, Slurm can do this.", "tokens": [51208, 291, 360, 307, 291, 6002, 577, 428, 1185, 307, 1143, 11, 597, 307, 41183, 13, 1171, 1365, 11, 6187, 26717, 393, 360, 341, 13, 51492], "temperature": 0.0, "avg_logprob": -0.12484318742128177, "compression_ratio": 1.6332179930795847, "no_speech_prob": 0.0018350108293816447}, {"id": 47, "seek": 25120, "start": 274.32, "end": 280.08, "text": " And then you figure out that your users are running lamps and grommets and open form your", "tokens": [51520, 400, 550, 291, 2573, 484, 300, 428, 5022, 366, 2614, 34887, 293, 677, 1204, 1385, 293, 1269, 1254, 428, 51808], "temperature": 0.0, "avg_logprob": -0.12484318742128177, "compression_ratio": 1.6332179930795847, "no_speech_prob": 0.0018350108293816447}, {"id": 48, "seek": 28008, "start": 280.08, "end": 286.0, "text": " typical HPC software. And then you cannot really give that one to the vendors, can you? Because", "tokens": [50364, 7476, 12557, 34, 4722, 13, 400, 550, 291, 2644, 534, 976, 300, 472, 281, 264, 22056, 11, 393, 291, 30, 1436, 50660], "temperature": 0.0, "avg_logprob": -0.10876346038559735, "compression_ratio": 1.676056338028169, "no_speech_prob": 0.0033064214512705803}, {"id": 49, "seek": 28008, "start": 286.0, "end": 291.91999999999996, "text": " if you give a big grommet run to your hardware vendor and say, well, you have 48 hours to run", "tokens": [50660, 498, 291, 976, 257, 955, 677, 1204, 302, 1190, 281, 428, 8837, 24321, 293, 584, 11, 731, 11, 291, 362, 11174, 2496, 281, 1190, 50956], "temperature": 0.0, "avg_logprob": -0.10876346038559735, "compression_ratio": 1.676056338028169, "no_speech_prob": 0.0033064214512705803}, {"id": 50, "seek": 28008, "start": 291.91999999999996, "end": 296.56, "text": " this code through, then your vendor will probably not do it. And in an even more extreme case,", "tokens": [50956, 341, 3089, 807, 11, 550, 428, 24321, 486, 1391, 406, 360, 309, 13, 400, 294, 364, 754, 544, 8084, 1389, 11, 51188], "temperature": 0.0, "avg_logprob": -0.10876346038559735, "compression_ratio": 1.676056338028169, "no_speech_prob": 0.0033064214512705803}, {"id": 51, "seek": 28008, "start": 296.56, "end": 301.44, "text": " you have this weird institute like the scientific computing institute where I'm from, which runs", "tokens": [51188, 291, 362, 341, 3657, 26860, 411, 264, 8134, 15866, 26860, 689, 286, 478, 490, 11, 597, 6676, 51432], "temperature": 0.0, "avg_logprob": -0.10876346038559735, "compression_ratio": 1.676056338028169, "no_speech_prob": 0.0033064214512705803}, {"id": 52, "seek": 28008, "start": 301.44, "end": 308.47999999999996, "text": " one weird A.out executable. They self-compiled with a custom build script. And you cannot give", "tokens": [51432, 472, 3657, 316, 13, 346, 7568, 712, 13, 814, 2698, 12, 21541, 7292, 365, 257, 2375, 1322, 5755, 13, 400, 291, 2644, 976, 51784], "temperature": 0.0, "avg_logprob": -0.10876346038559735, "compression_ratio": 1.676056338028169, "no_speech_prob": 0.0033064214512705803}, {"id": 53, "seek": 30848, "start": 308.48, "end": 319.76, "text": " those to the vendors as well. But the problem is that all those HPC applications are large and", "tokens": [50364, 729, 281, 264, 22056, 382, 731, 13, 583, 264, 1154, 307, 300, 439, 729, 12557, 34, 5821, 366, 2416, 293, 50928], "temperature": 0.0, "avg_logprob": -0.057516860961914065, "compression_ratio": 1.564516129032258, "no_speech_prob": 0.001858880976215005}, {"id": 54, "seek": 30848, "start": 319.76, "end": 326.72, "text": " complex and have different coding and software patterns. But they are the most representative", "tokens": [50928, 3997, 293, 362, 819, 17720, 293, 4722, 8294, 13, 583, 436, 366, 264, 881, 12424, 51276], "temperature": 0.0, "avg_logprob": -0.057516860961914065, "compression_ratio": 1.564516129032258, "no_speech_prob": 0.001858880976215005}, {"id": 55, "seek": 30848, "start": 326.72, "end": 332.40000000000003, "text": " thing you can get about what is actually running on your clusters. And so the idea is if you have some", "tokens": [51276, 551, 291, 393, 483, 466, 437, 307, 767, 2614, 322, 428, 23313, 13, 400, 370, 264, 1558, 307, 498, 291, 362, 512, 51560], "temperature": 0.0, "avg_logprob": -0.057516860961914065, "compression_ratio": 1.564516129032258, "no_speech_prob": 0.001858880976215005}, {"id": 56, "seek": 33240, "start": 332.47999999999996, "end": 339.44, "text": " very big and complex HPC system like the one you see is simulated on the right, which has", "tokens": [50368, 588, 955, 293, 3997, 12557, 34, 1185, 411, 264, 472, 291, 536, 307, 41713, 322, 264, 558, 11, 597, 575, 50716], "temperature": 0.0, "avg_logprob": -0.10237091288847082, "compression_ratio": 1.608695652173913, "no_speech_prob": 0.004115974996238947}, {"id": 57, "seek": 33240, "start": 339.44, "end": 345.12, "text": " some kind of entry point and then does matrix multiplication and conditioning and heavy output", "tokens": [50716, 512, 733, 295, 8729, 935, 293, 550, 775, 8141, 27290, 293, 21901, 293, 4676, 5598, 51000], "temperature": 0.0, "avg_logprob": -0.10237091288847082, "compression_ratio": 1.608695652173913, "no_speech_prob": 0.004115974996238947}, {"id": 58, "seek": 33240, "start": 345.12, "end": 350.88, "text": " preparation, the thing that actually spends most of the compute cycles is the one in gray.", "tokens": [51000, 13081, 11, 264, 551, 300, 767, 25620, 881, 295, 264, 14722, 17796, 307, 264, 472, 294, 10855, 13, 51288], "temperature": 0.0, "avg_logprob": -0.10237091288847082, "compression_ratio": 1.608695652173913, "no_speech_prob": 0.004115974996238947}, {"id": 59, "seek": 33240, "start": 352.0, "end": 358.47999999999996, "text": " So the matrix conditioning matrix solving. And if you have a so-called mini-app, which is just", "tokens": [51344, 407, 264, 8141, 21901, 8141, 12606, 13, 400, 498, 291, 362, 257, 370, 12, 11880, 8382, 12, 1746, 11, 597, 307, 445, 51668], "temperature": 0.0, "avg_logprob": -0.10237091288847082, "compression_ratio": 1.608695652173913, "no_speech_prob": 0.004115974996238947}, {"id": 60, "seek": 35848, "start": 358.48, "end": 362.96000000000004, "text": " the gray part and not all the other things around, you might be able to shrink this application", "tokens": [50364, 264, 10855, 644, 293, 406, 439, 264, 661, 721, 926, 11, 291, 1062, 312, 1075, 281, 23060, 341, 3861, 50588], "temperature": 0.0, "avg_logprob": -0.10714380317759291, "compression_ratio": 1.72992700729927, "no_speech_prob": 0.022818801924586296}, {"id": 61, "seek": 35848, "start": 362.96000000000004, "end": 370.08000000000004, "text": " significantly. And this mini-app approach was in one actually pioneered by Jan-Patrick Ler,", "tokens": [50588, 10591, 13, 400, 341, 8382, 12, 1746, 3109, 390, 294, 472, 767, 19761, 4073, 538, 4956, 12, 29331, 9323, 441, 260, 11, 50944], "temperature": 0.0, "avg_logprob": -0.10714380317759291, "compression_ratio": 1.72992700729927, "no_speech_prob": 0.022818801924586296}, {"id": 62, "seek": 35848, "start": 370.08000000000004, "end": 376.08000000000004, "text": " which was the guy who gave the talk before me. So talk about coincidence. And the basic idea is", "tokens": [50944, 597, 390, 264, 2146, 567, 2729, 264, 751, 949, 385, 13, 407, 751, 466, 22137, 13, 400, 264, 3875, 1558, 307, 51244], "temperature": 0.0, "avg_logprob": -0.10714380317759291, "compression_ratio": 1.72992700729927, "no_speech_prob": 0.022818801924586296}, {"id": 63, "seek": 35848, "start": 376.08000000000004, "end": 381.68, "text": " you shrink the size of your application, but keep the computational characteristics. So the", "tokens": [51244, 291, 23060, 264, 2744, 295, 428, 3861, 11, 457, 1066, 264, 28270, 10891, 13, 407, 264, 51524], "temperature": 0.0, "avg_logprob": -0.10714380317759291, "compression_ratio": 1.72992700729927, "no_speech_prob": 0.022818801924586296}, {"id": 64, "seek": 35848, "start": 381.68, "end": 386.32, "text": " computational kernel where actually most of your compute cycles are spent stays the same. And then", "tokens": [51524, 28270, 28256, 689, 767, 881, 295, 428, 14722, 17796, 366, 4418, 10834, 264, 912, 13, 400, 550, 51756], "temperature": 0.0, "avg_logprob": -0.10714380317759291, "compression_ratio": 1.72992700729927, "no_speech_prob": 0.022818801924586296}, {"id": 65, "seek": 38632, "start": 386.32, "end": 391.92, "text": " you just need to add some wrapper function that sets the kernel up. And then to finish, you just", "tokens": [50364, 291, 445, 643, 281, 909, 512, 46906, 2445, 300, 6352, 264, 28256, 493, 13, 400, 550, 281, 2413, 11, 291, 445, 50644], "temperature": 0.0, "avg_logprob": -0.09380054473876953, "compression_ratio": 1.7900763358778626, "no_speech_prob": 0.001620084629394114}, {"id": 66, "seek": 38632, "start": 391.92, "end": 397.2, "text": " need to find some way to graceful terminator program because you can then have time measurements,", "tokens": [50644, 643, 281, 915, 512, 636, 281, 10042, 906, 10761, 1639, 1461, 570, 291, 393, 550, 362, 565, 15383, 11, 50908], "temperature": 0.0, "avg_logprob": -0.09380054473876953, "compression_ratio": 1.7900763358778626, "no_speech_prob": 0.001620084629394114}, {"id": 67, "seek": 38632, "start": 397.2, "end": 403.52, "text": " power measurements on this little part of the actual big program. Great. And so this is why", "tokens": [50908, 1347, 15383, 322, 341, 707, 644, 295, 264, 3539, 955, 1461, 13, 3769, 13, 400, 370, 341, 307, 983, 51224], "temperature": 0.0, "avg_logprob": -0.09380054473876953, "compression_ratio": 1.7900763358778626, "no_speech_prob": 0.001620084629394114}, {"id": 68, "seek": 38632, "start": 403.52, "end": 409.12, "text": " they needed the compiler guy to do this because they wanted in this total cost of ownership", "tokens": [51224, 436, 2978, 264, 31958, 2146, 281, 360, 341, 570, 436, 1415, 294, 341, 3217, 2063, 295, 15279, 51504], "temperature": 0.0, "avg_logprob": -0.09380054473876953, "compression_ratio": 1.7900763358778626, "no_speech_prob": 0.001620084629394114}, {"id": 69, "seek": 38632, "start": 410.0, "end": 415.84, "text": " project the idea was to have a fully automatic extraction pipeline. And the basic idea for", "tokens": [51548, 1716, 264, 1558, 390, 281, 362, 257, 4498, 12509, 30197, 15517, 13, 400, 264, 3875, 1558, 337, 51840], "temperature": 0.0, "avg_logprob": -0.09380054473876953, "compression_ratio": 1.7900763358778626, "no_speech_prob": 0.001620084629394114}, {"id": 70, "seek": 41584, "start": 415.84, "end": 421.84, "text": " this pipeline was first you analyze the whole program. For this, we used the MetaCG framework.", "tokens": [50364, 341, 15517, 390, 700, 291, 12477, 264, 1379, 1461, 13, 1171, 341, 11, 321, 1143, 264, 6377, 64, 34, 38, 8388, 13, 50664], "temperature": 0.0, "avg_logprob": -0.0752459910877964, "compression_ratio": 1.6881720430107527, "no_speech_prob": 0.0009213305893354118}, {"id": 71, "seek": 41584, "start": 421.84, "end": 426.96, "text": " And those of you who happened to be there last year when I gave a completely different talk,", "tokens": [50664, 400, 729, 295, 291, 567, 2011, 281, 312, 456, 1036, 1064, 562, 286, 2729, 257, 2584, 819, 751, 11, 50920], "temperature": 0.0, "avg_logprob": -0.0752459910877964, "compression_ratio": 1.6881720430107527, "no_speech_prob": 0.0009213305893354118}, {"id": 72, "seek": 41584, "start": 426.96, "end": 431.59999999999997, "text": " we were using MetaCG as well. So it's a tool that's used at our institute quite heavily", "tokens": [50920, 321, 645, 1228, 6377, 64, 34, 38, 382, 731, 13, 407, 309, 311, 257, 2290, 300, 311, 1143, 412, 527, 26860, 1596, 10950, 51152], "temperature": 0.0, "avg_logprob": -0.0752459910877964, "compression_ratio": 1.6881720430107527, "no_speech_prob": 0.0009213305893354118}, {"id": 73, "seek": 41584, "start": 431.59999999999997, "end": 438.08, "text": " and allows you to have a representation of how do functions behave according to each other over", "tokens": [51152, 293, 4045, 291, 281, 362, 257, 10290, 295, 577, 360, 6828, 15158, 4650, 281, 1184, 661, 670, 51476], "temperature": 0.0, "avg_logprob": -0.0752459910877964, "compression_ratio": 1.6881720430107527, "no_speech_prob": 0.0009213305893354118}, {"id": 74, "seek": 41584, "start": 438.08, "end": 443.35999999999996, "text": " the whole program. So you can get a whole program call graph. Once you know how all those functions", "tokens": [51476, 264, 1379, 1461, 13, 407, 291, 393, 483, 257, 1379, 1461, 818, 4295, 13, 3443, 291, 458, 577, 439, 729, 6828, 51740], "temperature": 0.0, "avg_logprob": -0.0752459910877964, "compression_ratio": 1.6881720430107527, "no_speech_prob": 0.0009213305893354118}, {"id": 75, "seek": 44336, "start": 443.36, "end": 447.92, "text": " relate to another, you can figure out what is the actual kernel. So where are my compute cycles", "tokens": [50364, 10961, 281, 1071, 11, 291, 393, 2573, 484, 437, 307, 264, 3539, 28256, 13, 407, 689, 366, 452, 14722, 17796, 50592], "temperature": 0.0, "avg_logprob": -0.10292223120937828, "compression_ratio": 1.6783216783216783, "no_speech_prob": 0.005048511084169149}, {"id": 76, "seek": 44336, "start": 447.92, "end": 454.56, "text": " spent? For this, the intention was to use Pira. The other idea is you just ask a domain expert", "tokens": [50592, 4418, 30, 1171, 341, 11, 264, 7789, 390, 281, 764, 430, 4271, 13, 440, 661, 1558, 307, 291, 445, 1029, 257, 9274, 5844, 50924], "temperature": 0.0, "avg_logprob": -0.10292223120937828, "compression_ratio": 1.6783216783216783, "no_speech_prob": 0.005048511084169149}, {"id": 77, "seek": 44336, "start": 454.56, "end": 458.88, "text": " what's the slow part of your program and they will probably tell you. So this is much more easy", "tokens": [50924, 437, 311, 264, 2964, 644, 295, 428, 1461, 293, 436, 486, 1391, 980, 291, 13, 407, 341, 307, 709, 544, 1858, 51140], "temperature": 0.0, "avg_logprob": -0.10292223120937828, "compression_ratio": 1.6783216783216783, "no_speech_prob": 0.005048511084169149}, {"id": 78, "seek": 44336, "start": 458.88, "end": 464.64, "text": " usually. And then the actual extraction of the kernel. And for this, we developed the Apex tool,", "tokens": [51140, 2673, 13, 400, 550, 264, 3539, 30197, 295, 264, 28256, 13, 400, 337, 341, 11, 321, 4743, 264, 316, 29420, 2290, 11, 51428], "temperature": 0.0, "avg_logprob": -0.10292223120937828, "compression_ratio": 1.6783216783216783, "no_speech_prob": 0.005048511084169149}, {"id": 79, "seek": 44336, "start": 464.64, "end": 470.8, "text": " so the app extraction tool. And it's a clang front and based compiler tool that does source code", "tokens": [51428, 370, 264, 724, 30197, 2290, 13, 400, 309, 311, 257, 596, 656, 1868, 293, 2361, 31958, 2290, 300, 775, 4009, 3089, 51736], "temperature": 0.0, "avg_logprob": -0.10292223120937828, "compression_ratio": 1.6783216783216783, "no_speech_prob": 0.005048511084169149}, {"id": 80, "seek": 47080, "start": 470.8, "end": 476.32, "text": " manipulation. And the basic idea is you query the so-called AST. You do not need to know how", "tokens": [50364, 26475, 13, 400, 264, 3875, 1558, 307, 291, 14581, 264, 370, 12, 11880, 316, 6840, 13, 509, 360, 406, 643, 281, 458, 577, 50640], "temperature": 0.0, "avg_logprob": -0.09360138269571158, "compression_ratio": 1.6858407079646018, "no_speech_prob": 0.004527201876044273}, {"id": 81, "seek": 47080, "start": 476.32, "end": 481.52000000000004, "text": " you get the AST, what an AST is. The only thing that you know an AST is a very, very condensed", "tokens": [50640, 291, 483, 264, 316, 6840, 11, 437, 364, 316, 6840, 307, 13, 440, 787, 551, 300, 291, 458, 364, 316, 6840, 307, 257, 588, 11, 588, 36398, 50900], "temperature": 0.0, "avg_logprob": -0.09360138269571158, "compression_ratio": 1.6858407079646018, "no_speech_prob": 0.004527201876044273}, {"id": 82, "seek": 47080, "start": 481.52000000000004, "end": 490.88, "text": " and information dense form and representation of a single CPP file. So if you have this CPP file", "tokens": [50900, 293, 1589, 18011, 1254, 293, 10290, 295, 257, 2167, 383, 17755, 3991, 13, 407, 498, 291, 362, 341, 383, 17755, 3991, 51368], "temperature": 0.0, "avg_logprob": -0.09360138269571158, "compression_ratio": 1.6858407079646018, "no_speech_prob": 0.004527201876044273}, {"id": 83, "seek": 47080, "start": 490.88, "end": 496.72, "text": " on the right, which only contains the main function, you get the thing on the right. Admittedly,", "tokens": [51368, 322, 264, 558, 11, 597, 787, 8306, 264, 2135, 2445, 11, 291, 483, 264, 551, 322, 264, 558, 13, 46292, 3944, 356, 11, 51660], "temperature": 0.0, "avg_logprob": -0.09360138269571158, "compression_ratio": 1.6858407079646018, "no_speech_prob": 0.004527201876044273}, {"id": 84, "seek": 49672, "start": 496.72, "end": 502.8, "text": " this is very much shortened. Where you can then find your record declaration, you find your structs,", "tokens": [50364, 341, 307, 588, 709, 45183, 13, 2305, 291, 393, 550, 915, 428, 2136, 27606, 11, 291, 915, 428, 6594, 82, 11, 50668], "temperature": 0.0, "avg_logprob": -0.09610516808249733, "compression_ratio": 1.8674698795180722, "no_speech_prob": 0.0017253127880394459}, {"id": 85, "seek": 49672, "start": 502.8, "end": 509.12, "text": " and you find your assignments, and you find your function calls. So what you then do is you can", "tokens": [50668, 293, 291, 915, 428, 22546, 11, 293, 291, 915, 428, 2445, 5498, 13, 407, 437, 291, 550, 360, 307, 291, 393, 50984], "temperature": 0.0, "avg_logprob": -0.09610516808249733, "compression_ratio": 1.8674698795180722, "no_speech_prob": 0.0017253127880394459}, {"id": 86, "seek": 49672, "start": 509.12, "end": 515.0400000000001, "text": " query this AST for your information to figure out how these function behave. So if you want to", "tokens": [50984, 14581, 341, 316, 6840, 337, 428, 1589, 281, 2573, 484, 577, 613, 2445, 15158, 13, 407, 498, 291, 528, 281, 51280], "temperature": 0.0, "avg_logprob": -0.09610516808249733, "compression_ratio": 1.8674698795180722, "no_speech_prob": 0.0017253127880394459}, {"id": 87, "seek": 49672, "start": 515.6800000000001, "end": 519.2, "text": " track the kernel, so you already know which part of the program you want to extract,", "tokens": [51312, 2837, 264, 28256, 11, 370, 291, 1217, 458, 597, 644, 295, 264, 1461, 291, 528, 281, 8947, 11, 51488], "temperature": 0.0, "avg_logprob": -0.09610516808249733, "compression_ratio": 1.8674698795180722, "no_speech_prob": 0.0017253127880394459}, {"id": 88, "seek": 49672, "start": 520.96, "end": 525.84, "text": " you find all the functions that are used for this kernel. So your kernel might call some", "tokens": [51576, 291, 915, 439, 264, 6828, 300, 366, 1143, 337, 341, 28256, 13, 407, 428, 28256, 1062, 818, 512, 51820], "temperature": 0.0, "avg_logprob": -0.09610516808249733, "compression_ratio": 1.8674698795180722, "no_speech_prob": 0.0017253127880394459}, {"id": 89, "seek": 52584, "start": 525.84, "end": 531.36, "text": " subroutines, you want to extract all those subroutines as well. And sadly, the AST is unable to provide us", "tokens": [50364, 1422, 81, 346, 1652, 11, 291, 528, 281, 8947, 439, 729, 1422, 81, 346, 1652, 382, 731, 13, 400, 22023, 11, 264, 316, 6840, 307, 11299, 281, 2893, 505, 50640], "temperature": 0.0, "avg_logprob": -0.0810770896764902, "compression_ratio": 1.7264957264957266, "no_speech_prob": 0.0010304495226591825}, {"id": 90, "seek": 52584, "start": 531.36, "end": 538.32, "text": " this information because we only can extract when we have the definition, so the body of the function.", "tokens": [50640, 341, 1589, 570, 321, 787, 393, 8947, 562, 321, 362, 264, 7123, 11, 370, 264, 1772, 295, 264, 2445, 13, 50988], "temperature": 0.0, "avg_logprob": -0.0810770896764902, "compression_ratio": 1.7264957264957266, "no_speech_prob": 0.0010304495226591825}, {"id": 91, "seek": 52584, "start": 538.32, "end": 544.32, "text": " And as we are only limited to one CPP file with our AST information at a time, we only have to", "tokens": [50988, 400, 382, 321, 366, 787, 5567, 281, 472, 383, 17755, 3991, 365, 527, 316, 6840, 1589, 412, 257, 565, 11, 321, 787, 362, 281, 51288], "temperature": 0.0, "avg_logprob": -0.0810770896764902, "compression_ratio": 1.7264957264957266, "no_speech_prob": 0.0010304495226591825}, {"id": 92, "seek": 52584, "start": 545.0400000000001, "end": 551.36, "text": " the declaration in this case, which was part of the header. So the print as function in our example", "tokens": [51324, 264, 27606, 294, 341, 1389, 11, 597, 390, 644, 295, 264, 23117, 13, 407, 264, 4482, 382, 2445, 294, 527, 1365, 51640], "temperature": 0.0, "avg_logprob": -0.0810770896764902, "compression_ratio": 1.7264957264957266, "no_speech_prob": 0.0010304495226591825}, {"id": 93, "seek": 55136, "start": 551.36, "end": 557.36, "text": " is only declared, it's not defined, we have no body there. So if we have the whole body of a function,", "tokens": [50364, 307, 787, 15489, 11, 309, 311, 406, 7642, 11, 321, 362, 572, 1772, 456, 13, 407, 498, 321, 362, 264, 1379, 1772, 295, 257, 2445, 11, 50664], "temperature": 0.0, "avg_logprob": -0.07192082924417931, "compression_ratio": 1.798206278026906, "no_speech_prob": 0.004450683016330004}, {"id": 94, "seek": 55136, "start": 557.36, "end": 562.5600000000001, "text": " we get it as a whole text block. If we only have a definition, we remember that we need that one,", "tokens": [50664, 321, 483, 309, 382, 257, 1379, 2487, 3461, 13, 759, 321, 787, 362, 257, 7123, 11, 321, 1604, 300, 321, 643, 300, 472, 11, 50924], "temperature": 0.0, "avg_logprob": -0.07192082924417931, "compression_ratio": 1.798206278026906, "no_speech_prob": 0.004450683016330004}, {"id": 95, "seek": 55136, "start": 562.5600000000001, "end": 567.6800000000001, "text": " and we extract it once we actually find the source file that contains the definition for this function.", "tokens": [50924, 293, 321, 8947, 309, 1564, 321, 767, 915, 264, 4009, 3991, 300, 8306, 264, 7123, 337, 341, 2445, 13, 51180], "temperature": 0.0, "avg_logprob": -0.07192082924417931, "compression_ratio": 1.798206278026906, "no_speech_prob": 0.004450683016330004}, {"id": 96, "seek": 55136, "start": 569.28, "end": 576.5600000000001, "text": " What we can do is we can find and extract all the used globals, because you usually rely on some", "tokens": [51260, 708, 321, 393, 360, 307, 321, 393, 915, 293, 8947, 439, 264, 1143, 16125, 1124, 11, 570, 291, 2673, 10687, 322, 512, 51624], "temperature": 0.0, "avg_logprob": -0.07192082924417931, "compression_ratio": 1.798206278026906, "no_speech_prob": 0.004450683016330004}, {"id": 97, "seek": 57656, "start": 576.64, "end": 582.0799999999999, "text": " kind of struct definition, you might even be using global state. And this is where the AST has the", "tokens": [50368, 733, 295, 6594, 7123, 11, 291, 1062, 754, 312, 1228, 4338, 1785, 13, 400, 341, 307, 689, 264, 316, 6840, 575, 264, 50640], "temperature": 0.0, "avg_logprob": -0.11293246006143504, "compression_ratio": 1.7411347517730495, "no_speech_prob": 0.009841769002377987}, {"id": 98, "seek": 57656, "start": 582.0799999999999, "end": 587.28, "text": " information. The whole definition of our struct S was inside the header files, and the header files", "tokens": [50640, 1589, 13, 440, 1379, 7123, 295, 527, 6594, 318, 390, 1854, 264, 23117, 7098, 11, 293, 264, 23117, 7098, 50900], "temperature": 0.0, "avg_logprob": -0.11293246006143504, "compression_ratio": 1.7411347517730495, "no_speech_prob": 0.009841769002377987}, {"id": 99, "seek": 57656, "start": 587.28, "end": 593.28, "text": " are included by the preprocessor, though they are part when the AST is built. Great. So we just", "tokens": [50900, 366, 5556, 538, 264, 2666, 340, 25432, 11, 1673, 436, 366, 644, 562, 264, 316, 6840, 307, 3094, 13, 3769, 13, 407, 321, 445, 51200], "temperature": 0.0, "avg_logprob": -0.11293246006143504, "compression_ratio": 1.7411347517730495, "no_speech_prob": 0.009841769002377987}, {"id": 100, "seek": 57656, "start": 593.28, "end": 597.5999999999999, "text": " extract those as a text block, and then we need to find all include statements because include is", "tokens": [51200, 8947, 729, 382, 257, 2487, 3461, 11, 293, 550, 321, 643, 281, 915, 439, 4090, 12363, 570, 4090, 307, 51416], "temperature": 0.0, "avg_logprob": -0.11293246006143504, "compression_ratio": 1.7411347517730495, "no_speech_prob": 0.009841769002377987}, {"id": 101, "seek": 57656, "start": 597.5999999999999, "end": 604.7199999999999, "text": " the last colored thing in our example. And then we run into a little problem. Because remember how", "tokens": [51416, 264, 1036, 14332, 551, 294, 527, 1365, 13, 400, 550, 321, 1190, 666, 257, 707, 1154, 13, 1436, 1604, 577, 51772], "temperature": 0.0, "avg_logprob": -0.11293246006143504, "compression_ratio": 1.7411347517730495, "no_speech_prob": 0.009841769002377987}, {"id": 102, "seek": 60472, "start": 604.72, "end": 611.12, "text": " I told you that it's great that the preprocessor put the header files into our source code,", "tokens": [50364, 286, 1907, 291, 300, 309, 311, 869, 300, 264, 2666, 340, 25432, 829, 264, 23117, 7098, 666, 527, 4009, 3089, 11, 50684], "temperature": 0.0, "avg_logprob": -0.10653725316969015, "compression_ratio": 1.8735177865612649, "no_speech_prob": 0.002541051944717765}, {"id": 103, "seek": 60472, "start": 612.08, "end": 617.28, "text": " well, include statements are also handled by the preprocessor. So everything that was specified in", "tokens": [50732, 731, 11, 4090, 12363, 366, 611, 18033, 538, 264, 2666, 340, 25432, 13, 407, 1203, 300, 390, 22206, 294, 50992], "temperature": 0.0, "avg_logprob": -0.10653725316969015, "compression_ratio": 1.8735177865612649, "no_speech_prob": 0.002541051944717765}, {"id": 104, "seek": 60472, "start": 617.28, "end": 622.8000000000001, "text": " this include statement header is put physically in the AST once it's built, and we do not have", "tokens": [50992, 341, 4090, 5629, 23117, 307, 829, 9762, 294, 264, 316, 6840, 1564, 309, 311, 3094, 11, 293, 321, 360, 406, 362, 51268], "temperature": 0.0, "avg_logprob": -0.10653725316969015, "compression_ratio": 1.8735177865612649, "no_speech_prob": 0.002541051944717765}, {"id": 105, "seek": 60472, "start": 622.8000000000001, "end": 628.1600000000001, "text": " the information anymore. So what we need to, and this is also true for defines and if and defs", "tokens": [51268, 264, 1589, 3602, 13, 407, 437, 321, 643, 281, 11, 293, 341, 307, 611, 2074, 337, 23122, 293, 498, 293, 1060, 82, 51536], "temperature": 0.0, "avg_logprob": -0.10653725316969015, "compression_ratio": 1.8735177865612649, "no_speech_prob": 0.002541051944717765}, {"id": 106, "seek": 60472, "start": 628.1600000000001, "end": 633.44, "text": " and pragmas, all those are resolved by the preprocessor, and we do not have any way to really", "tokens": [51536, 293, 33394, 3799, 11, 439, 729, 366, 20772, 538, 264, 2666, 340, 25432, 11, 293, 321, 360, 406, 362, 604, 636, 281, 534, 51800], "temperature": 0.0, "avg_logprob": -0.10653725316969015, "compression_ratio": 1.8735177865612649, "no_speech_prob": 0.002541051944717765}, {"id": 107, "seek": 63344, "start": 633.44, "end": 638.48, "text": " figure this out once we get to the AST level. So we do not only need to hook into the AST,", "tokens": [50364, 2573, 341, 484, 1564, 321, 483, 281, 264, 316, 6840, 1496, 13, 407, 321, 360, 406, 787, 643, 281, 6328, 666, 264, 316, 6840, 11, 50616], "temperature": 0.0, "avg_logprob": -0.06681370238463084, "compression_ratio": 1.7201834862385321, "no_speech_prob": 0.0020122318528592587}, {"id": 108, "seek": 63344, "start": 638.48, "end": 643.6, "text": " but we also need to hook into the preprocessor. Those of you who have actually worked with a", "tokens": [50616, 457, 321, 611, 643, 281, 6328, 666, 264, 2666, 340, 25432, 13, 3950, 295, 291, 567, 362, 767, 2732, 365, 257, 50872], "temperature": 0.0, "avg_logprob": -0.06681370238463084, "compression_ratio": 1.7201834862385321, "no_speech_prob": 0.0020122318528592587}, {"id": 109, "seek": 63344, "start": 643.6, "end": 652.32, "text": " preprocessor might know that the preprocessor is basically doing copy paste. So it's not context", "tokens": [50872, 2666, 340, 25432, 1062, 458, 300, 264, 2666, 340, 25432, 307, 1936, 884, 5055, 9163, 13, 407, 309, 311, 406, 4319, 51308], "temperature": 0.0, "avg_logprob": -0.06681370238463084, "compression_ratio": 1.7201834862385321, "no_speech_prob": 0.0020122318528592587}, {"id": 110, "seek": 63344, "start": 652.32, "end": 659.7600000000001, "text": " sensitive, it just takes include files, puts it where the include statement was. So we somehow", "tokens": [51308, 9477, 11, 309, 445, 2516, 4090, 7098, 11, 8137, 309, 689, 264, 4090, 5629, 390, 13, 407, 321, 6063, 51680], "temperature": 0.0, "avg_logprob": -0.06681370238463084, "compression_ratio": 1.7201834862385321, "no_speech_prob": 0.0020122318528592587}, {"id": 111, "seek": 65976, "start": 659.76, "end": 665.6, "text": " need to map this context insensitive analysis results we get from our preprocessor hooks", "tokens": [50364, 643, 281, 4471, 341, 4319, 1028, 34465, 5215, 3542, 321, 483, 490, 527, 2666, 340, 25432, 26485, 50656], "temperature": 0.0, "avg_logprob": -0.09037512673272027, "compression_ratio": 1.7285067873303168, "no_speech_prob": 0.004000380635261536}, {"id": 112, "seek": 65976, "start": 666.48, "end": 672.64, "text": " to figure out how do those relate to the context sensitive information that we get from our AST.", "tokens": [50700, 281, 2573, 484, 577, 360, 729, 10961, 281, 264, 4319, 9477, 1589, 300, 321, 483, 490, 527, 316, 6840, 13, 51008], "temperature": 0.0, "avg_logprob": -0.09037512673272027, "compression_ratio": 1.7285067873303168, "no_speech_prob": 0.004000380635261536}, {"id": 113, "seek": 65976, "start": 674.3199999999999, "end": 679.52, "text": " And the only thing that those two share in common is source file locations. The preprocessor knows", "tokens": [51092, 400, 264, 787, 551, 300, 729, 732, 2073, 294, 2689, 307, 4009, 3991, 9253, 13, 440, 2666, 340, 25432, 3255, 51352], "temperature": 0.0, "avg_logprob": -0.09037512673272027, "compression_ratio": 1.7285067873303168, "no_speech_prob": 0.004000380635261536}, {"id": 114, "seek": 65976, "start": 679.52, "end": 686.8, "text": " in which source file line it currently is when it does its copy pasting, and the AST can map back", "tokens": [51352, 294, 597, 4009, 3991, 1622, 309, 4362, 307, 562, 309, 775, 1080, 5055, 1791, 278, 11, 293, 264, 316, 6840, 393, 4471, 646, 51716], "temperature": 0.0, "avg_logprob": -0.09037512673272027, "compression_ratio": 1.7285067873303168, "no_speech_prob": 0.004000380635261536}, {"id": 115, "seek": 68680, "start": 686.8, "end": 692.88, "text": " to the original source file. So what we do is if we now go to a more realistic example, this is an", "tokens": [50364, 281, 264, 3380, 4009, 3991, 13, 407, 437, 321, 360, 307, 498, 321, 586, 352, 281, 257, 544, 12465, 1365, 11, 341, 307, 364, 50668], "temperature": 0.0, "avg_logprob": -0.13455201003511072, "compression_ratio": 1.6542372881355931, "no_speech_prob": 0.007881405763328075}, {"id": 116, "seek": 68680, "start": 692.88, "end": 698.88, "text": " excerpt from the Lulish code, you do not, it's heavily shortened so there's no way to figure", "tokens": [50668, 42760, 662, 490, 264, 441, 425, 742, 3089, 11, 291, 360, 406, 11, 309, 311, 10950, 45183, 370, 456, 311, 572, 636, 281, 2573, 50968], "temperature": 0.0, "avg_logprob": -0.13455201003511072, "compression_ratio": 1.6542372881355931, "no_speech_prob": 0.007881405763328075}, {"id": 117, "seek": 68680, "start": 698.88, "end": 704.4, "text": " out what it does exactly, but we are mostly interested in the things colored yellow, which means", "tokens": [50968, 484, 437, 309, 775, 2293, 11, 457, 321, 366, 5240, 3102, 294, 264, 721, 14332, 5566, 11, 597, 1355, 51244], "temperature": 0.0, "avg_logprob": -0.13455201003511072, "compression_ratio": 1.6542372881355931, "no_speech_prob": 0.007881405763328075}, {"id": 118, "seek": 68680, "start": 704.4, "end": 709.92, "text": " it starts with an open MP, if open MP is available statement and then it includes the actual header", "tokens": [51244, 309, 3719, 365, 364, 1269, 14146, 11, 498, 1269, 14146, 307, 2435, 5629, 293, 550, 309, 5974, 264, 3539, 23117, 51520], "temperature": 0.0, "avg_logprob": -0.13455201003511072, "compression_ratio": 1.6542372881355931, "no_speech_prob": 0.007881405763328075}, {"id": 119, "seek": 68680, "start": 709.92, "end": 714.4, "text": " and the preprocessor gives us all this information. Whenever it encounters one of these statements,", "tokens": [51520, 293, 264, 2666, 340, 25432, 2709, 505, 439, 341, 1589, 13, 14159, 309, 26310, 472, 295, 613, 12363, 11, 51744], "temperature": 0.0, "avg_logprob": -0.13455201003511072, "compression_ratio": 1.6542372881355931, "no_speech_prob": 0.007881405763328075}, {"id": 120, "seek": 71440, "start": 714.4, "end": 720.0, "text": " we get a callback that tells us we found an if open MP, it goes from line one to line three,", "tokens": [50364, 321, 483, 257, 818, 3207, 300, 5112, 505, 321, 1352, 364, 498, 1269, 14146, 11, 309, 1709, 490, 1622, 472, 281, 1622, 1045, 11, 50644], "temperature": 0.0, "avg_logprob": -0.08717049274247946, "compression_ratio": 1.7432432432432432, "no_speech_prob": 0.003461504587903619}, {"id": 121, "seek": 71440, "start": 720.0, "end": 726.16, "text": " and then we found an include statement in line two, and then it's on us to figure out that line one", "tokens": [50644, 293, 550, 321, 1352, 364, 4090, 5629, 294, 1622, 732, 11, 293, 550, 309, 311, 322, 505, 281, 2573, 484, 300, 1622, 472, 50952], "temperature": 0.0, "avg_logprob": -0.08717049274247946, "compression_ratio": 1.7432432432432432, "no_speech_prob": 0.003461504587903619}, {"id": 122, "seek": 71440, "start": 726.16, "end": 731.68, "text": " to three fully encompasses the statement we found in line two, because again we're only doing text", "tokens": [50952, 281, 1045, 4498, 49866, 264, 5629, 321, 1352, 294, 1622, 732, 11, 570, 797, 321, 434, 787, 884, 2487, 51228], "temperature": 0.0, "avg_logprob": -0.08717049274247946, "compression_ratio": 1.7432432432432432, "no_speech_prob": 0.003461504587903619}, {"id": 123, "seek": 71440, "start": 731.68, "end": 739.28, "text": " block extraction. So this is the conflicts that happen inside the preprocessor, but if we go on", "tokens": [51228, 3461, 30197, 13, 407, 341, 307, 264, 19807, 300, 1051, 1854, 264, 2666, 340, 25432, 11, 457, 498, 321, 352, 322, 51608], "temperature": 0.0, "avg_logprob": -0.08717049274247946, "compression_ratio": 1.7432432432432432, "no_speech_prob": 0.003461504587903619}, {"id": 124, "seek": 73928, "start": 739.28, "end": 744.88, "text": " the preprocessor also tells us that it found an if open MP statement again in line six to 13,", "tokens": [50364, 264, 2666, 340, 25432, 611, 5112, 505, 300, 309, 1352, 364, 498, 1269, 14146, 5629, 797, 294, 1622, 2309, 281, 3705, 11, 50644], "temperature": 0.0, "avg_logprob": -0.09274978428096561, "compression_ratio": 1.6434782608695653, "no_speech_prob": 0.004174799658358097}, {"id": 125, "seek": 73928, "start": 744.88, "end": 750.88, "text": " and seven to nine, and 15, but we also have the knowledge that there is a whole function going", "tokens": [50644, 293, 3407, 281, 4949, 11, 293, 2119, 11, 457, 321, 611, 362, 264, 3601, 300, 456, 307, 257, 1379, 2445, 516, 50944], "temperature": 0.0, "avg_logprob": -0.09274978428096561, "compression_ratio": 1.6434782608695653, "no_speech_prob": 0.004174799658358097}, {"id": 126, "seek": 73928, "start": 750.88, "end": 756.9599999999999, "text": " from line five to line 20, so we need to marry those two informations together as well, and", "tokens": [50944, 490, 1622, 1732, 281, 1622, 945, 11, 370, 321, 643, 281, 9747, 729, 732, 38855, 1214, 382, 731, 11, 293, 51248], "temperature": 0.0, "avg_logprob": -0.09274978428096561, "compression_ratio": 1.6434782608695653, "no_speech_prob": 0.004174799658358097}, {"id": 127, "seek": 73928, "start": 757.8399999999999, "end": 765.1999999999999, "text": " this matching process was one of the challenges that we needed to overcome when we did the kernel", "tokens": [51292, 341, 14324, 1399, 390, 472, 295, 264, 4759, 300, 321, 2978, 281, 10473, 562, 321, 630, 264, 28256, 51660], "temperature": 0.0, "avg_logprob": -0.09274978428096561, "compression_ratio": 1.6434782608695653, "no_speech_prob": 0.004174799658358097}, {"id": 128, "seek": 76520, "start": 765.2800000000001, "end": 774.08, "text": " extraction. So when we started this whole process, we had a very good idea how to do single translation", "tokens": [50368, 30197, 13, 407, 562, 321, 1409, 341, 1379, 1399, 11, 321, 632, 257, 588, 665, 1558, 577, 281, 360, 2167, 12853, 50808], "temperature": 0.0, "avg_logprob": -0.14885800608088462, "compression_ratio": 1.668103448275862, "no_speech_prob": 0.002663696650415659}, {"id": 129, "seek": 76520, "start": 774.08, "end": 781.12, "text": " unit C code, and we expanded on this to allow for multi-translation unit C code and C with C++", "tokens": [50808, 4985, 383, 3089, 11, 293, 321, 14342, 322, 341, 281, 2089, 337, 4825, 12, 24999, 24278, 4985, 383, 3089, 293, 383, 365, 383, 25472, 51160], "temperature": 0.0, "avg_logprob": -0.14885800608088462, "compression_ratio": 1.668103448275862, "no_speech_prob": 0.002663696650415659}, {"id": 130, "seek": 76520, "start": 781.12, "end": 786.24, "text": " components like new and delete and classes, and we're currently working on getting codes that", "tokens": [51160, 6677, 411, 777, 293, 12097, 293, 5359, 11, 293, 321, 434, 4362, 1364, 322, 1242, 14211, 300, 51416], "temperature": 0.0, "avg_logprob": -0.14885800608088462, "compression_ratio": 1.668103448275862, "no_speech_prob": 0.002663696650415659}, {"id": 131, "seek": 76520, "start": 786.24, "end": 793.12, "text": " makes heavy use of templates working, because the problem once you come into templates is that", "tokens": [51416, 1669, 4676, 764, 295, 21165, 1364, 11, 570, 264, 1154, 1564, 291, 808, 666, 21165, 307, 300, 51760], "temperature": 0.0, "avg_logprob": -0.14885800608088462, "compression_ratio": 1.668103448275862, "no_speech_prob": 0.002663696650415659}, {"id": 132, "seek": 79312, "start": 793.12, "end": 799.04, "text": " if you think back about our analysis step, we only get information about functions and how those", "tokens": [50364, 498, 291, 519, 646, 466, 527, 5215, 1823, 11, 321, 787, 483, 1589, 466, 6828, 293, 577, 729, 50660], "temperature": 0.0, "avg_logprob": -0.06567166745662689, "compression_ratio": 1.9506172839506173, "no_speech_prob": 0.0034176066983491182}, {"id": 133, "seek": 79312, "start": 799.04, "end": 804.48, "text": " functions relate to another, and templates are in a compiler speaking sense not necessarily", "tokens": [50660, 6828, 10961, 281, 1071, 11, 293, 21165, 366, 294, 257, 31958, 4124, 2020, 406, 4725, 50932], "temperature": 0.0, "avg_logprob": -0.06567166745662689, "compression_ratio": 1.9506172839506173, "no_speech_prob": 0.0034176066983491182}, {"id": 134, "seek": 79312, "start": 804.48, "end": 811.44, "text": " functions, they are descriptions of how functions will be generated at compile time, so our analysis", "tokens": [50932, 6828, 11, 436, 366, 24406, 295, 577, 6828, 486, 312, 10833, 412, 31413, 565, 11, 370, 527, 5215, 51280], "temperature": 0.0, "avg_logprob": -0.06567166745662689, "compression_ratio": 1.9506172839506173, "no_speech_prob": 0.0034176066983491182}, {"id": 135, "seek": 79312, "start": 811.44, "end": 816.32, "text": " is currently not offering us the information about the original template, but only about the", "tokens": [51280, 307, 4362, 406, 8745, 505, 264, 1589, 466, 264, 3380, 12379, 11, 457, 787, 466, 264, 51524], "temperature": 0.0, "avg_logprob": -0.06567166745662689, "compression_ratio": 1.9506172839506173, "no_speech_prob": 0.0034176066983491182}, {"id": 136, "seek": 79312, "start": 816.32, "end": 821.76, "text": " instantiated templates as generated by the compiler, so we are currently working on getting", "tokens": [51524, 9836, 72, 770, 21165, 382, 10833, 538, 264, 31958, 11, 370, 321, 366, 4362, 1364, 322, 1242, 51796], "temperature": 0.0, "avg_logprob": -0.06567166745662689, "compression_ratio": 1.9506172839506173, "no_speech_prob": 0.0034176066983491182}, {"id": 137, "seek": 82176, "start": 821.76, "end": 830.96, "text": " templates to work, and if you think back about the global usage analysis we are doing, if you have", "tokens": [50364, 21165, 281, 589, 11, 293, 498, 291, 519, 646, 466, 264, 4338, 14924, 5215, 321, 366, 884, 11, 498, 291, 362, 50824], "temperature": 0.0, "avg_logprob": -0.0811986202417418, "compression_ratio": 1.6695278969957081, "no_speech_prob": 0.0020424984395503998}, {"id": 138, "seek": 82176, "start": 830.96, "end": 836.96, "text": " complex class inheritance and polymorphism, we are currently not able to traverse all possible", "tokens": [50824, 3997, 1508, 32122, 293, 6754, 76, 18191, 1434, 11, 321, 366, 4362, 406, 1075, 281, 45674, 439, 1944, 51124], "temperature": 0.0, "avg_logprob": -0.0811986202417418, "compression_ratio": 1.6695278969957081, "no_speech_prob": 0.0020424984395503998}, {"id": 139, "seek": 82176, "start": 836.96, "end": 843.76, "text": " diamond inheritance hierarchical implementations that are possible in C++, and lastly the idea is to", "tokens": [51124, 16059, 32122, 35250, 804, 4445, 763, 300, 366, 1944, 294, 383, 25472, 11, 293, 16386, 264, 1558, 307, 281, 51464], "temperature": 0.0, "avg_logprob": -0.0811986202417418, "compression_ratio": 1.6695278969957081, "no_speech_prob": 0.0020424984395503998}, {"id": 140, "seek": 82176, "start": 843.76, "end": 850.48, "text": " also allow for automatic check pointing, so the wrapper calls that need to be generated to set", "tokens": [51464, 611, 2089, 337, 12509, 1520, 12166, 11, 370, 264, 46906, 5498, 300, 643, 281, 312, 10833, 281, 992, 51800], "temperature": 0.0, "avg_logprob": -0.0811986202417418, "compression_ratio": 1.6695278969957081, "no_speech_prob": 0.0020424984395503998}, {"id": 141, "seek": 85048, "start": 850.48, "end": 855.6800000000001, "text": " up the environment for the kernel to run, it is theoretically possible to fully automatically", "tokens": [50364, 493, 264, 2823, 337, 264, 28256, 281, 1190, 11, 309, 307, 29400, 1944, 281, 4498, 6772, 50624], "temperature": 0.0, "avg_logprob": -0.08633482191297744, "compression_ratio": 1.7181818181818183, "no_speech_prob": 0.007280298974364996}, {"id": 142, "seek": 85048, "start": 855.6800000000001, "end": 862.32, "text": " generate those wrapper calls, we just haven't looked into it, and lastly the thing we are", "tokens": [50624, 8460, 729, 46906, 5498, 11, 321, 445, 2378, 380, 2956, 666, 309, 11, 293, 16386, 264, 551, 321, 366, 50956], "temperature": 0.0, "avg_logprob": -0.08633482191297744, "compression_ratio": 1.7181818181818183, "no_speech_prob": 0.007280298974364996}, {"id": 143, "seek": 85048, "start": 862.96, "end": 869.76, "text": " very skeptical if we are ever able to do it is to just mini extract from every C++ code ever written", "tokens": [50988, 588, 28601, 498, 321, 366, 1562, 1075, 281, 360, 309, 307, 281, 445, 8382, 8947, 490, 633, 383, 25472, 3089, 1562, 3720, 51328], "temperature": 0.0, "avg_logprob": -0.08633482191297744, "compression_ratio": 1.7181818181818183, "no_speech_prob": 0.007280298974364996}, {"id": 144, "seek": 85048, "start": 869.76, "end": 877.76, "text": " ever, because there are so many things you can do in C++ that we can try to achieve this, but", "tokens": [51328, 1562, 11, 570, 456, 366, 370, 867, 721, 291, 393, 360, 294, 383, 25472, 300, 321, 393, 853, 281, 4584, 341, 11, 457, 51728], "temperature": 0.0, "avg_logprob": -0.08633482191297744, "compression_ratio": 1.7181818181818183, "no_speech_prob": 0.007280298974364996}, {"id": 145, "seek": 87776, "start": 877.76, "end": 884.16, "text": " I am very skeptical if we ever will be able to do this, but I don't want to leave you on this", "tokens": [50364, 286, 669, 588, 28601, 498, 321, 1562, 486, 312, 1075, 281, 360, 341, 11, 457, 286, 500, 380, 528, 281, 1856, 291, 322, 341, 50684], "temperature": 0.0, "avg_logprob": -0.09968787570332371, "compression_ratio": 1.7222222222222223, "no_speech_prob": 0.004418340511620045}, {"id": 146, "seek": 87776, "start": 885.04, "end": 892.08, "text": " kind of depressing note actually, even in a state like this where the tool cannot fully", "tokens": [50728, 733, 295, 36355, 3637, 767, 11, 754, 294, 257, 1785, 411, 341, 689, 264, 2290, 2644, 4498, 51080], "temperature": 0.0, "avg_logprob": -0.09968787570332371, "compression_ratio": 1.7222222222222223, "no_speech_prob": 0.004418340511620045}, {"id": 147, "seek": 87776, "start": 892.08, "end": 899.04, "text": " handle all templates, even in a state where the tool cannot handle most complex inheritance hierarchies,", "tokens": [51080, 4813, 439, 21165, 11, 754, 294, 257, 1785, 689, 264, 2290, 2644, 4813, 881, 3997, 32122, 35250, 530, 11, 51428], "temperature": 0.0, "avg_logprob": -0.09968787570332371, "compression_ratio": 1.7222222222222223, "no_speech_prob": 0.004418340511620045}, {"id": 148, "seek": 87776, "start": 900.4, "end": 904.88, "text": " tool assisted mini abstraction can still be useful, for example if you are willing to", "tokens": [51496, 2290, 30291, 8382, 37765, 393, 920, 312, 4420, 11, 337, 1365, 498, 291, 366, 4950, 281, 51720], "temperature": 0.0, "avg_logprob": -0.09968787570332371, "compression_ratio": 1.7222222222222223, "no_speech_prob": 0.004418340511620045}, {"id": 149, "seek": 90488, "start": 904.88, "end": 909.92, "text": " include the templates manually, because your program won't compile with the templates, you can", "tokens": [50364, 4090, 264, 21165, 16945, 11, 570, 428, 1461, 1582, 380, 31413, 365, 264, 21165, 11, 291, 393, 50616], "temperature": 0.0, "avg_logprob": -0.11382633390880767, "compression_ratio": 1.8196078431372549, "no_speech_prob": 0.00743231363594532}, {"id": 150, "seek": 90488, "start": 909.92, "end": 916.0, "text": " just copy paste them, then you can get mini abstraction to work right now, and if you are", "tokens": [50616, 445, 5055, 9163, 552, 11, 550, 291, 393, 483, 8382, 37765, 281, 589, 558, 586, 11, 293, 498, 291, 366, 50920], "temperature": 0.0, "avg_logprob": -0.11382633390880767, "compression_ratio": 1.8196078431372549, "no_speech_prob": 0.00743231363594532}, {"id": 151, "seek": 90488, "start": 916.0, "end": 921.76, "text": " interested in doing pinpoint optimizations on your source code, you can extract only those small", "tokens": [50920, 3102, 294, 884, 40837, 5028, 14455, 322, 428, 4009, 3089, 11, 291, 393, 8947, 787, 729, 1359, 51208], "temperature": 0.0, "avg_logprob": -0.11382633390880767, "compression_ratio": 1.8196078431372549, "no_speech_prob": 0.00743231363594532}, {"id": 152, "seek": 90488, "start": 921.76, "end": 928.08, "text": " snippets of code that you actually intend to work on, optimize those, and then do manual", "tokens": [51208, 35623, 1385, 295, 3089, 300, 291, 767, 19759, 281, 589, 322, 11, 19719, 729, 11, 293, 550, 360, 9688, 51524], "temperature": 0.0, "avg_logprob": -0.11382633390880767, "compression_ratio": 1.8196078431372549, "no_speech_prob": 0.00743231363594532}, {"id": 153, "seek": 90488, "start": 928.08, "end": 933.12, "text": " optimization and reintegrate those easily, so there are uses even for a tool that is not able", "tokens": [51524, 19618, 293, 319, 31131, 473, 729, 3612, 11, 370, 456, 366, 4960, 754, 337, 257, 2290, 300, 307, 406, 1075, 51776], "temperature": 0.0, "avg_logprob": -0.11382633390880767, "compression_ratio": 1.8196078431372549, "no_speech_prob": 0.00743231363594532}, {"id": 154, "seek": 93312, "start": 933.12, "end": 942.0, "text": " to handle every C++ code ever written, and if you know of any HPC code that you think has a kernel", "tokens": [50364, 281, 4813, 633, 383, 25472, 3089, 1562, 3720, 11, 293, 498, 291, 458, 295, 604, 12557, 34, 3089, 300, 291, 519, 575, 257, 28256, 50808], "temperature": 0.0, "avg_logprob": -0.10778653749855616, "compression_ratio": 1.6228813559322033, "no_speech_prob": 0.0017477485816925764}, {"id": 155, "seek": 93312, "start": 942.0, "end": 948.88, "text": " that is identifiable and maybe not using the most and the deepest inheritance hierarchies,", "tokens": [50808, 300, 307, 2473, 30876, 293, 1310, 406, 1228, 264, 881, 293, 264, 28288, 32122, 35250, 530, 11, 51152], "temperature": 0.0, "avg_logprob": -0.10778653749855616, "compression_ratio": 1.6228813559322033, "no_speech_prob": 0.0017477485816925764}, {"id": 156, "seek": 93312, "start": 948.88, "end": 954.64, "text": " let me know, because I am always interested in figuring out how well my tool performs on other", "tokens": [51152, 718, 385, 458, 11, 570, 286, 669, 1009, 3102, 294, 15213, 484, 577, 731, 452, 2290, 26213, 322, 661, 51440], "temperature": 0.0, "avg_logprob": -0.10778653749855616, "compression_ratio": 1.6228813559322033, "no_speech_prob": 0.0017477485816925764}, {"id": 157, "seek": 93312, "start": 954.64, "end": 962.08, "text": " codes, so with this, thank you for your attention, I hope it was kind of interesting and I am open", "tokens": [51440, 14211, 11, 370, 365, 341, 11, 1309, 291, 337, 428, 3202, 11, 286, 1454, 309, 390, 733, 295, 1880, 293, 286, 669, 1269, 51812], "temperature": 0.0, "avg_logprob": -0.10778653749855616, "compression_ratio": 1.6228813559322033, "no_speech_prob": 0.0017477485816925764}, {"id": 158, "seek": 96208, "start": 962.08, "end": 964.08, "text": " for questions.", "tokens": [50364, 337, 1651, 13, 50464], "temperature": 0.0, "avg_logprob": -0.658415953318278, "compression_ratio": 1.0357142857142858, "no_speech_prob": 0.03842548653483391}, {"id": 159, "seek": 96208, "start": 974.88, "end": 976.88, "text": " Any questions?", "tokens": [51004, 2639, 1651, 30, 51104], "temperature": 0.0, "avg_logprob": -0.658415953318278, "compression_ratio": 1.0357142857142858, "no_speech_prob": 0.03842548653483391}, {"id": 160, "seek": 97688, "start": 977.12, "end": 993.12, "text": " I am the author of a large sparse matrix library, do you have something similar already in your", "tokens": [50376, 286, 669, 264, 3793, 295, 257, 2416, 637, 11668, 8141, 6405, 11, 360, 291, 362, 746, 2531, 1217, 294, 428, 51176], "temperature": 0.0, "avg_logprob": -0.3127898340639861, "compression_ratio": 1.3732394366197183, "no_speech_prob": 0.019044695422053337}, {"id": 161, "seek": 97688, "start": 994.0, "end": 1001.92, "text": " catalog or collection? So it would be interesting to apply this tool on a library, but usually when", "tokens": [51220, 19746, 420, 5765, 30, 407, 309, 576, 312, 1880, 281, 3079, 341, 2290, 322, 257, 6405, 11, 457, 2673, 562, 51616], "temperature": 0.0, "avg_logprob": -0.3127898340639861, "compression_ratio": 1.3732394366197183, "no_speech_prob": 0.019044695422053337}, {"id": 162, "seek": 100192, "start": 1002.8, "end": 1010.0799999999999, "text": " the thing we are doing is we have the whole HPC software and then you call into the library,", "tokens": [50408, 264, 551, 321, 366, 884, 307, 321, 362, 264, 1379, 12557, 34, 4722, 293, 550, 291, 818, 666, 264, 6405, 11, 50772], "temperature": 0.0, "avg_logprob": -0.13606289661291873, "compression_ratio": 1.7484662576687116, "no_speech_prob": 0.044809140264987946}, {"id": 163, "seek": 100192, "start": 1010.0799999999999, "end": 1015.68, "text": " so of course your library is probably doing the heavy lifting and therefore probably doing the", "tokens": [50772, 370, 295, 1164, 428, 6405, 307, 1391, 884, 264, 4676, 15798, 293, 4412, 1391, 884, 264, 51052], "temperature": 0.0, "avg_logprob": -0.13606289661291873, "compression_ratio": 1.7484662576687116, "no_speech_prob": 0.044809140264987946}, {"id": 164, "seek": 100192, "start": 1016.9599999999999, "end": 1024.1599999999999, "text": " kernel part of the program, but extracting this one, we can look into that, but extracting a call", "tokens": [51116, 28256, 644, 295, 264, 1461, 11, 457, 49844, 341, 472, 11, 321, 393, 574, 666, 300, 11, 457, 49844, 257, 818, 51476], "temperature": 0.0, "avg_logprob": -0.13606289661291873, "compression_ratio": 1.7484662576687116, "no_speech_prob": 0.044809140264987946}, {"id": 165, "seek": 102416, "start": 1024.24, "end": 1035.2, "text": " to a library is relatively speaking very easy, so programs whose basic structure is do some setup,", "tokens": [50368, 281, 257, 6405, 307, 7226, 4124, 588, 1858, 11, 370, 4268, 6104, 3875, 3877, 307, 360, 512, 8657, 11, 50916], "temperature": 0.0, "avg_logprob": -0.1353311258203843, "compression_ratio": 1.572972972972973, "no_speech_prob": 0.03934106230735779}, {"id": 166, "seek": 102416, "start": 1035.2, "end": 1042.4, "text": " call an HPC library, get input back, those are basically mini-apps in the sense that we are", "tokens": [50916, 818, 364, 12557, 34, 6405, 11, 483, 4846, 646, 11, 729, 366, 1936, 8382, 12, 1746, 82, 294, 264, 2020, 300, 321, 366, 51276], "temperature": 0.0, "avg_logprob": -0.1353311258203843, "compression_ratio": 1.572972972972973, "no_speech_prob": 0.03934106230735779}, {"id": 167, "seek": 102416, "start": 1042.4, "end": 1047.68, "text": " talking about because they are not doing most of the heavy computing themselves, but if your library", "tokens": [51276, 1417, 466, 570, 436, 366, 406, 884, 881, 295, 264, 4676, 15866, 2969, 11, 457, 498, 428, 6405, 51540], "temperature": 0.0, "avg_logprob": -0.1353311258203843, "compression_ratio": 1.572972972972973, "no_speech_prob": 0.03934106230735779}, {"id": 168, "seek": 104768, "start": 1047.68, "end": 1054.48, "text": " has internal conditioning or matrix solving capabilities that you know of that your library", "tokens": [50364, 575, 6920, 21901, 420, 8141, 12606, 10862, 300, 291, 458, 295, 300, 428, 6405, 50704], "temperature": 0.0, "avg_logprob": -0.24455364288822298, "compression_ratio": 1.4969325153374233, "no_speech_prob": 0.009726609103381634}, {"id": 169, "seek": 104768, "start": 1054.48, "end": 1060.3200000000002, "text": " struggles to do, then we are talking again, so just let me know the name of your library and I will", "tokens": [50704, 17592, 281, 360, 11, 550, 321, 366, 1417, 797, 11, 370, 445, 718, 385, 458, 264, 1315, 295, 428, 6405, 293, 286, 486, 50996], "temperature": 0.0, "avg_logprob": -0.24455364288822298, "compression_ratio": 1.4969325153374233, "no_speech_prob": 0.009726609103381634}, {"id": 170, "seek": 104768, "start": 1060.88, "end": 1062.88, "text": " try to look into it.", "tokens": [51024, 853, 281, 574, 666, 309, 13, 51124], "temperature": 0.0, "avg_logprob": -0.24455364288822298, "compression_ratio": 1.4969325153374233, "no_speech_prob": 0.009726609103381634}, {"id": 171, "seek": 104768, "start": 1067.92, "end": 1069.92, "text": " Four questions?", "tokens": [51376, 7451, 1651, 30, 51476], "temperature": 0.0, "avg_logprob": -0.24455364288822298, "compression_ratio": 1.4969325153374233, "no_speech_prob": 0.009726609103381634}, {"id": 172, "seek": 104768, "start": 1070.64, "end": 1072.64, "text": " Alex was first.", "tokens": [51512, 5202, 390, 700, 13, 51612], "temperature": 0.0, "avg_logprob": -0.24455364288822298, "compression_ratio": 1.4969325153374233, "no_speech_prob": 0.009726609103381634}, {"id": 173, "seek": 107264, "start": 1072.96, "end": 1084.0800000000002, "text": " Hi. I was wondering your mini-apps seem to be focused on compute-intensive parts of the code,", "tokens": [50380, 2421, 13, 286, 390, 6359, 428, 8382, 12, 1746, 82, 1643, 281, 312, 5178, 322, 14722, 12, 686, 2953, 3166, 295, 264, 3089, 11, 50936], "temperature": 0.0, "avg_logprob": -0.26508591880261057, "compression_ratio": 1.5480225988700564, "no_speech_prob": 0.011308815330266953}, {"id": 174, "seek": 107264, "start": 1084.88, "end": 1091.0400000000002, "text": " do you also construct mini-apps for storage-intensive applications or something else?", "tokens": [50976, 360, 291, 611, 7690, 8382, 12, 1746, 82, 337, 6725, 12, 686, 2953, 5821, 420, 746, 1646, 30, 51284], "temperature": 0.0, "avg_logprob": -0.26508591880261057, "compression_ratio": 1.5480225988700564, "no_speech_prob": 0.011308815330266953}, {"id": 175, "seek": 107264, "start": 1093.0400000000002, "end": 1098.5600000000002, "text": " So the automatic identification wire, the PIRRA tool, tries to figure out what is the compute-", "tokens": [51384, 407, 264, 12509, 22065, 6234, 11, 264, 430, 7740, 3750, 2290, 11, 9898, 281, 2573, 484, 437, 307, 264, 14722, 12, 51660], "temperature": 0.0, "avg_logprob": -0.26508591880261057, "compression_ratio": 1.5480225988700564, "no_speech_prob": 0.011308815330266953}, {"id": 176, "seek": 109856, "start": 1098.56, "end": 1103.76, "text": " intensive part of the program, and this is the only kernel, so to speak, that we are able to", "tokens": [50364, 18957, 644, 295, 264, 1461, 11, 293, 341, 307, 264, 787, 28256, 11, 370, 281, 1710, 11, 300, 321, 366, 1075, 281, 50624], "temperature": 0.0, "avg_logprob": -0.10765550491657663, "compression_ratio": 1.761467889908257, "no_speech_prob": 0.06269563734531403}, {"id": 177, "seek": 109856, "start": 1103.76, "end": 1109.2, "text": " automatically identify, but if you as a domain expert know that this is the part of our program", "tokens": [50624, 6772, 5876, 11, 457, 498, 291, 382, 257, 9274, 5844, 458, 300, 341, 307, 264, 644, 295, 527, 1461, 50896], "temperature": 0.0, "avg_logprob": -0.10765550491657663, "compression_ratio": 1.761467889908257, "no_speech_prob": 0.06269563734531403}, {"id": 178, "seek": 109856, "start": 1109.2, "end": 1115.12, "text": " where we are IO limited, then this is nothing PIRRA can identify, but if you say I want to extract", "tokens": [50896, 689, 321, 366, 39839, 5567, 11, 550, 341, 307, 1825, 430, 7740, 3750, 393, 5876, 11, 457, 498, 291, 584, 286, 528, 281, 8947, 51192], "temperature": 0.0, "avg_logprob": -0.10765550491657663, "compression_ratio": 1.761467889908257, "no_speech_prob": 0.06269563734531403}, {"id": 179, "seek": 109856, "start": 1115.12, "end": 1122.1599999999999, "text": " starting from this function, our tool should in theory be able to extract the IO limited part of", "tokens": [51192, 2891, 490, 341, 2445, 11, 527, 2290, 820, 294, 5261, 312, 1075, 281, 8947, 264, 39839, 5567, 644, 295, 51544], "temperature": 0.0, "avg_logprob": -0.10765550491657663, "compression_ratio": 1.761467889908257, "no_speech_prob": 0.06269563734531403}, {"id": 180, "seek": 112216, "start": 1122.16, "end": 1128.3200000000002, "text": " your code. So this is the point where you as a domain expert need to specify this is the part I", "tokens": [50364, 428, 3089, 13, 407, 341, 307, 264, 935, 689, 291, 382, 257, 9274, 5844, 643, 281, 16500, 341, 307, 264, 644, 286, 50672], "temperature": 0.0, "avg_logprob": -0.15270681381225587, "compression_ratio": 1.5462555066079295, "no_speech_prob": 0.07502961158752441}, {"id": 181, "seek": 112216, "start": 1128.3200000000002, "end": 1133.8400000000001, "text": " want to extract, because the only thing that is very prominently identifiable is compute-limited", "tokens": [50672, 528, 281, 8947, 11, 570, 264, 787, 551, 300, 307, 588, 39225, 2276, 2473, 30876, 307, 14722, 12, 18692, 50948], "temperature": 0.0, "avg_logprob": -0.15270681381225587, "compression_ratio": 1.5462555066079295, "no_speech_prob": 0.07502961158752441}, {"id": 182, "seek": 112216, "start": 1134.5600000000002, "end": 1137.6000000000001, "text": " parts of the program, but yeah, in theory it should work.", "tokens": [50984, 3166, 295, 264, 1461, 11, 457, 1338, 11, 294, 5261, 309, 820, 589, 13, 51136], "temperature": 0.0, "avg_logprob": -0.15270681381225587, "compression_ratio": 1.5462555066079295, "no_speech_prob": 0.07502961158752441}, {"id": 183, "seek": 112216, "start": 1137.6000000000001, "end": 1143.76, "text": " And second question, I might allow, and do you have a library of mini-apps that are ready to use for", "tokens": [51136, 400, 1150, 1168, 11, 286, 1062, 2089, 11, 293, 360, 291, 362, 257, 6405, 295, 8382, 12, 1746, 82, 300, 366, 1919, 281, 764, 337, 51444], "temperature": 0.0, "avg_logprob": -0.15270681381225587, "compression_ratio": 1.5462555066079295, "no_speech_prob": 0.07502961158752441}, {"id": 184, "seek": 114376, "start": 1143.84, "end": 1151.52, "text": " others by third parties? So currently we're doing our benchmark, our benchmarks on already", "tokens": [50368, 2357, 538, 2636, 8265, 30, 407, 4362, 321, 434, 884, 527, 18927, 11, 527, 43751, 322, 1217, 50752], "temperature": 0.0, "avg_logprob": -0.1420750916004181, "compression_ratio": 1.669603524229075, "no_speech_prob": 0.08543886244297028}, {"id": 185, "seek": 114376, "start": 1151.52, "end": 1156.48, "text": " existing mini-apps, so we're doing mini-app extraction from mini-apps because I am profiting from", "tokens": [50752, 6741, 8382, 12, 1746, 82, 11, 370, 321, 434, 884, 8382, 12, 1746, 30197, 490, 8382, 12, 1746, 82, 570, 286, 669, 1740, 1748, 490, 51000], "temperature": 0.0, "avg_logprob": -0.1420750916004181, "compression_ratio": 1.669603524229075, "no_speech_prob": 0.08543886244297028}, {"id": 186, "seek": 114376, "start": 1156.48, "end": 1160.4, "text": " the small size of those mini-apps to validate that my program actually runs, for example the", "tokens": [51000, 264, 1359, 2744, 295, 729, 8382, 12, 1746, 82, 281, 29562, 300, 452, 1461, 767, 6676, 11, 337, 1365, 264, 51196], "temperature": 0.0, "avg_logprob": -0.1420750916004181, "compression_ratio": 1.669603524229075, "no_speech_prob": 0.08543886244297028}, {"id": 187, "seek": 114376, "start": 1160.4, "end": 1167.84, "text": " Lulash example I showed is a mini-app in itself. If I remember correctly, it's a shock simulation", "tokens": [51196, 441, 425, 1299, 1365, 286, 4712, 307, 257, 8382, 12, 1746, 294, 2564, 13, 759, 286, 1604, 8944, 11, 309, 311, 257, 5588, 16575, 51568], "temperature": 0.0, "avg_logprob": -0.1420750916004181, "compression_ratio": 1.669603524229075, "no_speech_prob": 0.08543886244297028}, {"id": 188, "seek": 116784, "start": 1167.84, "end": 1175.12, "text": " in fluids, please don't quote me on that, but it's a great code and it's very easy to work with,", "tokens": [50364, 294, 33033, 11, 1767, 500, 380, 6513, 385, 322, 300, 11, 457, 309, 311, 257, 869, 3089, 293, 309, 311, 588, 1858, 281, 589, 365, 11, 50728], "temperature": 0.0, "avg_logprob": -0.12046374320983887, "compression_ratio": 1.6991150442477876, "no_speech_prob": 0.015549972653388977}, {"id": 189, "seek": 116784, "start": 1175.12, "end": 1181.1999999999998, "text": " so I'm using that for my evaluation, but the idea is to get it to work on larger codes, for example", "tokens": [50728, 370, 286, 478, 1228, 300, 337, 452, 13344, 11, 457, 264, 1558, 307, 281, 483, 309, 281, 589, 322, 4833, 14211, 11, 337, 1365, 51032], "temperature": 0.0, "avg_logprob": -0.12046374320983887, "compression_ratio": 1.6991150442477876, "no_speech_prob": 0.015549972653388977}, {"id": 190, "seek": 116784, "start": 1181.1999999999998, "end": 1188.0, "text": " we're currently looking to the ISSM ice sheet and system model, which is a well ice melting", "tokens": [51032, 321, 434, 4362, 1237, 281, 264, 6205, 26693, 4435, 8193, 293, 1185, 2316, 11, 597, 307, 257, 731, 4435, 20493, 51372], "temperature": 0.0, "avg_logprob": -0.12046374320983887, "compression_ratio": 1.6991150442477876, "no_speech_prob": 0.015549972653388977}, {"id": 191, "seek": 116784, "start": 1188.0, "end": 1195.04, "text": " simulation for large ice sheets, but yeah we're always looking for other codes, and if you have", "tokens": [51372, 16575, 337, 2416, 4435, 15421, 11, 457, 1338, 321, 434, 1009, 1237, 337, 661, 14211, 11, 293, 498, 291, 362, 51724], "temperature": 0.0, "avg_logprob": -0.12046374320983887, "compression_ratio": 1.6991150442477876, "no_speech_prob": 0.015549972653388977}, {"id": 192, "seek": 119504, "start": 1195.12, "end": 1204.0, "text": " something that is IO bound then of course tell me. Thank you. Plenty of time for more questions, Chris.", "tokens": [50368, 746, 300, 307, 286, 46, 5472, 550, 295, 1164, 980, 385, 13, 1044, 291, 13, 2149, 4179, 295, 565, 337, 544, 1651, 11, 6688, 13, 50812], "temperature": 0.0, "avg_logprob": -0.16883644992358063, "compression_ratio": 1.484375, "no_speech_prob": 0.07220291346311569}, {"id": 193, "seek": 119504, "start": 1206.3999999999999, "end": 1211.12, "text": " Sorry to be that guy, but how hard would it be to adapt this approach to Fortran?", "tokens": [50932, 4919, 281, 312, 300, 2146, 11, 457, 577, 1152, 576, 309, 312, 281, 6231, 341, 3109, 281, 11002, 4257, 30, 51168], "temperature": 0.0, "avg_logprob": -0.16883644992358063, "compression_ratio": 1.484375, "no_speech_prob": 0.07220291346311569}, {"id": 194, "seek": 119504, "start": 1215.04, "end": 1221.36, "text": " Fortran tooling in general is something that has been of interest at our institute for a long time,", "tokens": [51364, 11002, 4257, 46593, 294, 2674, 307, 746, 300, 575, 668, 295, 1179, 412, 527, 26860, 337, 257, 938, 565, 11, 51680], "temperature": 0.0, "avg_logprob": -0.16883644992358063, "compression_ratio": 1.484375, "no_speech_prob": 0.07220291346311569}, {"id": 195, "seek": 122136, "start": 1221.36, "end": 1226.6399999999999, "text": " but the problem with Fortran tooling is that most of our knowledge is coming from the Klang front", "tokens": [50364, 457, 264, 1154, 365, 11002, 4257, 46593, 307, 300, 881, 295, 527, 3601, 307, 1348, 490, 264, 16053, 656, 1868, 50628], "temperature": 0.0, "avg_logprob": -0.14965266685981254, "compression_ratio": 1.581151832460733, "no_speech_prob": 0.006039997562766075}, {"id": 196, "seek": 122136, "start": 1226.6399999999999, "end": 1237.6799999999998, "text": " and so the C language front end, and I am not sure if Fortran, the current new Fortran LLVM front end,", "tokens": [50628, 293, 370, 264, 383, 2856, 1868, 917, 11, 293, 286, 669, 406, 988, 498, 11002, 4257, 11, 264, 2190, 777, 11002, 4257, 441, 43, 53, 44, 1868, 917, 11, 51180], "temperature": 0.0, "avg_logprob": -0.14965266685981254, "compression_ratio": 1.581151832460733, "no_speech_prob": 0.006039997562766075}, {"id": 197, "seek": 122136, "start": 1237.6799999999998, "end": 1247.04, "text": " offers the same analysis and query capabilities as Klang, and the idea to move lower in the hierarchy", "tokens": [51180, 7736, 264, 912, 5215, 293, 14581, 10862, 382, 16053, 656, 11, 293, 264, 1558, 281, 1286, 3126, 294, 264, 22333, 51648], "temperature": 0.0, "avg_logprob": -0.14965266685981254, "compression_ratio": 1.581151832460733, "no_speech_prob": 0.006039997562766075}, {"id": 198, "seek": 124704, "start": 1247.04, "end": 1252.96, "text": " towards the LLVM IR, which is more target agnostic, or language agnostic more really,", "tokens": [50364, 3030, 264, 441, 43, 53, 44, 16486, 11, 597, 307, 544, 3779, 623, 77, 19634, 11, 420, 2856, 623, 77, 19634, 544, 534, 11, 50660], "temperature": 0.0, "avg_logprob": -0.09147583612120978, "compression_ratio": 1.5958333333333334, "no_speech_prob": 0.018408149480819702}, {"id": 199, "seek": 124704, "start": 1254.8799999999999, "end": 1260.72, "text": " is that as soon as you go down to IR it's very hard to go back to figure out what was the source", "tokens": [50756, 307, 300, 382, 2321, 382, 291, 352, 760, 281, 16486, 309, 311, 588, 1152, 281, 352, 646, 281, 2573, 484, 437, 390, 264, 4009, 51048], "temperature": 0.0, "avg_logprob": -0.09147583612120978, "compression_ratio": 1.5958333333333334, "no_speech_prob": 0.018408149480819702}, {"id": 200, "seek": 124704, "start": 1260.72, "end": 1268.24, "text": " code files that actually made up this IR. So yes we already have in the back of our mind that there", "tokens": [51048, 3089, 7098, 300, 767, 1027, 493, 341, 16486, 13, 407, 2086, 321, 1217, 362, 294, 264, 646, 295, 527, 1575, 300, 456, 51424], "temperature": 0.0, "avg_logprob": -0.09147583612120978, "compression_ratio": 1.5958333333333334, "no_speech_prob": 0.018408149480819702}, {"id": 201, "seek": 124704, "start": 1268.24, "end": 1276.08, "text": " are other languages that are used in HPC systems, and usually if I present this approach I'm getting", "tokens": [51424, 366, 661, 8650, 300, 366, 1143, 294, 12557, 34, 3652, 11, 293, 2673, 498, 286, 1974, 341, 3109, 286, 478, 1242, 51816], "temperature": 0.0, "avg_logprob": -0.09147583612120978, "compression_ratio": 1.5958333333333334, "no_speech_prob": 0.018408149480819702}, {"id": 202, "seek": 127608, "start": 1276.08, "end": 1280.8799999999999, "text": " asked, well we have some Fortran codes, we have some Python codes, how does your approach work,", "tokens": [50364, 2351, 11, 731, 321, 362, 512, 11002, 4257, 14211, 11, 321, 362, 512, 15329, 14211, 11, 577, 775, 428, 3109, 589, 11, 50604], "temperature": 0.0, "avg_logprob": -0.15269722938537597, "compression_ratio": 1.6622222222222223, "no_speech_prob": 0.04399828240275383}, {"id": 203, "seek": 127608, "start": 1280.8799999999999, "end": 1286.56, "text": " but we are sadly limited by the Klang front end's capabilities, so C++, Objective C,", "tokens": [50604, 457, 321, 366, 22023, 5567, 538, 264, 16053, 656, 1868, 917, 311, 10862, 11, 370, 383, 25472, 11, 24753, 488, 383, 11, 50888], "temperature": 0.0, "avg_logprob": -0.15269722938537597, "compression_ratio": 1.6622222222222223, "no_speech_prob": 0.04399828240275383}, {"id": 204, "seek": 127608, "start": 1287.52, "end": 1292.8799999999999, "text": " which we have never tried, I'm not saying that we are able to do Objective C, but C and C++ we", "tokens": [50936, 597, 321, 362, 1128, 3031, 11, 286, 478, 406, 1566, 300, 321, 366, 1075, 281, 360, 24753, 488, 383, 11, 457, 383, 293, 383, 25472, 321, 51204], "temperature": 0.0, "avg_logprob": -0.15269722938537597, "compression_ratio": 1.6622222222222223, "no_speech_prob": 0.04399828240275383}, {"id": 205, "seek": 127608, "start": 1292.8799999999999, "end": 1297.1999999999998, "text": " have tried and are currently limited to because of our design choice. There is a Fortran front end", "tokens": [51204, 362, 3031, 293, 366, 4362, 5567, 281, 570, 295, 527, 1715, 3922, 13, 821, 307, 257, 11002, 4257, 1868, 917, 51420], "temperature": 0.0, "avg_logprob": -0.15269722938537597, "compression_ratio": 1.6622222222222223, "no_speech_prob": 0.04399828240275383}, {"id": 206, "seek": 129720, "start": 1298.0800000000002, "end": 1307.76, "text": " for Klang. Yes, but this is a Fortran front end for the LLVM infrastructure.", "tokens": [50408, 337, 16053, 656, 13, 1079, 11, 457, 341, 307, 257, 11002, 4257, 1868, 917, 337, 264, 441, 43, 53, 44, 6896, 13, 50892], "temperature": 0.0, "avg_logprob": -0.1520422958746189, "compression_ratio": 1.5290697674418605, "no_speech_prob": 0.08029504865407944}, {"id": 207, "seek": 129720, "start": 1309.28, "end": 1314.56, "text": " The C-Lang front end is the part of the LLVM project which takes C code and translates to the", "tokens": [50968, 440, 383, 12, 43, 656, 1868, 917, 307, 264, 644, 295, 264, 441, 43, 53, 44, 1716, 597, 2516, 383, 3089, 293, 28468, 281, 264, 51232], "temperature": 0.0, "avg_logprob": -0.1520422958746189, "compression_ratio": 1.5290697674418605, "no_speech_prob": 0.08029504865407944}, {"id": 208, "seek": 129720, "start": 1314.56, "end": 1321.92, "text": " LLVM IR, so I'm not sure if we're talking about the same thing. There is a Fortran front end", "tokens": [51232, 441, 43, 53, 44, 16486, 11, 370, 286, 478, 406, 988, 498, 321, 434, 1417, 466, 264, 912, 551, 13, 821, 307, 257, 11002, 4257, 1868, 917, 51600], "temperature": 0.0, "avg_logprob": -0.1520422958746189, "compression_ratio": 1.5290697674418605, "no_speech_prob": 0.08029504865407944}, {"id": 209, "seek": 132192, "start": 1321.92, "end": 1328.3200000000002, "text": " for LLVM, yes, but I would be very surprised if there is a way to translate Fortran code into", "tokens": [50364, 337, 441, 43, 53, 44, 11, 2086, 11, 457, 286, 576, 312, 588, 6100, 498, 456, 307, 257, 636, 281, 13799, 11002, 4257, 3089, 666, 50684], "temperature": 0.0, "avg_logprob": -0.11679046028538755, "compression_ratio": 1.6144067796610169, "no_speech_prob": 0.013984890654683113}, {"id": 210, "seek": 132192, "start": 1328.3200000000002, "end": 1334.0, "text": " something that Klang can understand, but I might be wrong, there is a myriad of interesting software", "tokens": [50684, 746, 300, 16053, 656, 393, 1223, 11, 457, 286, 1062, 312, 2085, 11, 456, 307, 257, 452, 45192, 295, 1880, 4722, 50968], "temperature": 0.0, "avg_logprob": -0.11679046028538755, "compression_ratio": 1.6144067796610169, "no_speech_prob": 0.013984890654683113}, {"id": 211, "seek": 132192, "start": 1334.0, "end": 1341.76, "text": " repositories, but currently consider Miscoptic. Then you can use this small part of your code", "tokens": [50968, 22283, 2083, 11, 457, 4362, 1949, 376, 5606, 5747, 299, 13, 1396, 291, 393, 764, 341, 1359, 644, 295, 428, 3089, 51356], "temperature": 0.0, "avg_logprob": -0.11679046028538755, "compression_ratio": 1.6144067796610169, "no_speech_prob": 0.013984890654683113}, {"id": 212, "seek": 132192, "start": 1341.76, "end": 1346.72, "text": " to stress the floating point unit only of linear hardware. Then this other part is very well", "tokens": [51356, 281, 4244, 264, 12607, 935, 4985, 787, 295, 8213, 8837, 13, 1396, 341, 661, 644, 307, 588, 731, 51604], "temperature": 0.0, "avg_logprob": -0.11679046028538755, "compression_ratio": 1.6144067796610169, "no_speech_prob": 0.013984890654683113}, {"id": 213, "seek": 134672, "start": 1346.72, "end": 1353.52, "text": " vectorized, so we extract this one and suddenly you are able to use AVX 512 instructions.", "tokens": [50364, 8062, 1602, 11, 370, 321, 8947, 341, 472, 293, 5800, 291, 366, 1075, 281, 764, 30198, 55, 1025, 4762, 9415, 13, 50704], "temperature": 0.0, "avg_logprob": -0.14168901154489227, "compression_ratio": 1.507936507936508, "no_speech_prob": 0.046827416867017746}, {"id": 214, "seek": 134672, "start": 1354.4, "end": 1361.3600000000001, "text": " The idea is to extract every code intensive part into its own little package and then benchmark", "tokens": [50748, 440, 1558, 307, 281, 8947, 633, 3089, 18957, 644, 666, 1080, 1065, 707, 7372, 293, 550, 18927, 51096], "temperature": 0.0, "avg_logprob": -0.14168901154489227, "compression_ratio": 1.507936507936508, "no_speech_prob": 0.046827416867017746}, {"id": 215, "seek": 134672, "start": 1361.3600000000001, "end": 1369.3600000000001, "text": " with those separate packages, so at the end you can get an idea about the whole performance of your", "tokens": [51096, 365, 729, 4994, 17401, 11, 370, 412, 264, 917, 291, 393, 483, 364, 1558, 466, 264, 1379, 3389, 295, 428, 51496], "temperature": 0.0, "avg_logprob": -0.14168901154489227, "compression_ratio": 1.507936507936508, "no_speech_prob": 0.046827416867017746}, {"id": 216, "seek": 136936, "start": 1370.24, "end": 1376.4799999999998, "text": " as your individual kernel regions. This would be the approach I take.", "tokens": [50408, 382, 428, 2609, 28256, 10682, 13, 639, 576, 312, 264, 3109, 286, 747, 13, 50720], "temperature": 0.0, "avg_logprob": -0.293770340253722, "compression_ratio": 1.2866666666666666, "no_speech_prob": 0.01570967026054859}, {"id": 217, "seek": 136936, "start": 1380.8, "end": 1383.76, "text": " Maybe one more? In the back, okay.", "tokens": [50936, 2704, 472, 544, 30, 682, 264, 646, 11, 1392, 13, 51084], "temperature": 0.0, "avg_logprob": -0.293770340253722, "compression_ratio": 1.2866666666666666, "no_speech_prob": 0.01570967026054859}, {"id": 218, "seek": 136936, "start": 1392.56, "end": 1396.7199999999998, "text": " Great talk, thank you so much. A couple of questions, Chris. I believe there was a paper", "tokens": [51524, 3769, 751, 11, 1309, 291, 370, 709, 13, 316, 1916, 295, 1651, 11, 6688, 13, 286, 1697, 456, 390, 257, 3035, 51732], "temperature": 0.0, "avg_logprob": -0.293770340253722, "compression_ratio": 1.2866666666666666, "no_speech_prob": 0.01570967026054859}, {"id": 219, "seek": 139672, "start": 1396.72, "end": 1402.48, "text": " about a Fortran mini app extractor some time ago. I can dig that up and send it to you.", "tokens": [50364, 466, 257, 11002, 4257, 8382, 724, 8947, 284, 512, 565, 2057, 13, 286, 393, 2528, 300, 493, 293, 2845, 309, 281, 291, 13, 50652], "temperature": 0.0, "avg_logprob": -0.1346066834090592, "compression_ratio": 1.4248704663212435, "no_speech_prob": 0.1355927586555481}, {"id": 220, "seek": 139672, "start": 1402.48, "end": 1413.28, "text": " If I remember that, if not, shoot me a message. Then the flank front end in the LLVM project", "tokens": [50652, 759, 286, 1604, 300, 11, 498, 406, 11, 3076, 385, 257, 3636, 13, 1396, 264, 36318, 1868, 917, 294, 264, 441, 43, 53, 44, 1716, 51192], "temperature": 0.0, "avg_logprob": -0.1346066834090592, "compression_ratio": 1.4248704663212435, "no_speech_prob": 0.1355927586555481}, {"id": 221, "seek": 139672, "start": 1413.28, "end": 1419.76, "text": " currently is not compatible with Klang, so we do get different ASTs. This approach is actually", "tokens": [51192, 4362, 307, 406, 18218, 365, 16053, 656, 11, 370, 321, 360, 483, 819, 316, 6840, 82, 13, 639, 3109, 307, 767, 51516], "temperature": 0.0, "avg_logprob": -0.1346066834090592, "compression_ratio": 1.4248704663212435, "no_speech_prob": 0.1355927586555481}, {"id": 222, "seek": 141976, "start": 1419.76, "end": 1427.6, "text": " working at the AST level, so if it were using the LLVM IR level and then somehow like magically", "tokens": [50364, 1364, 412, 264, 316, 6840, 1496, 11, 370, 498, 309, 645, 1228, 264, 441, 43, 53, 44, 16486, 1496, 293, 550, 6063, 411, 39763, 50756], "temperature": 0.0, "avg_logprob": -0.13342073340164987, "compression_ratio": 1.5887096774193548, "no_speech_prob": 0.014041002839803696}, {"id": 223, "seek": 141976, "start": 1427.6, "end": 1433.52, "text": " map back dwarf, then it would work, but there was a different project that did that, it worked kind", "tokens": [50756, 4471, 646, 35527, 11, 550, 309, 576, 589, 11, 457, 456, 390, 257, 819, 1716, 300, 630, 300, 11, 309, 2732, 733, 51052], "temperature": 0.0, "avg_logprob": -0.13342073340164987, "compression_ratio": 1.5887096774193548, "no_speech_prob": 0.014041002839803696}, {"id": 224, "seek": 141976, "start": 1433.52, "end": 1442.4, "text": " of okay. I would have a question about you for the complex inheritance hierarchies. Do you have any", "tokens": [51052, 295, 1392, 13, 286, 576, 362, 257, 1168, 466, 291, 337, 264, 3997, 32122, 35250, 530, 13, 1144, 291, 362, 604, 51496], "temperature": 0.0, "avg_logprob": -0.13342073340164987, "compression_ratio": 1.5887096774193548, "no_speech_prob": 0.014041002839803696}, {"id": 225, "seek": 141976, "start": 1442.4, "end": 1449.04, "text": " idea on how you could tackle that, approach that, represent this thing across the whole program or", "tokens": [51496, 1558, 322, 577, 291, 727, 14896, 300, 11, 3109, 300, 11, 2906, 341, 551, 2108, 264, 1379, 1461, 420, 51828], "temperature": 0.0, "avg_logprob": -0.13342073340164987, "compression_ratio": 1.5887096774193548, "no_speech_prob": 0.014041002839803696}, {"id": 226, "seek": 144976, "start": 1449.92, "end": 1456.08, "text": " things so, I mean, did you have spent any time so far looking at that or did you say like okay,", "tokens": [50372, 721, 370, 11, 286, 914, 11, 630, 291, 362, 4418, 604, 565, 370, 1400, 1237, 412, 300, 420, 630, 291, 584, 411, 1392, 11, 50680], "temperature": 0.0, "avg_logprob": -0.18040898082020518, "compression_ratio": 1.619718309859155, "no_speech_prob": 0.00775449862703681}, {"id": 227, "seek": 144976, "start": 1456.08, "end": 1460.32, "text": " that's future me or future someone going to do that?", "tokens": [50680, 300, 311, 2027, 385, 420, 2027, 1580, 516, 281, 360, 300, 30, 50892], "temperature": 0.0, "avg_logprob": -0.18040898082020518, "compression_ratio": 1.619718309859155, "no_speech_prob": 0.00775449862703681}, {"id": 228, "seek": 144976, "start": 1461.2, "end": 1467.28, "text": " So thank you for the question. So it's a mix of both. I spent some time thinking about it and decided", "tokens": [50936, 407, 1309, 291, 337, 264, 1168, 13, 407, 309, 311, 257, 2890, 295, 1293, 13, 286, 4418, 512, 565, 1953, 466, 309, 293, 3047, 51240], "temperature": 0.0, "avg_logprob": -0.18040898082020518, "compression_ratio": 1.619718309859155, "no_speech_prob": 0.00775449862703681}, {"id": 229, "seek": 144976, "start": 1467.28, "end": 1475.28, "text": " it was for future me because I didn't assume it to be very easy, but you already mentioned the", "tokens": [51240, 309, 390, 337, 2027, 385, 570, 286, 994, 380, 6552, 309, 281, 312, 588, 1858, 11, 457, 291, 1217, 2835, 264, 51640], "temperature": 0.0, "avg_logprob": -0.18040898082020518, "compression_ratio": 1.619718309859155, "no_speech_prob": 0.00775449862703681}, {"id": 230, "seek": 147528, "start": 1475.36, "end": 1481.52, "text": " general idea that as soon as you go into more complex inheritance chains, you aren't able to", "tokens": [50368, 2674, 1558, 300, 382, 2321, 382, 291, 352, 666, 544, 3997, 32122, 12626, 11, 291, 3212, 380, 1075, 281, 50676], "temperature": 0.0, "avg_logprob": -0.09887126322542683, "compression_ratio": 1.747787610619469, "no_speech_prob": 0.02045116201043129}, {"id": 231, "seek": 147528, "start": 1481.52, "end": 1488.3999999999999, "text": " extract everything from one header file per se, so you need to do the same opportunistic extraction", "tokens": [50676, 8947, 1203, 490, 472, 23117, 3991, 680, 369, 11, 370, 291, 643, 281, 360, 264, 912, 2070, 3142, 30197, 51020], "temperature": 0.0, "avg_logprob": -0.09887126322542683, "compression_ratio": 1.747787610619469, "no_speech_prob": 0.02045116201043129}, {"id": 232, "seek": 147528, "start": 1489.12, "end": 1494.8799999999999, "text": " idea that we do for functions, but now for classes, structs and all their possible inheritance parents.", "tokens": [51056, 1558, 300, 321, 360, 337, 6828, 11, 457, 586, 337, 5359, 11, 6594, 82, 293, 439, 641, 1944, 32122, 3152, 13, 51344], "temperature": 0.0, "avg_logprob": -0.09887126322542683, "compression_ratio": 1.747787610619469, "no_speech_prob": 0.02045116201043129}, {"id": 233, "seek": 147528, "start": 1495.52, "end": 1500.8, "text": " So this is something that we need to analyze on the whole program scale, so this is something that", "tokens": [51376, 407, 341, 307, 746, 300, 321, 643, 281, 12477, 322, 264, 1379, 1461, 4373, 11, 370, 341, 307, 746, 300, 51640], "temperature": 0.0, "avg_logprob": -0.09887126322542683, "compression_ratio": 1.747787610619469, "no_speech_prob": 0.02045116201043129}, {"id": 234, "seek": 150080, "start": 1501.76, "end": 1510.0, "text": " in the not near future, but in the foreseeable future, I intend to put as an analysis pass into", "tokens": [50412, 294, 264, 406, 2651, 2027, 11, 457, 294, 264, 38736, 712, 2027, 11, 286, 19759, 281, 829, 382, 364, 5215, 1320, 666, 50824], "temperature": 0.0, "avg_logprob": -0.08575546079211765, "compression_ratio": 1.545945945945946, "no_speech_prob": 0.005774011369794607}, {"id": 235, "seek": 150080, "start": 1510.0, "end": 1518.3999999999999, "text": " the CG collector, which you probably are familiar with. So the idea is that this tool is then able", "tokens": [50824, 264, 38007, 23960, 11, 597, 291, 1391, 366, 4963, 365, 13, 407, 264, 1558, 307, 300, 341, 2290, 307, 550, 1075, 51244], "temperature": 0.0, "avg_logprob": -0.08575546079211765, "compression_ratio": 1.545945945945946, "no_speech_prob": 0.005774011369794607}, {"id": 236, "seek": 150080, "start": 1518.3999999999999, "end": 1525.84, "text": " to annotate all this information as metadata and then once we merge it, we get a very good,", "tokens": [51244, 281, 25339, 473, 439, 341, 1589, 382, 26603, 293, 550, 1564, 321, 22183, 309, 11, 321, 483, 257, 588, 665, 11, 51616], "temperature": 0.0, "avg_logprob": -0.08575546079211765, "compression_ratio": 1.545945945945946, "no_speech_prob": 0.005774011369794607}, {"id": 237, "seek": 152584, "start": 1525.84, "end": 1533.76, "text": " hopefully, impression of how those inheritance chains flow through the whole program. So the idea.", "tokens": [50364, 4696, 11, 9995, 295, 577, 729, 32122, 12626, 3095, 807, 264, 1379, 1461, 13, 407, 264, 1558, 13, 50760], "temperature": 0.0, "avg_logprob": -0.20680695045285108, "compression_ratio": 1.28, "no_speech_prob": 0.03333228826522827}, {"id": 238, "seek": 152584, "start": 1535.12, "end": 1546.32, "text": " Thanks. Okay, that's all we have time for. Thanks a lot, Tim.", "tokens": [50828, 2561, 13, 1033, 11, 300, 311, 439, 321, 362, 565, 337, 13, 2561, 257, 688, 11, 7172, 13, 51388], "temperature": 0.0, "avg_logprob": -0.20680695045285108, "compression_ratio": 1.28, "no_speech_prob": 0.03333228826522827}], "language": "en"}