{"text": " especially state machines and how they are handled in Ireland and also from a theoretical point of view. So, it's up to you. Thank you. All right. Yes, he said, like, I'm relatively young but I know a school guy, so I code in V-man and use Ireland. So, this went too fast already. I work in Erlang Solutions. We do like Erlang stuff, so concurrency, scalability, the useful things that most of you would be hopefully familiar and we also contribute a lot to open source. This talk is going to be about state machines, as you heard. First, a question of protocols. What are protocols? I wanted to make a survey and ask you and so on, but we have limited time, so I'm going to answer the question already. System of rules. A few examples. Okay, I need to point here for this to work. Protocol defines the system of rules for syntax, semantics of the project, the program that you want to write. Some examples, the usual ones are TCP for network communication, is connection oriented, stream oriented, messages are ordered and they are acknowledged. Another common example, TLS for privacy, integrity and authenticity, encryption, very important. I hope that everybody has HTTPS enabling the browsers by default. Some other examples are file formats or markup languages. Parsers for them can also be implemented as state machines. The two classic examples, XML and JSON. XML is particularly interesting to me because I work in XMPP messaging server written in Erlang, of course. If you saw our talk in CodeBeam, for those that are following CodeBeam, Pablo and me, we talked about the state machine re-implementation in Mongo's IM. This is a bit of a continuation to that. Some more complex protocols can be implemented as state machines like HTTP and as I mentioned, XMPP, which is my specialty, which is extensible, that's the X and my favorite part of the whole thing, it's an instant messaging protocol that also has presences, the green bubble, whether your friend is connected or not and it also does contact list maintenance on the core protocol, 500 extensions and build your own. This is the state machine diagram for the protocol. Much like a flow chart on steroids, I really like that analogy. With the state machines, we are like the usual thing, how you think about state machines, you draw the state with some arrows, the arrows have tags about how you transition to the next state. Finest state machines give you a way to visualize a system that can be very complex. Why state machines? State machines can be seen as a model. We want to model the behavior of protocol that can be very complex like TLS or HTTP, most of you will be familiar, XMPP, my specialty. Let's talk a little bit quickly about state machines in particular. A few formalities. I studied mathematics in university, I'm excited by these weird symbols, but some people can find them off-putting, so I will try to make it pleasant. A few terminologies, we define an alphabet, terminologies, you use Greek symbols, mathematicians, which are the input symbols, zeros and ones, or ASCII characters, UTF-8, or complex symbols treated as a single element, half, and you can do equivalences. One of the weakest ones is the regular grammars, it's how you do regexes. A regex, this thing that right ones are never read, but very powerful, is theoretically equivalent to a state machine. Again, this is jumping too fast. Something a little bit more powerful is the partial automata, I'm not going to focus on this one too much, use a key difference, then nothing else parsed, now it has one more thing, it's the same thing before, plus a stack, and the stack behaves as you would expect. The function that used to take the state and the input symbol also takes the stack and the output of the function is whether you pop something from the stack or you push something on the stack. It's safe to consume a string that you give to this PDA as it arrives to one of the final states with an empty stack. There are equivalent definitions, not all definitions require the empty stack, but I choose that one. They are equivalent to context-free grammars, parsers, but not compilers. Why a compiler? So in tree, the thing about being context-free is that it doesn't remember symbols that were defined before. So for a compiler, for example, the usual regex compiler for C that needs to remember the definition when you say int e and then you use e later below, parser doesn't remember that, you need symbol tables, parser only builds the syntax tree. And the fancy one, the computer, theoretically, Turing machines, which is again the same thing, but nothing else is supplanted by a tape that is infinite. It is equivalent whether it's finite in one side and infinite in the other, all of those are equivalents, whether it has two tapes is also equivalent, will arrive to that. The function takes the tape and the action go one to the left and write something, go one to the right and write something. Very similar, a Turing machine is said to consume a string when the next step is undefined. When it holds, you have all heard of the holding problem. There is no way to know whether a Turing machine will hold. That is important. They are equivalent to interested grammars, compilers in the Chomsky hierarchy that are like four levels. The three things that I describe are zero, one and four, there is something in the level three that is not directly useful for the moment. So I skip that. So how do they compare? This goes very fast sometimes. So that's the power that they have. A Turing machine can do all the others. PDA can do the one over there. So that's the power that they can do. They contain the power of each other. Two FSMs running together has still the same theoretical power, the same thing that a PDA with a finite buffer or a PDA with a finite state machine is still as powerful as one PDA. Turing machines, whether it's multi-tape, tape one banded on one side, they are all equivalent again. A Turing machine doesn't get more powerful by giving it 100 tapes. It gets maybe more performant theoretically, but the problems that it can solve are all the same. And a PDA with two stacks is really a Turing machine when you know you can just go in both directions. So when you give the PDA two stacks, you build a Turing machine. So conceptually, finite state machines can keep track of one thing, the state. The push-down automata can keep track of two things, the state and the top of the stack. And a Turing machine can keep track of infinite things. When I was going through the mathematics and I came to this conclusion, I found this funny for a completely unrelated reason. In the European languages, I mean to human languages, used to have the concept of dual as something different to singular and plural. The function that it computes depends on one thing to things or an infinite number of them. The function that was defined before. So in the European languages, as I said, they had this special concept of the dual. And I found it very funny how informal human languages used to have such a thing as a dual, as a different grammatical category than one and infinite. When you build the declinations, they had a different thing. Why do I know this strange thing about languages? Because I live in Poland. So Slavic languages have some remnants of that dual concept. So there is this famous joke of in Polish you have like 100 ways to declinate number two. And you have more ways to declinate number two than you have number three because of that all dual. So two is special. I live in Poland, but I'm not Polish. It's challenging. So do FSMs produce output? Let's go move slowly to what is useful here. We can define finite state transducers, which same thing than before and then nothing else is supplanted by another output alphabet. The function takes the state and the input and decides the next state and a symbol for the output. It's a to consume a string the same and they are also equivalent to regular grammars. When it comes to the problems they can solve, again, they're all equivalent. You get fancier tools, but there are properties that are going to be all the same. You will see in a second there are many, but let's focus on two ways of defining transducers, the milley machines and Moore machines, whether the output, I have a laser, yes, whether the output symbol depends on the input and the previous state or only on the previous state. There is a way to define Moore machines from a milley machine, but not the other way around, so milley has a bit more powerful. Now something a bit more useful, how do they compare? They are still the same than the FSM machines, but this can be composed. We are getting into a bit of engineering. We are almost there. Not that much. This is a thing, laser. Yes, oh god. Come on, sometimes. So given three sets of states, three alphabets, one machine goes from one state and one alphabet to the next state and the other alphabet. The second machine uses the same the output of the previous as its input, so you can define the composition as a state machine that takes the first alphabet and the first set of inputs and gives you the third alphabet and set of inputs. Composition, cool. Why? Because you can implement all these things as state machines and the output of one is the input of the next. So my stack on XMPP, you can implement TCP as a state machine. Have you heard of the Erlang socket, the new socket? It's implemented in TCP on top of gain state them. If you go to the source code. So I have the output of one state them, throwing into the output of the next state them. TLS is also implemented as a gain state them, throwing output to my thing, to the XML parser that throws its output to the XMPP protocol. So we are composing things. One last theoretical thing. The unions of FSMs that is uniting all the states and strings, it's also an FSM intersection, so the states and its input symbols in common gives you a very small FSM. It's also an FSM reversing, still an FSM, empty, so no states and no input is also an FSM that when you do union and concatenation with another FSM does nothing and homomorphism, so a function that transforms alphabets and states into other alphabets and states preserves the structure of an FSM. So FSMs are a semi-ring. This is an algebraic structure. Why is it useful to have search algebras? To prove things that you cannot prove with Turing machines because they do not form an algebra. So now let's do something engineering, state them. So as I said before, it's a Melly machine. It gets the input and the alphabets, it produces the states and alphabets, it produces the next, you follow, I hope. We can consider that the input are the messages in the mailbox and the output symbols are side effects, like for example sending messages to another mailbox. Gain state them. I'm a big fan. I love it, but I know that people sometimes don't use it because maybe it's confusing or I don't know, complicated. So I'm going to try to explain one thing that is very useful here. An extended mailbox. This is a discussion that the OTP team, when they put the pull request for gain state them, there is a big discussion with over a thousand messages that was probably forgotten, but when they discovered gain state them and I liked it, I went to the source and I read that super long thing. And there are useful things said there. A way to visualize a gain state them. Imagine that it has one queue, that is something more than the process mailbox, with like three pointers. The head pointing at the oldest event and the tail pointing at the youngest and current is where I am now. You can move where current is with some of the actions that gain state them gives you, for example postponing an event. Postponing an event means that current moves to the next, but the event is not forgotten. There is a different action that will put current again in the head. Not postponing and you consume it is removed from the queue. When the state changes, current goes again to head. Next event inserts things where current is and not at the tail. And timeouts inserts things at the tail. So the engine, the gain state them implementation allows you to extend the inputs that your formal state machine is going to get. How does it work? Imagine that we are here, we have event one and we decide to postpone it. What happens? It's still on the mailbox. We just are now going to deal with event two. Now we decide to do some stuff and then go to the next state. So that has been processed and current because we changed the state goes back to the previous. Now we are again going to handle event one and this time we decide to not change the state, but we generate new inputs as if this process has received a message. But this event A, which is ad hoc, we just created it, is inserted where current is. So it's the next event that we are going to handle. We can decide to postpone it. Now we are going to handle event three. With event three we do some stuff, but we don't generate events. Imagine that there is middle code here doing. So event three has been dealt with. Now you go to event four and you decide to postpone event four, but also insert and event B. So event four goes behind, you insert and event B, you get the idea. So the engine gives you a way to extend the process queue. What am I doing with time? Oh, one more important power. I'm not going to have time for everything. One more useful power of the state machines. Managing accidental complexity. There is a talk that I want to recommend. It's quite an old one, maybe something like 10 or 15 years ago by Ulf Rieger, where he was complaining about some limitations of GANFSM, but even GAN server that we all use. Very useful talk and I have one tiny answer to that with the new GAN state that didn't exist back then. Typical state on, off, but you can imagine that you're switching a light, but your switch talks to a through a cable protocol to the light machine. So when the user says on, this is a GAN server, you say and the state is off, you send a request to on, you wait for the answer on, it's on, vice versa, relatively intuitive code. Now imagine that that request through the cable protocol was not synchronous and imagine that the switches cannot block. It needs to do other stuff. So you send an asynchronous request to the light, hey, turn on yourself and continue doing other things, but then the user sends more off and on. What do you decide to do here? It's not part of the protocol. The events are now asynchronous and out of order. There is no global ordering. So there are some questions like you need to choose what to do. Sometimes this, this is the, so we can use a state machine. They use all the way. The name of the function is the name of the state and you can postpone things if you are already running a request, you postpone it and when if the user press on like a hundred times, by the time they like says on, then you have changed the state and you're going to handle all those. It's already on, so just do nothing. But the code is terribly symmetric. It feels repetitive. So problems, there is no ordering when things are asynchronous. Tying yourself to the ordering of events leads to accidental complexity. This is the point of Ulfiger when the order changes, the whole implementation changes. It grows relative to the number of states. This is super simple. It's a like that goes on and off. But imagine complicated protocols and for example a middle layer between a very talkative protocol and a like one and code reuse. So I really like the handle event way of handling things. It's a single function callback that gets a simple the state and the data. By the way, it's very confusing because we are used to the state of the process for the server thing. But in the state, the state is the state machine state. So the other thing where you save like, I don't know, the socket, for example, is called data. So just confusing terminology. This, you can just pattern match whether you're in the same state and the previous function that was terribly repetitive is now in a single function head. This is, I believe, a way to answer to the problem that Ulf raised and now I'm exactly on time. One more slide. A way to answer to that problem and in a way that you can reuse code, that you can decide the order of events because you can postpone things and you can also insert things. Quickly here, why I use on the XMPP, we had like this implementation. There is only one thing that I really like here. The composing. As I said before, you have the TCP state machines that go to TLS that goes to XML that goes to messaging. So if we want to implement this on a single process, this can be, for example, this is a simplification on my data. I have a parser and the crypto library that when I get that TCP payload, this is how we do it in Mongoose. I am not TCP, TCP we just use TCP to complicate it. So it's a separate process. But crypto and XML parsers, we implemented on the spot. There is a C code that the parsers, part of the XML, for example, it gives you a new parser with a buffer and the XML structure that then you can use to generate the events that my protocol cares about, the XML payloads. That's one use case that we have. That's me. You can find me by that picture in all the places. Those are some of the projects I work in and I was going to say questions, but we are one minute late. Thank you.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 10.88, "text": " especially state machines and how they are handled in Ireland and also from a theoretical", "tokens": [50364, 2318, 1785, 8379, 293, 577, 436, 366, 18033, 294, 15880, 293, 611, 490, 257, 20864, 50908], "temperature": 0.0, "avg_logprob": -0.46427632891942583, "compression_ratio": 1.3636363636363635, "no_speech_prob": 0.2986890971660614}, {"id": 1, "seek": 0, "start": 10.88, "end": 20.2, "text": " point of view. So, it's up to you. Thank you.", "tokens": [50908, 935, 295, 1910, 13, 407, 11, 309, 311, 493, 281, 291, 13, 1044, 291, 13, 51374], "temperature": 0.0, "avg_logprob": -0.46427632891942583, "compression_ratio": 1.3636363636363635, "no_speech_prob": 0.2986890971660614}, {"id": 2, "seek": 0, "start": 20.2, "end": 24.72, "text": " All right. Yes, he said, like, I'm relatively young but I know a school guy, so I code in", "tokens": [51374, 1057, 558, 13, 1079, 11, 415, 848, 11, 411, 11, 286, 478, 7226, 2037, 457, 286, 458, 257, 1395, 2146, 11, 370, 286, 3089, 294, 51600], "temperature": 0.0, "avg_logprob": -0.46427632891942583, "compression_ratio": 1.3636363636363635, "no_speech_prob": 0.2986890971660614}, {"id": 3, "seek": 2472, "start": 24.72, "end": 33.96, "text": " V-man and use Ireland. So, this went too fast already. I work in Erlang Solutions. We do", "tokens": [50364, 691, 12, 1601, 293, 764, 15880, 13, 407, 11, 341, 1437, 886, 2370, 1217, 13, 286, 589, 294, 3300, 25241, 36295, 13, 492, 360, 50826], "temperature": 0.0, "avg_logprob": -0.2697043626204781, "compression_ratio": 1.5321888412017168, "no_speech_prob": 0.4945647716522217}, {"id": 4, "seek": 2472, "start": 33.96, "end": 39.2, "text": " like Erlang stuff, so concurrency, scalability, the useful things that most of you would be", "tokens": [50826, 411, 3300, 25241, 1507, 11, 370, 23702, 10457, 11, 15664, 2310, 11, 264, 4420, 721, 300, 881, 295, 291, 576, 312, 51088], "temperature": 0.0, "avg_logprob": -0.2697043626204781, "compression_ratio": 1.5321888412017168, "no_speech_prob": 0.4945647716522217}, {"id": 5, "seek": 2472, "start": 39.2, "end": 44.480000000000004, "text": " hopefully familiar and we also contribute a lot to open source. This talk is going to", "tokens": [51088, 4696, 4963, 293, 321, 611, 10586, 257, 688, 281, 1269, 4009, 13, 639, 751, 307, 516, 281, 51352], "temperature": 0.0, "avg_logprob": -0.2697043626204781, "compression_ratio": 1.5321888412017168, "no_speech_prob": 0.4945647716522217}, {"id": 6, "seek": 2472, "start": 44.480000000000004, "end": 50.76, "text": " be about state machines, as you heard. First, a question of protocols. What are protocols?", "tokens": [51352, 312, 466, 1785, 8379, 11, 382, 291, 2198, 13, 2386, 11, 257, 1168, 295, 20618, 13, 708, 366, 20618, 30, 51666], "temperature": 0.0, "avg_logprob": -0.2697043626204781, "compression_ratio": 1.5321888412017168, "no_speech_prob": 0.4945647716522217}, {"id": 7, "seek": 5076, "start": 50.76, "end": 54.599999999999994, "text": " I wanted to make a survey and ask you and so on, but we have limited time, so I'm going", "tokens": [50364, 286, 1415, 281, 652, 257, 8984, 293, 1029, 291, 293, 370, 322, 11, 457, 321, 362, 5567, 565, 11, 370, 286, 478, 516, 50556], "temperature": 0.0, "avg_logprob": -0.1906305669428228, "compression_ratio": 1.5765765765765767, "no_speech_prob": 0.06116925925016403}, {"id": 8, "seek": 5076, "start": 54.599999999999994, "end": 64.03999999999999, "text": " to answer the question already. System of rules. A few examples. Okay, I need to point", "tokens": [50556, 281, 1867, 264, 1168, 1217, 13, 8910, 295, 4474, 13, 316, 1326, 5110, 13, 1033, 11, 286, 643, 281, 935, 51028], "temperature": 0.0, "avg_logprob": -0.1906305669428228, "compression_ratio": 1.5765765765765767, "no_speech_prob": 0.06116925925016403}, {"id": 9, "seek": 5076, "start": 64.03999999999999, "end": 70.24, "text": " here for this to work. Protocol defines the system of rules for syntax, semantics of the", "tokens": [51028, 510, 337, 341, 281, 589, 13, 48753, 23122, 264, 1185, 295, 4474, 337, 28431, 11, 4361, 45298, 295, 264, 51338], "temperature": 0.0, "avg_logprob": -0.1906305669428228, "compression_ratio": 1.5765765765765767, "no_speech_prob": 0.06116925925016403}, {"id": 10, "seek": 5076, "start": 70.24, "end": 77.0, "text": " project, the program that you want to write. Some examples, the usual ones are TCP for", "tokens": [51338, 1716, 11, 264, 1461, 300, 291, 528, 281, 2464, 13, 2188, 5110, 11, 264, 7713, 2306, 366, 48965, 337, 51676], "temperature": 0.0, "avg_logprob": -0.1906305669428228, "compression_ratio": 1.5765765765765767, "no_speech_prob": 0.06116925925016403}, {"id": 11, "seek": 7700, "start": 77.0, "end": 82.56, "text": " network communication, is connection oriented, stream oriented, messages are ordered and", "tokens": [50364, 3209, 6101, 11, 307, 4984, 21841, 11, 4309, 21841, 11, 7897, 366, 8866, 293, 50642], "temperature": 0.0, "avg_logprob": -0.23334684251229973, "compression_ratio": 1.5349794238683128, "no_speech_prob": 0.4084009528160095}, {"id": 12, "seek": 7700, "start": 82.56, "end": 89.4, "text": " they are acknowledged. Another common example, TLS for privacy, integrity and authenticity,", "tokens": [50642, 436, 366, 27262, 13, 3996, 2689, 1365, 11, 314, 19198, 337, 11427, 11, 16000, 293, 34215, 11, 50984], "temperature": 0.0, "avg_logprob": -0.23334684251229973, "compression_ratio": 1.5349794238683128, "no_speech_prob": 0.4084009528160095}, {"id": 13, "seek": 7700, "start": 89.4, "end": 98.12, "text": " encryption, very important. I hope that everybody has HTTPS enabling the browsers by default.", "tokens": [50984, 29575, 11, 588, 1021, 13, 286, 1454, 300, 2201, 575, 11751, 51, 6273, 23148, 264, 36069, 538, 7576, 13, 51420], "temperature": 0.0, "avg_logprob": -0.23334684251229973, "compression_ratio": 1.5349794238683128, "no_speech_prob": 0.4084009528160095}, {"id": 14, "seek": 7700, "start": 98.12, "end": 104.52, "text": " Some other examples are file formats or markup languages. Parsers for them can also be implemented", "tokens": [51420, 2188, 661, 5110, 366, 3991, 25879, 420, 1491, 1010, 8650, 13, 49691, 433, 337, 552, 393, 611, 312, 12270, 51740], "temperature": 0.0, "avg_logprob": -0.23334684251229973, "compression_ratio": 1.5349794238683128, "no_speech_prob": 0.4084009528160095}, {"id": 15, "seek": 10452, "start": 104.52, "end": 111.8, "text": " as state machines. The two classic examples, XML and JSON. XML is particularly interesting", "tokens": [50364, 382, 1785, 8379, 13, 440, 732, 7230, 5110, 11, 43484, 293, 31828, 13, 43484, 307, 4098, 1880, 50728], "temperature": 0.0, "avg_logprob": -0.2309499840987356, "compression_ratio": 1.5126050420168067, "no_speech_prob": 0.12463635206222534}, {"id": 16, "seek": 10452, "start": 111.8, "end": 120.0, "text": " to me because I work in XMPP messaging server written in Erlang, of course. If you saw our", "tokens": [50728, 281, 385, 570, 286, 589, 294, 1783, 12224, 47, 21812, 7154, 3720, 294, 3300, 25241, 11, 295, 1164, 13, 759, 291, 1866, 527, 51138], "temperature": 0.0, "avg_logprob": -0.2309499840987356, "compression_ratio": 1.5126050420168067, "no_speech_prob": 0.12463635206222534}, {"id": 17, "seek": 10452, "start": 120.0, "end": 126.72, "text": " talk in CodeBeam, for those that are following CodeBeam, Pablo and me, we talked about the", "tokens": [51138, 751, 294, 15549, 6524, 335, 11, 337, 729, 300, 366, 3480, 15549, 6524, 335, 11, 31554, 293, 385, 11, 321, 2825, 466, 264, 51474], "temperature": 0.0, "avg_logprob": -0.2309499840987356, "compression_ratio": 1.5126050420168067, "no_speech_prob": 0.12463635206222534}, {"id": 18, "seek": 10452, "start": 126.72, "end": 133.0, "text": " state machine re-implementation in Mongo's IM. This is a bit of a continuation to that.", "tokens": [51474, 1785, 3479, 319, 12, 332, 781, 19631, 294, 48380, 311, 21463, 13, 639, 307, 257, 857, 295, 257, 29357, 281, 300, 13, 51788], "temperature": 0.0, "avg_logprob": -0.2309499840987356, "compression_ratio": 1.5126050420168067, "no_speech_prob": 0.12463635206222534}, {"id": 19, "seek": 13300, "start": 133.2, "end": 140.56, "text": " Some more complex protocols can be implemented as state machines like HTTP and as I mentioned,", "tokens": [50374, 2188, 544, 3997, 20618, 393, 312, 12270, 382, 1785, 8379, 411, 33283, 293, 382, 286, 2835, 11, 50742], "temperature": 0.0, "avg_logprob": -0.240466317465139, "compression_ratio": 1.5665236051502145, "no_speech_prob": 0.03832804411649704}, {"id": 20, "seek": 13300, "start": 140.56, "end": 146.44, "text": " XMPP, which is my specialty, which is extensible, that's the X and my favorite part of the whole", "tokens": [50742, 1783, 12224, 47, 11, 597, 307, 452, 22000, 11, 597, 307, 1279, 30633, 11, 300, 311, 264, 1783, 293, 452, 2954, 644, 295, 264, 1379, 51036], "temperature": 0.0, "avg_logprob": -0.240466317465139, "compression_ratio": 1.5665236051502145, "no_speech_prob": 0.03832804411649704}, {"id": 21, "seek": 13300, "start": 146.44, "end": 152.24, "text": " thing, it's an instant messaging protocol that also has presences, the green bubble,", "tokens": [51036, 551, 11, 309, 311, 364, 9836, 21812, 10336, 300, 611, 575, 1183, 2667, 11, 264, 3092, 12212, 11, 51326], "temperature": 0.0, "avg_logprob": -0.240466317465139, "compression_ratio": 1.5665236051502145, "no_speech_prob": 0.03832804411649704}, {"id": 22, "seek": 13300, "start": 152.24, "end": 156.56, "text": " whether your friend is connected or not and it also does contact list maintenance on the", "tokens": [51326, 1968, 428, 1277, 307, 4582, 420, 406, 293, 309, 611, 775, 3385, 1329, 11258, 322, 264, 51542], "temperature": 0.0, "avg_logprob": -0.240466317465139, "compression_ratio": 1.5665236051502145, "no_speech_prob": 0.03832804411649704}, {"id": 23, "seek": 15656, "start": 156.6, "end": 164.84, "text": " core protocol, 500 extensions and build your own. This is the state machine diagram for", "tokens": [50366, 4965, 10336, 11, 5923, 25129, 293, 1322, 428, 1065, 13, 639, 307, 264, 1785, 3479, 10686, 337, 50778], "temperature": 0.0, "avg_logprob": -0.24481446402413504, "compression_ratio": 1.6919431279620853, "no_speech_prob": 0.05006169155240059}, {"id": 24, "seek": 15656, "start": 164.84, "end": 175.48000000000002, "text": " the protocol. Much like a flow chart on steroids, I really like that analogy. With the state", "tokens": [50778, 264, 10336, 13, 12313, 411, 257, 3095, 6927, 322, 45717, 11, 286, 534, 411, 300, 21663, 13, 2022, 264, 1785, 51310], "temperature": 0.0, "avg_logprob": -0.24481446402413504, "compression_ratio": 1.6919431279620853, "no_speech_prob": 0.05006169155240059}, {"id": 25, "seek": 15656, "start": 175.48000000000002, "end": 180.24, "text": " machines, we are like the usual thing, how you think about state machines, you draw the", "tokens": [51310, 8379, 11, 321, 366, 411, 264, 7713, 551, 11, 577, 291, 519, 466, 1785, 8379, 11, 291, 2642, 264, 51548], "temperature": 0.0, "avg_logprob": -0.24481446402413504, "compression_ratio": 1.6919431279620853, "no_speech_prob": 0.05006169155240059}, {"id": 26, "seek": 15656, "start": 180.24, "end": 185.12, "text": " state with some arrows, the arrows have tags about how you transition to the next state.", "tokens": [51548, 1785, 365, 512, 19669, 11, 264, 19669, 362, 18632, 466, 577, 291, 6034, 281, 264, 958, 1785, 13, 51792], "temperature": 0.0, "avg_logprob": -0.24481446402413504, "compression_ratio": 1.6919431279620853, "no_speech_prob": 0.05006169155240059}, {"id": 27, "seek": 18512, "start": 186.12, "end": 191.92000000000002, "text": " Finest state machines give you a way to visualize a system that can be very complex.", "tokens": [50414, 3773, 377, 1785, 8379, 976, 291, 257, 636, 281, 23273, 257, 1185, 300, 393, 312, 588, 3997, 13, 50704], "temperature": 0.0, "avg_logprob": -0.21677055911741394, "compression_ratio": 1.5621301775147929, "no_speech_prob": 0.006349299103021622}, {"id": 28, "seek": 18512, "start": 191.92000000000002, "end": 202.52, "text": " Why state machines? State machines can be seen as a model. We want to model the behavior of", "tokens": [50704, 1545, 1785, 8379, 30, 4533, 8379, 393, 312, 1612, 382, 257, 2316, 13, 492, 528, 281, 2316, 264, 5223, 295, 51234], "temperature": 0.0, "avg_logprob": -0.21677055911741394, "compression_ratio": 1.5621301775147929, "no_speech_prob": 0.006349299103021622}, {"id": 29, "seek": 18512, "start": 202.52, "end": 209.64000000000001, "text": " protocol that can be very complex like TLS or HTTP, most of you will be familiar, XMPP,", "tokens": [51234, 10336, 300, 393, 312, 588, 3997, 411, 314, 19198, 420, 33283, 11, 881, 295, 291, 486, 312, 4963, 11, 1783, 12224, 47, 11, 51590], "temperature": 0.0, "avg_logprob": -0.21677055911741394, "compression_ratio": 1.5621301775147929, "no_speech_prob": 0.006349299103021622}, {"id": 30, "seek": 20964, "start": 209.67999999999998, "end": 218.07999999999998, "text": " my specialty. Let's talk a little bit quickly about state machines in particular. A few", "tokens": [50366, 452, 22000, 13, 961, 311, 751, 257, 707, 857, 2661, 466, 1785, 8379, 294, 1729, 13, 316, 1326, 50786], "temperature": 0.0, "avg_logprob": -0.20599830851835363, "compression_ratio": 1.4166666666666667, "no_speech_prob": 0.05899174138903618}, {"id": 31, "seek": 20964, "start": 218.07999999999998, "end": 225.67999999999998, "text": " formalities. I studied mathematics in university, I'm excited by these weird symbols, but some", "tokens": [50786, 9860, 1088, 13, 286, 9454, 18666, 294, 5454, 11, 286, 478, 2919, 538, 613, 3657, 16944, 11, 457, 512, 51166], "temperature": 0.0, "avg_logprob": -0.20599830851835363, "compression_ratio": 1.4166666666666667, "no_speech_prob": 0.05899174138903618}, {"id": 32, "seek": 20964, "start": 225.67999999999998, "end": 233.56, "text": " people can find them off-putting, so I will try to make it pleasant. A few terminologies,", "tokens": [51166, 561, 393, 915, 552, 766, 12, 2582, 783, 11, 370, 286, 486, 853, 281, 652, 309, 16232, 13, 316, 1326, 10761, 6204, 11, 51560], "temperature": 0.0, "avg_logprob": -0.20599830851835363, "compression_ratio": 1.4166666666666667, "no_speech_prob": 0.05899174138903618}, {"id": 33, "seek": 23356, "start": 233.88, "end": 240.48, "text": " we define an alphabet, terminologies, you use Greek symbols, mathematicians, which are the", "tokens": [50380, 321, 6964, 364, 23339, 11, 10761, 6204, 11, 291, 764, 10281, 16944, 11, 32811, 2567, 11, 597, 366, 264, 50710], "temperature": 0.0, "avg_logprob": -0.27549857062262456, "compression_ratio": 1.4191919191919191, "no_speech_prob": 0.12234145402908325}, {"id": 34, "seek": 23356, "start": 240.48, "end": 248.28, "text": " input symbols, zeros and ones, or ASCII characters, UTF-8, or complex symbols treated as a single", "tokens": [50710, 4846, 16944, 11, 35193, 293, 2306, 11, 420, 7469, 34, 9503, 4342, 11, 624, 20527, 12, 23, 11, 420, 3997, 16944, 8668, 382, 257, 2167, 51100], "temperature": 0.0, "avg_logprob": -0.27549857062262456, "compression_ratio": 1.4191919191919191, "no_speech_prob": 0.12234145402908325}, {"id": 35, "seek": 23356, "start": 248.28, "end": 256.2, "text": " element, half, and you can do equivalences. One of the weakest ones is the regular grammars,", "tokens": [51100, 4478, 11, 1922, 11, 293, 291, 393, 360, 9052, 2667, 13, 1485, 295, 264, 44001, 2306, 307, 264, 3890, 17570, 685, 11, 51496], "temperature": 0.0, "avg_logprob": -0.27549857062262456, "compression_ratio": 1.4191919191919191, "no_speech_prob": 0.12234145402908325}, {"id": 36, "seek": 25620, "start": 256.36, "end": 263.15999999999997, "text": " it's how you do regexes. A regex, this thing that right ones are never read, but very powerful,", "tokens": [50372, 309, 311, 577, 291, 360, 1121, 3121, 279, 13, 316, 1121, 3121, 11, 341, 551, 300, 558, 2306, 366, 1128, 1401, 11, 457, 588, 4005, 11, 50712], "temperature": 0.0, "avg_logprob": -0.23288349190143623, "compression_ratio": 1.6363636363636365, "no_speech_prob": 0.14475449919700623}, {"id": 37, "seek": 25620, "start": 263.96, "end": 272.2, "text": " is theoretically equivalent to a state machine. Again, this is jumping too fast. Something a", "tokens": [50752, 307, 29400, 10344, 281, 257, 1785, 3479, 13, 3764, 11, 341, 307, 11233, 886, 2370, 13, 6595, 257, 51164], "temperature": 0.0, "avg_logprob": -0.23288349190143623, "compression_ratio": 1.6363636363636365, "no_speech_prob": 0.14475449919700623}, {"id": 38, "seek": 25620, "start": 272.2, "end": 276.76, "text": " little bit more powerful is the partial automata, I'm not going to focus on this one too much,", "tokens": [51164, 707, 857, 544, 4005, 307, 264, 14641, 3553, 3274, 11, 286, 478, 406, 516, 281, 1879, 322, 341, 472, 886, 709, 11, 51392], "temperature": 0.0, "avg_logprob": -0.23288349190143623, "compression_ratio": 1.6363636363636365, "no_speech_prob": 0.14475449919700623}, {"id": 39, "seek": 25620, "start": 276.76, "end": 281.64, "text": " use a key difference, then nothing else parsed, now it has one more thing, it's the same thing", "tokens": [51392, 764, 257, 2141, 2649, 11, 550, 1825, 1646, 21156, 292, 11, 586, 309, 575, 472, 544, 551, 11, 309, 311, 264, 912, 551, 51636], "temperature": 0.0, "avg_logprob": -0.23288349190143623, "compression_ratio": 1.6363636363636365, "no_speech_prob": 0.14475449919700623}, {"id": 40, "seek": 28164, "start": 281.71999999999997, "end": 286.91999999999996, "text": " before, plus a stack, and the stack behaves as you would expect. The function that used to take", "tokens": [50368, 949, 11, 1804, 257, 8630, 11, 293, 264, 8630, 36896, 382, 291, 576, 2066, 13, 440, 2445, 300, 1143, 281, 747, 50628], "temperature": 0.0, "avg_logprob": -0.14559487982110664, "compression_ratio": 1.7652582159624413, "no_speech_prob": 0.28774118423461914}, {"id": 41, "seek": 28164, "start": 286.91999999999996, "end": 294.12, "text": " the state and the input symbol also takes the stack and the output of the function is whether", "tokens": [50628, 264, 1785, 293, 264, 4846, 5986, 611, 2516, 264, 8630, 293, 264, 5598, 295, 264, 2445, 307, 1968, 50988], "temperature": 0.0, "avg_logprob": -0.14559487982110664, "compression_ratio": 1.7652582159624413, "no_speech_prob": 0.28774118423461914}, {"id": 42, "seek": 28164, "start": 294.12, "end": 299.88, "text": " you pop something from the stack or you push something on the stack. It's safe to consume a", "tokens": [50988, 291, 1665, 746, 490, 264, 8630, 420, 291, 2944, 746, 322, 264, 8630, 13, 467, 311, 3273, 281, 14732, 257, 51276], "temperature": 0.0, "avg_logprob": -0.14559487982110664, "compression_ratio": 1.7652582159624413, "no_speech_prob": 0.28774118423461914}, {"id": 43, "seek": 28164, "start": 299.88, "end": 305.88, "text": " string that you give to this PDA as it arrives to one of the final states with an empty stack.", "tokens": [51276, 6798, 300, 291, 976, 281, 341, 430, 7509, 382, 309, 20116, 281, 472, 295, 264, 2572, 4368, 365, 364, 6707, 8630, 13, 51576], "temperature": 0.0, "avg_logprob": -0.14559487982110664, "compression_ratio": 1.7652582159624413, "no_speech_prob": 0.28774118423461914}, {"id": 44, "seek": 30588, "start": 305.88, "end": 311.8, "text": " There are equivalent definitions, not all definitions require the empty stack, but I choose", "tokens": [50364, 821, 366, 10344, 21988, 11, 406, 439, 21988, 3651, 264, 6707, 8630, 11, 457, 286, 2826, 50660], "temperature": 0.0, "avg_logprob": -0.16729357902039874, "compression_ratio": 1.7232142857142858, "no_speech_prob": 0.031021691858768463}, {"id": 45, "seek": 30588, "start": 311.8, "end": 319.64, "text": " that one. They are equivalent to context-free grammars, parsers, but not compilers. Why a compiler?", "tokens": [50660, 300, 472, 13, 814, 366, 10344, 281, 4319, 12, 10792, 17570, 685, 11, 21156, 433, 11, 457, 406, 715, 388, 433, 13, 1545, 257, 31958, 30, 51052], "temperature": 0.0, "avg_logprob": -0.16729357902039874, "compression_ratio": 1.7232142857142858, "no_speech_prob": 0.031021691858768463}, {"id": 46, "seek": 30588, "start": 320.44, "end": 326.04, "text": " So in tree, the thing about being context-free is that it doesn't remember symbols that were", "tokens": [51092, 407, 294, 4230, 11, 264, 551, 466, 885, 4319, 12, 10792, 307, 300, 309, 1177, 380, 1604, 16944, 300, 645, 51372], "temperature": 0.0, "avg_logprob": -0.16729357902039874, "compression_ratio": 1.7232142857142858, "no_speech_prob": 0.031021691858768463}, {"id": 47, "seek": 30588, "start": 326.04, "end": 334.44, "text": " defined before. So for a compiler, for example, the usual regex compiler for C that needs to remember", "tokens": [51372, 7642, 949, 13, 407, 337, 257, 31958, 11, 337, 1365, 11, 264, 7713, 1121, 3121, 31958, 337, 383, 300, 2203, 281, 1604, 51792], "temperature": 0.0, "avg_logprob": -0.16729357902039874, "compression_ratio": 1.7232142857142858, "no_speech_prob": 0.031021691858768463}, {"id": 48, "seek": 33444, "start": 334.92, "end": 342.68, "text": " the definition when you say int e and then you use e later below, parser doesn't remember that,", "tokens": [50388, 264, 7123, 562, 291, 584, 560, 308, 293, 550, 291, 764, 308, 1780, 2507, 11, 21156, 260, 1177, 380, 1604, 300, 11, 50776], "temperature": 0.0, "avg_logprob": -0.15752050500167045, "compression_ratio": 1.6637931034482758, "no_speech_prob": 0.005734747275710106}, {"id": 49, "seek": 33444, "start": 342.68, "end": 351.88, "text": " you need symbol tables, parser only builds the syntax tree. And the fancy one, the computer,", "tokens": [50776, 291, 643, 5986, 8020, 11, 21156, 260, 787, 15182, 264, 28431, 4230, 13, 400, 264, 10247, 472, 11, 264, 3820, 11, 51236], "temperature": 0.0, "avg_logprob": -0.15752050500167045, "compression_ratio": 1.6637931034482758, "no_speech_prob": 0.005734747275710106}, {"id": 50, "seek": 33444, "start": 351.88, "end": 356.68, "text": " theoretically, Turing machines, which is again the same thing, but nothing else is supplanted by a", "tokens": [51236, 29400, 11, 314, 1345, 8379, 11, 597, 307, 797, 264, 912, 551, 11, 457, 1825, 1646, 307, 9386, 15587, 538, 257, 51476], "temperature": 0.0, "avg_logprob": -0.15752050500167045, "compression_ratio": 1.6637931034482758, "no_speech_prob": 0.005734747275710106}, {"id": 51, "seek": 33444, "start": 356.68, "end": 363.24, "text": " tape that is infinite. It is equivalent whether it's finite in one side and infinite in the other,", "tokens": [51476, 7314, 300, 307, 13785, 13, 467, 307, 10344, 1968, 309, 311, 19362, 294, 472, 1252, 293, 13785, 294, 264, 661, 11, 51804], "temperature": 0.0, "avg_logprob": -0.15752050500167045, "compression_ratio": 1.6637931034482758, "no_speech_prob": 0.005734747275710106}, {"id": 52, "seek": 36324, "start": 363.24, "end": 367.48, "text": " all of those are equivalents, whether it has two tapes is also equivalent, will arrive to that.", "tokens": [50364, 439, 295, 729, 366, 9052, 791, 11, 1968, 309, 575, 732, 31349, 307, 611, 10344, 11, 486, 8881, 281, 300, 13, 50576], "temperature": 0.0, "avg_logprob": -0.11867629963418712, "compression_ratio": 1.716279069767442, "no_speech_prob": 0.004708177410066128}, {"id": 53, "seek": 36324, "start": 367.48, "end": 373.32, "text": " The function takes the tape and the action go one to the left and write something, go one to the", "tokens": [50576, 440, 2445, 2516, 264, 7314, 293, 264, 3069, 352, 472, 281, 264, 1411, 293, 2464, 746, 11, 352, 472, 281, 264, 50868], "temperature": 0.0, "avg_logprob": -0.11867629963418712, "compression_ratio": 1.716279069767442, "no_speech_prob": 0.004708177410066128}, {"id": 54, "seek": 36324, "start": 373.32, "end": 378.28000000000003, "text": " right and write something. Very similar, a Turing machine is said to consume a string", "tokens": [50868, 558, 293, 2464, 746, 13, 4372, 2531, 11, 257, 314, 1345, 3479, 307, 848, 281, 14732, 257, 6798, 51116], "temperature": 0.0, "avg_logprob": -0.11867629963418712, "compression_ratio": 1.716279069767442, "no_speech_prob": 0.004708177410066128}, {"id": 55, "seek": 36324, "start": 379.56, "end": 386.84000000000003, "text": " when the next step is undefined. When it holds, you have all heard of the holding problem.", "tokens": [51180, 562, 264, 958, 1823, 307, 674, 5666, 2001, 13, 1133, 309, 9190, 11, 291, 362, 439, 2198, 295, 264, 5061, 1154, 13, 51544], "temperature": 0.0, "avg_logprob": -0.11867629963418712, "compression_ratio": 1.716279069767442, "no_speech_prob": 0.004708177410066128}, {"id": 56, "seek": 38684, "start": 386.91999999999996, "end": 393.23999999999995, "text": " There is no way to know whether a Turing machine will hold. That is important. They are equivalent", "tokens": [50368, 821, 307, 572, 636, 281, 458, 1968, 257, 314, 1345, 3479, 486, 1797, 13, 663, 307, 1021, 13, 814, 366, 10344, 50684], "temperature": 0.0, "avg_logprob": -0.182869424211218, "compression_ratio": 1.6085106382978724, "no_speech_prob": 0.021512817591428757}, {"id": 57, "seek": 38684, "start": 393.23999999999995, "end": 397.4, "text": " to interested grammars, compilers in the Chomsky hierarchy that are like four levels.", "tokens": [50684, 281, 3102, 17570, 685, 11, 715, 388, 433, 294, 264, 761, 4785, 4133, 22333, 300, 366, 411, 1451, 4358, 13, 50892], "temperature": 0.0, "avg_logprob": -0.182869424211218, "compression_ratio": 1.6085106382978724, "no_speech_prob": 0.021512817591428757}, {"id": 58, "seek": 38684, "start": 397.4, "end": 401.4, "text": " The three things that I describe are zero, one and four, there is something in the level three", "tokens": [50892, 440, 1045, 721, 300, 286, 6786, 366, 4018, 11, 472, 293, 1451, 11, 456, 307, 746, 294, 264, 1496, 1045, 51092], "temperature": 0.0, "avg_logprob": -0.182869424211218, "compression_ratio": 1.6085106382978724, "no_speech_prob": 0.021512817591428757}, {"id": 59, "seek": 38684, "start": 401.4, "end": 410.03999999999996, "text": " that is not directly useful for the moment. So I skip that. So how do they compare? This goes very", "tokens": [51092, 300, 307, 406, 3838, 4420, 337, 264, 1623, 13, 407, 286, 10023, 300, 13, 407, 577, 360, 436, 6794, 30, 639, 1709, 588, 51524], "temperature": 0.0, "avg_logprob": -0.182869424211218, "compression_ratio": 1.6085106382978724, "no_speech_prob": 0.021512817591428757}, {"id": 60, "seek": 41004, "start": 410.04, "end": 416.68, "text": " fast sometimes. So that's the power that they have. A Turing machine can do all the others.", "tokens": [50364, 2370, 2171, 13, 407, 300, 311, 264, 1347, 300, 436, 362, 13, 316, 314, 1345, 3479, 393, 360, 439, 264, 2357, 13, 50696], "temperature": 0.0, "avg_logprob": -0.1325608648435034, "compression_ratio": 1.8855721393034826, "no_speech_prob": 0.0210317000746727}, {"id": 61, "seek": 41004, "start": 417.48, "end": 423.64000000000004, "text": " PDA can do the one over there. So that's the power that they can do. They contain the power of each", "tokens": [50736, 430, 7509, 393, 360, 264, 472, 670, 456, 13, 407, 300, 311, 264, 1347, 300, 436, 393, 360, 13, 814, 5304, 264, 1347, 295, 1184, 51044], "temperature": 0.0, "avg_logprob": -0.1325608648435034, "compression_ratio": 1.8855721393034826, "no_speech_prob": 0.0210317000746727}, {"id": 62, "seek": 41004, "start": 423.64000000000004, "end": 431.96000000000004, "text": " other. Two FSMs running together has still the same theoretical power, the same thing that a PDA", "tokens": [51044, 661, 13, 4453, 41138, 26386, 2614, 1214, 575, 920, 264, 912, 20864, 1347, 11, 264, 912, 551, 300, 257, 430, 7509, 51460], "temperature": 0.0, "avg_logprob": -0.1325608648435034, "compression_ratio": 1.8855721393034826, "no_speech_prob": 0.0210317000746727}, {"id": 63, "seek": 41004, "start": 431.96000000000004, "end": 439.24, "text": " with a finite buffer or a PDA with a finite state machine is still as powerful as one PDA.", "tokens": [51460, 365, 257, 19362, 21762, 420, 257, 430, 7509, 365, 257, 19362, 1785, 3479, 307, 920, 382, 4005, 382, 472, 430, 7509, 13, 51824], "temperature": 0.0, "avg_logprob": -0.1325608648435034, "compression_ratio": 1.8855721393034826, "no_speech_prob": 0.0210317000746727}, {"id": 64, "seek": 44004, "start": 440.04, "end": 445.0, "text": " Turing machines, whether it's multi-tape, tape one banded on one side, they are all equivalent", "tokens": [50364, 314, 1345, 8379, 11, 1968, 309, 311, 4825, 12, 1328, 494, 11, 7314, 472, 4116, 292, 322, 472, 1252, 11, 436, 366, 439, 10344, 50612], "temperature": 0.0, "avg_logprob": -0.11971078600202288, "compression_ratio": 1.6008403361344539, "no_speech_prob": 0.017774121835827827}, {"id": 65, "seek": 44004, "start": 445.0, "end": 452.12, "text": " again. A Turing machine doesn't get more powerful by giving it 100 tapes. It gets maybe more", "tokens": [50612, 797, 13, 316, 314, 1345, 3479, 1177, 380, 483, 544, 4005, 538, 2902, 309, 2319, 31349, 13, 467, 2170, 1310, 544, 50968], "temperature": 0.0, "avg_logprob": -0.11971078600202288, "compression_ratio": 1.6008403361344539, "no_speech_prob": 0.017774121835827827}, {"id": 66, "seek": 44004, "start": 452.12, "end": 461.72, "text": " performant theoretically, but the problems that it can solve are all the same. And a PDA with two", "tokens": [50968, 2042, 394, 29400, 11, 457, 264, 2740, 300, 309, 393, 5039, 366, 439, 264, 912, 13, 400, 257, 430, 7509, 365, 732, 51448], "temperature": 0.0, "avg_logprob": -0.11971078600202288, "compression_ratio": 1.6008403361344539, "no_speech_prob": 0.017774121835827827}, {"id": 67, "seek": 44004, "start": 461.72, "end": 465.72, "text": " stacks is really a Turing machine when you know you can just go in both directions. So when you", "tokens": [51448, 30792, 307, 534, 257, 314, 1345, 3479, 562, 291, 458, 291, 393, 445, 352, 294, 1293, 11095, 13, 407, 562, 291, 51648], "temperature": 0.0, "avg_logprob": -0.11971078600202288, "compression_ratio": 1.6008403361344539, "no_speech_prob": 0.017774121835827827}, {"id": 68, "seek": 46572, "start": 465.72, "end": 472.92, "text": " give the PDA two stacks, you build a Turing machine. So conceptually, finite state machines can keep", "tokens": [50364, 976, 264, 430, 7509, 732, 30792, 11, 291, 1322, 257, 314, 1345, 3479, 13, 407, 3410, 671, 11, 19362, 1785, 8379, 393, 1066, 50724], "temperature": 0.0, "avg_logprob": -0.07626244997737383, "compression_ratio": 1.763157894736842, "no_speech_prob": 0.009992615319788456}, {"id": 69, "seek": 46572, "start": 472.92, "end": 479.96000000000004, "text": " track of one thing, the state. The push-down automata can keep track of two things, the state and the", "tokens": [50724, 2837, 295, 472, 551, 11, 264, 1785, 13, 440, 2944, 12, 5093, 3553, 3274, 393, 1066, 2837, 295, 732, 721, 11, 264, 1785, 293, 264, 51076], "temperature": 0.0, "avg_logprob": -0.07626244997737383, "compression_ratio": 1.763157894736842, "no_speech_prob": 0.009992615319788456}, {"id": 70, "seek": 46572, "start": 479.96000000000004, "end": 486.28000000000003, "text": " top of the stack. And a Turing machine can keep track of infinite things. When I was going through", "tokens": [51076, 1192, 295, 264, 8630, 13, 400, 257, 314, 1345, 3479, 393, 1066, 2837, 295, 13785, 721, 13, 1133, 286, 390, 516, 807, 51392], "temperature": 0.0, "avg_logprob": -0.07626244997737383, "compression_ratio": 1.763157894736842, "no_speech_prob": 0.009992615319788456}, {"id": 71, "seek": 46572, "start": 486.28000000000003, "end": 491.96000000000004, "text": " the mathematics and I came to this conclusion, I found this funny for a completely unrelated reason.", "tokens": [51392, 264, 18666, 293, 286, 1361, 281, 341, 10063, 11, 286, 1352, 341, 4074, 337, 257, 2584, 38967, 1778, 13, 51676], "temperature": 0.0, "avg_logprob": -0.07626244997737383, "compression_ratio": 1.763157894736842, "no_speech_prob": 0.009992615319788456}, {"id": 72, "seek": 49196, "start": 492.52, "end": 496.35999999999996, "text": " In the European languages, I mean to human languages,", "tokens": [50392, 682, 264, 6473, 8650, 11, 286, 914, 281, 1952, 8650, 11, 50584], "temperature": 0.0, "avg_logprob": -0.2289771768781874, "compression_ratio": 1.6983240223463687, "no_speech_prob": 0.05108816549181938}, {"id": 73, "seek": 49196, "start": 496.35999999999996, "end": 501.56, "text": " used to have the concept of dual as something different to singular and plural.", "tokens": [50584, 1143, 281, 362, 264, 3410, 295, 11848, 382, 746, 819, 281, 20010, 293, 25377, 13, 50844], "temperature": 0.0, "avg_logprob": -0.2289771768781874, "compression_ratio": 1.6983240223463687, "no_speech_prob": 0.05108816549181938}, {"id": 74, "seek": 49196, "start": 508.12, "end": 512.92, "text": " The function that it computes depends on one thing to things or an infinite number of them.", "tokens": [51172, 440, 2445, 300, 309, 715, 1819, 5946, 322, 472, 551, 281, 721, 420, 364, 13785, 1230, 295, 552, 13, 51412], "temperature": 0.0, "avg_logprob": -0.2289771768781874, "compression_ratio": 1.6983240223463687, "no_speech_prob": 0.05108816549181938}, {"id": 75, "seek": 49196, "start": 515.3199999999999, "end": 520.28, "text": " The function that was defined before. So in the European languages, as I said,", "tokens": [51532, 440, 2445, 300, 390, 7642, 949, 13, 407, 294, 264, 6473, 8650, 11, 382, 286, 848, 11, 51780], "temperature": 0.0, "avg_logprob": -0.2289771768781874, "compression_ratio": 1.6983240223463687, "no_speech_prob": 0.05108816549181938}, {"id": 76, "seek": 52028, "start": 520.36, "end": 527.3199999999999, "text": " they had this special concept of the dual. And I found it very funny how informal human languages", "tokens": [50368, 436, 632, 341, 2121, 3410, 295, 264, 11848, 13, 400, 286, 1352, 309, 588, 4074, 577, 24342, 1952, 8650, 50716], "temperature": 0.0, "avg_logprob": -0.10901560408345769, "compression_ratio": 1.632034632034632, "no_speech_prob": 0.07326573133468628}, {"id": 77, "seek": 52028, "start": 527.3199999999999, "end": 532.6, "text": " used to have such a thing as a dual, as a different grammatical category than one and infinite.", "tokens": [50716, 1143, 281, 362, 1270, 257, 551, 382, 257, 11848, 11, 382, 257, 819, 17570, 267, 804, 7719, 813, 472, 293, 13785, 13, 50980], "temperature": 0.0, "avg_logprob": -0.10901560408345769, "compression_ratio": 1.632034632034632, "no_speech_prob": 0.07326573133468628}, {"id": 78, "seek": 52028, "start": 533.4, "end": 538.04, "text": " When you build the declinations, they had a different thing. Why do I know this strange thing", "tokens": [51020, 1133, 291, 1322, 264, 7488, 10325, 11, 436, 632, 257, 819, 551, 13, 1545, 360, 286, 458, 341, 5861, 551, 51252], "temperature": 0.0, "avg_logprob": -0.10901560408345769, "compression_ratio": 1.632034632034632, "no_speech_prob": 0.07326573133468628}, {"id": 79, "seek": 52028, "start": 538.04, "end": 547.24, "text": " about languages? Because I live in Poland. So Slavic languages have some remnants of that", "tokens": [51252, 466, 8650, 30, 1436, 286, 1621, 294, 15950, 13, 407, 6187, 41053, 8650, 362, 512, 44652, 295, 300, 51712], "temperature": 0.0, "avg_logprob": -0.10901560408345769, "compression_ratio": 1.632034632034632, "no_speech_prob": 0.07326573133468628}, {"id": 80, "seek": 54724, "start": 547.32, "end": 551.72, "text": " dual concept. So there is this famous joke of in Polish you have like 100 ways to", "tokens": [50368, 11848, 3410, 13, 407, 456, 307, 341, 4618, 7647, 295, 294, 18504, 291, 362, 411, 2319, 2098, 281, 50588], "temperature": 0.0, "avg_logprob": -0.18041745476100757, "compression_ratio": 1.583710407239819, "no_speech_prob": 0.055258169770240784}, {"id": 81, "seek": 54724, "start": 552.36, "end": 556.36, "text": " declinate number two. And you have more ways to declinate number two than you have number three", "tokens": [50620, 7488, 13923, 1230, 732, 13, 400, 291, 362, 544, 2098, 281, 7488, 13923, 1230, 732, 813, 291, 362, 1230, 1045, 50820], "temperature": 0.0, "avg_logprob": -0.18041745476100757, "compression_ratio": 1.583710407239819, "no_speech_prob": 0.055258169770240784}, {"id": 82, "seek": 54724, "start": 556.36, "end": 562.84, "text": " because of that all dual. So two is special. I live in Poland, but I'm not Polish. It's challenging.", "tokens": [50820, 570, 295, 300, 439, 11848, 13, 407, 732, 307, 2121, 13, 286, 1621, 294, 15950, 11, 457, 286, 478, 406, 18504, 13, 467, 311, 7595, 13, 51144], "temperature": 0.0, "avg_logprob": -0.18041745476100757, "compression_ratio": 1.583710407239819, "no_speech_prob": 0.055258169770240784}, {"id": 83, "seek": 54724, "start": 564.12, "end": 571.88, "text": " So do FSMs produce output? Let's go move slowly to what is useful here.", "tokens": [51208, 407, 360, 41138, 26386, 5258, 5598, 30, 961, 311, 352, 1286, 5692, 281, 437, 307, 4420, 510, 13, 51596], "temperature": 0.0, "avg_logprob": -0.18041745476100757, "compression_ratio": 1.583710407239819, "no_speech_prob": 0.055258169770240784}, {"id": 84, "seek": 57188, "start": 572.04, "end": 580.04, "text": " We can define finite state transducers, which same thing than before and then nothing else is", "tokens": [50372, 492, 393, 6964, 19362, 1785, 1145, 8117, 433, 11, 597, 912, 551, 813, 949, 293, 550, 1825, 1646, 307, 50772], "temperature": 0.0, "avg_logprob": -0.1779407501220703, "compression_ratio": 1.6608695652173913, "no_speech_prob": 0.019790994003415108}, {"id": 85, "seek": 57188, "start": 580.04, "end": 587.64, "text": " supplanted by another output alphabet. The function takes the state and the input and decides the", "tokens": [50772, 9386, 15587, 538, 1071, 5598, 23339, 13, 440, 2445, 2516, 264, 1785, 293, 264, 4846, 293, 14898, 264, 51152], "temperature": 0.0, "avg_logprob": -0.1779407501220703, "compression_ratio": 1.6608695652173913, "no_speech_prob": 0.019790994003415108}, {"id": 86, "seek": 57188, "start": 587.64, "end": 594.6, "text": " next state and a symbol for the output. It's a to consume a string the same and they are also", "tokens": [51152, 958, 1785, 293, 257, 5986, 337, 264, 5598, 13, 467, 311, 257, 281, 14732, 257, 6798, 264, 912, 293, 436, 366, 611, 51500], "temperature": 0.0, "avg_logprob": -0.1779407501220703, "compression_ratio": 1.6608695652173913, "no_speech_prob": 0.019790994003415108}, {"id": 87, "seek": 57188, "start": 594.6, "end": 600.04, "text": " equivalent to regular grammars. When it comes to the problems they can solve, again, they're all", "tokens": [51500, 10344, 281, 3890, 17570, 685, 13, 1133, 309, 1487, 281, 264, 2740, 436, 393, 5039, 11, 797, 11, 436, 434, 439, 51772], "temperature": 0.0, "avg_logprob": -0.1779407501220703, "compression_ratio": 1.6608695652173913, "no_speech_prob": 0.019790994003415108}, {"id": 88, "seek": 60004, "start": 600.04, "end": 605.16, "text": " equivalent. You get fancier tools, but there are properties that are going to be all the same.", "tokens": [50364, 10344, 13, 509, 483, 3429, 27674, 3873, 11, 457, 456, 366, 7221, 300, 366, 516, 281, 312, 439, 264, 912, 13, 50620], "temperature": 0.0, "avg_logprob": -0.14729652208151275, "compression_ratio": 1.7092511013215859, "no_speech_prob": 0.01947835274040699}, {"id": 89, "seek": 60004, "start": 606.1999999999999, "end": 611.9599999999999, "text": " You will see in a second there are many, but let's focus on two ways of defining transducers,", "tokens": [50672, 509, 486, 536, 294, 257, 1150, 456, 366, 867, 11, 457, 718, 311, 1879, 322, 732, 2098, 295, 17827, 1145, 8117, 433, 11, 50960], "temperature": 0.0, "avg_logprob": -0.14729652208151275, "compression_ratio": 1.7092511013215859, "no_speech_prob": 0.01947835274040699}, {"id": 90, "seek": 60004, "start": 611.9599999999999, "end": 618.92, "text": " the milley machines and Moore machines, whether the output, I have a laser, yes, whether the output", "tokens": [50960, 264, 1728, 2030, 8379, 293, 21644, 8379, 11, 1968, 264, 5598, 11, 286, 362, 257, 12530, 11, 2086, 11, 1968, 264, 5598, 51308], "temperature": 0.0, "avg_logprob": -0.14729652208151275, "compression_ratio": 1.7092511013215859, "no_speech_prob": 0.01947835274040699}, {"id": 91, "seek": 60004, "start": 618.92, "end": 626.8399999999999, "text": " symbol depends on the input and the previous state or only on the previous state. There is a way to", "tokens": [51308, 5986, 5946, 322, 264, 4846, 293, 264, 3894, 1785, 420, 787, 322, 264, 3894, 1785, 13, 821, 307, 257, 636, 281, 51704], "temperature": 0.0, "avg_logprob": -0.14729652208151275, "compression_ratio": 1.7092511013215859, "no_speech_prob": 0.01947835274040699}, {"id": 92, "seek": 62684, "start": 626.84, "end": 632.9200000000001, "text": " define Moore machines from a milley machine, but not the other way around, so milley has a", "tokens": [50364, 6964, 21644, 8379, 490, 257, 1728, 2030, 3479, 11, 457, 406, 264, 661, 636, 926, 11, 370, 1728, 2030, 575, 257, 50668], "temperature": 0.0, "avg_logprob": -0.1495253065942039, "compression_ratio": 1.5795454545454546, "no_speech_prob": 0.012197200208902359}, {"id": 93, "seek": 62684, "start": 632.9200000000001, "end": 640.12, "text": " bit more powerful. Now something a bit more useful, how do they compare? They are still", "tokens": [50668, 857, 544, 4005, 13, 823, 746, 257, 857, 544, 4420, 11, 577, 360, 436, 6794, 30, 814, 366, 920, 51028], "temperature": 0.0, "avg_logprob": -0.1495253065942039, "compression_ratio": 1.5795454545454546, "no_speech_prob": 0.012197200208902359}, {"id": 94, "seek": 62684, "start": 640.6800000000001, "end": 646.44, "text": " the same than the FSM machines, but this can be composed. We are getting into a bit of engineering.", "tokens": [51056, 264, 912, 813, 264, 41138, 44, 8379, 11, 457, 341, 393, 312, 18204, 13, 492, 366, 1242, 666, 257, 857, 295, 7043, 13, 51344], "temperature": 0.0, "avg_logprob": -0.1495253065942039, "compression_ratio": 1.5795454545454546, "no_speech_prob": 0.012197200208902359}, {"id": 95, "seek": 64644, "start": 646.5200000000001, "end": 654.6800000000001, "text": " We are almost there. Not that much. This is a thing, laser. Yes, oh god. Come on,", "tokens": [50368, 492, 366, 1920, 456, 13, 1726, 300, 709, 13, 639, 307, 257, 551, 11, 12530, 13, 1079, 11, 1954, 3044, 13, 2492, 322, 11, 50776], "temperature": 0.0, "avg_logprob": -0.1597956885462222, "compression_ratio": 1.6886792452830188, "no_speech_prob": 0.019363319501280785}, {"id": 96, "seek": 64644, "start": 656.36, "end": 663.5600000000001, "text": " sometimes. So given three sets of states, three alphabets, one machine goes from one state and", "tokens": [50860, 2171, 13, 407, 2212, 1045, 6352, 295, 4368, 11, 1045, 419, 950, 455, 1385, 11, 472, 3479, 1709, 490, 472, 1785, 293, 51220], "temperature": 0.0, "avg_logprob": -0.1597956885462222, "compression_ratio": 1.6886792452830188, "no_speech_prob": 0.019363319501280785}, {"id": 97, "seek": 64644, "start": 663.5600000000001, "end": 667.6400000000001, "text": " one alphabet to the next state and the other alphabet. The second machine uses the same", "tokens": [51220, 472, 23339, 281, 264, 958, 1785, 293, 264, 661, 23339, 13, 440, 1150, 3479, 4960, 264, 912, 51424], "temperature": 0.0, "avg_logprob": -0.1597956885462222, "compression_ratio": 1.6886792452830188, "no_speech_prob": 0.019363319501280785}, {"id": 98, "seek": 64644, "start": 667.6400000000001, "end": 673.5600000000001, "text": " the output of the previous as its input, so you can define the composition as a state machine", "tokens": [51424, 264, 5598, 295, 264, 3894, 382, 1080, 4846, 11, 370, 291, 393, 6964, 264, 12686, 382, 257, 1785, 3479, 51720], "temperature": 0.0, "avg_logprob": -0.1597956885462222, "compression_ratio": 1.6886792452830188, "no_speech_prob": 0.019363319501280785}, {"id": 99, "seek": 67356, "start": 673.56, "end": 679.7199999999999, "text": " that takes the first alphabet and the first set of inputs and gives you the third alphabet and set", "tokens": [50364, 300, 2516, 264, 700, 23339, 293, 264, 700, 992, 295, 15743, 293, 2709, 291, 264, 2636, 23339, 293, 992, 50672], "temperature": 0.0, "avg_logprob": -0.07712038787635597, "compression_ratio": 1.6723163841807909, "no_speech_prob": 0.027246152982115746}, {"id": 100, "seek": 67356, "start": 679.7199999999999, "end": 688.4399999999999, "text": " of inputs. Composition, cool. Why? Because you can implement all these things as state machines and", "tokens": [50672, 295, 15743, 13, 6620, 5830, 11, 1627, 13, 1545, 30, 1436, 291, 393, 4445, 439, 613, 721, 382, 1785, 8379, 293, 51108], "temperature": 0.0, "avg_logprob": -0.07712038787635597, "compression_ratio": 1.6723163841807909, "no_speech_prob": 0.027246152982115746}, {"id": 101, "seek": 67356, "start": 688.4399999999999, "end": 697.88, "text": " the output of one is the input of the next. So my stack on XMPP, you can implement TCP as a state", "tokens": [51108, 264, 5598, 295, 472, 307, 264, 4846, 295, 264, 958, 13, 407, 452, 8630, 322, 1783, 12224, 47, 11, 291, 393, 4445, 48965, 382, 257, 1785, 51580], "temperature": 0.0, "avg_logprob": -0.07712038787635597, "compression_ratio": 1.6723163841807909, "no_speech_prob": 0.027246152982115746}, {"id": 102, "seek": 69788, "start": 697.88, "end": 705.64, "text": " machine. Have you heard of the Erlang socket, the new socket? It's implemented in TCP on top of", "tokens": [50364, 3479, 13, 3560, 291, 2198, 295, 264, 3300, 25241, 19741, 11, 264, 777, 19741, 30, 467, 311, 12270, 294, 48965, 322, 1192, 295, 50752], "temperature": 0.0, "avg_logprob": -0.16604170507314253, "compression_ratio": 1.7571428571428571, "no_speech_prob": 0.0691237598657608}, {"id": 103, "seek": 69788, "start": 705.64, "end": 712.84, "text": " gain state them. If you go to the source code. So I have the output of one state them, throwing", "tokens": [50752, 6052, 1785, 552, 13, 759, 291, 352, 281, 264, 4009, 3089, 13, 407, 286, 362, 264, 5598, 295, 472, 1785, 552, 11, 10238, 51112], "temperature": 0.0, "avg_logprob": -0.16604170507314253, "compression_ratio": 1.7571428571428571, "no_speech_prob": 0.0691237598657608}, {"id": 104, "seek": 69788, "start": 712.84, "end": 717.16, "text": " into the output of the next state them. TLS is also implemented as a gain state them,", "tokens": [51112, 666, 264, 5598, 295, 264, 958, 1785, 552, 13, 314, 19198, 307, 611, 12270, 382, 257, 6052, 1785, 552, 11, 51328], "temperature": 0.0, "avg_logprob": -0.16604170507314253, "compression_ratio": 1.7571428571428571, "no_speech_prob": 0.0691237598657608}, {"id": 105, "seek": 69788, "start": 717.16, "end": 725.56, "text": " throwing output to my thing, to the XML parser that throws its output to the XMPP protocol.", "tokens": [51328, 10238, 5598, 281, 452, 551, 11, 281, 264, 43484, 21156, 260, 300, 19251, 1080, 5598, 281, 264, 1783, 12224, 47, 10336, 13, 51748], "temperature": 0.0, "avg_logprob": -0.16604170507314253, "compression_ratio": 1.7571428571428571, "no_speech_prob": 0.0691237598657608}, {"id": 106, "seek": 72556, "start": 726.28, "end": 733.3199999999999, "text": " So we are composing things. One last theoretical thing. The unions of FSMs that is", "tokens": [50400, 407, 321, 366, 715, 6110, 721, 13, 1485, 1036, 20864, 551, 13, 440, 24914, 295, 41138, 26386, 300, 307, 50752], "temperature": 0.0, "avg_logprob": -0.17195757470949732, "compression_ratio": 1.7427184466019416, "no_speech_prob": 0.009600721299648285}, {"id": 107, "seek": 72556, "start": 734.52, "end": 740.76, "text": " uniting all the states and strings, it's also an FSM intersection, so the states and its input", "tokens": [50812, 517, 1748, 439, 264, 4368, 293, 13985, 11, 309, 311, 611, 364, 41138, 44, 15236, 11, 370, 264, 4368, 293, 1080, 4846, 51124], "temperature": 0.0, "avg_logprob": -0.17195757470949732, "compression_ratio": 1.7427184466019416, "no_speech_prob": 0.009600721299648285}, {"id": 108, "seek": 72556, "start": 740.76, "end": 747.0, "text": " symbols in common gives you a very small FSM. It's also an FSM reversing, still an FSM,", "tokens": [51124, 16944, 294, 2689, 2709, 291, 257, 588, 1359, 41138, 44, 13, 467, 311, 611, 364, 41138, 44, 14582, 278, 11, 920, 364, 41138, 44, 11, 51436], "temperature": 0.0, "avg_logprob": -0.17195757470949732, "compression_ratio": 1.7427184466019416, "no_speech_prob": 0.009600721299648285}, {"id": 109, "seek": 72556, "start": 749.0799999999999, "end": 755.2399999999999, "text": " empty, so no states and no input is also an FSM that when you do union and concatenation with", "tokens": [51540, 6707, 11, 370, 572, 4368, 293, 572, 4846, 307, 611, 364, 41138, 44, 300, 562, 291, 360, 11671, 293, 1588, 7186, 399, 365, 51848], "temperature": 0.0, "avg_logprob": -0.17195757470949732, "compression_ratio": 1.7427184466019416, "no_speech_prob": 0.009600721299648285}, {"id": 110, "seek": 75524, "start": 755.24, "end": 761.8, "text": " another FSM does nothing and homomorphism, so a function that transforms alphabets and", "tokens": [50364, 1071, 41138, 44, 775, 1825, 293, 3655, 32702, 1434, 11, 370, 257, 2445, 300, 35592, 419, 950, 455, 1385, 293, 50692], "temperature": 0.0, "avg_logprob": -0.12082227071126302, "compression_ratio": 1.6359447004608294, "no_speech_prob": 0.004958620294928551}, {"id": 111, "seek": 75524, "start": 762.52, "end": 770.36, "text": " states into other alphabets and states preserves the structure of an FSM. So FSMs are a semi-ring.", "tokens": [50728, 4368, 666, 661, 419, 950, 455, 1385, 293, 4368, 1183, 9054, 264, 3877, 295, 364, 41138, 44, 13, 407, 41138, 26386, 366, 257, 12909, 12, 2937, 13, 51120], "temperature": 0.0, "avg_logprob": -0.12082227071126302, "compression_ratio": 1.6359447004608294, "no_speech_prob": 0.004958620294928551}, {"id": 112, "seek": 75524, "start": 770.92, "end": 778.12, "text": " This is an algebraic structure. Why is it useful to have search algebras? To prove things", "tokens": [51148, 639, 307, 364, 21989, 299, 3877, 13, 1545, 307, 309, 4420, 281, 362, 3164, 419, 432, 38182, 30, 1407, 7081, 721, 51508], "temperature": 0.0, "avg_logprob": -0.12082227071126302, "compression_ratio": 1.6359447004608294, "no_speech_prob": 0.004958620294928551}, {"id": 113, "seek": 75524, "start": 778.76, "end": 783.48, "text": " that you cannot prove with Turing machines because they do not form an algebra.", "tokens": [51540, 300, 291, 2644, 7081, 365, 314, 1345, 8379, 570, 436, 360, 406, 1254, 364, 21989, 13, 51776], "temperature": 0.0, "avg_logprob": -0.12082227071126302, "compression_ratio": 1.6359447004608294, "no_speech_prob": 0.004958620294928551}, {"id": 114, "seek": 78524, "start": 786.04, "end": 794.92, "text": " So now let's do something engineering, state them. So as I said before, it's a Melly machine.", "tokens": [50404, 407, 586, 718, 311, 360, 746, 7043, 11, 1785, 552, 13, 407, 382, 286, 848, 949, 11, 309, 311, 257, 376, 7442, 3479, 13, 50848], "temperature": 0.0, "avg_logprob": -0.2329117014438291, "compression_ratio": 1.6271186440677967, "no_speech_prob": 0.0028408558573573828}, {"id": 115, "seek": 78524, "start": 794.92, "end": 803.4, "text": " It gets the input and the alphabets, it produces the states and alphabets, it produces the next,", "tokens": [50848, 467, 2170, 264, 4846, 293, 264, 419, 950, 455, 1385, 11, 309, 14725, 264, 4368, 293, 419, 950, 455, 1385, 11, 309, 14725, 264, 958, 11, 51272], "temperature": 0.0, "avg_logprob": -0.2329117014438291, "compression_ratio": 1.6271186440677967, "no_speech_prob": 0.0028408558573573828}, {"id": 116, "seek": 78524, "start": 803.4, "end": 809.24, "text": " you follow, I hope. We can consider that the input are the messages in the mailbox and the output", "tokens": [51272, 291, 1524, 11, 286, 1454, 13, 492, 393, 1949, 300, 264, 4846, 366, 264, 7897, 294, 264, 43602, 293, 264, 5598, 51564], "temperature": 0.0, "avg_logprob": -0.2329117014438291, "compression_ratio": 1.6271186440677967, "no_speech_prob": 0.0028408558573573828}, {"id": 117, "seek": 80924, "start": 810.04, "end": 814.04, "text": " symbols are side effects, like for example sending messages to another mailbox.", "tokens": [50404, 16944, 366, 1252, 5065, 11, 411, 337, 1365, 7750, 7897, 281, 1071, 43602, 13, 50604], "temperature": 0.0, "avg_logprob": -0.14556508594089085, "compression_ratio": 1.491891891891892, "no_speech_prob": 0.019443631172180176}, {"id": 118, "seek": 80924, "start": 816.36, "end": 826.84, "text": " Gain state them. I'm a big fan. I love it, but I know that people sometimes don't use it because", "tokens": [50720, 460, 491, 1785, 552, 13, 286, 478, 257, 955, 3429, 13, 286, 959, 309, 11, 457, 286, 458, 300, 561, 2171, 500, 380, 764, 309, 570, 51244], "temperature": 0.0, "avg_logprob": -0.14556508594089085, "compression_ratio": 1.491891891891892, "no_speech_prob": 0.019443631172180176}, {"id": 119, "seek": 80924, "start": 826.84, "end": 833.32, "text": " maybe it's confusing or I don't know, complicated. So I'm going to try to explain one thing that is", "tokens": [51244, 1310, 309, 311, 13181, 420, 286, 500, 380, 458, 11, 6179, 13, 407, 286, 478, 516, 281, 853, 281, 2903, 472, 551, 300, 307, 51568], "temperature": 0.0, "avg_logprob": -0.14556508594089085, "compression_ratio": 1.491891891891892, "no_speech_prob": 0.019443631172180176}, {"id": 120, "seek": 83332, "start": 833.88, "end": 841.8000000000001, "text": " very useful here. An extended mailbox. This is a discussion that the OTP team, when they put the", "tokens": [50392, 588, 4420, 510, 13, 1107, 10913, 43602, 13, 639, 307, 257, 5017, 300, 264, 422, 16804, 1469, 11, 562, 436, 829, 264, 50788], "temperature": 0.0, "avg_logprob": -0.12531260822130286, "compression_ratio": 1.6724137931034482, "no_speech_prob": 0.14690372347831726}, {"id": 121, "seek": 83332, "start": 841.8000000000001, "end": 847.88, "text": " pull request for gain state them, there is a big discussion with over a thousand messages that was", "tokens": [50788, 2235, 5308, 337, 6052, 1785, 552, 11, 456, 307, 257, 955, 5017, 365, 670, 257, 4714, 7897, 300, 390, 51092], "temperature": 0.0, "avg_logprob": -0.12531260822130286, "compression_ratio": 1.6724137931034482, "no_speech_prob": 0.14690372347831726}, {"id": 122, "seek": 83332, "start": 847.88, "end": 851.96, "text": " probably forgotten, but when they discovered gain state them and I liked it, I went to the source", "tokens": [51092, 1391, 11832, 11, 457, 562, 436, 6941, 6052, 1785, 552, 293, 286, 4501, 309, 11, 286, 1437, 281, 264, 4009, 51296], "temperature": 0.0, "avg_logprob": -0.12531260822130286, "compression_ratio": 1.6724137931034482, "no_speech_prob": 0.14690372347831726}, {"id": 123, "seek": 83332, "start": 851.96, "end": 859.0, "text": " and I read that super long thing. And there are useful things said there. A way to visualize a", "tokens": [51296, 293, 286, 1401, 300, 1687, 938, 551, 13, 400, 456, 366, 4420, 721, 848, 456, 13, 316, 636, 281, 23273, 257, 51648], "temperature": 0.0, "avg_logprob": -0.12531260822130286, "compression_ratio": 1.6724137931034482, "no_speech_prob": 0.14690372347831726}, {"id": 124, "seek": 85900, "start": 859.08, "end": 866.36, "text": " gain state them. Imagine that it has one queue, that is something more than the process mailbox,", "tokens": [50368, 6052, 1785, 552, 13, 11739, 300, 309, 575, 472, 18639, 11, 300, 307, 746, 544, 813, 264, 1399, 43602, 11, 50732], "temperature": 0.0, "avg_logprob": -0.11069936018723708, "compression_ratio": 1.8240740740740742, "no_speech_prob": 0.05939238518476486}, {"id": 125, "seek": 85900, "start": 866.36, "end": 872.92, "text": " with like three pointers. The head pointing at the oldest event and the tail pointing at the youngest", "tokens": [50732, 365, 411, 1045, 44548, 13, 440, 1378, 12166, 412, 264, 14026, 2280, 293, 264, 6838, 12166, 412, 264, 17747, 51060], "temperature": 0.0, "avg_logprob": -0.11069936018723708, "compression_ratio": 1.8240740740740742, "no_speech_prob": 0.05939238518476486}, {"id": 126, "seek": 85900, "start": 872.92, "end": 882.36, "text": " and current is where I am now. You can move where current is with some of the actions that gain", "tokens": [51060, 293, 2190, 307, 689, 286, 669, 586, 13, 509, 393, 1286, 689, 2190, 307, 365, 512, 295, 264, 5909, 300, 6052, 51532], "temperature": 0.0, "avg_logprob": -0.11069936018723708, "compression_ratio": 1.8240740740740742, "no_speech_prob": 0.05939238518476486}, {"id": 127, "seek": 85900, "start": 882.36, "end": 888.44, "text": " state them gives you, for example postponing an event. Postponing an event means that current moves", "tokens": [51532, 1785, 552, 2709, 291, 11, 337, 1365, 28973, 16638, 364, 2280, 13, 10223, 79, 16638, 364, 2280, 1355, 300, 2190, 6067, 51836], "temperature": 0.0, "avg_logprob": -0.11069936018723708, "compression_ratio": 1.8240740740740742, "no_speech_prob": 0.05939238518476486}, {"id": 128, "seek": 88844, "start": 888.44, "end": 892.36, "text": " to the next, but the event is not forgotten. There is a different action that will put current", "tokens": [50364, 281, 264, 958, 11, 457, 264, 2280, 307, 406, 11832, 13, 821, 307, 257, 819, 3069, 300, 486, 829, 2190, 50560], "temperature": 0.0, "avg_logprob": -0.1209257549709744, "compression_ratio": 1.7397260273972603, "no_speech_prob": 0.01489781029522419}, {"id": 129, "seek": 88844, "start": 892.36, "end": 898.44, "text": " again in the head. Not postponing and you consume it is removed from the queue. When the state changes,", "tokens": [50560, 797, 294, 264, 1378, 13, 1726, 28973, 16638, 293, 291, 14732, 309, 307, 7261, 490, 264, 18639, 13, 1133, 264, 1785, 2962, 11, 50864], "temperature": 0.0, "avg_logprob": -0.1209257549709744, "compression_ratio": 1.7397260273972603, "no_speech_prob": 0.01489781029522419}, {"id": 130, "seek": 88844, "start": 898.44, "end": 903.5600000000001, "text": " current goes again to head. Next event inserts things where current is and not at the tail.", "tokens": [50864, 2190, 1709, 797, 281, 1378, 13, 3087, 2280, 49163, 721, 689, 2190, 307, 293, 406, 412, 264, 6838, 13, 51120], "temperature": 0.0, "avg_logprob": -0.1209257549709744, "compression_ratio": 1.7397260273972603, "no_speech_prob": 0.01489781029522419}, {"id": 131, "seek": 88844, "start": 904.36, "end": 912.44, "text": " And timeouts inserts things at the tail. So the engine, the gain state them implementation", "tokens": [51160, 400, 565, 7711, 49163, 721, 412, 264, 6838, 13, 407, 264, 2848, 11, 264, 6052, 1785, 552, 11420, 51564], "temperature": 0.0, "avg_logprob": -0.1209257549709744, "compression_ratio": 1.7397260273972603, "no_speech_prob": 0.01489781029522419}, {"id": 132, "seek": 91244, "start": 912.44, "end": 919.32, "text": " allows you to extend the inputs that your formal state machine is going to get. How does it work?", "tokens": [50364, 4045, 291, 281, 10101, 264, 15743, 300, 428, 9860, 1785, 3479, 307, 516, 281, 483, 13, 1012, 775, 309, 589, 30, 50708], "temperature": 0.0, "avg_logprob": -0.12143061558405559, "compression_ratio": 1.6050420168067228, "no_speech_prob": 0.048508260399103165}, {"id": 133, "seek": 91244, "start": 919.32, "end": 924.44, "text": " Imagine that we are here, we have event one and we decide to postpone it. What happens?", "tokens": [50708, 11739, 300, 321, 366, 510, 11, 321, 362, 2280, 472, 293, 321, 4536, 281, 28973, 546, 309, 13, 708, 2314, 30, 50964], "temperature": 0.0, "avg_logprob": -0.12143061558405559, "compression_ratio": 1.6050420168067228, "no_speech_prob": 0.048508260399103165}, {"id": 134, "seek": 91244, "start": 924.44, "end": 931.8800000000001, "text": " It's still on the mailbox. We just are now going to deal with event two. Now we decide to do some", "tokens": [50964, 467, 311, 920, 322, 264, 43602, 13, 492, 445, 366, 586, 516, 281, 2028, 365, 2280, 732, 13, 823, 321, 4536, 281, 360, 512, 51336], "temperature": 0.0, "avg_logprob": -0.12143061558405559, "compression_ratio": 1.6050420168067228, "no_speech_prob": 0.048508260399103165}, {"id": 135, "seek": 91244, "start": 931.8800000000001, "end": 937.1600000000001, "text": " stuff and then go to the next state. So that has been processed and current because we changed the", "tokens": [51336, 1507, 293, 550, 352, 281, 264, 958, 1785, 13, 407, 300, 575, 668, 18846, 293, 2190, 570, 321, 3105, 264, 51600], "temperature": 0.0, "avg_logprob": -0.12143061558405559, "compression_ratio": 1.6050420168067228, "no_speech_prob": 0.048508260399103165}, {"id": 136, "seek": 93716, "start": 937.16, "end": 945.88, "text": " state goes back to the previous. Now we are again going to handle event one and this time we decide", "tokens": [50364, 1785, 1709, 646, 281, 264, 3894, 13, 823, 321, 366, 797, 516, 281, 4813, 2280, 472, 293, 341, 565, 321, 4536, 50800], "temperature": 0.0, "avg_logprob": -0.11503311157226563, "compression_ratio": 1.7433628318584071, "no_speech_prob": 0.05714745447039604}, {"id": 137, "seek": 93716, "start": 945.88, "end": 954.6, "text": " to not change the state, but we generate new inputs as if this process has received a message.", "tokens": [50800, 281, 406, 1319, 264, 1785, 11, 457, 321, 8460, 777, 15743, 382, 498, 341, 1399, 575, 4613, 257, 3636, 13, 51236], "temperature": 0.0, "avg_logprob": -0.11503311157226563, "compression_ratio": 1.7433628318584071, "no_speech_prob": 0.05714745447039604}, {"id": 138, "seek": 93716, "start": 954.6, "end": 961.3199999999999, "text": " But this event A, which is ad hoc, we just created it, is inserted where current is. So it's the next", "tokens": [51236, 583, 341, 2280, 316, 11, 597, 307, 614, 16708, 11, 321, 445, 2942, 309, 11, 307, 27992, 689, 2190, 307, 13, 407, 309, 311, 264, 958, 51572], "temperature": 0.0, "avg_logprob": -0.11503311157226563, "compression_ratio": 1.7433628318584071, "no_speech_prob": 0.05714745447039604}, {"id": 139, "seek": 93716, "start": 961.3199999999999, "end": 966.52, "text": " event that we are going to handle. We can decide to postpone it. Now we are going to handle event", "tokens": [51572, 2280, 300, 321, 366, 516, 281, 4813, 13, 492, 393, 4536, 281, 28973, 546, 309, 13, 823, 321, 366, 516, 281, 4813, 2280, 51832], "temperature": 0.0, "avg_logprob": -0.11503311157226563, "compression_ratio": 1.7433628318584071, "no_speech_prob": 0.05714745447039604}, {"id": 140, "seek": 96652, "start": 967.48, "end": 971.8, "text": " three. With event three we do some stuff, but we don't generate events. Imagine that there is", "tokens": [50412, 1045, 13, 2022, 2280, 1045, 321, 360, 512, 1507, 11, 457, 321, 500, 380, 8460, 3931, 13, 11739, 300, 456, 307, 50628], "temperature": 0.0, "avg_logprob": -0.16606045695184504, "compression_ratio": 1.7822222222222222, "no_speech_prob": 0.014450423419475555}, {"id": 141, "seek": 96652, "start": 971.8, "end": 977.4, "text": " middle code here doing. So event three has been dealt with. Now you go to event four and you decide", "tokens": [50628, 2808, 3089, 510, 884, 13, 407, 2280, 1045, 575, 668, 15991, 365, 13, 823, 291, 352, 281, 2280, 1451, 293, 291, 4536, 50908], "temperature": 0.0, "avg_logprob": -0.16606045695184504, "compression_ratio": 1.7822222222222222, "no_speech_prob": 0.014450423419475555}, {"id": 142, "seek": 96652, "start": 977.4, "end": 984.6, "text": " to postpone event four, but also insert and event B. So event four goes behind, you insert and event", "tokens": [50908, 281, 28973, 546, 2280, 1451, 11, 457, 611, 8969, 293, 2280, 363, 13, 407, 2280, 1451, 1709, 2261, 11, 291, 8969, 293, 2280, 51268], "temperature": 0.0, "avg_logprob": -0.16606045695184504, "compression_ratio": 1.7822222222222222, "no_speech_prob": 0.014450423419475555}, {"id": 143, "seek": 96652, "start": 984.6, "end": 991.16, "text": " B, you get the idea. So the engine gives you a way to extend the process queue. What am I doing with time?", "tokens": [51268, 363, 11, 291, 483, 264, 1558, 13, 407, 264, 2848, 2709, 291, 257, 636, 281, 10101, 264, 1399, 18639, 13, 708, 669, 286, 884, 365, 565, 30, 51596], "temperature": 0.0, "avg_logprob": -0.16606045695184504, "compression_ratio": 1.7822222222222222, "no_speech_prob": 0.014450423419475555}, {"id": 144, "seek": 99116, "start": 991.9599999999999, "end": 1000.6, "text": " Oh, one more important power. I'm not going to have time for everything. One more useful power of", "tokens": [50404, 876, 11, 472, 544, 1021, 1347, 13, 286, 478, 406, 516, 281, 362, 565, 337, 1203, 13, 1485, 544, 4420, 1347, 295, 50836], "temperature": 0.0, "avg_logprob": -0.1949004939958161, "compression_ratio": 1.5115384615384615, "no_speech_prob": 0.022048933431506157}, {"id": 145, "seek": 99116, "start": 1000.6, "end": 1005.8, "text": " the state machines. Managing accidental complexity. There is a talk that I want to recommend. It's", "tokens": [50836, 264, 1785, 8379, 13, 2458, 3568, 38094, 14024, 13, 821, 307, 257, 751, 300, 286, 528, 281, 2748, 13, 467, 311, 51096], "temperature": 0.0, "avg_logprob": -0.1949004939958161, "compression_ratio": 1.5115384615384615, "no_speech_prob": 0.022048933431506157}, {"id": 146, "seek": 99116, "start": 1005.8, "end": 1010.92, "text": " quite an old one, maybe something like 10 or 15 years ago by Ulf Rieger, where he was complaining", "tokens": [51096, 1596, 364, 1331, 472, 11, 1310, 746, 411, 1266, 420, 2119, 924, 2057, 538, 24853, 69, 497, 414, 1321, 11, 689, 415, 390, 20740, 51352], "temperature": 0.0, "avg_logprob": -0.1949004939958161, "compression_ratio": 1.5115384615384615, "no_speech_prob": 0.022048933431506157}, {"id": 147, "seek": 99116, "start": 1010.92, "end": 1018.28, "text": " about some limitations of GANFSM, but even GAN server that we all use. Very useful talk and I have", "tokens": [51352, 466, 512, 15705, 295, 460, 1770, 37, 26693, 11, 457, 754, 460, 1770, 7154, 300, 321, 439, 764, 13, 4372, 4420, 751, 293, 286, 362, 51720], "temperature": 0.0, "avg_logprob": -0.1949004939958161, "compression_ratio": 1.5115384615384615, "no_speech_prob": 0.022048933431506157}, {"id": 148, "seek": 101828, "start": 1018.28, "end": 1025.16, "text": " one tiny answer to that with the new GAN state that didn't exist back then. Typical state on, off,", "tokens": [50364, 472, 5870, 1867, 281, 300, 365, 264, 777, 460, 1770, 1785, 300, 994, 380, 2514, 646, 550, 13, 17722, 804, 1785, 322, 11, 766, 11, 50708], "temperature": 0.0, "avg_logprob": -0.18812630726740912, "compression_ratio": 1.663716814159292, "no_speech_prob": 0.008001367561519146}, {"id": 149, "seek": 101828, "start": 1025.16, "end": 1031.8, "text": " but you can imagine that you're switching a light, but your switch talks to a", "tokens": [50708, 457, 291, 393, 3811, 300, 291, 434, 16493, 257, 1442, 11, 457, 428, 3679, 6686, 281, 257, 51040], "temperature": 0.0, "avg_logprob": -0.18812630726740912, "compression_ratio": 1.663716814159292, "no_speech_prob": 0.008001367561519146}, {"id": 150, "seek": 101828, "start": 1033.72, "end": 1040.04, "text": " through a cable protocol to the light machine. So when the user says on, this is a GAN server,", "tokens": [51136, 807, 257, 8220, 10336, 281, 264, 1442, 3479, 13, 407, 562, 264, 4195, 1619, 322, 11, 341, 307, 257, 460, 1770, 7154, 11, 51452], "temperature": 0.0, "avg_logprob": -0.18812630726740912, "compression_ratio": 1.663716814159292, "no_speech_prob": 0.008001367561519146}, {"id": 151, "seek": 101828, "start": 1040.04, "end": 1045.56, "text": " you say and the state is off, you send a request to on, you wait for the answer on, it's on, vice versa,", "tokens": [51452, 291, 584, 293, 264, 1785, 307, 766, 11, 291, 2845, 257, 5308, 281, 322, 11, 291, 1699, 337, 264, 1867, 322, 11, 309, 311, 322, 11, 11964, 25650, 11, 51728], "temperature": 0.0, "avg_logprob": -0.18812630726740912, "compression_ratio": 1.663716814159292, "no_speech_prob": 0.008001367561519146}, {"id": 152, "seek": 104556, "start": 1046.2, "end": 1052.76, "text": " relatively intuitive code. Now imagine that that request through the cable protocol was not", "tokens": [50396, 7226, 21769, 3089, 13, 823, 3811, 300, 300, 5308, 807, 264, 8220, 10336, 390, 406, 50724], "temperature": 0.0, "avg_logprob": -0.16781421189897516, "compression_ratio": 1.668103448275862, "no_speech_prob": 0.008520365692675114}, {"id": 153, "seek": 104556, "start": 1052.76, "end": 1058.52, "text": " synchronous and imagine that the switches cannot block. It needs to do other stuff. So you send", "tokens": [50724, 44743, 293, 3811, 300, 264, 19458, 2644, 3461, 13, 467, 2203, 281, 360, 661, 1507, 13, 407, 291, 2845, 51012], "temperature": 0.0, "avg_logprob": -0.16781421189897516, "compression_ratio": 1.668103448275862, "no_speech_prob": 0.008520365692675114}, {"id": 154, "seek": 104556, "start": 1058.52, "end": 1063.96, "text": " an asynchronous request to the light, hey, turn on yourself and continue doing other things, but then", "tokens": [51012, 364, 49174, 5308, 281, 264, 1442, 11, 4177, 11, 1261, 322, 1803, 293, 2354, 884, 661, 721, 11, 457, 550, 51284], "temperature": 0.0, "avg_logprob": -0.16781421189897516, "compression_ratio": 1.668103448275862, "no_speech_prob": 0.008520365692675114}, {"id": 155, "seek": 104556, "start": 1063.96, "end": 1071.3999999999999, "text": " the user sends more off and on. What do you decide to do here? It's not part of the protocol. The", "tokens": [51284, 264, 4195, 14790, 544, 766, 293, 322, 13, 708, 360, 291, 4536, 281, 360, 510, 30, 467, 311, 406, 644, 295, 264, 10336, 13, 440, 51656], "temperature": 0.0, "avg_logprob": -0.16781421189897516, "compression_ratio": 1.668103448275862, "no_speech_prob": 0.008520365692675114}, {"id": 156, "seek": 107140, "start": 1071.4, "end": 1078.6000000000001, "text": " events are now asynchronous and out of order. There is no global ordering. So there are some", "tokens": [50364, 3931, 366, 586, 49174, 293, 484, 295, 1668, 13, 821, 307, 572, 4338, 21739, 13, 407, 456, 366, 512, 50724], "temperature": 0.0, "avg_logprob": -0.16215750511656415, "compression_ratio": 1.7268518518518519, "no_speech_prob": 0.011485141701996326}, {"id": 157, "seek": 107140, "start": 1078.6000000000001, "end": 1090.52, "text": " questions like you need to choose what to do. Sometimes this, this is the, so we can use a", "tokens": [50724, 1651, 411, 291, 643, 281, 2826, 437, 281, 360, 13, 4803, 341, 11, 341, 307, 264, 11, 370, 321, 393, 764, 257, 51320], "temperature": 0.0, "avg_logprob": -0.16215750511656415, "compression_ratio": 1.7268518518518519, "no_speech_prob": 0.011485141701996326}, {"id": 158, "seek": 107140, "start": 1090.52, "end": 1095.72, "text": " state machine. They use all the way. The name of the function is the name of the state and you can", "tokens": [51320, 1785, 3479, 13, 814, 764, 439, 264, 636, 13, 440, 1315, 295, 264, 2445, 307, 264, 1315, 295, 264, 1785, 293, 291, 393, 51580], "temperature": 0.0, "avg_logprob": -0.16215750511656415, "compression_ratio": 1.7268518518518519, "no_speech_prob": 0.011485141701996326}, {"id": 159, "seek": 107140, "start": 1095.72, "end": 1099.8000000000002, "text": " postpone things if you are already running a request, you postpone it and when if the user", "tokens": [51580, 28973, 546, 721, 498, 291, 366, 1217, 2614, 257, 5308, 11, 291, 28973, 546, 309, 293, 562, 498, 264, 4195, 51784], "temperature": 0.0, "avg_logprob": -0.16215750511656415, "compression_ratio": 1.7268518518518519, "no_speech_prob": 0.011485141701996326}, {"id": 160, "seek": 109980, "start": 1099.8799999999999, "end": 1104.44, "text": " press on like a hundred times, by the time they like says on, then you have changed the state and", "tokens": [50368, 1886, 322, 411, 257, 3262, 1413, 11, 538, 264, 565, 436, 411, 1619, 322, 11, 550, 291, 362, 3105, 264, 1785, 293, 50596], "temperature": 0.0, "avg_logprob": -0.14772354472767224, "compression_ratio": 1.6845878136200716, "no_speech_prob": 0.007891620509326458}, {"id": 161, "seek": 109980, "start": 1104.44, "end": 1110.36, "text": " you're going to handle all those. It's already on, so just do nothing. But the code is terribly", "tokens": [50596, 291, 434, 516, 281, 4813, 439, 729, 13, 467, 311, 1217, 322, 11, 370, 445, 360, 1825, 13, 583, 264, 3089, 307, 22903, 50892], "temperature": 0.0, "avg_logprob": -0.14772354472767224, "compression_ratio": 1.6845878136200716, "no_speech_prob": 0.007891620509326458}, {"id": 162, "seek": 109980, "start": 1110.36, "end": 1115.56, "text": " symmetric. It feels repetitive. So problems, there is no ordering when things are asynchronous.", "tokens": [50892, 32330, 13, 467, 3417, 29404, 13, 407, 2740, 11, 456, 307, 572, 21739, 562, 721, 366, 49174, 13, 51152], "temperature": 0.0, "avg_logprob": -0.14772354472767224, "compression_ratio": 1.6845878136200716, "no_speech_prob": 0.007891620509326458}, {"id": 163, "seek": 109980, "start": 1117.08, "end": 1121.56, "text": " Tying yourself to the ordering of events leads to accidental complexity. This is the", "tokens": [51228, 314, 1840, 1803, 281, 264, 21739, 295, 3931, 6689, 281, 38094, 14024, 13, 639, 307, 264, 51452], "temperature": 0.0, "avg_logprob": -0.14772354472767224, "compression_ratio": 1.6845878136200716, "no_speech_prob": 0.007891620509326458}, {"id": 164, "seek": 109980, "start": 1121.56, "end": 1127.0, "text": " point of Ulfiger when the order changes, the whole implementation changes. It grows relative to", "tokens": [51452, 935, 295, 24853, 69, 4810, 562, 264, 1668, 2962, 11, 264, 1379, 11420, 2962, 13, 467, 13156, 4972, 281, 51724], "temperature": 0.0, "avg_logprob": -0.14772354472767224, "compression_ratio": 1.6845878136200716, "no_speech_prob": 0.007891620509326458}, {"id": 165, "seek": 112700, "start": 1127.0, "end": 1130.36, "text": " the number of states. This is super simple. It's a like that goes on and off. But imagine", "tokens": [50364, 264, 1230, 295, 4368, 13, 639, 307, 1687, 2199, 13, 467, 311, 257, 411, 300, 1709, 322, 293, 766, 13, 583, 3811, 50532], "temperature": 0.0, "avg_logprob": -0.1484544697929831, "compression_ratio": 1.516304347826087, "no_speech_prob": 0.005687081255018711}, {"id": 166, "seek": 112700, "start": 1130.92, "end": 1136.28, "text": " complicated protocols and for example a middle layer between a very talkative protocol and a", "tokens": [50560, 6179, 20618, 293, 337, 1365, 257, 2808, 4583, 1296, 257, 588, 751, 1166, 10336, 293, 257, 50828], "temperature": 0.0, "avg_logprob": -0.1484544697929831, "compression_ratio": 1.516304347826087, "no_speech_prob": 0.005687081255018711}, {"id": 167, "seek": 112700, "start": 1136.28, "end": 1147.48, "text": " like one and code reuse. So I really like the handle event way of handling things. It's a single", "tokens": [50828, 411, 472, 293, 3089, 26225, 13, 407, 286, 534, 411, 264, 4813, 2280, 636, 295, 13175, 721, 13, 467, 311, 257, 2167, 51388], "temperature": 0.0, "avg_logprob": -0.1484544697929831, "compression_ratio": 1.516304347826087, "no_speech_prob": 0.005687081255018711}, {"id": 168, "seek": 114748, "start": 1147.48, "end": 1157.8, "text": " function callback that gets a simple the state and the data. By the way, it's very confusing", "tokens": [50364, 2445, 818, 3207, 300, 2170, 257, 2199, 264, 1785, 293, 264, 1412, 13, 3146, 264, 636, 11, 309, 311, 588, 13181, 50880], "temperature": 0.0, "avg_logprob": -0.22370809438277264, "compression_ratio": 1.757847533632287, "no_speech_prob": 0.19511115550994873}, {"id": 169, "seek": 114748, "start": 1157.8, "end": 1164.1200000000001, "text": " because we are used to the state of the process for the server thing. But in the state, the state is", "tokens": [50880, 570, 321, 366, 1143, 281, 264, 1785, 295, 264, 1399, 337, 264, 7154, 551, 13, 583, 294, 264, 1785, 11, 264, 1785, 307, 51196], "temperature": 0.0, "avg_logprob": -0.22370809438277264, "compression_ratio": 1.757847533632287, "no_speech_prob": 0.19511115550994873}, {"id": 170, "seek": 114748, "start": 1164.1200000000001, "end": 1169.08, "text": " the state machine state. So the other thing where you save like, I don't know, the socket, for example,", "tokens": [51196, 264, 1785, 3479, 1785, 13, 407, 264, 661, 551, 689, 291, 3155, 411, 11, 286, 500, 380, 458, 11, 264, 19741, 11, 337, 1365, 11, 51444], "temperature": 0.0, "avg_logprob": -0.22370809438277264, "compression_ratio": 1.757847533632287, "no_speech_prob": 0.19511115550994873}, {"id": 171, "seek": 114748, "start": 1169.08, "end": 1176.2, "text": " is called data. So just confusing terminology. This, you can just pattern match whether you're", "tokens": [51444, 307, 1219, 1412, 13, 407, 445, 13181, 27575, 13, 639, 11, 291, 393, 445, 5102, 2995, 1968, 291, 434, 51800], "temperature": 0.0, "avg_logprob": -0.22370809438277264, "compression_ratio": 1.757847533632287, "no_speech_prob": 0.19511115550994873}, {"id": 172, "seek": 117620, "start": 1176.2, "end": 1182.28, "text": " in the same state and the previous function that was terribly repetitive is now in a single", "tokens": [50364, 294, 264, 912, 1785, 293, 264, 3894, 2445, 300, 390, 22903, 29404, 307, 586, 294, 257, 2167, 50668], "temperature": 0.0, "avg_logprob": -0.0899864359104887, "compression_ratio": 1.7058823529411764, "no_speech_prob": 0.007032782770693302}, {"id": 173, "seek": 117620, "start": 1182.92, "end": 1190.1200000000001, "text": " function head. This is, I believe, a way to answer to the problem that Ulf raised and now I'm", "tokens": [50700, 2445, 1378, 13, 639, 307, 11, 286, 1697, 11, 257, 636, 281, 1867, 281, 264, 1154, 300, 24853, 69, 6005, 293, 586, 286, 478, 51060], "temperature": 0.0, "avg_logprob": -0.0899864359104887, "compression_ratio": 1.7058823529411764, "no_speech_prob": 0.007032782770693302}, {"id": 174, "seek": 117620, "start": 1190.1200000000001, "end": 1199.0, "text": " exactly on time. One more slide. A way to answer to that problem and in a way that you can reuse", "tokens": [51060, 2293, 322, 565, 13, 1485, 544, 4137, 13, 316, 636, 281, 1867, 281, 300, 1154, 293, 294, 257, 636, 300, 291, 393, 26225, 51504], "temperature": 0.0, "avg_logprob": -0.0899864359104887, "compression_ratio": 1.7058823529411764, "no_speech_prob": 0.007032782770693302}, {"id": 175, "seek": 117620, "start": 1199.0, "end": 1204.68, "text": " code, that you can decide the order of events because you can postpone things and you can also", "tokens": [51504, 3089, 11, 300, 291, 393, 4536, 264, 1668, 295, 3931, 570, 291, 393, 28973, 546, 721, 293, 291, 393, 611, 51788], "temperature": 0.0, "avg_logprob": -0.0899864359104887, "compression_ratio": 1.7058823529411764, "no_speech_prob": 0.007032782770693302}, {"id": 176, "seek": 120468, "start": 1204.68, "end": 1213.64, "text": " insert things. Quickly here, why I use on the XMPP, we had like this implementation. There is only", "tokens": [50364, 8969, 721, 13, 31800, 510, 11, 983, 286, 764, 322, 264, 1783, 12224, 47, 11, 321, 632, 411, 341, 11420, 13, 821, 307, 787, 50812], "temperature": 0.0, "avg_logprob": -0.12388576325916109, "compression_ratio": 1.638655462184874, "no_speech_prob": 0.010551976040005684}, {"id": 177, "seek": 120468, "start": 1213.64, "end": 1219.16, "text": " one thing that I really like here. The composing. As I said before, you have the TCP state machines", "tokens": [50812, 472, 551, 300, 286, 534, 411, 510, 13, 440, 715, 6110, 13, 1018, 286, 848, 949, 11, 291, 362, 264, 48965, 1785, 8379, 51088], "temperature": 0.0, "avg_logprob": -0.12388576325916109, "compression_ratio": 1.638655462184874, "no_speech_prob": 0.010551976040005684}, {"id": 178, "seek": 120468, "start": 1219.16, "end": 1224.68, "text": " that go to TLS that goes to XML that goes to messaging. So if we want to implement this on a", "tokens": [51088, 300, 352, 281, 314, 19198, 300, 1709, 281, 43484, 300, 1709, 281, 21812, 13, 407, 498, 321, 528, 281, 4445, 341, 322, 257, 51364], "temperature": 0.0, "avg_logprob": -0.12388576325916109, "compression_ratio": 1.638655462184874, "no_speech_prob": 0.010551976040005684}, {"id": 179, "seek": 120468, "start": 1224.68, "end": 1231.5600000000002, "text": " single process, this can be, for example, this is a simplification on my data. I have a parser and", "tokens": [51364, 2167, 1399, 11, 341, 393, 312, 11, 337, 1365, 11, 341, 307, 257, 6883, 3774, 322, 452, 1412, 13, 286, 362, 257, 21156, 260, 293, 51708], "temperature": 0.0, "avg_logprob": -0.12388576325916109, "compression_ratio": 1.638655462184874, "no_speech_prob": 0.010551976040005684}, {"id": 180, "seek": 123156, "start": 1231.56, "end": 1237.0, "text": " the crypto library that when I get that TCP payload, this is how we do it in Mongoose. I am not", "tokens": [50364, 264, 17240, 6405, 300, 562, 286, 483, 300, 48965, 30918, 11, 341, 307, 577, 321, 360, 309, 294, 48380, 541, 13, 286, 669, 406, 50636], "temperature": 0.0, "avg_logprob": -0.14826380411783854, "compression_ratio": 1.6, "no_speech_prob": 0.022675583139061928}, {"id": 181, "seek": 123156, "start": 1237.0, "end": 1244.6, "text": " TCP, TCP we just use TCP to complicate it. So it's a separate process. But crypto and XML parsers,", "tokens": [50636, 48965, 11, 48965, 321, 445, 764, 48965, 281, 1209, 8700, 309, 13, 407, 309, 311, 257, 4994, 1399, 13, 583, 17240, 293, 43484, 21156, 433, 11, 51016], "temperature": 0.0, "avg_logprob": -0.14826380411783854, "compression_ratio": 1.6, "no_speech_prob": 0.022675583139061928}, {"id": 182, "seek": 123156, "start": 1244.6, "end": 1252.6, "text": " we implemented on the spot. There is a C code that the parsers, part of the XML, for example,", "tokens": [51016, 321, 12270, 322, 264, 4008, 13, 821, 307, 257, 383, 3089, 300, 264, 21156, 433, 11, 644, 295, 264, 43484, 11, 337, 1365, 11, 51416], "temperature": 0.0, "avg_logprob": -0.14826380411783854, "compression_ratio": 1.6, "no_speech_prob": 0.022675583139061928}, {"id": 183, "seek": 123156, "start": 1252.6, "end": 1259.3999999999999, "text": " it gives you a new parser with a buffer and the XML structure that then you can use to generate", "tokens": [51416, 309, 2709, 291, 257, 777, 21156, 260, 365, 257, 21762, 293, 264, 43484, 3877, 300, 550, 291, 393, 764, 281, 8460, 51756], "temperature": 0.0, "avg_logprob": -0.14826380411783854, "compression_ratio": 1.6, "no_speech_prob": 0.022675583139061928}, {"id": 184, "seek": 125940, "start": 1259.4, "end": 1267.88, "text": " the events that my protocol cares about, the XML payloads. That's one use case that we have.", "tokens": [50364, 264, 3931, 300, 452, 10336, 12310, 466, 11, 264, 43484, 30918, 82, 13, 663, 311, 472, 764, 1389, 300, 321, 362, 13, 50788], "temperature": 0.0, "avg_logprob": -0.17036174403296578, "compression_ratio": 1.4806629834254144, "no_speech_prob": 0.018687434494495392}, {"id": 185, "seek": 125940, "start": 1269.24, "end": 1275.3200000000002, "text": " That's me. You can find me by that picture in all the places. Those are some of the projects I", "tokens": [50856, 663, 311, 385, 13, 509, 393, 915, 385, 538, 300, 3036, 294, 439, 264, 3190, 13, 3950, 366, 512, 295, 264, 4455, 286, 51160], "temperature": 0.0, "avg_logprob": -0.17036174403296578, "compression_ratio": 1.4806629834254144, "no_speech_prob": 0.018687434494495392}, {"id": 186, "seek": 125940, "start": 1275.3200000000002, "end": 1283.0, "text": " work in and I was going to say questions, but we are one minute late. Thank you.", "tokens": [51160, 589, 294, 293, 286, 390, 516, 281, 584, 1651, 11, 457, 321, 366, 472, 3456, 3469, 13, 1044, 291, 13, 51544], "temperature": 0.0, "avg_logprob": -0.17036174403296578, "compression_ratio": 1.4806629834254144, "no_speech_prob": 0.018687434494495392}], "language": "en"}