{"text": " Alright, so time has flown. This is already the last talk for the emulator development room today. Thanks everybody for showing up. It's a crazy turnout. Today we've got Peter who's going to talk about a really interesting feature from Microsoft Windows. Is there a question already at the start? Let's get what's happening here. Oh, okay. Alright, so Peter has a lot of C++ experience and he can talk more about what he's going to do. So let's give him a hand. Okay, so first of all, why am I here at FOSDEM talking about some closed source Microsoft attack? That's what you're all thinking, right? So let's address that question first. So if you don't know me, one of my hobbies is hacking on LuaJet, which is a free and open source JIT compiler for Lua. And LuaJet recently gained support for Windows on ARM 64. Or at least I thought it did until this guy came along and was like, so do you support this other Windows on ARM 64? And we're like, wait, wait, what? You did what? So first I was horrified, then I was intrigued, and now I'm here speaking to all of you about what it is. So that went well. So hopefully I'm going to take you all on the same journey that I went through, kind of figuring out what this thing is, what it does, why it does it, and whether it does what it says it should do. Before we get into any of that, I'm talking about some Microsoft tech I do not work for. Microsoft, I'm talking about emulating Intel on ARM. I don't work for either Intel or ARM. If you know about LuaJet, you might have heard of Mike Paul. That's not me. Any of yous herein are my own, bugs are my own. If I'm wrong, that's my fault. Right then. Let's go into things. So we're going to do three kind of broad chapters here. First, we're going to have a general look at doing emulation of Intel code on ARM. I'm going to get really bored saying 64 all the time. So when I say Intel, I mean X64 code, and when I say ARM, I mean ARM 64 code, because otherwise all of 64 is going to get way too much. Then we'll look at this ARM 64 EC thing in particular, and then a bit of time about how LuaJet ported to this thing and whether that worked and how it worked. So emulation 101. You take Intel instructions like that one there, you turn them into ARM instructions like those three there, and you just do this for every single instruction that you find. How hard can this be? We've got this entire room to talk about doing this. One Intel instruction may become several, because Intel instructions are often more complex than ARM ones. If you're not familiar with assembly code, the square brackets here are memory loads or memory stores. In this case, they're all loads, but they could also be stores. I mentioned this because memory is complicated. Memory is what makes this more complex than it might look. Here are some of the things that I forgot to mention on the first slide. Let's start with memory ordering. If you have several threads that are all trying to work with memory at the same time, you can do cross-thread communication through memory, which on Intel often works. Intel gives you a very nice memory ordering properties, so you don't need memory barriers all that often. Whereas ARM is whatever, if you want to do cross-thread memory stuff, you will want some barriers in there to make it work. If you are trying to emulate the Intel code on ARM, you need to insert extra barriers that weren't there, otherwise we're going to introduce some concurrency bugs that weren't there. The annoying part here is that most memory operations aren't doing cross-thread stuff, but if you're doing an emulator, you don't know which instructions need the barriers and which ones don't, so you have to throw in the expensive memory barriers for almost every load and store, which is going to slow you right down. This middle question mark is saying, so memory is not just a big array of bytes. Memory is working out into pages, and those pages can have protections on them and other stuff, and all they make mapped to a PCIe device rather than going to RAM. You've got a question like, do you emulate an MMU and a bunch of things on it, or do you just pass it off to the host and let the host do whatever it would do? The final question mark here is flags. If that doesn't yet mean anything to you, that's good for you. Where can I get to the flag next? Because flags are a pain. Most Intel instructions, when you run them, they'll give you the main result that you're trying to get. They will also give you this array of six flags. Meanwhile, on ARM, some instructions will give you flags, and those that do only give you an array of four flags. I'm not a mathematician, but four is less than six, right? We've got a slight problem here. The question is, can we emulate the two that we don't have? Let's just run through all the flags. This could be a quick summary of what they are. We've got Z or ZF, just telling you whether the actual result, your main computation was zero or not. SF or N is telling you whether it was negative or not. Then we get to PF. Now, PF is great. Intel added PF in 1972 to give you the parity of the low eight bits of whatever it is that you were actually doing the computation of. Because back in 1972, you wanted a one bit checksum for doing modems and stuff. Intel being Intel, they've kept it ever since. You can emulate this thing on ARM. You just need to do a pop count of the low eight bits of whatever it is that you computed. If you know ARM assembly, you'll be like, wait a minute, there is no pop count instruction for general purpose rotors. We'll just gloss over that one. Then you've got the overflow flag or OF or V. That tells you whether any overflow happened during your computation. Useful for doing checks. Arithmetic and stuff. Then we've got CF and C, which is an extra carry bit in or out of your addition or subtraction. Fun point here is that there are two possible meanings for this flag in subtraction. And guess what? Intel choose one meaning, ARM choose the other meaning. If you're trying to emulate one on the other, you often have to flip the value of this flag to make them match up. Thankfully for this, ARM in ARM V8.4 added an instruction called CFINV, which for flipping the value of that flag added to make doing this kind of emulation easier. The final flag ARM doesn't have is AF on the right there. AF. AF is if you're doing binary coded decimal arithmetic. If you've never done any of that, good. Again, good for you. Intel thought back when they made these chips back in the 70s, BCD was a thing that people did. To make it fast, they added this extra flag that gives you the carry bit out of the low four bits of your computation because BCD uses groups of four bits. You can emulate the AF flag if you need to. We're doing a bunch of extra work to compute these things that we'd rather not do. A good emulator will try and work out when it doesn't have to compute anything at all or if it can defer the problem and hope that you don't actually need the answers at all. If you do have to compute them, there's extra work to do here which will slow you down. Start flags quickly. Next up, there are a bunch of existing solutions for doing emulation of Intel on ARM. Q emu we've heard quite a lot about here. With two flavors of Q emu, there's system mode and user mode, which boils down to in system mode, which will emulate an MMU and a bunch of devices on it, whereas user mode won't, so it's pushed off to the host. Therefore, Q emu user is much faster, but can't emulate as many things. There are a bunch of other open source solutions in the middle here. Starting with Justine Tini's Blink, which if you've not seen it, is part of a portable executable project for emulating Intel on anything. Her take is like, you know, we don't need a JVM with a portable bytecode that's used Intel code as a portable... Anyway, it does actually work. There's FeX emu that I'm not overly familiar with, but I think they're trying to be like Q emu user, but faster by only doing certain emulation of certain things on certain other things. I basically only Intel on ARM, whereas Q emu does everything on everything. Box 64 I wanted to mention because they pull this Q trick of saying, we will spot when you're trying to emulate a library that we've heard of, they're like, yeah, that's libc, that's SDL. I'm like, well, we won't emulate it. We'll just like, swap it out for our native version of it, which makes it faster because you don't have to emulate as much code. Obviously, the other big one that's not open source is Apple's Rosetta 2, which cheats by solving things in hardware. So, you know, this slide again, yeah, Apple solved this problem in hardware, this problem in hardware, this problem in hardware. So, you know, they cheat by adding extra hardware to their chips, and that makes that emulation extremely fast. Good for them, less good for other people. So, Apple can make a very appealing pitch to their developers, which is, you know, you can keep on with your kind of Intel code, and it'll like run fast on our custom hardware still. Or you can import it to ARM code, and it'll run even faster. I know Apple will port all of their kind of first party code, and the programmers in their ecosystem will do what they are told. Apple says you port your code, they will put their code. You know, the trade-off of working in a kind of Apple type system. Meanwhile, Microsoft have a far harder time. Like, you can target Intel, but it'll be dog-snow. Okay, not good. Or you can port your code to ARM, but you can't if you've got something like closed source library or plugins as part of your program. And this being that Microsoft's ecosystem, of course there are closed source libraries or plugins. So, yeah, Microsoft are in a really hard place here. And when I say slow, I mean slow. So, to give you a kind of idea here, I took the AllureJet benchmark suite, and I ran it on this Mac here as ARM code, 33 seconds. Fine, fine. Compiled it as Intel code, ran it under, was that a 2? 44 seconds. I mean, not great, but it's not a massive slow down. You can live with that. I ran a Windows VM on this thing, and the ARM version then took 37 seconds, which is a little bit slower. I'm not sure whether that's part of the VM or part of Windows slowing it down, or because Windows is running with 4K pages rather than 16K pages, same kind of ballpark. Then take the Intel version and run it under Windows' emulation, 106 seconds. Yeah, this is not good, not good. So, you know, you are someone at Microsoft, okay, so option one, I emulate the Intel code, it's too slow. Option two, I port it to ARM, is possibly impossible. At this point, I like to imagine some mad scientist at Microsoft, like, so, can we take two bad options, blend them together, and get a good option. Which, when you put it like that, seems insausable, but it turns out to actually work, surprisingly. So, that gets to part two. What is ARM64 EC? I, this crazy idea to get out of this error or to spot. Which is, let's let you port part of your application to ARM code. So, you know, if there are any kind of Intel bits that you can't port, because they're plug-ins or closed source, sure, leave them as like Intel code, but the stuff that you can port, you should port, and you can mix them all up, like, together, and allow you to like, cheaply interrupt between the two parts. And, you know, this is ARM64 EC. The ARM code is compactable with the emulated Intel code in a way that should hopefully work. Hopefully. So, that's the kind of thing. Big plan. But what does this mean? Like, how do we actually do this? Like, we're going to have to share the virtual address space between the Intel parts and the ARM parts, okay? We're going to need to share data structures out between the Intel parts and the ARM parts, okay? We're going to need to share call stacks between the two, fair enough. We're going to make things a little bit simpler by saying we can only kind of switch between Intel and ARM when you make a function call or you return from a function call. Or when you throw from a function and catch it higher up, that's, you know, painful. We're going to have to adjust how we do function calls a little bit to make this work, but ideally not too much. So, we're going to kind of delve into each of these points in turn. A shared virtual address space means, you know, you have all of your, you know, kind of address space and there's X people code in there and you have to know for any piece of X people code, is it ARM code or is it Intel code? So, we need an extra bit on every page to tell you kind of which one it is. I mentioned kind of doing cross thread communication earlier. Obviously, you know, our address space can have several threads in it. We're all trying to kind of talk to each other and any kind of Intel code running under, emulation still needs all of those extra barriers to be put in by the emulator, which will, you know, keep it slowed down but keep it correct. Meanwhile, any ARM code, Microsoft thought, just, you know, let the programmer that's doing the port put in the barriers where they have to be, which, you know, solves that problem at the cost of, you know, the programmer has to actually think. You can't just like recompile and not change your code and hope it works. So, all of that is kind of fine. Let me go to shared data structure layouts. Now, this starts off looking fairly simple. We say, you know, this is some kind of data structure. Let's make it compatible between Intel and ARM. Obviously, we can't change the Intel code, the whole point is we're kind of running free existing Intel code under emulation. So, we have to, you know, in ARM 64 EC mode, all of these types need the same size and alignment as ARM Intel. So, you know, longs are four bytes because windows doubles are eight bytes, pointers are eight bytes fine, function pointers, again, eight bytes. And this being why we needed an extra bit on every page to tell you whether it's Intel code or ARM code, because you might think, just like put it in the function pointer, but like there's no space. You have to make them one bit bigger to tell you whether they are Intel ARM pointers, which we can't do. So, we have to put that bit on the per page. But, you know, this all looks fine so far. Things get more interesting, though. So, if you're a C programmer, you'll know about set jump and long jump, which are C's equivalence to throw and catch. And there's this structure called jump buff that kind of tells you when I catch, this is the CPU state to kind of go back to when I do my catch. And you can pass the jump buff, you know, around, you know, you'll set it over here and use it over there. And in particular, in ARM 64 EC, you can do a long jump from Intel code to ARM code or from ARM code to Intel code. So, this jump buff guy has to be kind of compatible between the two. As I said, jump buff contains the CPU state that you want to go back to. But, like, Intel CPUs and ARM CPUs have different amounts of CPU state. So, that's going to be fun. To make it even worse, there's this Windows structure called context in all caps that contains the entire CPU state for a particular thread. But, again, you can pass around and do things with. And, yeah, so that guy has to be the same size as on ARM 64 EC as it is on Intel, despite there being a different amount of CPU state. So, this is starting to look a little hairy. So, what is all of the CPU state that we have to fit in to make these data structures compatible? So, we want a quick table here of, like, the user-visible CPU state on Intel and on ARM. ARM in one column, Intel in the other. I'm going to go through row by row to kind of go through them quickly. To, like, general purpose registers to start with, Intel has 16 of them, ARM has 32. You will notice we can't fit 32 into 16. This is going to be a slight problem. Next row is not so bad. We've got a bunch of, like, weird kind of edge cases. We've got RIP and PC. They're, like, the same thing. PSA and PSA because they're the same thing. The two FP things on ARM, we can fit into MX, CSR on Intel, but that much is fine. We've got the spare GS thing, which we'll come back to later. Next row is our floating point or vector registers. Again, Intel has 16, ARM has 32. 32 is more than 16. So, again, problem there. The bright sparks in the audience might say doesn't modern Intel with, like, AVEX 2 and AVEX 512 have far more registers than they're far larger. Yes, but ambient laters can't use AVEX or AVEX 2 or AVEX 512 because of patents. So, we're stuck with the kind of old, kind of, 16 of them and not only 128 bits wide. This final row is interesting because Intel way back added the AVEX 87 stack, which is 880-bit floating point registers. ARM has no such thing because this is, like, this old weird, like, legacy thing, but this is actually really good for us. So, our question is how do we fit all of the ARM column into the Intel column? So, let's start with the floating point registers and we'll say, okay, let's pretend ARM only has 16 of them. Problem solved, right? If you're writing ARM 64 EC code, you cannot use the high 16 of these guys. I mean, it'll come in a performance cost, but it'll make things work. The other way we had problem was with this first row, where we'd like to be not quite as extreme as throwing away half of them. So, we've got, like, 16 that we can fit over here. One can fit in GS and then 10 can fit down there. So, 16 plus 1 plus 10 means we can fit 27 of these guys in here somewhere. It works, it works. But we are still down 5. So, they'll become 5 general purpose registers that you cannot use. So, Microsoft said, okay, you just can't use X13, X14, X23, X24 or X28 in addition to the 16 factor things that you cannot use. So, this is the cost of making your data structures compatible between the two and it seems like a fairly high cost, but, you know, such is life. Moving on, we are sharing our call stacks between Intel and ARM. If you're familiar with Intel and ARM, your first point will be, so, doesn't like ARM put the return address in a register, whereas Intel puts it on the stack. Yes, we're going to have to fix that one up. The problem that you might not have noticed was that ARM requires your stack points to be 16-byte aligned when you use it for a load or a store. Intel merely recommends this very strongly. But doesn't actually check for it. So, you can very happily run with an only eight-byte aligned stack for a very long time and not notice that you've done anything wrong because it doesn't actually check for it. So, we're going to have to fix that one up, that one up too. So, a bit of work required to make these things work, but, you know, we can understand what that work is. And then we get to the actual meter things of, like, how do we switch between these two modes? We've made these things of compatible-ish or we've understood how to make them compatible, but how do we actually switch between Intel and ARM? So, if you're at use for assembly, you'll know what a calling convention is, which is, like, when we make a function call, where do we put the arguments for that call? Which registers contain when or what do you put on the stack when? And then, like, you can read these, like, long docs from ARM or from, like, other people about how to do this. And then there's a set of these rules for ARM, a set of these rules for Intel. We don't want to change those rules too much because, like, they mostly work, but they're not the same rules. You have to, like, put things in different places between Intel and ARM. So, we have to do some work to kind of fix that one up. And the work that you have to do will depend on the types of the arguments and the type of the return value of your function. So, we're going to need some kind of code for doing this work, and this code has to live on the ARM side of things because, again, we're trying to run Intel code that doesn't know it's running under emulation, so we can't change it. We can't add extra stuff in there. We have to add the extra stuff on the ARM side, which means if you're writing assembly code in ARM 64 it's like, how do I do a function call? This is how you do a function call. Step one, as you would normally put the arguments where they would be for a normal ARM call, and then, like, so, am I calling Intel or am I calling ARM? On the left-hand side, we've got the am I calling ARM column, and it, again, works like a normal ARM call other than this mystery box about exit points in X10 that I'm going to gloss over from now and come back to later. But other than that box, the left-hand column is a fairly normal function call on ARM. You put the results where they're meant to be, you call the function, you get the results back from where they are normally meant to be. The weird case is the Intel case on the right here, where we reduce some other things. Where we put the function that we want to call in the X9 register, has to be X9, and then we call an exit function. You're going to say, Peter, what is an exit function? And I will get to that in just a bit, but I want to address a different point first, which is this code has a branch in it, right? Everyone prefers straight line code to branchy code. But, like, we can get rid of these branches, mostly. You know, we'll have to have to do, like, both of these two steps, and push them up there, and then combine both of the calls. Because, like, this row, we're going to do a function call. We just don't know, like, where to yet. So, like, some kind of, like, conditional marks on where we want to call. And then we can make this whole lot straight line code. At which point, it'll look like this. You know, first box is the same. Second box is, like, we've pulled up both of the previous steps and just done both of them. This middle step is calling this magical mystery function from Microsoft. And then you do a call to somewhere. And then this last box is the same as previously. And if you're wondering, what does this magical mystery function from Microsoft do? You know, it turns this side back into this side. I mean, so, if you're reading assembly code, this is what you will see, but this is what it does. And now, I'll get to the previous point of so, what are these exit functions? So, they kind of fill the gap in. They kind of, the extra bits you have to do to transition off to arm mode. Which is we have to take the arguments that we carefully put in their arm places, take them out of their arm places, and put them into where they should be for the Intel style call. Which, you know, a bunch of work, but it's fine. And then ensure that the function that we want to call is still in X9. And then we call the next magical mystery function from Microsoft. And we have to do it in a special way. We have to put the address of this function in X16 and then call X16. Which is going to seem weird, but we're going to have to see why in a bit. And once the magical mystery function kind of comes back, we take the results from where they would live in Intel world, pull them out of that world, and put them where they would be for an arm world, and then we return as normal. So, okay. Next up, let's look at this magical mystery function. Which is this guy. So, first box in the top left. I mentioned that ARM puts return address on the register, whereas Intel puts it on the stack. This first box is fixing up that problem. Then the rest of the left-hand column is your kind of usual loop for emulating a CPU. You know, we get the next instruction. We do it somehow. Then we move to the next instruction and we do that one. In practice, there's going to be a far more complex logic in here. So, you know, like optimize stuff. And you're like, you know, jit compiler or AOT compiler or all sorts of clever stuff in there. But as far as we're concerned, as well as what it does, this kind of describes what it does. At some point, it'll say, wait a minute. You're now asking me to go back to ARM mode, because I've found code that's no longer like Intel code. We are doing some kind of mode switch. Now, I said earlier, mode switches, we've said they're only going to happen at function call or function return. Oh, go. If we've now gone from Intel's ARM, this is either a call or a return. And how do we know which? And the cheeky part there is that we look at the four bytes just before where we're going to start running and say, is this a call X16 instruction? Why is that the question? Because we have to call this magical mystery function as a call X16, which means if we just found that, it means we've just come back from the call that we were doing. We are in a function return type thing. And we set the return pointer to the code we want to run to, and we go to it. And this final column means that we're doing a function call, because the four bytes before where we're going to are anything else. And then we need to do, again, the opposite problem of where your return address wants to be. Is it on the stack or is it in a register? So we fix up that problem. And then we've set X4 to be the stack pointer. Why do we do that? Because the next step is to say we have to forcibly realign the stack pointer. Because remember that point where I said like, Intel code doesn't care about your alignment for as ARM does, this is where we fix that problem. And then we tail call X9's alternative entry point. Remember, X9 being the sting that we've inferred is a function tool that we're trying to make. So we do a call to almost that function. Again, you're going to say, Peter, what are these alternative entry points? So that's next. So every ARM function that could be called from Intel needs a so-called alternative entry point for handling when it is called from Intel. And it does all of the gubbins that have to be done to make this transition work. The only question is how do you find this alternative entry point, which is you put the offset of it in the four bytes before the start of the function, which is handy because we already had to read those four bytes to check whether they were that guy. So if they're not that guy, then they are the offset of this guy. And what is in one of these guys? Ignore the right hand column for now and look at just the left hand column, which point in the left hand column is mostly the opposite of what we saw earlier. We have to take the arguments from where they are in Intel and pull them out of there, put them where they should be for ARM land, call the real part of the function, and then take the results out of there and put them where they should be for Intel, and then call the next magical mystery function. The only interesting part here is this first box where we're saying if there are arguments that come off the stack, we can't read them from the stack point, we have to read them from x4. Why is this because of this forcibly realigning sp? You can no longer read your arguments from there because we might have changed it to realign it, but x4 tells you where they used to be. So that's fine. The interesting point is that the logic on the slide only depends upon the types of the arguments and the types of the return. It doesn't actually care about what the function actually does, and therefore you can kind of share these guys between multiple functions if those functions have the same type, which is good for like, you know, code sharing keeps your memory usage down, your iCash is happier, whatnot. But if you want to, you could write one of these per function, which point in the right hand side becomes an option that you could do, and then you can kind of skip the kind of calling in the other bits, just put the copy of your function in there, if you so wish. Okay, so next magical mystery point function is this guy. Don't worry, you've seen most of this side previously. It's all the same side except for the first box in the top left, for which you're going to ask, so what does this box in the top left do? What is the value of lr that we have up there? And if you trace all the stuff through, you'll see it's the same lr that we popped over on this side, which was the return address that we popped off the stack because we think the Intel code just made a function call, at which point what we're putting back in the top left is the return address to go back into Intel mode. So it all kind of works out. As you've seen this slide previously, at which point we have run out of magical mystery functions, so you know, there's a hard part over, that all kind of works out. So that tells you roughly very quickly what arm64 EC is, what the kind of code for it will look like, so next up, the kind of the lured part of how did I make lured work with this thing. So if you know lured, it's written in a mixture of assembly and C, and notably the interpreter is several thousand lines of assembly code, which is, you know, fun. So porting that code, that assembly code to arm64 EC, means that we can no longer use the versus that we said we couldn't use, they don't fit in the context structures. So we lose v16 to v31. That's fine, didn't use them to start with. x13, x14, again didn't use them to start with, not a problem. Unfortunately we did use x23 and x24 for various things, but because of what they were used for, they could be reworked to not require them with some almost zero cost tricks, so that wasn't too much of a pain. Losing x28, more annoying, that kind of required extra loads and stores to kind of split. In this regard, the jic and pilot was actually easier to port than the interpreter, because the jic and pilot could already just not use certain things, so you just had to add some things onto the list of what it can't use, and like, you know, it'll then just not use them. Again, there will be some kind of like perf cost to not using them, but it wasn't hard on the kind of porting side. Next up is handling these mode switches. So the C compiler will do most of the work for all of the C parts of Lerget, but again, it won't handle the assembly parts. So there are kind of three parts, therefore, that it doesn't really handle. One is the interpreter opcode for calling Ler API C functions. That one's fairly simple, like the, it's only one place, it can only call one type of function, and the type of that function is super simple. So that one's fine. Harder is the ffi. So if you're not familiar with the ffi, it's the Lerget's foreign function interface, and it lets Ler code call C functions of any type. Whatever type you want, it'll call it for you, and it'll just make it work. And you can also jit compile your ffi calls in most cases. I say with simple types, like most types are simple, so you can jit compile most of them. We also support ffi callbacks, but you can take a Ler function and make it into a C function, and then C code can call you. So again, it's like Intel code is trying to call your kind of ARM code that you created from your Ler code. You have to make that one work. That one's actually not too bad. 10, great, thank you. So the hard part is these two, just because they're kind of arbitrary types of function. So this is what I made Lerget do for interpreted ffi calls. So the good thing about ffi calls is that they are one shot calls. You give the ffi a pointer to call, and the type to use it to call it, and it'll go and do it, and it'll do it once. Because you're doing it once, you can look at the thing that you're trying to call it like so. Is this ARM code or is it Intel code, and just do the right thing for whatever it is that you're trying to call? Which gives you this nice, simple diagram. There is a slight problem with this diagram, though. So this is what we're meant to do. This is our slide from previously, and this is what we're actually doing. The right-hand side is just like we've inlined the exit tank, it's all fine. The left-hand side has a slight problem. I skipped over this box a while ago, and it's like we'll just forget about that box. And you'll notice that it's missing on this side, which will mean that certain things don't work. And the question is what doesn't work? So this is why I have to now tell you why this weird box is there on the left about putting a thing in X10 when there's no obvious reason why you need to do it. So let's answer that question, which is if we are making a function call and we are ARM code, and we might call Intel code, then we will need an exit tank. Hopefully we've now covered what those do and why you need them, and things of that mind, etc. If you want to do a function call, you need an exit tank, and to know which one to use, you have to know the type of the function that you want to call. Now, there's a particular subset of functions that don't know the type of the thing that they want to call. You might say that that's kind of weird, but let's just run with it for a while. And furthermore, these functions don't know their own type, also weird, but what they do know is that their own type matches the type of the thing that they want to call. Now this may sound like a somewhat contrived set of properties, but it does actually crop up enough in practice that it's worth caring about. So to let these weird typeless functions that don't know their own type and don't know what they're calling, to make them work, we give them an exit tank in X10. So if they are ARM code, they can just like, you know, run and say, well, whoever calls us put the appropriate thing in X10, and that will let us do the call that we want to do. So that means that if we end up calling one of those functions, and it then wants to call an Intel function, then this isn't actually going to work, but in practice it's actually fine. It's not yet been a problem. It could be fixed, but it's going to be like a pain to fix. You might ask, why is it going to be a pain to fix? That's because the FRI can call any type of function. So we can't just like preprepare an appropriate function for every single type of function. That's going to be way too many functions. So we have to jit compile the function that we want to use. And I mean, like really, like, can we just like not do that? Yeah, I just rather not do that yet. So I've skipped it. But it works. So, you know, great. That was interpreted, FRI calls. Then we've got jit compiled FRI calls. They're different because you will jit compile your call once, but then run it multiple times. So if we are jit compiling a call through a function pointer, we don't know whether that function pointer will be Intel or will be ARM. So we have to kind of do what we're meant to do more closely or almost do what we're meant to do. So, you know, we prepare the arguments as if it were a ARM call. If it ends up going to Intel, then we'll use an exit function to fix it up. We do the prep work that we went to do for the magical mystery function. All but again, I didn't want to jit compile an exit function for every possible type of thing that we might call. Because like, we're already jit compiling a function. We don't want to jit compile a function in addition to that at the same time. It just gets kind of hairy. So again, I cheated a bit and said, well, let's just write one function. They can handle like every case that can get jit compiled and just pass it the signature that it has to kind of pretend to be and just put that in some other register. And again, this will work fine in practice unless we hit the case of calling one of these typos functions that doesn't know their own type and it wants to call Intel and it happens to trash X15 that I've used to like, stash this X foot piece of state in. So again, not quite following the rules, but again, it works fine in practice. And then the slide that you've possibly all been waiting for, like, does this whole thing work? So you'll recall the first two lines from previous day. We said like, native ARM code ran in 37 seconds. The Intel code running under relation to 106, whereas the R54 you see code takes 38, which is pretty good, right? So we're kind of saying here, this is, it's native ARM code, so it should be close to 37 seconds, but it's making a combination such that it could call Intel code as and when it needs to. And making those combinations will slow you down by a few percentage points. But you know, you're in a much better place than you would otherwise be. And yeah, this crazy idea of Microsoft actually works. I can do one more slide or questions. Do you want to do? One more slide. Okay, great. So problems you didn't know that you had. Yeah, Linux has LD preload, which if you've used, you know, I want to let you know, change the malloc that I call or like, make F sync not slow. LD preload, great. Mac OS has LD, the old insert libraries, same thing, not quite the same details, but like the same thing. Windows doesn't have such a thing. It has ad hoc machine code patching. Yeah. And as a bonus point, Microsoft research used to sell a product called detours for doing this. Possibly like Microsoft research is only consumer facing product. Unsure. They made that open source on GitHub in like 2016. So you can go and find detours on GitHub and it will do 0.3. So you know how code lying around in your Intel code that expects to be able to go into other functions and patch them up. So to make this work, we have to take our functions and wrap them in a small Intel shell. So if you look at the shell, you're like, yeah, that's in the Intel code. I'll just patch that for you. And that's fun, right? So one of these magical mystery functions can kind of spot these shells and kind of skip right over them. But yeah, those shells are going to be here to make this thing work. That shouldn't be a problem in the first place, but it is because Windows doesn't have any of these systems. Bonus funds. Let's get back to here when we don't have to worry about the bonus problems. Okay. Great. Thank you, Peter. We have time. All right, let's do some questions. I'm going to start with one from online because otherwise we won't forget it. Can Intel code call ARM code? Oh, yes. Quick yes. Yes. Hands. This is the loop. Am I now trying to call ARM code? No. So I'm going to call Intel code. No, I'm trying to call ARM code. So we go over here and we go through the stack for calling ARM code. Yep, it all works. All right, one more time, hands, because I wasn't paying attention. I'll start here. How do you decide which code you can compile to ARM and which parts of the code you cannot and have to leave as Intel? So for the Luiget case, it's fairly simple because there's already an ARM version of Luiget. If you're going to write your own program, the advice is start with the hot parts and port those first. If that works, then you can slowly port more and more. I can get incremental speed improvements after you're porting more and more code. Over. Next question. Close by. Okay. Hi. Very nice presentation. Thank you. Hello. Okay. Yeah. Thank you very much. It was a very nice presentation. I was just curious what your experience is with the tooling support for these. What support? Like tooling support for these AVI, like the bloggers, compilers, what the support is like, if it's easy to use or. So yeah, the Microsoft C compiler can handle all of this fine. I think clang in LVM, kind of getting a few patches solely, but I'm going to be there for a while. The Visual Studio debugger for this stuff is great. You can single step through from ARM code to Intel code. I like not even notice that you've done a mode switch, which was kind of scary. Like, okay, single step, single step, single step, wait, what? I'm now in like ARM code. Okay, fine. So yeah, the Microsoft tooling is very good. The open source tooling not yet, not yet really there. So what I don't, maybe I've missed it, but what I don't quite understand is what I see here is the ARM64 AVI has been changed to match the Intel AVI a little bit more, right, to make this work. Yep. So how does that work when calling ARM64 Windows API functions? Do they have ARM64 EC versions of all of them? Yep. Wow. Yep. Yes, I have another question. It's a bit related to the question that was just asked about tool sense. Do you know other open source tool sense that support ARM64 EC, like GCC or maybe other GIT compilers? Yeah, that's my first question. Yeah, I've seen some patches land in Y and in Clang and LVM, but I kind of, I suspect they're all kind of starting to do things rather than like full support. Okay, another question and maybe, maybe I'm not sure I understood, but so you have LuaGIT users that want to call, do FFI basically with X64 code. So that's basically why you implemented the... Yeah, yes, most of your program is in Lua. Thank you. Any more questions? Oh, yeah, of course. Just, I think I didn't get, so you reduced the number of ARM registers, but wouldn't it possible to spill them to memory when you do the mode switch? Here's my cutout. So I'm going to run around. Here you go. Yeah, so it's, you can't spill them because you don't have any way to spill them to. Like if it was only the operating system that did mode switches between threads, you'd be fine. But you know, you can call such jump and long jump and there's like, there's not space in the jump buff to put the extra things. Or if you're really adventurous, you can do kind of user space scheduling in Windows. You know, you can call suspend thread and then like resume thread and like move your contacts in between threads. And you know, you could have Intel threads doing this onto your ARM threads. The Intel threads don't know that they're doing this to ARM threads. So you don't have any extra space to put the ARM states because they didn't know that they'd need this extra space. Yeah, I'm going to be running. We have somebody all the way in the back who's been waiting for a long time. Sorry, I didn't see you. I'm going to have to run back. I said a question to you. How do you deal with the red zone? I was like, why is he not answering? So short answer, Windows doesn't have a red zone in either Intel or ARM. So that's mostly fine. There was a related concept of home space for the first four integer registers in a kind of Intel call. And yeah, you have to handle that. So when you're doing your marshalling and remarshalling of arguments, you need to leave space for the home space as you would for a normal Intel call. So yeah, there is no red zone, but the closest equivalent thing, yes, you have to handle. Are there more questions? Are we? Oh, great. How long did this take you to figure out? Probably not very long. I mean, the documentation is pretty good on the Microsoft side. So possibly a week or two, probably. One more over there. So is there any way to call like regular, let's call them closed source ARM 64 Windows components, or is it complete separation? Completely separate. Any more questions? Oh, were you going to elaborate on the answer? Of course, yeah. I thought that was a really short answer. I'm just trying to save myself from running. Yeah, completely separate. So yeah, any kind of ARM only DLLs you can't call into, you have to have these special ARM 64 EC DLLs. Thankfully Microsoft have already done that for all of the kind of system libraries. So anything from Microsoft you can already call. But yeah, other code has to be in this weird mode to make it work. Any more questions? Yeah. Really making me work this year. Where were you? I was wondering, like, is there already examples of software that uses it because you can find it quite easily because the executable is like a different type that it uses? Because I, is there any like software, I haven't heard of this feature before, but like so far already using this major things? Yeah, so the person that opened the issue on the Lujo project is apparently using this thing. I mean, I'm told that most of like Microsoft like Office and similar are running in this mode so that you can have your Intel type plugins work. But yeah, apparently there's a user for this stuff of the Lujo thing and using it. The last question or was that the last question? Can we pass it? Sorry, what did the EC stand for? Emulator compatible. Am I stealing it from you? Emulator compatibility. That's what it stands for. If that was the last question, then let's thank Peter one more time. So am I still, yeah, with that, that closes up the Emulator Development Room this year. I want to thank you all for coming.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 11.6, "text": " Alright, so time has flown. This is already the last talk for the emulator development", "tokens": [50364, 2798, 11, 370, 565, 575, 34536, 13, 639, 307, 1217, 264, 1036, 751, 337, 264, 846, 16381, 3250, 50944], "temperature": 0.0, "avg_logprob": -0.22813077956911118, "compression_ratio": 1.394736842105263, "no_speech_prob": 0.49296796321868896}, {"id": 1, "seek": 0, "start": 11.6, "end": 17.76, "text": " room today. Thanks everybody for showing up. It's a crazy turnout. Today we've got Peter", "tokens": [50944, 1808, 965, 13, 2561, 2201, 337, 4099, 493, 13, 467, 311, 257, 3219, 42497, 13, 2692, 321, 600, 658, 6508, 51252], "temperature": 0.0, "avg_logprob": -0.22813077956911118, "compression_ratio": 1.394736842105263, "no_speech_prob": 0.49296796321868896}, {"id": 2, "seek": 0, "start": 17.76, "end": 24.92, "text": " who's going to talk about a really interesting feature from Microsoft Windows. Is there a", "tokens": [51252, 567, 311, 516, 281, 751, 466, 257, 534, 1880, 4111, 490, 8116, 8591, 13, 1119, 456, 257, 51610], "temperature": 0.0, "avg_logprob": -0.22813077956911118, "compression_ratio": 1.394736842105263, "no_speech_prob": 0.49296796321868896}, {"id": 3, "seek": 2492, "start": 24.92, "end": 31.360000000000003, "text": " question already at the start? Let's get what's happening here. Oh, okay. Alright, so Peter", "tokens": [50364, 1168, 1217, 412, 264, 722, 30, 961, 311, 483, 437, 311, 2737, 510, 13, 876, 11, 1392, 13, 2798, 11, 370, 6508, 50686], "temperature": 0.0, "avg_logprob": -0.3282041782286109, "compression_ratio": 1.4179104477611941, "no_speech_prob": 0.08239804953336716}, {"id": 4, "seek": 2492, "start": 31.360000000000003, "end": 36.96, "text": " has a lot of C++ experience and he can talk more about what he's going to do. So let's", "tokens": [50686, 575, 257, 688, 295, 383, 25472, 1752, 293, 415, 393, 751, 544, 466, 437, 415, 311, 516, 281, 360, 13, 407, 718, 311, 50966], "temperature": 0.0, "avg_logprob": -0.3282041782286109, "compression_ratio": 1.4179104477611941, "no_speech_prob": 0.08239804953336716}, {"id": 5, "seek": 2492, "start": 36.96, "end": 40.0, "text": " give him a hand.", "tokens": [50966, 976, 796, 257, 1011, 13, 51118], "temperature": 0.0, "avg_logprob": -0.3282041782286109, "compression_ratio": 1.4179104477611941, "no_speech_prob": 0.08239804953336716}, {"id": 6, "seek": 2492, "start": 40.0, "end": 51.32000000000001, "text": " Okay, so first of all, why am I here at FOSDEM talking about some closed source Microsoft", "tokens": [51118, 1033, 11, 370, 700, 295, 439, 11, 983, 669, 286, 510, 412, 479, 4367, 35, 6683, 1417, 466, 512, 5395, 4009, 8116, 51684], "temperature": 0.0, "avg_logprob": -0.3282041782286109, "compression_ratio": 1.4179104477611941, "no_speech_prob": 0.08239804953336716}, {"id": 7, "seek": 5132, "start": 51.32, "end": 58.8, "text": " attack? That's what you're all thinking, right? So let's address that question first.", "tokens": [50364, 2690, 30, 663, 311, 437, 291, 434, 439, 1953, 11, 558, 30, 407, 718, 311, 2985, 300, 1168, 700, 13, 50738], "temperature": 0.0, "avg_logprob": -0.2130275648467395, "compression_ratio": 1.4421487603305785, "no_speech_prob": 0.42271411418914795}, {"id": 8, "seek": 5132, "start": 58.8, "end": 63.16, "text": " So if you don't know me, one of my hobbies is hacking on LuaJet, which is a free and", "tokens": [50738, 407, 498, 291, 500, 380, 458, 385, 11, 472, 295, 452, 35750, 307, 31422, 322, 441, 4398, 41, 302, 11, 597, 307, 257, 1737, 293, 50956], "temperature": 0.0, "avg_logprob": -0.2130275648467395, "compression_ratio": 1.4421487603305785, "no_speech_prob": 0.42271411418914795}, {"id": 9, "seek": 5132, "start": 63.16, "end": 69.96000000000001, "text": " open source JIT compiler for Lua. And LuaJet recently gained support for Windows on ARM", "tokens": [50956, 1269, 4009, 508, 3927, 31958, 337, 441, 4398, 13, 400, 441, 4398, 41, 302, 3938, 12634, 1406, 337, 8591, 322, 45209, 51296], "temperature": 0.0, "avg_logprob": -0.2130275648467395, "compression_ratio": 1.4421487603305785, "no_speech_prob": 0.42271411418914795}, {"id": 10, "seek": 5132, "start": 69.96000000000001, "end": 77.32, "text": " 64. Or at least I thought it did until this guy came along and was like, so do you support", "tokens": [51296, 12145, 13, 1610, 412, 1935, 286, 1194, 309, 630, 1826, 341, 2146, 1361, 2051, 293, 390, 411, 11, 370, 360, 291, 1406, 51664], "temperature": 0.0, "avg_logprob": -0.2130275648467395, "compression_ratio": 1.4421487603305785, "no_speech_prob": 0.42271411418914795}, {"id": 11, "seek": 7732, "start": 77.32, "end": 86.16, "text": " this other Windows on ARM 64? And we're like, wait, wait, what? You did what? So first I", "tokens": [50364, 341, 661, 8591, 322, 45209, 12145, 30, 400, 321, 434, 411, 11, 1699, 11, 1699, 11, 437, 30, 509, 630, 437, 30, 407, 700, 286, 50806], "temperature": 0.0, "avg_logprob": -0.14496966770717076, "compression_ratio": 1.6232558139534883, "no_speech_prob": 0.2098776400089264}, {"id": 12, "seek": 7732, "start": 86.16, "end": 92.16, "text": " was horrified, then I was intrigued, and now I'm here speaking to all of you about what", "tokens": [50806, 390, 17582, 2587, 11, 550, 286, 390, 35140, 11, 293, 586, 286, 478, 510, 4124, 281, 439, 295, 291, 466, 437, 51106], "temperature": 0.0, "avg_logprob": -0.14496966770717076, "compression_ratio": 1.6232558139534883, "no_speech_prob": 0.2098776400089264}, {"id": 13, "seek": 7732, "start": 92.16, "end": 99.08, "text": " it is. So that went well. So hopefully I'm going to take you all on the same journey", "tokens": [51106, 309, 307, 13, 407, 300, 1437, 731, 13, 407, 4696, 286, 478, 516, 281, 747, 291, 439, 322, 264, 912, 4671, 51452], "temperature": 0.0, "avg_logprob": -0.14496966770717076, "compression_ratio": 1.6232558139534883, "no_speech_prob": 0.2098776400089264}, {"id": 14, "seek": 7732, "start": 99.08, "end": 104.6, "text": " that I went through, kind of figuring out what this thing is, what it does, why it does", "tokens": [51452, 300, 286, 1437, 807, 11, 733, 295, 15213, 484, 437, 341, 551, 307, 11, 437, 309, 775, 11, 983, 309, 775, 51728], "temperature": 0.0, "avg_logprob": -0.14496966770717076, "compression_ratio": 1.6232558139534883, "no_speech_prob": 0.2098776400089264}, {"id": 15, "seek": 10460, "start": 104.67999999999999, "end": 112.11999999999999, "text": " it, and whether it does what it says it should do. Before we get into any of that, I'm talking", "tokens": [50368, 309, 11, 293, 1968, 309, 775, 437, 309, 1619, 309, 820, 360, 13, 4546, 321, 483, 666, 604, 295, 300, 11, 286, 478, 1417, 50740], "temperature": 0.0, "avg_logprob": -0.1953116380251371, "compression_ratio": 1.6376146788990826, "no_speech_prob": 0.09573833644390106}, {"id": 16, "seek": 10460, "start": 112.11999999999999, "end": 117.16, "text": " about some Microsoft tech I do not work for. Microsoft, I'm talking about emulating Intel", "tokens": [50740, 466, 512, 8116, 7553, 286, 360, 406, 589, 337, 13, 8116, 11, 286, 478, 1417, 466, 846, 12162, 19762, 50992], "temperature": 0.0, "avg_logprob": -0.1953116380251371, "compression_ratio": 1.6376146788990826, "no_speech_prob": 0.09573833644390106}, {"id": 17, "seek": 10460, "start": 117.16, "end": 122.11999999999999, "text": " on ARM. I don't work for either Intel or ARM. If you know about LuaJet, you might have", "tokens": [50992, 322, 45209, 13, 286, 500, 380, 589, 337, 2139, 19762, 420, 45209, 13, 759, 291, 458, 466, 441, 4398, 41, 302, 11, 291, 1062, 362, 51240], "temperature": 0.0, "avg_logprob": -0.1953116380251371, "compression_ratio": 1.6376146788990826, "no_speech_prob": 0.09573833644390106}, {"id": 18, "seek": 10460, "start": 122.11999999999999, "end": 129.64, "text": " heard of Mike Paul. That's not me. Any of yous herein are my own, bugs are my own. If", "tokens": [51240, 2198, 295, 6602, 4552, 13, 663, 311, 406, 385, 13, 2639, 295, 291, 82, 510, 259, 366, 452, 1065, 11, 15120, 366, 452, 1065, 13, 759, 51616], "temperature": 0.0, "avg_logprob": -0.1953116380251371, "compression_ratio": 1.6376146788990826, "no_speech_prob": 0.09573833644390106}, {"id": 19, "seek": 12964, "start": 130.2, "end": 136.27999999999997, "text": " I'm wrong, that's my fault. Right then. Let's go into things. So we're going to do three", "tokens": [50392, 286, 478, 2085, 11, 300, 311, 452, 7441, 13, 1779, 550, 13, 961, 311, 352, 666, 721, 13, 407, 321, 434, 516, 281, 360, 1045, 50696], "temperature": 0.0, "avg_logprob": -0.2962647806299795, "compression_ratio": 1.6090909090909091, "no_speech_prob": 0.017792480066418648}, {"id": 20, "seek": 12964, "start": 136.27999999999997, "end": 141.07999999999998, "text": " kind of broad chapters here. First, we're going to have a general look at doing emulation", "tokens": [50696, 733, 295, 4152, 20013, 510, 13, 2386, 11, 321, 434, 516, 281, 362, 257, 2674, 574, 412, 884, 846, 2776, 50936], "temperature": 0.0, "avg_logprob": -0.2962647806299795, "compression_ratio": 1.6090909090909091, "no_speech_prob": 0.017792480066418648}, {"id": 21, "seek": 12964, "start": 141.07999999999998, "end": 147.16, "text": " of Intel code on ARM. I'm going to get really bored saying 64 all the time. So when I say", "tokens": [50936, 295, 19762, 3089, 322, 45209, 13, 286, 478, 516, 281, 483, 534, 13521, 1566, 12145, 439, 264, 565, 13, 407, 562, 286, 584, 51240], "temperature": 0.0, "avg_logprob": -0.2962647806299795, "compression_ratio": 1.6090909090909091, "no_speech_prob": 0.017792480066418648}, {"id": 22, "seek": 12964, "start": 147.16, "end": 154.16, "text": " Intel, I mean X64 code, and when I say ARM, I mean ARM 64 code, because otherwise all", "tokens": [51240, 19762, 11, 286, 914, 1783, 19395, 3089, 11, 293, 562, 286, 584, 45209, 11, 286, 914, 45209, 12145, 3089, 11, 570, 5911, 439, 51590], "temperature": 0.0, "avg_logprob": -0.2962647806299795, "compression_ratio": 1.6090909090909091, "no_speech_prob": 0.017792480066418648}, {"id": 23, "seek": 15416, "start": 155.12, "end": 161.12, "text": " of 64 is going to get way too much. Then we'll look at this ARM 64 EC thing in particular,", "tokens": [50412, 295, 12145, 307, 516, 281, 483, 636, 886, 709, 13, 1396, 321, 603, 574, 412, 341, 45209, 12145, 19081, 551, 294, 1729, 11, 50712], "temperature": 0.0, "avg_logprob": -0.20545923840868605, "compression_ratio": 1.5784753363228698, "no_speech_prob": 0.0054585314355790615}, {"id": 24, "seek": 15416, "start": 161.12, "end": 166.12, "text": " and then a bit of time about how LuaJet ported to this thing and whether that worked and", "tokens": [50712, 293, 550, 257, 857, 295, 565, 466, 577, 441, 4398, 41, 302, 2436, 292, 281, 341, 551, 293, 1968, 300, 2732, 293, 50962], "temperature": 0.0, "avg_logprob": -0.20545923840868605, "compression_ratio": 1.5784753363228698, "no_speech_prob": 0.0054585314355790615}, {"id": 25, "seek": 15416, "start": 166.12, "end": 173.12, "text": " how it worked. So emulation 101. You take Intel instructions like that one there, you", "tokens": [50962, 577, 309, 2732, 13, 407, 846, 2776, 21055, 13, 509, 747, 19762, 9415, 411, 300, 472, 456, 11, 291, 51312], "temperature": 0.0, "avg_logprob": -0.20545923840868605, "compression_ratio": 1.5784753363228698, "no_speech_prob": 0.0054585314355790615}, {"id": 26, "seek": 15416, "start": 173.6, "end": 177.92, "text": " turn them into ARM instructions like those three there, and you just do this for every", "tokens": [51336, 1261, 552, 666, 45209, 9415, 411, 729, 1045, 456, 11, 293, 291, 445, 360, 341, 337, 633, 51552], "temperature": 0.0, "avg_logprob": -0.20545923840868605, "compression_ratio": 1.5784753363228698, "no_speech_prob": 0.0054585314355790615}, {"id": 27, "seek": 17792, "start": 178.0, "end": 185.0, "text": " single instruction that you find. How hard can this be? We've got this entire room to", "tokens": [50368, 2167, 10951, 300, 291, 915, 13, 1012, 1152, 393, 341, 312, 30, 492, 600, 658, 341, 2302, 1808, 281, 50718], "temperature": 0.0, "avg_logprob": -0.27965118224362295, "compression_ratio": 1.6, "no_speech_prob": 0.025077583268284798}, {"id": 28, "seek": 17792, "start": 186.07999999999998, "end": 192.07999999999998, "text": " talk about doing this. One Intel instruction may become several, because Intel instructions", "tokens": [50772, 751, 466, 884, 341, 13, 1485, 19762, 10951, 815, 1813, 2940, 11, 570, 19762, 9415, 51072], "temperature": 0.0, "avg_logprob": -0.27965118224362295, "compression_ratio": 1.6, "no_speech_prob": 0.025077583268284798}, {"id": 29, "seek": 17792, "start": 192.07999999999998, "end": 199.07999999999998, "text": " are often more complex than ARM ones. If you're not familiar with assembly code, the square", "tokens": [51072, 366, 2049, 544, 3997, 813, 45209, 2306, 13, 759, 291, 434, 406, 4963, 365, 12103, 3089, 11, 264, 3732, 51422], "temperature": 0.0, "avg_logprob": -0.27965118224362295, "compression_ratio": 1.6, "no_speech_prob": 0.025077583268284798}, {"id": 30, "seek": 17792, "start": 200.67999999999998, "end": 205.67999999999998, "text": " brackets here are memory loads or memory stores. In this case, they're all loads, but they", "tokens": [51502, 26179, 510, 366, 4675, 12668, 420, 4675, 9512, 13, 682, 341, 1389, 11, 436, 434, 439, 12668, 11, 457, 436, 51752], "temperature": 0.0, "avg_logprob": -0.27965118224362295, "compression_ratio": 1.6, "no_speech_prob": 0.025077583268284798}, {"id": 31, "seek": 20568, "start": 205.76000000000002, "end": 212.76000000000002, "text": " could also be stores. I mentioned this because memory is complicated. Memory is what makes", "tokens": [50368, 727, 611, 312, 9512, 13, 286, 2835, 341, 570, 4675, 307, 6179, 13, 38203, 307, 437, 1669, 50718], "temperature": 0.0, "avg_logprob": -0.2034216154189337, "compression_ratio": 1.646788990825688, "no_speech_prob": 0.0035632080398499966}, {"id": 32, "seek": 20568, "start": 213.0, "end": 219.64000000000001, "text": " this more complex than it might look. Here are some of the things that I forgot to mention", "tokens": [50730, 341, 544, 3997, 813, 309, 1062, 574, 13, 1692, 366, 512, 295, 264, 721, 300, 286, 5298, 281, 2152, 51062], "temperature": 0.0, "avg_logprob": -0.2034216154189337, "compression_ratio": 1.646788990825688, "no_speech_prob": 0.0035632080398499966}, {"id": 33, "seek": 20568, "start": 219.64000000000001, "end": 225.4, "text": " on the first slide. Let's start with memory ordering. If you have several threads that", "tokens": [51062, 322, 264, 700, 4137, 13, 961, 311, 722, 365, 4675, 21739, 13, 759, 291, 362, 2940, 19314, 300, 51350], "temperature": 0.0, "avg_logprob": -0.2034216154189337, "compression_ratio": 1.646788990825688, "no_speech_prob": 0.0035632080398499966}, {"id": 34, "seek": 20568, "start": 225.4, "end": 229.88, "text": " are all trying to work with memory at the same time, you can do cross-thread communication", "tokens": [51350, 366, 439, 1382, 281, 589, 365, 4675, 412, 264, 912, 565, 11, 291, 393, 360, 3278, 12, 392, 2538, 6101, 51574], "temperature": 0.0, "avg_logprob": -0.2034216154189337, "compression_ratio": 1.646788990825688, "no_speech_prob": 0.0035632080398499966}, {"id": 35, "seek": 22988, "start": 229.96, "end": 235.96, "text": " through memory, which on Intel often works. Intel gives you a very nice memory ordering", "tokens": [50368, 807, 4675, 11, 597, 322, 19762, 2049, 1985, 13, 19762, 2709, 291, 257, 588, 1481, 4675, 21739, 50668], "temperature": 0.0, "avg_logprob": -0.2008480357232495, "compression_ratio": 1.7470817120622568, "no_speech_prob": 0.15464656054973602}, {"id": 36, "seek": 22988, "start": 236.35999999999999, "end": 243.35999999999999, "text": " properties, so you don't need memory barriers all that often. Whereas ARM is whatever, if", "tokens": [50688, 7221, 11, 370, 291, 500, 380, 643, 4675, 13565, 439, 300, 2049, 13, 13813, 45209, 307, 2035, 11, 498, 51038], "temperature": 0.0, "avg_logprob": -0.2008480357232495, "compression_ratio": 1.7470817120622568, "no_speech_prob": 0.15464656054973602}, {"id": 37, "seek": 22988, "start": 243.35999999999999, "end": 247.76, "text": " you want to do cross-thread memory stuff, you will want some barriers in there to make", "tokens": [51038, 291, 528, 281, 360, 3278, 12, 392, 2538, 4675, 1507, 11, 291, 486, 528, 512, 13565, 294, 456, 281, 652, 51258], "temperature": 0.0, "avg_logprob": -0.2008480357232495, "compression_ratio": 1.7470817120622568, "no_speech_prob": 0.15464656054973602}, {"id": 38, "seek": 22988, "start": 247.76, "end": 253.68, "text": " it work. If you are trying to emulate the Intel code on ARM, you need to insert extra barriers", "tokens": [51258, 309, 589, 13, 759, 291, 366, 1382, 281, 45497, 264, 19762, 3089, 322, 45209, 11, 291, 643, 281, 8969, 2857, 13565, 51554], "temperature": 0.0, "avg_logprob": -0.2008480357232495, "compression_ratio": 1.7470817120622568, "no_speech_prob": 0.15464656054973602}, {"id": 39, "seek": 22988, "start": 253.68, "end": 257.96, "text": " that weren't there, otherwise we're going to introduce some concurrency bugs that weren't", "tokens": [51554, 300, 4999, 380, 456, 11, 5911, 321, 434, 516, 281, 5366, 512, 23702, 10457, 15120, 300, 4999, 380, 51768], "temperature": 0.0, "avg_logprob": -0.2008480357232495, "compression_ratio": 1.7470817120622568, "no_speech_prob": 0.15464656054973602}, {"id": 40, "seek": 25796, "start": 258.03999999999996, "end": 264.03999999999996, "text": " there. The annoying part here is that most memory operations aren't doing cross-thread", "tokens": [50368, 456, 13, 440, 11304, 644, 510, 307, 300, 881, 4675, 7705, 3212, 380, 884, 3278, 12, 392, 2538, 50668], "temperature": 0.0, "avg_logprob": -0.19571889003860615, "compression_ratio": 1.7093023255813953, "no_speech_prob": 0.0026823547668755054}, {"id": 41, "seek": 25796, "start": 264.03999999999996, "end": 268.59999999999997, "text": " stuff, but if you're doing an emulator, you don't know which instructions need the barriers", "tokens": [50668, 1507, 11, 457, 498, 291, 434, 884, 364, 846, 16381, 11, 291, 500, 380, 458, 597, 9415, 643, 264, 13565, 50896], "temperature": 0.0, "avg_logprob": -0.19571889003860615, "compression_ratio": 1.7093023255813953, "no_speech_prob": 0.0026823547668755054}, {"id": 42, "seek": 25796, "start": 268.59999999999997, "end": 273.2, "text": " and which ones don't, so you have to throw in the expensive memory barriers for almost", "tokens": [50896, 293, 597, 2306, 500, 380, 11, 370, 291, 362, 281, 3507, 294, 264, 5124, 4675, 13565, 337, 1920, 51126], "temperature": 0.0, "avg_logprob": -0.19571889003860615, "compression_ratio": 1.7093023255813953, "no_speech_prob": 0.0026823547668755054}, {"id": 43, "seek": 25796, "start": 273.2, "end": 280.2, "text": " every load and store, which is going to slow you right down. This middle question mark is", "tokens": [51126, 633, 3677, 293, 3531, 11, 597, 307, 516, 281, 2964, 291, 558, 760, 13, 639, 2808, 1168, 1491, 307, 51476], "temperature": 0.0, "avg_logprob": -0.19571889003860615, "compression_ratio": 1.7093023255813953, "no_speech_prob": 0.0026823547668755054}, {"id": 44, "seek": 25796, "start": 280.32, "end": 286.32, "text": " saying, so memory is not just a big array of bytes. Memory is working out into pages,", "tokens": [51482, 1566, 11, 370, 4675, 307, 406, 445, 257, 955, 10225, 295, 36088, 13, 38203, 307, 1364, 484, 666, 7183, 11, 51782], "temperature": 0.0, "avg_logprob": -0.19571889003860615, "compression_ratio": 1.7093023255813953, "no_speech_prob": 0.0026823547668755054}, {"id": 45, "seek": 28632, "start": 286.88, "end": 293.88, "text": " and those pages can have protections on them and other stuff, and all they make mapped", "tokens": [50392, 293, 729, 7183, 393, 362, 29031, 322, 552, 293, 661, 1507, 11, 293, 439, 436, 652, 33318, 50742], "temperature": 0.0, "avg_logprob": -0.2796093555206948, "compression_ratio": 1.5414847161572052, "no_speech_prob": 0.002764180302619934}, {"id": 46, "seek": 28632, "start": 293.96, "end": 299.96, "text": " to a PCIe device rather than going to RAM. You've got a question like, do you emulate", "tokens": [50746, 281, 257, 6465, 40, 68, 4302, 2831, 813, 516, 281, 14561, 13, 509, 600, 658, 257, 1168, 411, 11, 360, 291, 45497, 51046], "temperature": 0.0, "avg_logprob": -0.2796093555206948, "compression_ratio": 1.5414847161572052, "no_speech_prob": 0.002764180302619934}, {"id": 47, "seek": 28632, "start": 299.96, "end": 305.96, "text": " an MMU and a bunch of things on it, or do you just pass it off to the host and let the", "tokens": [51046, 364, 34191, 52, 293, 257, 3840, 295, 721, 322, 309, 11, 420, 360, 291, 445, 1320, 309, 766, 281, 264, 3975, 293, 718, 264, 51346], "temperature": 0.0, "avg_logprob": -0.2796093555206948, "compression_ratio": 1.5414847161572052, "no_speech_prob": 0.002764180302619934}, {"id": 48, "seek": 28632, "start": 305.96, "end": 312.96, "text": " host do whatever it would do? The final question mark here is flags. If that doesn't yet mean", "tokens": [51346, 3975, 360, 2035, 309, 576, 360, 30, 440, 2572, 1168, 1491, 510, 307, 23265, 13, 759, 300, 1177, 380, 1939, 914, 51696], "temperature": 0.0, "avg_logprob": -0.2796093555206948, "compression_ratio": 1.5414847161572052, "no_speech_prob": 0.002764180302619934}, {"id": 49, "seek": 31296, "start": 313.91999999999996, "end": 320.91999999999996, "text": " anything to you, that's good for you. Where can I get to the flag next? Because flags are", "tokens": [50412, 1340, 281, 291, 11, 300, 311, 665, 337, 291, 13, 2305, 393, 286, 483, 281, 264, 7166, 958, 30, 1436, 23265, 366, 50762], "temperature": 0.0, "avg_logprob": -0.24717100373991244, "compression_ratio": 1.6372093023255814, "no_speech_prob": 0.005442553665488958}, {"id": 50, "seek": 31296, "start": 320.96, "end": 327.96, "text": " a pain. Most Intel instructions, when you run them, they'll give you the main result", "tokens": [50764, 257, 1822, 13, 4534, 19762, 9415, 11, 562, 291, 1190, 552, 11, 436, 603, 976, 291, 264, 2135, 1874, 51114], "temperature": 0.0, "avg_logprob": -0.24717100373991244, "compression_ratio": 1.6372093023255814, "no_speech_prob": 0.005442553665488958}, {"id": 51, "seek": 31296, "start": 328.24, "end": 334.0, "text": " that you're trying to get. They will also give you this array of six flags. Meanwhile, on", "tokens": [51128, 300, 291, 434, 1382, 281, 483, 13, 814, 486, 611, 976, 291, 341, 10225, 295, 2309, 23265, 13, 13879, 11, 322, 51416], "temperature": 0.0, "avg_logprob": -0.24717100373991244, "compression_ratio": 1.6372093023255814, "no_speech_prob": 0.005442553665488958}, {"id": 52, "seek": 31296, "start": 334.0, "end": 339.12, "text": " ARM, some instructions will give you flags, and those that do only give you an array of", "tokens": [51416, 45209, 11, 512, 9415, 486, 976, 291, 23265, 11, 293, 729, 300, 360, 787, 976, 291, 364, 10225, 295, 51672], "temperature": 0.0, "avg_logprob": -0.24717100373991244, "compression_ratio": 1.6372093023255814, "no_speech_prob": 0.005442553665488958}, {"id": 53, "seek": 33912, "start": 339.12, "end": 346.12, "text": " four flags. I'm not a mathematician, but four is less than six, right? We've got a", "tokens": [50364, 1451, 23265, 13, 286, 478, 406, 257, 48281, 11, 457, 1451, 307, 1570, 813, 2309, 11, 558, 30, 492, 600, 658, 257, 50714], "temperature": 0.0, "avg_logprob": -0.29980230844149025, "compression_ratio": 1.4786324786324787, "no_speech_prob": 0.007092372514307499}, {"id": 54, "seek": 33912, "start": 346.2, "end": 353.2, "text": " slight problem here. The question is, can we emulate the two that we don't have? Let's", "tokens": [50718, 4036, 1154, 510, 13, 440, 1168, 307, 11, 393, 321, 45497, 264, 732, 300, 321, 500, 380, 362, 30, 961, 311, 51068], "temperature": 0.0, "avg_logprob": -0.29980230844149025, "compression_ratio": 1.4786324786324787, "no_speech_prob": 0.007092372514307499}, {"id": 55, "seek": 33912, "start": 354.2, "end": 358.88, "text": " just run through all the flags. This could be a quick summary of what they are. We've", "tokens": [51118, 445, 1190, 807, 439, 264, 23265, 13, 639, 727, 312, 257, 1702, 12691, 295, 437, 436, 366, 13, 492, 600, 51352], "temperature": 0.0, "avg_logprob": -0.29980230844149025, "compression_ratio": 1.4786324786324787, "no_speech_prob": 0.007092372514307499}, {"id": 56, "seek": 33912, "start": 358.88, "end": 364.88, "text": " got Z or ZF, just telling you whether the actual result, your main computation was zero or", "tokens": [51352, 658, 1176, 420, 1176, 37, 11, 445, 3585, 291, 1968, 264, 3539, 1874, 11, 428, 2135, 24903, 390, 4018, 420, 51652], "temperature": 0.0, "avg_logprob": -0.29980230844149025, "compression_ratio": 1.4786324786324787, "no_speech_prob": 0.007092372514307499}, {"id": 57, "seek": 36488, "start": 364.96, "end": 371.96, "text": " not. SF or N is telling you whether it was negative or not. Then we get to PF. Now, PF", "tokens": [50368, 406, 13, 31095, 420, 426, 307, 3585, 291, 1968, 309, 390, 3671, 420, 406, 13, 1396, 321, 483, 281, 43402, 13, 823, 11, 43402, 50718], "temperature": 0.0, "avg_logprob": -0.21754770780864516, "compression_ratio": 1.543103448275862, "no_speech_prob": 0.006342431530356407}, {"id": 58, "seek": 36488, "start": 372.64, "end": 379.64, "text": " is great. Intel added PF in 1972 to give you the parity of the low eight bits of whatever", "tokens": [50752, 307, 869, 13, 19762, 3869, 43402, 294, 32952, 281, 976, 291, 264, 44747, 295, 264, 2295, 3180, 9239, 295, 2035, 51102], "temperature": 0.0, "avg_logprob": -0.21754770780864516, "compression_ratio": 1.543103448275862, "no_speech_prob": 0.006342431530356407}, {"id": 59, "seek": 36488, "start": 380.2, "end": 385.36, "text": " it is that you were actually doing the computation of. Because back in 1972, you wanted a one", "tokens": [51130, 309, 307, 300, 291, 645, 767, 884, 264, 24903, 295, 13, 1436, 646, 294, 32952, 11, 291, 1415, 257, 472, 51388], "temperature": 0.0, "avg_logprob": -0.21754770780864516, "compression_ratio": 1.543103448275862, "no_speech_prob": 0.006342431530356407}, {"id": 60, "seek": 36488, "start": 385.36, "end": 392.36, "text": " bit checksum for doing modems and stuff. Intel being Intel, they've kept it ever since.", "tokens": [51388, 857, 13834, 449, 337, 884, 1072, 9097, 293, 1507, 13, 19762, 885, 19762, 11, 436, 600, 4305, 309, 1562, 1670, 13, 51738], "temperature": 0.0, "avg_logprob": -0.21754770780864516, "compression_ratio": 1.543103448275862, "no_speech_prob": 0.006342431530356407}, {"id": 61, "seek": 39236, "start": 392.78000000000003, "end": 399.28000000000003, "text": " You can emulate this thing on ARM. You just need to do a pop count of the low eight bits", "tokens": [50385, 509, 393, 45497, 341, 551, 322, 45209, 13, 509, 445, 643, 281, 360, 257, 1665, 1207, 295, 264, 2295, 3180, 9239, 50710], "temperature": 0.0, "avg_logprob": -0.27765417965975675, "compression_ratio": 1.5905797101449275, "no_speech_prob": 0.0022994535975158215}, {"id": 62, "seek": 39236, "start": 399.28000000000003, "end": 403.78000000000003, "text": " of whatever it is that you computed. If you know ARM assembly, you'll be like, wait a", "tokens": [50710, 295, 2035, 309, 307, 300, 291, 40610, 13, 759, 291, 458, 45209, 12103, 11, 291, 603, 312, 411, 11, 1699, 257, 50935], "temperature": 0.0, "avg_logprob": -0.27765417965975675, "compression_ratio": 1.5905797101449275, "no_speech_prob": 0.0022994535975158215}, {"id": 63, "seek": 39236, "start": 403.78000000000003, "end": 406.54, "text": " minute, there is no pop count instruction for general purpose rotors. We'll just gloss", "tokens": [50935, 3456, 11, 456, 307, 572, 1665, 1207, 10951, 337, 2674, 4334, 4297, 830, 13, 492, 603, 445, 19574, 51073], "temperature": 0.0, "avg_logprob": -0.27765417965975675, "compression_ratio": 1.5905797101449275, "no_speech_prob": 0.0022994535975158215}, {"id": 64, "seek": 39236, "start": 406.54, "end": 413.54, "text": " over that one. Then you've got the overflow flag or OF or V. That tells you whether any", "tokens": [51073, 670, 300, 472, 13, 1396, 291, 600, 658, 264, 37772, 7166, 420, 11944, 420, 691, 13, 663, 5112, 291, 1968, 604, 51423], "temperature": 0.0, "avg_logprob": -0.27765417965975675, "compression_ratio": 1.5905797101449275, "no_speech_prob": 0.0022994535975158215}, {"id": 65, "seek": 39236, "start": 414.2, "end": 420.2, "text": " overflow happened during your computation. Useful for doing checks. Arithmetic and stuff.", "tokens": [51456, 37772, 2011, 1830, 428, 24903, 13, 8278, 906, 337, 884, 13834, 13, 1587, 41179, 293, 1507, 13, 51756], "temperature": 0.0, "avg_logprob": -0.27765417965975675, "compression_ratio": 1.5905797101449275, "no_speech_prob": 0.0022994535975158215}, {"id": 66, "seek": 42020, "start": 420.36, "end": 427.36, "text": " Then we've got CF and C, which is an extra carry bit in or out of your addition or subtraction.", "tokens": [50372, 1396, 321, 600, 658, 21792, 293, 383, 11, 597, 307, 364, 2857, 3985, 857, 294, 420, 484, 295, 428, 4500, 420, 16390, 313, 13, 50722], "temperature": 0.0, "avg_logprob": -0.21744043785229064, "compression_ratio": 1.63003663003663, "no_speech_prob": 0.0015383402351289988}, {"id": 67, "seek": 42020, "start": 427.88, "end": 432.44, "text": " Fun point here is that there are two possible meanings for this flag in subtraction. And", "tokens": [50748, 11166, 935, 510, 307, 300, 456, 366, 732, 1944, 28138, 337, 341, 7166, 294, 16390, 313, 13, 400, 50976], "temperature": 0.0, "avg_logprob": -0.21744043785229064, "compression_ratio": 1.63003663003663, "no_speech_prob": 0.0015383402351289988}, {"id": 68, "seek": 42020, "start": 432.44, "end": 437.24, "text": " guess what? Intel choose one meaning, ARM choose the other meaning. If you're trying", "tokens": [50976, 2041, 437, 30, 19762, 2826, 472, 3620, 11, 45209, 2826, 264, 661, 3620, 13, 759, 291, 434, 1382, 51216], "temperature": 0.0, "avg_logprob": -0.21744043785229064, "compression_ratio": 1.63003663003663, "no_speech_prob": 0.0015383402351289988}, {"id": 69, "seek": 42020, "start": 437.24, "end": 441.36, "text": " to emulate one on the other, you often have to flip the value of this flag to make them", "tokens": [51216, 281, 45497, 472, 322, 264, 661, 11, 291, 2049, 362, 281, 7929, 264, 2158, 295, 341, 7166, 281, 652, 552, 51422], "temperature": 0.0, "avg_logprob": -0.21744043785229064, "compression_ratio": 1.63003663003663, "no_speech_prob": 0.0015383402351289988}, {"id": 70, "seek": 42020, "start": 441.36, "end": 448.36, "text": " match up. Thankfully for this, ARM in ARM V8.4 added an instruction called CFINV, which", "tokens": [51422, 2995, 493, 13, 28344, 337, 341, 11, 45209, 294, 45209, 691, 23, 13, 19, 3869, 364, 10951, 1219, 21792, 1464, 53, 11, 597, 51772], "temperature": 0.0, "avg_logprob": -0.21744043785229064, "compression_ratio": 1.63003663003663, "no_speech_prob": 0.0015383402351289988}, {"id": 71, "seek": 45020, "start": 450.36, "end": 457.2, "text": " for flipping the value of that flag added to make doing this kind of emulation easier.", "tokens": [50372, 337, 26886, 264, 2158, 295, 300, 7166, 3869, 281, 652, 884, 341, 733, 295, 846, 2776, 3571, 13, 50714], "temperature": 0.0, "avg_logprob": -0.2371900160234053, "compression_ratio": 1.5244444444444445, "no_speech_prob": 0.0024302888195961714}, {"id": 72, "seek": 45020, "start": 457.2, "end": 464.2, "text": " The final flag ARM doesn't have is AF on the right there. AF. AF is if you're doing", "tokens": [50714, 440, 2572, 7166, 45209, 1177, 380, 362, 307, 20389, 322, 264, 558, 456, 13, 20389, 13, 20389, 307, 498, 291, 434, 884, 51064], "temperature": 0.0, "avg_logprob": -0.2371900160234053, "compression_ratio": 1.5244444444444445, "no_speech_prob": 0.0024302888195961714}, {"id": 73, "seek": 45020, "start": 464.2, "end": 471.2, "text": " binary coded decimal arithmetic. If you've never done any of that, good. Again, good", "tokens": [51064, 17434, 34874, 26601, 42973, 13, 759, 291, 600, 1128, 1096, 604, 295, 300, 11, 665, 13, 3764, 11, 665, 51414], "temperature": 0.0, "avg_logprob": -0.2371900160234053, "compression_ratio": 1.5244444444444445, "no_speech_prob": 0.0024302888195961714}, {"id": 74, "seek": 45020, "start": 471.71999999999997, "end": 478.71999999999997, "text": " for you. Intel thought back when they made these chips back in the 70s, BCD was a thing", "tokens": [51440, 337, 291, 13, 19762, 1194, 646, 562, 436, 1027, 613, 11583, 646, 294, 264, 5285, 82, 11, 14359, 35, 390, 257, 551, 51790], "temperature": 0.0, "avg_logprob": -0.2371900160234053, "compression_ratio": 1.5244444444444445, "no_speech_prob": 0.0024302888195961714}, {"id": 75, "seek": 47872, "start": 478.8, "end": 483.28000000000003, "text": " that people did. To make it fast, they added this extra flag that gives you the carry bit", "tokens": [50368, 300, 561, 630, 13, 1407, 652, 309, 2370, 11, 436, 3869, 341, 2857, 7166, 300, 2709, 291, 264, 3985, 857, 50592], "temperature": 0.0, "avg_logprob": -0.18200065815343267, "compression_ratio": 1.662962962962963, "no_speech_prob": 0.0030037995893508196}, {"id": 76, "seek": 47872, "start": 483.28000000000003, "end": 489.48, "text": " out of the low four bits of your computation because BCD uses groups of four bits. You", "tokens": [50592, 484, 295, 264, 2295, 1451, 9239, 295, 428, 24903, 570, 14359, 35, 4960, 3935, 295, 1451, 9239, 13, 509, 50902], "temperature": 0.0, "avg_logprob": -0.18200065815343267, "compression_ratio": 1.662962962962963, "no_speech_prob": 0.0030037995893508196}, {"id": 77, "seek": 47872, "start": 489.48, "end": 496.48, "text": " can emulate the AF flag if you need to. We're doing a bunch of extra work to compute these", "tokens": [50902, 393, 45497, 264, 20389, 7166, 498, 291, 643, 281, 13, 492, 434, 884, 257, 3840, 295, 2857, 589, 281, 14722, 613, 51252], "temperature": 0.0, "avg_logprob": -0.18200065815343267, "compression_ratio": 1.662962962962963, "no_speech_prob": 0.0030037995893508196}, {"id": 78, "seek": 47872, "start": 496.72, "end": 501.8, "text": " things that we'd rather not do. A good emulator will try and work out when it doesn't have", "tokens": [51264, 721, 300, 321, 1116, 2831, 406, 360, 13, 316, 665, 846, 16381, 486, 853, 293, 589, 484, 562, 309, 1177, 380, 362, 51518], "temperature": 0.0, "avg_logprob": -0.18200065815343267, "compression_ratio": 1.662962962962963, "no_speech_prob": 0.0030037995893508196}, {"id": 79, "seek": 47872, "start": 501.8, "end": 507.20000000000005, "text": " to compute anything at all or if it can defer the problem and hope that you don't actually", "tokens": [51518, 281, 14722, 1340, 412, 439, 420, 498, 309, 393, 25704, 264, 1154, 293, 1454, 300, 291, 500, 380, 767, 51788], "temperature": 0.0, "avg_logprob": -0.18200065815343267, "compression_ratio": 1.662962962962963, "no_speech_prob": 0.0030037995893508196}, {"id": 80, "seek": 50720, "start": 507.2, "end": 513.04, "text": " need the answers at all. If you do have to compute them, there's extra work to do here", "tokens": [50364, 643, 264, 6338, 412, 439, 13, 759, 291, 360, 362, 281, 14722, 552, 11, 456, 311, 2857, 589, 281, 360, 510, 50656], "temperature": 0.0, "avg_logprob": -0.22326789299647012, "compression_ratio": 1.5676855895196506, "no_speech_prob": 0.002251307712867856}, {"id": 81, "seek": 50720, "start": 513.04, "end": 520.04, "text": " which will slow you down. Start flags quickly. Next up, there are a bunch of existing solutions", "tokens": [50656, 597, 486, 2964, 291, 760, 13, 6481, 23265, 2661, 13, 3087, 493, 11, 456, 366, 257, 3840, 295, 6741, 6547, 51006], "temperature": 0.0, "avg_logprob": -0.22326789299647012, "compression_ratio": 1.5676855895196506, "no_speech_prob": 0.002251307712867856}, {"id": 82, "seek": 50720, "start": 522.4, "end": 529.16, "text": " for doing emulation of Intel on ARM. Q emu we've heard quite a lot about here. With two", "tokens": [51124, 337, 884, 846, 2776, 295, 19762, 322, 45209, 13, 1249, 846, 84, 321, 600, 2198, 1596, 257, 688, 466, 510, 13, 2022, 732, 51462], "temperature": 0.0, "avg_logprob": -0.22326789299647012, "compression_ratio": 1.5676855895196506, "no_speech_prob": 0.002251307712867856}, {"id": 83, "seek": 50720, "start": 529.16, "end": 535.6, "text": " flavors of Q emu, there's system mode and user mode, which boils down to in system mode,", "tokens": [51462, 16303, 295, 1249, 846, 84, 11, 456, 311, 1185, 4391, 293, 4195, 4391, 11, 597, 35049, 760, 281, 294, 1185, 4391, 11, 51784], "temperature": 0.0, "avg_logprob": -0.22326789299647012, "compression_ratio": 1.5676855895196506, "no_speech_prob": 0.002251307712867856}, {"id": 84, "seek": 53560, "start": 535.64, "end": 541.8000000000001, "text": " which will emulate an MMU and a bunch of devices on it, whereas user mode won't, so it's pushed", "tokens": [50366, 597, 486, 45497, 364, 34191, 52, 293, 257, 3840, 295, 5759, 322, 309, 11, 9735, 4195, 4391, 1582, 380, 11, 370, 309, 311, 9152, 50674], "temperature": 0.0, "avg_logprob": -0.3435025507090043, "compression_ratio": 1.5381355932203389, "no_speech_prob": 0.0015825359150767326}, {"id": 85, "seek": 53560, "start": 541.8000000000001, "end": 548.8000000000001, "text": " off to the host. Therefore, Q emu user is much faster, but can't emulate as many things.", "tokens": [50674, 766, 281, 264, 3975, 13, 7504, 11, 1249, 846, 84, 4195, 307, 709, 4663, 11, 457, 393, 380, 45497, 382, 867, 721, 13, 51024], "temperature": 0.0, "avg_logprob": -0.3435025507090043, "compression_ratio": 1.5381355932203389, "no_speech_prob": 0.0015825359150767326}, {"id": 86, "seek": 53560, "start": 548.8000000000001, "end": 554.96, "text": " There are a bunch of other open source solutions in the middle here. Starting with Justine", "tokens": [51024, 821, 366, 257, 3840, 295, 661, 1269, 4009, 6547, 294, 264, 2808, 510, 13, 16217, 365, 1449, 533, 51332], "temperature": 0.0, "avg_logprob": -0.3435025507090043, "compression_ratio": 1.5381355932203389, "no_speech_prob": 0.0015825359150767326}, {"id": 87, "seek": 53560, "start": 554.96, "end": 561.96, "text": " Tini's Blink, which if you've not seen it, is part of a portable executable project for", "tokens": [51332, 314, 3812, 311, 2177, 475, 11, 597, 498, 291, 600, 406, 1612, 309, 11, 307, 644, 295, 257, 21800, 7568, 712, 1716, 337, 51682], "temperature": 0.0, "avg_logprob": -0.3435025507090043, "compression_ratio": 1.5381355932203389, "no_speech_prob": 0.0015825359150767326}, {"id": 88, "seek": 56196, "start": 562.0400000000001, "end": 569.0400000000001, "text": " emulating Intel on anything. Her take is like, you know, we don't need a JVM with a portable", "tokens": [50368, 846, 12162, 19762, 322, 1340, 13, 3204, 747, 307, 411, 11, 291, 458, 11, 321, 500, 380, 643, 257, 508, 53, 44, 365, 257, 21800, 50718], "temperature": 0.0, "avg_logprob": -0.2948789694874557, "compression_ratio": 1.5541125541125542, "no_speech_prob": 0.021129604429006577}, {"id": 89, "seek": 56196, "start": 570.36, "end": 577.36, "text": " bytecode that's used Intel code as a portable... Anyway, it does actually work. There's FeX", "tokens": [50784, 40846, 22332, 300, 311, 1143, 19762, 3089, 382, 257, 21800, 485, 5684, 11, 309, 775, 767, 589, 13, 821, 311, 3697, 55, 51134], "temperature": 0.0, "avg_logprob": -0.2948789694874557, "compression_ratio": 1.5541125541125542, "no_speech_prob": 0.021129604429006577}, {"id": 90, "seek": 56196, "start": 578.6, "end": 583.8000000000001, "text": " emu that I'm not overly familiar with, but I think they're trying to be like Q emu user,", "tokens": [51196, 846, 84, 300, 286, 478, 406, 24324, 4963, 365, 11, 457, 286, 519, 436, 434, 1382, 281, 312, 411, 1249, 846, 84, 4195, 11, 51456], "temperature": 0.0, "avg_logprob": -0.2948789694874557, "compression_ratio": 1.5541125541125542, "no_speech_prob": 0.021129604429006577}, {"id": 91, "seek": 56196, "start": 583.8000000000001, "end": 589.8000000000001, "text": " but faster by only doing certain emulation of certain things on certain other things.", "tokens": [51456, 457, 4663, 538, 787, 884, 1629, 846, 2776, 295, 1629, 721, 322, 1629, 661, 721, 13, 51756], "temperature": 0.0, "avg_logprob": -0.2948789694874557, "compression_ratio": 1.5541125541125542, "no_speech_prob": 0.021129604429006577}, {"id": 92, "seek": 58980, "start": 589.8399999999999, "end": 596.8399999999999, "text": " I basically only Intel on ARM, whereas Q emu does everything on everything.", "tokens": [50366, 286, 1936, 787, 19762, 322, 45209, 11, 9735, 1249, 846, 84, 775, 1203, 322, 1203, 13, 50716], "temperature": 0.0, "avg_logprob": -0.23571824535881122, "compression_ratio": 1.528888888888889, "no_speech_prob": 0.0005858232616446912}, {"id": 93, "seek": 58980, "start": 597.12, "end": 602.24, "text": " Box 64 I wanted to mention because they pull this Q trick of saying, we will spot when", "tokens": [50730, 15112, 12145, 286, 1415, 281, 2152, 570, 436, 2235, 341, 1249, 4282, 295, 1566, 11, 321, 486, 4008, 562, 50986], "temperature": 0.0, "avg_logprob": -0.23571824535881122, "compression_ratio": 1.528888888888889, "no_speech_prob": 0.0005858232616446912}, {"id": 94, "seek": 58980, "start": 602.24, "end": 608.76, "text": " you're trying to emulate a library that we've heard of, they're like, yeah, that's libc,", "tokens": [50986, 291, 434, 1382, 281, 45497, 257, 6405, 300, 321, 600, 2198, 295, 11, 436, 434, 411, 11, 1338, 11, 300, 311, 22854, 66, 11, 51312], "temperature": 0.0, "avg_logprob": -0.23571824535881122, "compression_ratio": 1.528888888888889, "no_speech_prob": 0.0005858232616446912}, {"id": 95, "seek": 58980, "start": 608.76, "end": 614.92, "text": " that's SDL. I'm like, well, we won't emulate it. We'll just like, swap it out for our native", "tokens": [51312, 300, 311, 14638, 43, 13, 286, 478, 411, 11, 731, 11, 321, 1582, 380, 45497, 309, 13, 492, 603, 445, 411, 11, 18135, 309, 484, 337, 527, 8470, 51620], "temperature": 0.0, "avg_logprob": -0.23571824535881122, "compression_ratio": 1.528888888888889, "no_speech_prob": 0.0005858232616446912}, {"id": 96, "seek": 61492, "start": 614.92, "end": 621.92, "text": " version of it, which makes it faster because you don't have to emulate as much code. Obviously,", "tokens": [50364, 3037, 295, 309, 11, 597, 1669, 309, 4663, 570, 291, 500, 380, 362, 281, 45497, 382, 709, 3089, 13, 7580, 11, 50714], "temperature": 0.0, "avg_logprob": -0.17427181941206737, "compression_ratio": 1.7766990291262137, "no_speech_prob": 0.01931804046034813}, {"id": 97, "seek": 61492, "start": 621.92, "end": 627.36, "text": " the other big one that's not open source is Apple's Rosetta 2, which cheats by solving", "tokens": [50714, 264, 661, 955, 472, 300, 311, 406, 1269, 4009, 307, 6373, 311, 11144, 16593, 568, 11, 597, 947, 1720, 538, 12606, 50986], "temperature": 0.0, "avg_logprob": -0.17427181941206737, "compression_ratio": 1.7766990291262137, "no_speech_prob": 0.01931804046034813}, {"id": 98, "seek": 61492, "start": 627.36, "end": 633.7199999999999, "text": " things in hardware. So, you know, this slide again, yeah, Apple solved this problem in", "tokens": [50986, 721, 294, 8837, 13, 407, 11, 291, 458, 11, 341, 4137, 797, 11, 1338, 11, 6373, 13041, 341, 1154, 294, 51304], "temperature": 0.0, "avg_logprob": -0.17427181941206737, "compression_ratio": 1.7766990291262137, "no_speech_prob": 0.01931804046034813}, {"id": 99, "seek": 61492, "start": 633.7199999999999, "end": 640.7199999999999, "text": " hardware, this problem in hardware, this problem in hardware. So, you know, they cheat by adding", "tokens": [51304, 8837, 11, 341, 1154, 294, 8837, 11, 341, 1154, 294, 8837, 13, 407, 11, 291, 458, 11, 436, 17470, 538, 5127, 51654], "temperature": 0.0, "avg_logprob": -0.17427181941206737, "compression_ratio": 1.7766990291262137, "no_speech_prob": 0.01931804046034813}, {"id": 100, "seek": 64072, "start": 640.8000000000001, "end": 646.76, "text": " extra hardware to their chips, and that makes that emulation extremely fast. Good for them,", "tokens": [50368, 2857, 8837, 281, 641, 11583, 11, 293, 300, 1669, 300, 846, 2776, 4664, 2370, 13, 2205, 337, 552, 11, 50666], "temperature": 0.0, "avg_logprob": -0.21568827043499864, "compression_ratio": 1.7461538461538462, "no_speech_prob": 0.0055314237251877785}, {"id": 101, "seek": 64072, "start": 646.76, "end": 652.76, "text": " less good for other people. So, Apple can make a very appealing pitch to their developers,", "tokens": [50666, 1570, 665, 337, 661, 561, 13, 407, 11, 6373, 393, 652, 257, 588, 23842, 7293, 281, 641, 8849, 11, 50966], "temperature": 0.0, "avg_logprob": -0.21568827043499864, "compression_ratio": 1.7461538461538462, "no_speech_prob": 0.0055314237251877785}, {"id": 102, "seek": 64072, "start": 652.76, "end": 657.84, "text": " which is, you know, you can keep on with your kind of Intel code, and it'll like run fast", "tokens": [50966, 597, 307, 11, 291, 458, 11, 291, 393, 1066, 322, 365, 428, 733, 295, 19762, 3089, 11, 293, 309, 603, 411, 1190, 2370, 51220], "temperature": 0.0, "avg_logprob": -0.21568827043499864, "compression_ratio": 1.7461538461538462, "no_speech_prob": 0.0055314237251877785}, {"id": 103, "seek": 64072, "start": 657.84, "end": 662.6800000000001, "text": " on our custom hardware still. Or you can import it to ARM code, and it'll run even faster.", "tokens": [51220, 322, 527, 2375, 8837, 920, 13, 1610, 291, 393, 974, 309, 281, 45209, 3089, 11, 293, 309, 603, 1190, 754, 4663, 13, 51462], "temperature": 0.0, "avg_logprob": -0.21568827043499864, "compression_ratio": 1.7461538461538462, "no_speech_prob": 0.0055314237251877785}, {"id": 104, "seek": 64072, "start": 662.6800000000001, "end": 669.28, "text": " I know Apple will port all of their kind of first party code, and the programmers in their", "tokens": [51462, 286, 458, 6373, 486, 2436, 439, 295, 641, 733, 295, 700, 3595, 3089, 11, 293, 264, 41504, 294, 641, 51792], "temperature": 0.0, "avg_logprob": -0.21568827043499864, "compression_ratio": 1.7461538461538462, "no_speech_prob": 0.0055314237251877785}, {"id": 105, "seek": 66928, "start": 669.3199999999999, "end": 674.28, "text": " ecosystem will do what they are told. Apple says you port your code, they will put their", "tokens": [50366, 11311, 486, 360, 437, 436, 366, 1907, 13, 6373, 1619, 291, 2436, 428, 3089, 11, 436, 486, 829, 641, 50614], "temperature": 0.0, "avg_logprob": -0.2570462954246392, "compression_ratio": 1.6340579710144927, "no_speech_prob": 0.0021908616181463003}, {"id": 106, "seek": 66928, "start": 674.28, "end": 681.04, "text": " code. You know, the trade-off of working in a kind of Apple type system. Meanwhile, Microsoft", "tokens": [50614, 3089, 13, 509, 458, 11, 264, 4923, 12, 4506, 295, 1364, 294, 257, 733, 295, 6373, 2010, 1185, 13, 13879, 11, 8116, 50952], "temperature": 0.0, "avg_logprob": -0.2570462954246392, "compression_ratio": 1.6340579710144927, "no_speech_prob": 0.0021908616181463003}, {"id": 107, "seek": 66928, "start": 681.04, "end": 687.3199999999999, "text": " have a far harder time. Like, you can target Intel, but it'll be dog-snow. Okay, not good.", "tokens": [50952, 362, 257, 1400, 6081, 565, 13, 1743, 11, 291, 393, 3779, 19762, 11, 457, 309, 603, 312, 3000, 12, 82, 3785, 13, 1033, 11, 406, 665, 13, 51266], "temperature": 0.0, "avg_logprob": -0.2570462954246392, "compression_ratio": 1.6340579710144927, "no_speech_prob": 0.0021908616181463003}, {"id": 108, "seek": 66928, "start": 687.3199999999999, "end": 691.48, "text": " Or you can port your code to ARM, but you can't if you've got something like closed source", "tokens": [51266, 1610, 291, 393, 2436, 428, 3089, 281, 45209, 11, 457, 291, 393, 380, 498, 291, 600, 658, 746, 411, 5395, 4009, 51474], "temperature": 0.0, "avg_logprob": -0.2570462954246392, "compression_ratio": 1.6340579710144927, "no_speech_prob": 0.0021908616181463003}, {"id": 109, "seek": 66928, "start": 691.48, "end": 696.76, "text": " library or plugins as part of your program. And this being that Microsoft's ecosystem,", "tokens": [51474, 6405, 420, 33759, 382, 644, 295, 428, 1461, 13, 400, 341, 885, 300, 8116, 311, 11311, 11, 51738], "temperature": 0.0, "avg_logprob": -0.2570462954246392, "compression_ratio": 1.6340579710144927, "no_speech_prob": 0.0021908616181463003}, {"id": 110, "seek": 69676, "start": 696.8, "end": 702.28, "text": " of course there are closed source libraries or plugins. So, yeah, Microsoft are in a really", "tokens": [50366, 295, 1164, 456, 366, 5395, 4009, 15148, 420, 33759, 13, 407, 11, 1338, 11, 8116, 366, 294, 257, 534, 50640], "temperature": 0.0, "avg_logprob": -0.2986851283482143, "compression_ratio": 1.5147679324894514, "no_speech_prob": 0.005332194268703461}, {"id": 111, "seek": 69676, "start": 702.28, "end": 709.28, "text": " hard place here. And when I say slow, I mean slow. So, to give you a kind of idea here,", "tokens": [50640, 1152, 1081, 510, 13, 400, 562, 286, 584, 2964, 11, 286, 914, 2964, 13, 407, 11, 281, 976, 291, 257, 733, 295, 1558, 510, 11, 50990], "temperature": 0.0, "avg_logprob": -0.2986851283482143, "compression_ratio": 1.5147679324894514, "no_speech_prob": 0.005332194268703461}, {"id": 112, "seek": 69676, "start": 709.68, "end": 716.68, "text": " I took the AllureJet benchmark suite, and I ran it on this Mac here as ARM code, 33 seconds.", "tokens": [51010, 286, 1890, 264, 1057, 540, 41, 302, 18927, 14205, 11, 293, 286, 5872, 309, 322, 341, 5707, 510, 382, 45209, 3089, 11, 11816, 3949, 13, 51360], "temperature": 0.0, "avg_logprob": -0.2986851283482143, "compression_ratio": 1.5147679324894514, "no_speech_prob": 0.005332194268703461}, {"id": 113, "seek": 69676, "start": 717.72, "end": 724.3199999999999, "text": " Fine, fine. Compiled it as Intel code, ran it under, was that a 2? 44 seconds. I mean,", "tokens": [51412, 12024, 11, 2489, 13, 6620, 7292, 309, 382, 19762, 3089, 11, 5872, 309, 833, 11, 390, 300, 257, 568, 30, 16408, 3949, 13, 286, 914, 11, 51742], "temperature": 0.0, "avg_logprob": -0.2986851283482143, "compression_ratio": 1.5147679324894514, "no_speech_prob": 0.005332194268703461}, {"id": 114, "seek": 72432, "start": 724.5200000000001, "end": 731.5200000000001, "text": " not great, but it's not a massive slow down. You can live with that. I ran a Windows VM", "tokens": [50374, 406, 869, 11, 457, 309, 311, 406, 257, 5994, 2964, 760, 13, 509, 393, 1621, 365, 300, 13, 286, 5872, 257, 8591, 18038, 50724], "temperature": 0.0, "avg_logprob": -0.23372397171823603, "compression_ratio": 1.5758928571428572, "no_speech_prob": 0.0060000354424119}, {"id": 115, "seek": 72432, "start": 731.72, "end": 737.96, "text": " on this thing, and the ARM version then took 37 seconds, which is a little bit slower.", "tokens": [50734, 322, 341, 551, 11, 293, 264, 45209, 3037, 550, 1890, 13435, 3949, 11, 597, 307, 257, 707, 857, 14009, 13, 51046], "temperature": 0.0, "avg_logprob": -0.23372397171823603, "compression_ratio": 1.5758928571428572, "no_speech_prob": 0.0060000354424119}, {"id": 116, "seek": 72432, "start": 737.96, "end": 742.2800000000001, "text": " I'm not sure whether that's part of the VM or part of Windows slowing it down, or because", "tokens": [51046, 286, 478, 406, 988, 1968, 300, 311, 644, 295, 264, 18038, 420, 644, 295, 8591, 26958, 309, 760, 11, 420, 570, 51262], "temperature": 0.0, "avg_logprob": -0.23372397171823603, "compression_ratio": 1.5758928571428572, "no_speech_prob": 0.0060000354424119}, {"id": 117, "seek": 72432, "start": 742.2800000000001, "end": 749.2800000000001, "text": " Windows is running with 4K pages rather than 16K pages, same kind of ballpark. Then take", "tokens": [51262, 8591, 307, 2614, 365, 1017, 42, 7183, 2831, 813, 3165, 42, 7183, 11, 912, 733, 295, 2594, 31239, 13, 1396, 747, 51612], "temperature": 0.0, "avg_logprob": -0.23372397171823603, "compression_ratio": 1.5758928571428572, "no_speech_prob": 0.0060000354424119}, {"id": 118, "seek": 74928, "start": 749.36, "end": 755.36, "text": " the Intel version and run it under Windows' emulation, 106 seconds. Yeah, this is not", "tokens": [50368, 264, 19762, 3037, 293, 1190, 309, 833, 8591, 6, 846, 2776, 11, 1266, 21, 3949, 13, 865, 11, 341, 307, 406, 50668], "temperature": 0.0, "avg_logprob": -0.30779497964041574, "compression_ratio": 1.579185520361991, "no_speech_prob": 0.024962302297353745}, {"id": 119, "seek": 74928, "start": 755.36, "end": 762.36, "text": " good, not good. So, you know, you are someone at Microsoft, okay, so option one, I emulate", "tokens": [50668, 665, 11, 406, 665, 13, 407, 11, 291, 458, 11, 291, 366, 1580, 412, 8116, 11, 1392, 11, 370, 3614, 472, 11, 286, 45497, 51018], "temperature": 0.0, "avg_logprob": -0.30779497964041574, "compression_ratio": 1.579185520361991, "no_speech_prob": 0.024962302297353745}, {"id": 120, "seek": 74928, "start": 762.68, "end": 769.68, "text": " the Intel code, it's too slow. Option two, I port it to ARM, is possibly impossible.", "tokens": [51034, 264, 19762, 3089, 11, 309, 311, 886, 2964, 13, 29284, 732, 11, 286, 2436, 309, 281, 45209, 11, 307, 6264, 6243, 13, 51384], "temperature": 0.0, "avg_logprob": -0.30779497964041574, "compression_ratio": 1.579185520361991, "no_speech_prob": 0.024962302297353745}, {"id": 121, "seek": 74928, "start": 769.68, "end": 775.48, "text": " At this point, I like to imagine some mad scientist at Microsoft, like, so, can we take", "tokens": [51384, 1711, 341, 935, 11, 286, 411, 281, 3811, 512, 5244, 12662, 412, 8116, 11, 411, 11, 370, 11, 393, 321, 747, 51674], "temperature": 0.0, "avg_logprob": -0.30779497964041574, "compression_ratio": 1.579185520361991, "no_speech_prob": 0.024962302297353745}, {"id": 122, "seek": 77548, "start": 775.52, "end": 782.52, "text": " two bad options, blend them together, and get a good option. Which, when you put it", "tokens": [50366, 732, 1578, 3956, 11, 10628, 552, 1214, 11, 293, 483, 257, 665, 3614, 13, 3013, 11, 562, 291, 829, 309, 50716], "temperature": 0.0, "avg_logprob": -0.3173813754565095, "compression_ratio": 1.4065934065934067, "no_speech_prob": 0.011787080205976963}, {"id": 123, "seek": 77548, "start": 785.16, "end": 792.16, "text": " like that, seems insausable, but it turns out to actually work, surprisingly. So, that", "tokens": [50848, 411, 300, 11, 2544, 1028, 8463, 712, 11, 457, 309, 4523, 484, 281, 767, 589, 11, 17600, 13, 407, 11, 300, 51198], "temperature": 0.0, "avg_logprob": -0.3173813754565095, "compression_ratio": 1.4065934065934067, "no_speech_prob": 0.011787080205976963}, {"id": 124, "seek": 77548, "start": 792.6, "end": 799.6, "text": " gets to part two. What is ARM64 EC? I, this crazy idea to get out of this error or to", "tokens": [51220, 2170, 281, 644, 732, 13, 708, 307, 45209, 19395, 19081, 30, 286, 11, 341, 3219, 1558, 281, 483, 484, 295, 341, 6713, 420, 281, 51570], "temperature": 0.0, "avg_logprob": -0.3173813754565095, "compression_ratio": 1.4065934065934067, "no_speech_prob": 0.011787080205976963}, {"id": 125, "seek": 79960, "start": 799.88, "end": 806.88, "text": " spot. Which is, let's let you port part of your application to ARM code. So, you know,", "tokens": [50378, 4008, 13, 3013, 307, 11, 718, 311, 718, 291, 2436, 644, 295, 428, 3861, 281, 45209, 3089, 13, 407, 11, 291, 458, 11, 50728], "temperature": 0.0, "avg_logprob": -0.248538040917767, "compression_ratio": 1.650375939849624, "no_speech_prob": 0.021438784897327423}, {"id": 126, "seek": 79960, "start": 807.88, "end": 811.24, "text": " if there are any kind of Intel bits that you can't port, because they're plug-ins or", "tokens": [50778, 498, 456, 366, 604, 733, 295, 19762, 9239, 300, 291, 393, 380, 2436, 11, 570, 436, 434, 5452, 12, 1292, 420, 50946], "temperature": 0.0, "avg_logprob": -0.248538040917767, "compression_ratio": 1.650375939849624, "no_speech_prob": 0.021438784897327423}, {"id": 127, "seek": 79960, "start": 811.24, "end": 816.28, "text": " closed source, sure, leave them as like Intel code, but the stuff that you can port, you", "tokens": [50946, 5395, 4009, 11, 988, 11, 1856, 552, 382, 411, 19762, 3089, 11, 457, 264, 1507, 300, 291, 393, 2436, 11, 291, 51198], "temperature": 0.0, "avg_logprob": -0.248538040917767, "compression_ratio": 1.650375939849624, "no_speech_prob": 0.021438784897327423}, {"id": 128, "seek": 79960, "start": 816.28, "end": 821.46, "text": " should port, and you can mix them all up, like, together, and allow you to like, cheaply", "tokens": [51198, 820, 2436, 11, 293, 291, 393, 2890, 552, 439, 493, 11, 411, 11, 1214, 11, 293, 2089, 291, 281, 411, 11, 7084, 356, 51457], "temperature": 0.0, "avg_logprob": -0.248538040917767, "compression_ratio": 1.650375939849624, "no_speech_prob": 0.021438784897327423}, {"id": 129, "seek": 79960, "start": 821.46, "end": 828.46, "text": " interrupt between the two parts. And, you know, this is ARM64 EC. The ARM code is compact", "tokens": [51457, 12729, 1296, 264, 732, 3166, 13, 400, 11, 291, 458, 11, 341, 307, 45209, 19395, 19081, 13, 440, 45209, 3089, 307, 14679, 51807], "temperature": 0.0, "avg_logprob": -0.248538040917767, "compression_ratio": 1.650375939849624, "no_speech_prob": 0.021438784897327423}, {"id": 130, "seek": 82960, "start": 829.84, "end": 836.84, "text": "able with the emulated Intel code in a way that should hopefully work. Hopefully. So,", "tokens": [50376, 712, 365, 264, 846, 6987, 19762, 3089, 294, 257, 636, 300, 820, 4696, 589, 13, 10429, 13, 407, 11, 50726], "temperature": 0.0, "avg_logprob": -0.24267389063249556, "compression_ratio": 1.9141630901287554, "no_speech_prob": 0.007368686608970165}, {"id": 131, "seek": 82960, "start": 836.84, "end": 841.84, "text": " that's the kind of thing. Big plan. But what does this mean? Like, how do we actually do", "tokens": [50726, 300, 311, 264, 733, 295, 551, 13, 5429, 1393, 13, 583, 437, 775, 341, 914, 30, 1743, 11, 577, 360, 321, 767, 360, 50976], "temperature": 0.0, "avg_logprob": -0.24267389063249556, "compression_ratio": 1.9141630901287554, "no_speech_prob": 0.007368686608970165}, {"id": 132, "seek": 82960, "start": 841.84, "end": 846.36, "text": " this? Like, we're going to have to share the virtual address space between the Intel parts", "tokens": [50976, 341, 30, 1743, 11, 321, 434, 516, 281, 362, 281, 2073, 264, 6374, 2985, 1901, 1296, 264, 19762, 3166, 51202], "temperature": 0.0, "avg_logprob": -0.24267389063249556, "compression_ratio": 1.9141630901287554, "no_speech_prob": 0.007368686608970165}, {"id": 133, "seek": 82960, "start": 846.36, "end": 850.48, "text": " and the ARM parts, okay? We're going to need to share data structures out between the Intel", "tokens": [51202, 293, 264, 45209, 3166, 11, 1392, 30, 492, 434, 516, 281, 643, 281, 2073, 1412, 9227, 484, 1296, 264, 19762, 51408], "temperature": 0.0, "avg_logprob": -0.24267389063249556, "compression_ratio": 1.9141630901287554, "no_speech_prob": 0.007368686608970165}, {"id": 134, "seek": 82960, "start": 850.48, "end": 855.48, "text": " parts and the ARM parts, okay? We're going to need to share call stacks between the two,", "tokens": [51408, 3166, 293, 264, 45209, 3166, 11, 1392, 30, 492, 434, 516, 281, 643, 281, 2073, 818, 30792, 1296, 264, 732, 11, 51658], "temperature": 0.0, "avg_logprob": -0.24267389063249556, "compression_ratio": 1.9141630901287554, "no_speech_prob": 0.007368686608970165}, {"id": 135, "seek": 85548, "start": 855.52, "end": 859.84, "text": " fair enough. We're going to make things a little bit simpler by saying we can only", "tokens": [50366, 3143, 1547, 13, 492, 434, 516, 281, 652, 721, 257, 707, 857, 18587, 538, 1566, 321, 393, 787, 50582], "temperature": 0.0, "avg_logprob": -0.18407603875914616, "compression_ratio": 1.8485915492957747, "no_speech_prob": 0.006474263966083527}, {"id": 136, "seek": 85548, "start": 859.84, "end": 863.96, "text": " kind of switch between Intel and ARM when you make a function call or you return from", "tokens": [50582, 733, 295, 3679, 1296, 19762, 293, 45209, 562, 291, 652, 257, 2445, 818, 420, 291, 2736, 490, 50788], "temperature": 0.0, "avg_logprob": -0.18407603875914616, "compression_ratio": 1.8485915492957747, "no_speech_prob": 0.006474263966083527}, {"id": 137, "seek": 85548, "start": 863.96, "end": 868.6800000000001, "text": " a function call. Or when you throw from a function and catch it higher up, that's, you", "tokens": [50788, 257, 2445, 818, 13, 1610, 562, 291, 3507, 490, 257, 2445, 293, 3745, 309, 2946, 493, 11, 300, 311, 11, 291, 51024], "temperature": 0.0, "avg_logprob": -0.18407603875914616, "compression_ratio": 1.8485915492957747, "no_speech_prob": 0.006474263966083527}, {"id": 138, "seek": 85548, "start": 868.6800000000001, "end": 874.04, "text": " know, painful. We're going to have to adjust how we do function calls a little bit to make", "tokens": [51024, 458, 11, 11697, 13, 492, 434, 516, 281, 362, 281, 4369, 577, 321, 360, 2445, 5498, 257, 707, 857, 281, 652, 51292], "temperature": 0.0, "avg_logprob": -0.18407603875914616, "compression_ratio": 1.8485915492957747, "no_speech_prob": 0.006474263966083527}, {"id": 139, "seek": 85548, "start": 874.04, "end": 879.6, "text": " this work, but ideally not too much. So, we're going to kind of delve into each of these", "tokens": [51292, 341, 589, 11, 457, 22915, 406, 886, 709, 13, 407, 11, 321, 434, 516, 281, 733, 295, 43098, 666, 1184, 295, 613, 51570], "temperature": 0.0, "avg_logprob": -0.18407603875914616, "compression_ratio": 1.8485915492957747, "no_speech_prob": 0.006474263966083527}, {"id": 140, "seek": 85548, "start": 879.6, "end": 884.84, "text": " points in turn. A shared virtual address space means, you know, you have all of your, you", "tokens": [51570, 2793, 294, 1261, 13, 316, 5507, 6374, 2985, 1901, 1355, 11, 291, 458, 11, 291, 362, 439, 295, 428, 11, 291, 51832], "temperature": 0.0, "avg_logprob": -0.18407603875914616, "compression_ratio": 1.8485915492957747, "no_speech_prob": 0.006474263966083527}, {"id": 141, "seek": 88484, "start": 884.88, "end": 890.2800000000001, "text": " know, kind of address space and there's X people code in there and you have to know for", "tokens": [50366, 458, 11, 733, 295, 2985, 1901, 293, 456, 311, 1783, 561, 3089, 294, 456, 293, 291, 362, 281, 458, 337, 50636], "temperature": 0.0, "avg_logprob": -0.21132343739002674, "compression_ratio": 1.7222222222222223, "no_speech_prob": 0.0034120078198611736}, {"id": 142, "seek": 88484, "start": 890.2800000000001, "end": 896.4, "text": " any piece of X people code, is it ARM code or is it Intel code? So, we need an extra", "tokens": [50636, 604, 2522, 295, 1783, 561, 3089, 11, 307, 309, 45209, 3089, 420, 307, 309, 19762, 3089, 30, 407, 11, 321, 643, 364, 2857, 50942], "temperature": 0.0, "avg_logprob": -0.21132343739002674, "compression_ratio": 1.7222222222222223, "no_speech_prob": 0.0034120078198611736}, {"id": 143, "seek": 88484, "start": 896.4, "end": 902.6, "text": " bit on every page to tell you kind of which one it is. I mentioned kind of doing cross", "tokens": [50942, 857, 322, 633, 3028, 281, 980, 291, 733, 295, 597, 472, 309, 307, 13, 286, 2835, 733, 295, 884, 3278, 51252], "temperature": 0.0, "avg_logprob": -0.21132343739002674, "compression_ratio": 1.7222222222222223, "no_speech_prob": 0.0034120078198611736}, {"id": 144, "seek": 88484, "start": 902.6, "end": 906.08, "text": " thread communication earlier. Obviously, you know, our address space can have several", "tokens": [51252, 7207, 6101, 3071, 13, 7580, 11, 291, 458, 11, 527, 2985, 1901, 393, 362, 2940, 51426], "temperature": 0.0, "avg_logprob": -0.21132343739002674, "compression_ratio": 1.7222222222222223, "no_speech_prob": 0.0034120078198611736}, {"id": 145, "seek": 88484, "start": 906.08, "end": 910.64, "text": " threads in it. We're all trying to kind of talk to each other and any kind of Intel code", "tokens": [51426, 19314, 294, 309, 13, 492, 434, 439, 1382, 281, 733, 295, 751, 281, 1184, 661, 293, 604, 733, 295, 19762, 3089, 51654], "temperature": 0.0, "avg_logprob": -0.21132343739002674, "compression_ratio": 1.7222222222222223, "no_speech_prob": 0.0034120078198611736}, {"id": 146, "seek": 91064, "start": 910.68, "end": 915.4, "text": " running under, emulation still needs all of those extra barriers to be put in by the emulator,", "tokens": [50366, 2614, 833, 11, 846, 2776, 920, 2203, 439, 295, 729, 2857, 13565, 281, 312, 829, 294, 538, 264, 846, 16381, 11, 50602], "temperature": 0.0, "avg_logprob": -0.25411972113415204, "compression_ratio": 1.725868725868726, "no_speech_prob": 0.029552217572927475}, {"id": 147, "seek": 91064, "start": 915.4, "end": 921.28, "text": " which will, you know, keep it slowed down but keep it correct. Meanwhile, any ARM code,", "tokens": [50602, 597, 486, 11, 291, 458, 11, 1066, 309, 32057, 760, 457, 1066, 309, 3006, 13, 13879, 11, 604, 45209, 3089, 11, 50896], "temperature": 0.0, "avg_logprob": -0.25411972113415204, "compression_ratio": 1.725868725868726, "no_speech_prob": 0.029552217572927475}, {"id": 148, "seek": 91064, "start": 921.28, "end": 925.84, "text": " Microsoft thought, just, you know, let the programmer that's doing the port put in the", "tokens": [50896, 8116, 1194, 11, 445, 11, 291, 458, 11, 718, 264, 32116, 300, 311, 884, 264, 2436, 829, 294, 264, 51124], "temperature": 0.0, "avg_logprob": -0.25411972113415204, "compression_ratio": 1.725868725868726, "no_speech_prob": 0.029552217572927475}, {"id": 149, "seek": 91064, "start": 925.84, "end": 930.4399999999999, "text": " barriers where they have to be, which, you know, solves that problem at the cost of, you", "tokens": [51124, 13565, 689, 436, 362, 281, 312, 11, 597, 11, 291, 458, 11, 39890, 300, 1154, 412, 264, 2063, 295, 11, 291, 51354], "temperature": 0.0, "avg_logprob": -0.25411972113415204, "compression_ratio": 1.725868725868726, "no_speech_prob": 0.029552217572927475}, {"id": 150, "seek": 91064, "start": 930.4399999999999, "end": 934.52, "text": " know, the programmer has to actually think. You can't just like recompile and not change", "tokens": [51354, 458, 11, 264, 32116, 575, 281, 767, 519, 13, 509, 393, 380, 445, 411, 48000, 794, 293, 406, 1319, 51558], "temperature": 0.0, "avg_logprob": -0.25411972113415204, "compression_ratio": 1.725868725868726, "no_speech_prob": 0.029552217572927475}, {"id": 151, "seek": 93452, "start": 934.56, "end": 941.4399999999999, "text": " your code and hope it works. So, all of that is kind of fine. Let me go to shared data structure", "tokens": [50366, 428, 3089, 293, 1454, 309, 1985, 13, 407, 11, 439, 295, 300, 307, 733, 295, 2489, 13, 961, 385, 352, 281, 5507, 1412, 3877, 50710], "temperature": 0.0, "avg_logprob": -0.20125322826838088, "compression_ratio": 1.6555555555555554, "no_speech_prob": 0.018566971644759178}, {"id": 152, "seek": 93452, "start": 941.4399999999999, "end": 946.48, "text": " layouts. Now, this starts off looking fairly simple. We say, you know, this is some kind", "tokens": [50710, 46100, 13, 823, 11, 341, 3719, 766, 1237, 6457, 2199, 13, 492, 584, 11, 291, 458, 11, 341, 307, 512, 733, 50962], "temperature": 0.0, "avg_logprob": -0.20125322826838088, "compression_ratio": 1.6555555555555554, "no_speech_prob": 0.018566971644759178}, {"id": 153, "seek": 93452, "start": 946.48, "end": 952.56, "text": " of data structure. Let's make it compatible between Intel and ARM. Obviously, we can't", "tokens": [50962, 295, 1412, 3877, 13, 961, 311, 652, 309, 18218, 1296, 19762, 293, 45209, 13, 7580, 11, 321, 393, 380, 51266], "temperature": 0.0, "avg_logprob": -0.20125322826838088, "compression_ratio": 1.6555555555555554, "no_speech_prob": 0.018566971644759178}, {"id": 154, "seek": 93452, "start": 952.56, "end": 956.56, "text": " change the Intel code, the whole point is we're kind of running free existing Intel code", "tokens": [51266, 1319, 264, 19762, 3089, 11, 264, 1379, 935, 307, 321, 434, 733, 295, 2614, 1737, 6741, 19762, 3089, 51466], "temperature": 0.0, "avg_logprob": -0.20125322826838088, "compression_ratio": 1.6555555555555554, "no_speech_prob": 0.018566971644759178}, {"id": 155, "seek": 93452, "start": 956.56, "end": 962.88, "text": " under emulation. So, we have to, you know, in ARM 64 EC mode, all of these types need", "tokens": [51466, 833, 846, 2776, 13, 407, 11, 321, 362, 281, 11, 291, 458, 11, 294, 45209, 12145, 19081, 4391, 11, 439, 295, 613, 3467, 643, 51782], "temperature": 0.0, "avg_logprob": -0.20125322826838088, "compression_ratio": 1.6555555555555554, "no_speech_prob": 0.018566971644759178}, {"id": 156, "seek": 96288, "start": 962.92, "end": 969.36, "text": " the same size and alignment as ARM Intel. So, you know, longs are four bytes because windows", "tokens": [50366, 264, 912, 2744, 293, 18515, 382, 45209, 19762, 13, 407, 11, 291, 458, 11, 938, 82, 366, 1451, 36088, 570, 9309, 50688], "temperature": 0.0, "avg_logprob": -0.27144941850142046, "compression_ratio": 1.763779527559055, "no_speech_prob": 0.014661959372460842}, {"id": 157, "seek": 96288, "start": 969.36, "end": 975.76, "text": " doubles are eight bytes, pointers are eight bytes fine, function pointers, again, eight", "tokens": [50688, 31634, 366, 3180, 36088, 11, 44548, 366, 3180, 36088, 2489, 11, 2445, 44548, 11, 797, 11, 3180, 51008], "temperature": 0.0, "avg_logprob": -0.27144941850142046, "compression_ratio": 1.763779527559055, "no_speech_prob": 0.014661959372460842}, {"id": 158, "seek": 96288, "start": 975.76, "end": 980.96, "text": " bytes. And this being why we needed an extra bit on every page to tell you whether it's", "tokens": [51008, 36088, 13, 400, 341, 885, 983, 321, 2978, 364, 2857, 857, 322, 633, 3028, 281, 980, 291, 1968, 309, 311, 51268], "temperature": 0.0, "avg_logprob": -0.27144941850142046, "compression_ratio": 1.763779527559055, "no_speech_prob": 0.014661959372460842}, {"id": 159, "seek": 96288, "start": 980.96, "end": 988.28, "text": " Intel code or ARM code, because you might think, just like put it in the function pointer,", "tokens": [51268, 19762, 3089, 420, 45209, 3089, 11, 570, 291, 1062, 519, 11, 445, 411, 829, 309, 294, 264, 2445, 23918, 11, 51634], "temperature": 0.0, "avg_logprob": -0.27144941850142046, "compression_ratio": 1.763779527559055, "no_speech_prob": 0.014661959372460842}, {"id": 160, "seek": 96288, "start": 988.28, "end": 991.6, "text": " but like there's no space. You have to make them one bit bigger to tell you whether they", "tokens": [51634, 457, 411, 456, 311, 572, 1901, 13, 509, 362, 281, 652, 552, 472, 857, 3801, 281, 980, 291, 1968, 436, 51800], "temperature": 0.0, "avg_logprob": -0.27144941850142046, "compression_ratio": 1.763779527559055, "no_speech_prob": 0.014661959372460842}, {"id": 161, "seek": 99160, "start": 991.64, "end": 998.64, "text": " are Intel ARM pointers, which we can't do. So, we have to put that bit on the per page.", "tokens": [50366, 366, 19762, 45209, 44548, 11, 597, 321, 393, 380, 360, 13, 407, 11, 321, 362, 281, 829, 300, 857, 322, 264, 680, 3028, 13, 50716], "temperature": 0.0, "avg_logprob": -0.2064290390801184, "compression_ratio": 1.5321888412017168, "no_speech_prob": 0.005986391566693783}, {"id": 162, "seek": 99160, "start": 998.64, "end": 1005.64, "text": " But, you know, this all looks fine so far. Things get more interesting, though. So, if", "tokens": [50716, 583, 11, 291, 458, 11, 341, 439, 1542, 2489, 370, 1400, 13, 9514, 483, 544, 1880, 11, 1673, 13, 407, 11, 498, 51066], "temperature": 0.0, "avg_logprob": -0.2064290390801184, "compression_ratio": 1.5321888412017168, "no_speech_prob": 0.005986391566693783}, {"id": 163, "seek": 99160, "start": 1005.64, "end": 1010.6800000000001, "text": " you're a C programmer, you'll know about set jump and long jump, which are C's equivalence", "tokens": [51066, 291, 434, 257, 383, 32116, 11, 291, 603, 458, 466, 992, 3012, 293, 938, 3012, 11, 597, 366, 383, 311, 9052, 655, 51318], "temperature": 0.0, "avg_logprob": -0.2064290390801184, "compression_ratio": 1.5321888412017168, "no_speech_prob": 0.005986391566693783}, {"id": 164, "seek": 99160, "start": 1010.6800000000001, "end": 1016.32, "text": " to throw and catch. And there's this structure called jump buff that kind of tells you when", "tokens": [51318, 281, 3507, 293, 3745, 13, 400, 456, 311, 341, 3877, 1219, 3012, 9204, 300, 733, 295, 5112, 291, 562, 51600], "temperature": 0.0, "avg_logprob": -0.2064290390801184, "compression_ratio": 1.5321888412017168, "no_speech_prob": 0.005986391566693783}, {"id": 165, "seek": 101632, "start": 1016.36, "end": 1023.0400000000001, "text": " I catch, this is the CPU state to kind of go back to when I do my catch. And you can", "tokens": [50366, 286, 3745, 11, 341, 307, 264, 13199, 1785, 281, 733, 295, 352, 646, 281, 562, 286, 360, 452, 3745, 13, 400, 291, 393, 50700], "temperature": 0.0, "avg_logprob": -0.17854693653137704, "compression_ratio": 1.7692307692307692, "no_speech_prob": 0.008198432624340057}, {"id": 166, "seek": 101632, "start": 1023.0400000000001, "end": 1028.48, "text": " pass the jump buff, you know, around, you know, you'll set it over here and use it over", "tokens": [50700, 1320, 264, 3012, 9204, 11, 291, 458, 11, 926, 11, 291, 458, 11, 291, 603, 992, 309, 670, 510, 293, 764, 309, 670, 50972], "temperature": 0.0, "avg_logprob": -0.17854693653137704, "compression_ratio": 1.7692307692307692, "no_speech_prob": 0.008198432624340057}, {"id": 167, "seek": 101632, "start": 1028.48, "end": 1035.48, "text": " there. And in particular, in ARM 64 EC, you can do a long jump from Intel code to ARM", "tokens": [50972, 456, 13, 400, 294, 1729, 11, 294, 45209, 12145, 19081, 11, 291, 393, 360, 257, 938, 3012, 490, 19762, 3089, 281, 45209, 51322], "temperature": 0.0, "avg_logprob": -0.17854693653137704, "compression_ratio": 1.7692307692307692, "no_speech_prob": 0.008198432624340057}, {"id": 168, "seek": 101632, "start": 1035.48, "end": 1040.44, "text": " code or from ARM code to Intel code. So, this jump buff guy has to be kind of compatible", "tokens": [51322, 3089, 420, 490, 45209, 3089, 281, 19762, 3089, 13, 407, 11, 341, 3012, 9204, 2146, 575, 281, 312, 733, 295, 18218, 51570], "temperature": 0.0, "avg_logprob": -0.17854693653137704, "compression_ratio": 1.7692307692307692, "no_speech_prob": 0.008198432624340057}, {"id": 169, "seek": 101632, "start": 1040.44, "end": 1046.28, "text": " between the two. As I said, jump buff contains the CPU state that you want to go back to.", "tokens": [51570, 1296, 264, 732, 13, 1018, 286, 848, 11, 3012, 9204, 8306, 264, 13199, 1785, 300, 291, 528, 281, 352, 646, 281, 13, 51862], "temperature": 0.0, "avg_logprob": -0.17854693653137704, "compression_ratio": 1.7692307692307692, "no_speech_prob": 0.008198432624340057}, {"id": 170, "seek": 104628, "start": 1047.24, "end": 1054.24, "text": " But, like, Intel CPUs and ARM CPUs have different amounts of CPU state. So, that's going to", "tokens": [50412, 583, 11, 411, 11, 19762, 13199, 82, 293, 45209, 13199, 82, 362, 819, 11663, 295, 13199, 1785, 13, 407, 11, 300, 311, 516, 281, 50762], "temperature": 0.0, "avg_logprob": -0.18467488239720925, "compression_ratio": 1.4917355371900827, "no_speech_prob": 0.00045292507275007665}, {"id": 171, "seek": 104628, "start": 1054.24, "end": 1060.04, "text": " be fun. To make it even worse, there's this Windows structure called context in all caps", "tokens": [50762, 312, 1019, 13, 1407, 652, 309, 754, 5324, 11, 456, 311, 341, 8591, 3877, 1219, 4319, 294, 439, 13855, 51052], "temperature": 0.0, "avg_logprob": -0.18467488239720925, "compression_ratio": 1.4917355371900827, "no_speech_prob": 0.00045292507275007665}, {"id": 172, "seek": 104628, "start": 1060.04, "end": 1066.6399999999999, "text": " that contains the entire CPU state for a particular thread. But, again, you can pass around and", "tokens": [51052, 300, 8306, 264, 2302, 13199, 1785, 337, 257, 1729, 7207, 13, 583, 11, 797, 11, 291, 393, 1320, 926, 293, 51382], "temperature": 0.0, "avg_logprob": -0.18467488239720925, "compression_ratio": 1.4917355371900827, "no_speech_prob": 0.00045292507275007665}, {"id": 173, "seek": 104628, "start": 1066.6399999999999, "end": 1073.08, "text": " do things with. And, yeah, so that guy has to be the same size as on ARM 64 EC as it", "tokens": [51382, 360, 721, 365, 13, 400, 11, 1338, 11, 370, 300, 2146, 575, 281, 312, 264, 912, 2744, 382, 322, 45209, 12145, 19081, 382, 309, 51704], "temperature": 0.0, "avg_logprob": -0.18467488239720925, "compression_ratio": 1.4917355371900827, "no_speech_prob": 0.00045292507275007665}, {"id": 174, "seek": 107308, "start": 1073.12, "end": 1077.76, "text": " is on Intel, despite there being a different amount of CPU state. So, this is starting to", "tokens": [50366, 307, 322, 19762, 11, 7228, 456, 885, 257, 819, 2372, 295, 13199, 1785, 13, 407, 11, 341, 307, 2891, 281, 50598], "temperature": 0.0, "avg_logprob": -0.19542972246805826, "compression_ratio": 1.5855855855855856, "no_speech_prob": 0.004343720618635416}, {"id": 175, "seek": 107308, "start": 1077.76, "end": 1086.76, "text": " look a little hairy. So, what is all of the CPU state that we have to fit in to make these", "tokens": [50598, 574, 257, 707, 42346, 13, 407, 11, 437, 307, 439, 295, 264, 13199, 1785, 300, 321, 362, 281, 3318, 294, 281, 652, 613, 51048], "temperature": 0.0, "avg_logprob": -0.19542972246805826, "compression_ratio": 1.5855855855855856, "no_speech_prob": 0.004343720618635416}, {"id": 176, "seek": 107308, "start": 1086.76, "end": 1091.72, "text": " data structures compatible? So, we want a quick table here of, like, the user-visible", "tokens": [51048, 1412, 9227, 18218, 30, 407, 11, 321, 528, 257, 1702, 3199, 510, 295, 11, 411, 11, 264, 4195, 12, 48990, 51296], "temperature": 0.0, "avg_logprob": -0.19542972246805826, "compression_ratio": 1.5855855855855856, "no_speech_prob": 0.004343720618635416}, {"id": 177, "seek": 107308, "start": 1091.72, "end": 1098.56, "text": " CPU state on Intel and on ARM. ARM in one column, Intel in the other. I'm going to go", "tokens": [51296, 13199, 1785, 322, 19762, 293, 322, 45209, 13, 45209, 294, 472, 7738, 11, 19762, 294, 264, 661, 13, 286, 478, 516, 281, 352, 51638], "temperature": 0.0, "avg_logprob": -0.19542972246805826, "compression_ratio": 1.5855855855855856, "no_speech_prob": 0.004343720618635416}, {"id": 178, "seek": 109856, "start": 1098.6399999999999, "end": 1103.96, "text": " through row by row to kind of go through them quickly. To, like, general purpose registers", "tokens": [50368, 807, 5386, 538, 5386, 281, 733, 295, 352, 807, 552, 2661, 13, 1407, 11, 411, 11, 2674, 4334, 38351, 50634], "temperature": 0.0, "avg_logprob": -0.22723868233816966, "compression_ratio": 1.4875, "no_speech_prob": 0.01713397167623043}, {"id": 179, "seek": 109856, "start": 1103.96, "end": 1110.96, "text": " to start with, Intel has 16 of them, ARM has 32. You will notice we can't fit 32 into 16.", "tokens": [50634, 281, 722, 365, 11, 19762, 575, 3165, 295, 552, 11, 45209, 575, 8858, 13, 509, 486, 3449, 321, 393, 380, 3318, 8858, 666, 3165, 13, 50984], "temperature": 0.0, "avg_logprob": -0.22723868233816966, "compression_ratio": 1.4875, "no_speech_prob": 0.01713397167623043}, {"id": 180, "seek": 109856, "start": 1110.96, "end": 1116.96, "text": " This is going to be a slight problem. Next row is not so bad. We've got a bunch of, like,", "tokens": [50984, 639, 307, 516, 281, 312, 257, 4036, 1154, 13, 3087, 5386, 307, 406, 370, 1578, 13, 492, 600, 658, 257, 3840, 295, 11, 411, 11, 51284], "temperature": 0.0, "avg_logprob": -0.22723868233816966, "compression_ratio": 1.4875, "no_speech_prob": 0.01713397167623043}, {"id": 181, "seek": 109856, "start": 1116.96, "end": 1123.96, "text": " weird kind of edge cases. We've got RIP and PC. They're, like, the same thing. PSA and", "tokens": [51284, 3657, 733, 295, 4691, 3331, 13, 492, 600, 658, 497, 9139, 293, 6465, 13, 814, 434, 11, 411, 11, 264, 912, 551, 13, 8168, 32, 293, 51634], "temperature": 0.0, "avg_logprob": -0.22723868233816966, "compression_ratio": 1.4875, "no_speech_prob": 0.01713397167623043}, {"id": 182, "seek": 112396, "start": 1124.04, "end": 1130.04, "text": " PSA because they're the same thing. The two FP things on ARM, we can fit into MX, CSR", "tokens": [50368, 8168, 32, 570, 436, 434, 264, 912, 551, 13, 440, 732, 36655, 721, 322, 45209, 11, 321, 393, 3318, 666, 47509, 11, 9460, 49, 50668], "temperature": 0.0, "avg_logprob": -0.2782216698232323, "compression_ratio": 1.4625, "no_speech_prob": 0.014480343088507652}, {"id": 183, "seek": 112396, "start": 1130.04, "end": 1135.04, "text": " on Intel, but that much is fine. We've got the spare GS thing, which we'll come back", "tokens": [50668, 322, 19762, 11, 457, 300, 709, 307, 2489, 13, 492, 600, 658, 264, 13798, 32047, 551, 11, 597, 321, 603, 808, 646, 50918], "temperature": 0.0, "avg_logprob": -0.2782216698232323, "compression_ratio": 1.4625, "no_speech_prob": 0.014480343088507652}, {"id": 184, "seek": 112396, "start": 1135.04, "end": 1142.04, "text": " to later. Next row is our floating point or vector registers. Again, Intel has 16, ARM", "tokens": [50918, 281, 1780, 13, 3087, 5386, 307, 527, 12607, 935, 420, 8062, 38351, 13, 3764, 11, 19762, 575, 3165, 11, 45209, 51268], "temperature": 0.0, "avg_logprob": -0.2782216698232323, "compression_ratio": 1.4625, "no_speech_prob": 0.014480343088507652}, {"id": 185, "seek": 112396, "start": 1142.76, "end": 1149.76, "text": " has 32. 32 is more than 16. So, again, problem there. The bright sparks in the audience might", "tokens": [51304, 575, 8858, 13, 8858, 307, 544, 813, 3165, 13, 407, 11, 797, 11, 1154, 456, 13, 440, 4730, 44102, 294, 264, 4034, 1062, 51654], "temperature": 0.0, "avg_logprob": -0.2782216698232323, "compression_ratio": 1.4625, "no_speech_prob": 0.014480343088507652}, {"id": 186, "seek": 114976, "start": 1150.52, "end": 1155.52, "text": " say doesn't modern Intel with, like, AVEX 2 and AVEX 512 have far more registers than", "tokens": [50402, 584, 1177, 380, 4363, 19762, 365, 11, 411, 11, 316, 7540, 55, 568, 293, 316, 7540, 55, 1025, 4762, 362, 1400, 544, 38351, 813, 50652], "temperature": 0.0, "avg_logprob": -0.2614935592368797, "compression_ratio": 1.5411255411255411, "no_speech_prob": 0.015930943191051483}, {"id": 187, "seek": 114976, "start": 1155.52, "end": 1162.52, "text": " they're far larger. Yes, but ambient laters can't use AVEX or AVEX 2 or AVEX 512 because", "tokens": [50652, 436, 434, 1400, 4833, 13, 1079, 11, 457, 22997, 4465, 433, 393, 380, 764, 316, 7540, 55, 420, 316, 7540, 55, 568, 420, 316, 7540, 55, 1025, 4762, 570, 51002], "temperature": 0.0, "avg_logprob": -0.2614935592368797, "compression_ratio": 1.5411255411255411, "no_speech_prob": 0.015930943191051483}, {"id": 188, "seek": 114976, "start": 1162.96, "end": 1167.96, "text": " of patents. So, we're stuck with the kind of old, kind of, 16 of them and not only 128", "tokens": [51024, 295, 38142, 13, 407, 11, 321, 434, 5541, 365, 264, 733, 295, 1331, 11, 733, 295, 11, 3165, 295, 552, 293, 406, 787, 29810, 51274], "temperature": 0.0, "avg_logprob": -0.2614935592368797, "compression_ratio": 1.5411255411255411, "no_speech_prob": 0.015930943191051483}, {"id": 189, "seek": 114976, "start": 1167.96, "end": 1174.96, "text": " bits wide. This final row is interesting because Intel way back added the AVEX 87 stack, which", "tokens": [51274, 9239, 4874, 13, 639, 2572, 5386, 307, 1880, 570, 19762, 636, 646, 3869, 264, 316, 7540, 55, 27990, 8630, 11, 597, 51624], "temperature": 0.0, "avg_logprob": -0.2614935592368797, "compression_ratio": 1.5411255411255411, "no_speech_prob": 0.015930943191051483}, {"id": 190, "seek": 117496, "start": 1175.96, "end": 1182.96, "text": " is 880-bit floating point registers. ARM has no such thing because this is, like, this", "tokens": [50414, 307, 1649, 4702, 12, 5260, 12607, 935, 38351, 13, 45209, 575, 572, 1270, 551, 570, 341, 307, 11, 411, 11, 341, 50764], "temperature": 0.0, "avg_logprob": -0.19733272351716694, "compression_ratio": 1.6063348416289593, "no_speech_prob": 0.0020535816438496113}, {"id": 191, "seek": 117496, "start": 1184.28, "end": 1191.28, "text": " old weird, like, legacy thing, but this is actually really good for us. So, our question", "tokens": [50830, 1331, 3657, 11, 411, 11, 11711, 551, 11, 457, 341, 307, 767, 534, 665, 337, 505, 13, 407, 11, 527, 1168, 51180], "temperature": 0.0, "avg_logprob": -0.19733272351716694, "compression_ratio": 1.6063348416289593, "no_speech_prob": 0.0020535816438496113}, {"id": 192, "seek": 117496, "start": 1191.32, "end": 1198.32, "text": " is how do we fit all of the ARM column into the Intel column? So, let's start with the", "tokens": [51182, 307, 577, 360, 321, 3318, 439, 295, 264, 45209, 7738, 666, 264, 19762, 7738, 30, 407, 11, 718, 311, 722, 365, 264, 51532], "temperature": 0.0, "avg_logprob": -0.19733272351716694, "compression_ratio": 1.6063348416289593, "no_speech_prob": 0.0020535816438496113}, {"id": 193, "seek": 117496, "start": 1198.52, "end": 1204.72, "text": " floating point registers and we'll say, okay, let's pretend ARM only has 16 of them. Problem", "tokens": [51542, 12607, 935, 38351, 293, 321, 603, 584, 11, 1392, 11, 718, 311, 11865, 45209, 787, 575, 3165, 295, 552, 13, 11676, 51852], "temperature": 0.0, "avg_logprob": -0.19733272351716694, "compression_ratio": 1.6063348416289593, "no_speech_prob": 0.0020535816438496113}, {"id": 194, "seek": 120472, "start": 1204.76, "end": 1211.76, "text": " solved, right? If you're writing ARM 64 EC code, you cannot use the high 16 of these", "tokens": [50366, 13041, 11, 558, 30, 759, 291, 434, 3579, 45209, 12145, 19081, 3089, 11, 291, 2644, 764, 264, 1090, 3165, 295, 613, 50716], "temperature": 0.0, "avg_logprob": -0.24377651603854433, "compression_ratio": 1.4703389830508475, "no_speech_prob": 0.0030281494837254286}, {"id": 195, "seek": 120472, "start": 1211.84, "end": 1218.84, "text": " guys. I mean, it'll come in a performance cost, but it'll make things work. The other", "tokens": [50720, 1074, 13, 286, 914, 11, 309, 603, 808, 294, 257, 3389, 2063, 11, 457, 309, 603, 652, 721, 589, 13, 440, 661, 51070], "temperature": 0.0, "avg_logprob": -0.24377651603854433, "compression_ratio": 1.4703389830508475, "no_speech_prob": 0.0030281494837254286}, {"id": 196, "seek": 120472, "start": 1219.0, "end": 1224.4, "text": " way we had problem was with this first row, where we'd like to be not quite as extreme", "tokens": [51078, 636, 321, 632, 1154, 390, 365, 341, 700, 5386, 11, 689, 321, 1116, 411, 281, 312, 406, 1596, 382, 8084, 51348], "temperature": 0.0, "avg_logprob": -0.24377651603854433, "compression_ratio": 1.4703389830508475, "no_speech_prob": 0.0030281494837254286}, {"id": 197, "seek": 120472, "start": 1224.4, "end": 1230.68, "text": " as throwing away half of them. So, we've got, like, 16 that we can fit over here. One can", "tokens": [51348, 382, 10238, 1314, 1922, 295, 552, 13, 407, 11, 321, 600, 658, 11, 411, 11, 3165, 300, 321, 393, 3318, 670, 510, 13, 1485, 393, 51662], "temperature": 0.0, "avg_logprob": -0.24377651603854433, "compression_ratio": 1.4703389830508475, "no_speech_prob": 0.0030281494837254286}, {"id": 198, "seek": 123068, "start": 1230.72, "end": 1237.72, "text": " fit in GS and then 10 can fit down there. So, 16 plus 1 plus 10 means we can fit 27 of", "tokens": [50366, 3318, 294, 32047, 293, 550, 1266, 393, 3318, 760, 456, 13, 407, 11, 3165, 1804, 502, 1804, 1266, 1355, 321, 393, 3318, 7634, 295, 50716], "temperature": 0.0, "avg_logprob": -0.2327810574884284, "compression_ratio": 1.463276836158192, "no_speech_prob": 0.03825265169143677}, {"id": 199, "seek": 123068, "start": 1239.88, "end": 1246.88, "text": " these guys in here somewhere. It works, it works. But we are still down 5. So, they'll", "tokens": [50824, 613, 1074, 294, 510, 4079, 13, 467, 1985, 11, 309, 1985, 13, 583, 321, 366, 920, 760, 1025, 13, 407, 11, 436, 603, 51174], "temperature": 0.0, "avg_logprob": -0.2327810574884284, "compression_ratio": 1.463276836158192, "no_speech_prob": 0.03825265169143677}, {"id": 200, "seek": 123068, "start": 1250.3200000000002, "end": 1255.76, "text": " become 5 general purpose registers that you cannot use. So, Microsoft said, okay, you", "tokens": [51346, 1813, 1025, 2674, 4334, 38351, 300, 291, 2644, 764, 13, 407, 11, 8116, 848, 11, 1392, 11, 291, 51618], "temperature": 0.0, "avg_logprob": -0.2327810574884284, "compression_ratio": 1.463276836158192, "no_speech_prob": 0.03825265169143677}, {"id": 201, "seek": 125576, "start": 1255.84, "end": 1262.84, "text": " just can't use X13, X14, X23, X24 or X28 in addition to the 16 factor things that you", "tokens": [50368, 445, 393, 380, 764, 1783, 7668, 11, 1783, 7271, 11, 1783, 9356, 11, 1783, 7911, 420, 1783, 11205, 294, 4500, 281, 264, 3165, 5952, 721, 300, 291, 50718], "temperature": 0.0, "avg_logprob": -0.2212955826207211, "compression_ratio": 1.4262295081967213, "no_speech_prob": 0.0015494856052100658}, {"id": 202, "seek": 125576, "start": 1264.8, "end": 1270.48, "text": " cannot use. So, this is the cost of making your data structures compatible between the", "tokens": [50816, 2644, 764, 13, 407, 11, 341, 307, 264, 2063, 295, 1455, 428, 1412, 9227, 18218, 1296, 264, 51100], "temperature": 0.0, "avg_logprob": -0.2212955826207211, "compression_ratio": 1.4262295081967213, "no_speech_prob": 0.0015494856052100658}, {"id": 203, "seek": 125576, "start": 1270.48, "end": 1277.48, "text": " two and it seems like a fairly high cost, but, you know, such is life. Moving on, we are", "tokens": [51100, 732, 293, 309, 2544, 411, 257, 6457, 1090, 2063, 11, 457, 11, 291, 458, 11, 1270, 307, 993, 13, 14242, 322, 11, 321, 366, 51450], "temperature": 0.0, "avg_logprob": -0.2212955826207211, "compression_ratio": 1.4262295081967213, "no_speech_prob": 0.0015494856052100658}, {"id": 204, "seek": 127748, "start": 1277.8, "end": 1284.8, "text": " sharing our call stacks between Intel and ARM. If you're familiar with Intel and ARM,", "tokens": [50380, 5414, 527, 818, 30792, 1296, 19762, 293, 45209, 13, 759, 291, 434, 4963, 365, 19762, 293, 45209, 11, 50730], "temperature": 0.0, "avg_logprob": -0.24742502732710406, "compression_ratio": 1.6176470588235294, "no_speech_prob": 0.006239759735763073}, {"id": 205, "seek": 127748, "start": 1285.4, "end": 1289.3600000000001, "text": " your first point will be, so, doesn't like ARM put the return address in a register,", "tokens": [50760, 428, 700, 935, 486, 312, 11, 370, 11, 1177, 380, 411, 45209, 829, 264, 2736, 2985, 294, 257, 7280, 11, 50958], "temperature": 0.0, "avg_logprob": -0.24742502732710406, "compression_ratio": 1.6176470588235294, "no_speech_prob": 0.006239759735763073}, {"id": 206, "seek": 127748, "start": 1289.3600000000001, "end": 1294.84, "text": " whereas Intel puts it on the stack. Yes, we're going to have to fix that one up. The problem", "tokens": [50958, 9735, 19762, 8137, 309, 322, 264, 8630, 13, 1079, 11, 321, 434, 516, 281, 362, 281, 3191, 300, 472, 493, 13, 440, 1154, 51232], "temperature": 0.0, "avg_logprob": -0.24742502732710406, "compression_ratio": 1.6176470588235294, "no_speech_prob": 0.006239759735763073}, {"id": 207, "seek": 127748, "start": 1294.84, "end": 1300.28, "text": " that you might not have noticed was that ARM requires your stack points to be 16-byte", "tokens": [51232, 300, 291, 1062, 406, 362, 5694, 390, 300, 45209, 7029, 428, 8630, 2793, 281, 312, 3165, 12, 2322, 975, 51504], "temperature": 0.0, "avg_logprob": -0.24742502732710406, "compression_ratio": 1.6176470588235294, "no_speech_prob": 0.006239759735763073}, {"id": 208, "seek": 127748, "start": 1300.28, "end": 1307.28, "text": " aligned when you use it for a load or a store. Intel merely recommends this very strongly.", "tokens": [51504, 17962, 562, 291, 764, 309, 337, 257, 3677, 420, 257, 3531, 13, 19762, 17003, 34556, 341, 588, 10613, 13, 51854], "temperature": 0.0, "avg_logprob": -0.24742502732710406, "compression_ratio": 1.6176470588235294, "no_speech_prob": 0.006239759735763073}, {"id": 209, "seek": 130748, "start": 1307.76, "end": 1313.64, "text": " But doesn't actually check for it. So, you can very happily run with an only eight-byte", "tokens": [50378, 583, 1177, 380, 767, 1520, 337, 309, 13, 407, 11, 291, 393, 588, 19909, 1190, 365, 364, 787, 3180, 12, 2322, 975, 50672], "temperature": 0.0, "avg_logprob": -0.16988929244112377, "compression_ratio": 1.7743190661478598, "no_speech_prob": 0.0011133798398077488}, {"id": 210, "seek": 130748, "start": 1313.64, "end": 1318.96, "text": " aligned stack for a very long time and not notice that you've done anything wrong because", "tokens": [50672, 17962, 8630, 337, 257, 588, 938, 565, 293, 406, 3449, 300, 291, 600, 1096, 1340, 2085, 570, 50938], "temperature": 0.0, "avg_logprob": -0.16988929244112377, "compression_ratio": 1.7743190661478598, "no_speech_prob": 0.0011133798398077488}, {"id": 211, "seek": 130748, "start": 1318.96, "end": 1322.6, "text": " it doesn't actually check for it. So, we're going to have to fix that one up, that one", "tokens": [50938, 309, 1177, 380, 767, 1520, 337, 309, 13, 407, 11, 321, 434, 516, 281, 362, 281, 3191, 300, 472, 493, 11, 300, 472, 51120], "temperature": 0.0, "avg_logprob": -0.16988929244112377, "compression_ratio": 1.7743190661478598, "no_speech_prob": 0.0011133798398077488}, {"id": 212, "seek": 130748, "start": 1322.6, "end": 1327.92, "text": " up too. So, a bit of work required to make these things work, but, you know, we can understand", "tokens": [51120, 493, 886, 13, 407, 11, 257, 857, 295, 589, 4739, 281, 652, 613, 721, 589, 11, 457, 11, 291, 458, 11, 321, 393, 1223, 51386], "temperature": 0.0, "avg_logprob": -0.16988929244112377, "compression_ratio": 1.7743190661478598, "no_speech_prob": 0.0011133798398077488}, {"id": 213, "seek": 130748, "start": 1327.92, "end": 1333.2, "text": " what that work is. And then we get to the actual meter things of, like, how do we switch between", "tokens": [51386, 437, 300, 589, 307, 13, 400, 550, 321, 483, 281, 264, 3539, 9255, 721, 295, 11, 411, 11, 577, 360, 321, 3679, 1296, 51650], "temperature": 0.0, "avg_logprob": -0.16988929244112377, "compression_ratio": 1.7743190661478598, "no_speech_prob": 0.0011133798398077488}, {"id": 214, "seek": 133320, "start": 1333.2, "end": 1337.44, "text": " these two modes? We've made these things of compatible-ish or we've understood how", "tokens": [50364, 613, 732, 14068, 30, 492, 600, 1027, 613, 721, 295, 18218, 12, 742, 420, 321, 600, 7320, 577, 50576], "temperature": 0.0, "avg_logprob": -0.22544815665797183, "compression_ratio": 1.6806083650190113, "no_speech_prob": 0.005430035293102264}, {"id": 215, "seek": 133320, "start": 1337.44, "end": 1344.44, "text": " to make them compatible, but how do we actually switch between Intel and ARM? So, if you're", "tokens": [50576, 281, 652, 552, 18218, 11, 457, 577, 360, 321, 767, 3679, 1296, 19762, 293, 45209, 30, 407, 11, 498, 291, 434, 50926], "temperature": 0.0, "avg_logprob": -0.22544815665797183, "compression_ratio": 1.6806083650190113, "no_speech_prob": 0.005430035293102264}, {"id": 216, "seek": 133320, "start": 1345.28, "end": 1348.96, "text": " at use for assembly, you'll know what a calling convention is, which is, like, when we make", "tokens": [50968, 412, 764, 337, 12103, 11, 291, 603, 458, 437, 257, 5141, 10286, 307, 11, 597, 307, 11, 411, 11, 562, 321, 652, 51152], "temperature": 0.0, "avg_logprob": -0.22544815665797183, "compression_ratio": 1.6806083650190113, "no_speech_prob": 0.005430035293102264}, {"id": 217, "seek": 133320, "start": 1348.96, "end": 1355.44, "text": " a function call, where do we put the arguments for that call? Which registers contain when", "tokens": [51152, 257, 2445, 818, 11, 689, 360, 321, 829, 264, 12869, 337, 300, 818, 30, 3013, 38351, 5304, 562, 51476], "temperature": 0.0, "avg_logprob": -0.22544815665797183, "compression_ratio": 1.6806083650190113, "no_speech_prob": 0.005430035293102264}, {"id": 218, "seek": 133320, "start": 1355.44, "end": 1360.24, "text": " or what do you put on the stack when? And then, like, you can read these, like, long", "tokens": [51476, 420, 437, 360, 291, 829, 322, 264, 8630, 562, 30, 400, 550, 11, 411, 11, 291, 393, 1401, 613, 11, 411, 11, 938, 51716], "temperature": 0.0, "avg_logprob": -0.22544815665797183, "compression_ratio": 1.6806083650190113, "no_speech_prob": 0.005430035293102264}, {"id": 219, "seek": 136024, "start": 1360.28, "end": 1366.56, "text": " docs from ARM or from, like, other people about how to do this. And then there's a set", "tokens": [50366, 45623, 490, 45209, 420, 490, 11, 411, 11, 661, 561, 466, 577, 281, 360, 341, 13, 400, 550, 456, 311, 257, 992, 50680], "temperature": 0.0, "avg_logprob": -0.1685821215311686, "compression_ratio": 1.7265625, "no_speech_prob": 0.01800348423421383}, {"id": 220, "seek": 136024, "start": 1366.56, "end": 1371.64, "text": " of these rules for ARM, a set of these rules for Intel. We don't want to change those rules", "tokens": [50680, 295, 613, 4474, 337, 45209, 11, 257, 992, 295, 613, 4474, 337, 19762, 13, 492, 500, 380, 528, 281, 1319, 729, 4474, 50934], "temperature": 0.0, "avg_logprob": -0.1685821215311686, "compression_ratio": 1.7265625, "no_speech_prob": 0.01800348423421383}, {"id": 221, "seek": 136024, "start": 1371.64, "end": 1377.0, "text": " too much because, like, they mostly work, but they're not the same rules. You have to,", "tokens": [50934, 886, 709, 570, 11, 411, 11, 436, 5240, 589, 11, 457, 436, 434, 406, 264, 912, 4474, 13, 509, 362, 281, 11, 51202], "temperature": 0.0, "avg_logprob": -0.1685821215311686, "compression_ratio": 1.7265625, "no_speech_prob": 0.01800348423421383}, {"id": 222, "seek": 136024, "start": 1377.0, "end": 1382.64, "text": " like, put things in different places between Intel and ARM. So, we have to do some work", "tokens": [51202, 411, 11, 829, 721, 294, 819, 3190, 1296, 19762, 293, 45209, 13, 407, 11, 321, 362, 281, 360, 512, 589, 51484], "temperature": 0.0, "avg_logprob": -0.1685821215311686, "compression_ratio": 1.7265625, "no_speech_prob": 0.01800348423421383}, {"id": 223, "seek": 136024, "start": 1382.64, "end": 1387.96, "text": " to kind of fix that one up. And the work that you have to do will depend on the types of", "tokens": [51484, 281, 733, 295, 3191, 300, 472, 493, 13, 400, 264, 589, 300, 291, 362, 281, 360, 486, 5672, 322, 264, 3467, 295, 51750], "temperature": 0.0, "avg_logprob": -0.1685821215311686, "compression_ratio": 1.7265625, "no_speech_prob": 0.01800348423421383}, {"id": 224, "seek": 138796, "start": 1388.0, "end": 1393.76, "text": " the arguments and the type of the return value of your function. So, we're going to need", "tokens": [50366, 264, 12869, 293, 264, 2010, 295, 264, 2736, 2158, 295, 428, 2445, 13, 407, 11, 321, 434, 516, 281, 643, 50654], "temperature": 0.0, "avg_logprob": -0.19874336844996401, "compression_ratio": 1.688715953307393, "no_speech_prob": 0.002277427352964878}, {"id": 225, "seek": 138796, "start": 1393.76, "end": 1398.16, "text": " some kind of code for doing this work, and this code has to live on the ARM side of things", "tokens": [50654, 512, 733, 295, 3089, 337, 884, 341, 589, 11, 293, 341, 3089, 575, 281, 1621, 322, 264, 45209, 1252, 295, 721, 50874], "temperature": 0.0, "avg_logprob": -0.19874336844996401, "compression_ratio": 1.688715953307393, "no_speech_prob": 0.002277427352964878}, {"id": 226, "seek": 138796, "start": 1398.16, "end": 1402.16, "text": " because, again, we're trying to run Intel code that doesn't know it's running under", "tokens": [50874, 570, 11, 797, 11, 321, 434, 1382, 281, 1190, 19762, 3089, 300, 1177, 380, 458, 309, 311, 2614, 833, 51074], "temperature": 0.0, "avg_logprob": -0.19874336844996401, "compression_ratio": 1.688715953307393, "no_speech_prob": 0.002277427352964878}, {"id": 227, "seek": 138796, "start": 1402.16, "end": 1406.88, "text": " emulation, so we can't change it. We can't add extra stuff in there. We have to add", "tokens": [51074, 846, 2776, 11, 370, 321, 393, 380, 1319, 309, 13, 492, 393, 380, 909, 2857, 1507, 294, 456, 13, 492, 362, 281, 909, 51310], "temperature": 0.0, "avg_logprob": -0.19874336844996401, "compression_ratio": 1.688715953307393, "no_speech_prob": 0.002277427352964878}, {"id": 228, "seek": 138796, "start": 1406.88, "end": 1413.88, "text": " the extra stuff on the ARM side, which means if you're writing assembly code in ARM 64", "tokens": [51310, 264, 2857, 1507, 322, 264, 45209, 1252, 11, 597, 1355, 498, 291, 434, 3579, 12103, 3089, 294, 45209, 12145, 51660], "temperature": 0.0, "avg_logprob": -0.19874336844996401, "compression_ratio": 1.688715953307393, "no_speech_prob": 0.002277427352964878}, {"id": 229, "seek": 141388, "start": 1413.88, "end": 1419.88, "text": " it's like, how do I do a function call? This is how you do a function call. Step one,", "tokens": [50364, 309, 311, 411, 11, 577, 360, 286, 360, 257, 2445, 818, 30, 639, 307, 577, 291, 360, 257, 2445, 818, 13, 5470, 472, 11, 50664], "temperature": 0.0, "avg_logprob": -0.22667195720057334, "compression_ratio": 1.7072243346007605, "no_speech_prob": 0.05112532526254654}, {"id": 230, "seek": 141388, "start": 1419.88, "end": 1424.88, "text": " as you would normally put the arguments where they would be for a normal ARM call, and then,", "tokens": [50664, 382, 291, 576, 5646, 829, 264, 12869, 689, 436, 576, 312, 337, 257, 2710, 45209, 818, 11, 293, 550, 11, 50914], "temperature": 0.0, "avg_logprob": -0.22667195720057334, "compression_ratio": 1.7072243346007605, "no_speech_prob": 0.05112532526254654}, {"id": 231, "seek": 141388, "start": 1424.88, "end": 1429.88, "text": " like, so, am I calling Intel or am I calling ARM? On the left-hand side, we've got the", "tokens": [50914, 411, 11, 370, 11, 669, 286, 5141, 19762, 420, 669, 286, 5141, 45209, 30, 1282, 264, 1411, 12, 5543, 1252, 11, 321, 600, 658, 264, 51164], "temperature": 0.0, "avg_logprob": -0.22667195720057334, "compression_ratio": 1.7072243346007605, "no_speech_prob": 0.05112532526254654}, {"id": 232, "seek": 141388, "start": 1429.88, "end": 1436.88, "text": " am I calling ARM column, and it, again, works like a normal ARM call other than this mystery", "tokens": [51164, 669, 286, 5141, 45209, 7738, 11, 293, 309, 11, 797, 11, 1985, 411, 257, 2710, 45209, 818, 661, 813, 341, 11422, 51514], "temperature": 0.0, "avg_logprob": -0.22667195720057334, "compression_ratio": 1.7072243346007605, "no_speech_prob": 0.05112532526254654}, {"id": 233, "seek": 141388, "start": 1437.3600000000001, "end": 1443.2, "text": " box about exit points in X10 that I'm going to gloss over from now and come back to later.", "tokens": [51538, 2424, 466, 11043, 2793, 294, 1783, 3279, 300, 286, 478, 516, 281, 19574, 670, 490, 586, 293, 808, 646, 281, 1780, 13, 51830], "temperature": 0.0, "avg_logprob": -0.22667195720057334, "compression_ratio": 1.7072243346007605, "no_speech_prob": 0.05112532526254654}, {"id": 234, "seek": 144320, "start": 1443.2, "end": 1448.48, "text": " But other than that box, the left-hand column is a fairly normal function call on ARM. You", "tokens": [50364, 583, 661, 813, 300, 2424, 11, 264, 1411, 12, 5543, 7738, 307, 257, 6457, 2710, 2445, 818, 322, 45209, 13, 509, 50628], "temperature": 0.0, "avg_logprob": -0.18141366724382368, "compression_ratio": 1.7845528455284554, "no_speech_prob": 0.0023217308335006237}, {"id": 235, "seek": 144320, "start": 1448.48, "end": 1451.68, "text": " put the results where they're meant to be, you call the function, you get the results", "tokens": [50628, 829, 264, 3542, 689, 436, 434, 4140, 281, 312, 11, 291, 818, 264, 2445, 11, 291, 483, 264, 3542, 50788], "temperature": 0.0, "avg_logprob": -0.18141366724382368, "compression_ratio": 1.7845528455284554, "no_speech_prob": 0.0023217308335006237}, {"id": 236, "seek": 144320, "start": 1451.68, "end": 1457.44, "text": " back from where they are normally meant to be. The weird case is the Intel case on the", "tokens": [50788, 646, 490, 689, 436, 366, 5646, 4140, 281, 312, 13, 440, 3657, 1389, 307, 264, 19762, 1389, 322, 264, 51076], "temperature": 0.0, "avg_logprob": -0.18141366724382368, "compression_ratio": 1.7845528455284554, "no_speech_prob": 0.0023217308335006237}, {"id": 237, "seek": 144320, "start": 1457.44, "end": 1461.6000000000001, "text": " right here, where we reduce some other things. Where we put the function that we want to", "tokens": [51076, 558, 510, 11, 689, 321, 5407, 512, 661, 721, 13, 2305, 321, 829, 264, 2445, 300, 321, 528, 281, 51284], "temperature": 0.0, "avg_logprob": -0.18141366724382368, "compression_ratio": 1.7845528455284554, "no_speech_prob": 0.0023217308335006237}, {"id": 238, "seek": 144320, "start": 1461.6000000000001, "end": 1468.6000000000001, "text": " call in the X9 register, has to be X9, and then we call an exit function. You're going", "tokens": [51284, 818, 294, 264, 1783, 24, 7280, 11, 575, 281, 312, 1783, 24, 11, 293, 550, 321, 818, 364, 11043, 2445, 13, 509, 434, 516, 51634], "temperature": 0.0, "avg_logprob": -0.18141366724382368, "compression_ratio": 1.7845528455284554, "no_speech_prob": 0.0023217308335006237}, {"id": 239, "seek": 146860, "start": 1469.3999999999999, "end": 1475.3999999999999, "text": " to say, Peter, what is an exit function? And I will get to that in just a bit, but I want", "tokens": [50404, 281, 584, 11, 6508, 11, 437, 307, 364, 11043, 2445, 30, 400, 286, 486, 483, 281, 300, 294, 445, 257, 857, 11, 457, 286, 528, 50704], "temperature": 0.0, "avg_logprob": -0.2267453384399414, "compression_ratio": 1.5701754385964912, "no_speech_prob": 0.012237883172929287}, {"id": 240, "seek": 146860, "start": 1475.3999999999999, "end": 1481.7199999999998, "text": " to address a different point first, which is this code has a branch in it, right? Everyone", "tokens": [50704, 281, 2985, 257, 819, 935, 700, 11, 597, 307, 341, 3089, 575, 257, 9819, 294, 309, 11, 558, 30, 5198, 51020], "temperature": 0.0, "avg_logprob": -0.2267453384399414, "compression_ratio": 1.5701754385964912, "no_speech_prob": 0.012237883172929287}, {"id": 241, "seek": 146860, "start": 1481.7199999999998, "end": 1488.7199999999998, "text": " prefers straight line code to branchy code. But, like, we can get rid of these branches,", "tokens": [51020, 44334, 2997, 1622, 3089, 281, 9819, 88, 3089, 13, 583, 11, 411, 11, 321, 393, 483, 3973, 295, 613, 14770, 11, 51370], "temperature": 0.0, "avg_logprob": -0.2267453384399414, "compression_ratio": 1.5701754385964912, "no_speech_prob": 0.012237883172929287}, {"id": 242, "seek": 146860, "start": 1488.7199999999998, "end": 1492.8799999999999, "text": " mostly. You know, we'll have to have to do, like, both of these two steps, and push them", "tokens": [51370, 5240, 13, 509, 458, 11, 321, 603, 362, 281, 362, 281, 360, 11, 411, 11, 1293, 295, 613, 732, 4439, 11, 293, 2944, 552, 51578], "temperature": 0.0, "avg_logprob": -0.2267453384399414, "compression_ratio": 1.5701754385964912, "no_speech_prob": 0.012237883172929287}, {"id": 243, "seek": 149288, "start": 1492.88, "end": 1498.92, "text": " up there, and then combine both of the calls. Because, like, this row, we're going to do", "tokens": [50364, 493, 456, 11, 293, 550, 10432, 1293, 295, 264, 5498, 13, 1436, 11, 411, 11, 341, 5386, 11, 321, 434, 516, 281, 360, 50666], "temperature": 0.0, "avg_logprob": -0.18930351443407012, "compression_ratio": 1.7176470588235293, "no_speech_prob": 0.02834324911236763}, {"id": 244, "seek": 149288, "start": 1498.92, "end": 1505.4, "text": " a function call. We just don't know, like, where to yet. So, like, some kind of, like,", "tokens": [50666, 257, 2445, 818, 13, 492, 445, 500, 380, 458, 11, 411, 11, 689, 281, 1939, 13, 407, 11, 411, 11, 512, 733, 295, 11, 411, 11, 50990], "temperature": 0.0, "avg_logprob": -0.18930351443407012, "compression_ratio": 1.7176470588235293, "no_speech_prob": 0.02834324911236763}, {"id": 245, "seek": 149288, "start": 1505.4, "end": 1508.96, "text": " conditional marks on where we want to call. And then we can make this whole lot straight", "tokens": [50990, 27708, 10640, 322, 689, 321, 528, 281, 818, 13, 400, 550, 321, 393, 652, 341, 1379, 688, 2997, 51168], "temperature": 0.0, "avg_logprob": -0.18930351443407012, "compression_ratio": 1.7176470588235293, "no_speech_prob": 0.02834324911236763}, {"id": 246, "seek": 149288, "start": 1508.96, "end": 1514.8400000000001, "text": " line code. At which point, it'll look like this. You know, first box is the same. Second", "tokens": [51168, 1622, 3089, 13, 1711, 597, 935, 11, 309, 603, 574, 411, 341, 13, 509, 458, 11, 700, 2424, 307, 264, 912, 13, 5736, 51462], "temperature": 0.0, "avg_logprob": -0.18930351443407012, "compression_ratio": 1.7176470588235293, "no_speech_prob": 0.02834324911236763}, {"id": 247, "seek": 149288, "start": 1514.8400000000001, "end": 1519.0, "text": " box is, like, we've pulled up both of the previous steps and just done both of them.", "tokens": [51462, 2424, 307, 11, 411, 11, 321, 600, 7373, 493, 1293, 295, 264, 3894, 4439, 293, 445, 1096, 1293, 295, 552, 13, 51670], "temperature": 0.0, "avg_logprob": -0.18930351443407012, "compression_ratio": 1.7176470588235293, "no_speech_prob": 0.02834324911236763}, {"id": 248, "seek": 151900, "start": 1519.12, "end": 1527.12, "text": " This middle step is calling this magical mystery function from Microsoft. And then you do a", "tokens": [50370, 639, 2808, 1823, 307, 5141, 341, 12066, 11422, 2445, 490, 8116, 13, 400, 550, 291, 360, 257, 50770], "temperature": 0.0, "avg_logprob": -0.20919464374410696, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.00660164188593626}, {"id": 249, "seek": 151900, "start": 1527.12, "end": 1532.64, "text": " call to somewhere. And then this last box is the same as previously. And if you're wondering,", "tokens": [50770, 818, 281, 4079, 13, 400, 550, 341, 1036, 2424, 307, 264, 912, 382, 8046, 13, 400, 498, 291, 434, 6359, 11, 51046], "temperature": 0.0, "avg_logprob": -0.20919464374410696, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.00660164188593626}, {"id": 250, "seek": 151900, "start": 1532.64, "end": 1537.44, "text": " what does this magical mystery function from Microsoft do? You know, it turns this side", "tokens": [51046, 437, 775, 341, 12066, 11422, 2445, 490, 8116, 360, 30, 509, 458, 11, 309, 4523, 341, 1252, 51286], "temperature": 0.0, "avg_logprob": -0.20919464374410696, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.00660164188593626}, {"id": 251, "seek": 151900, "start": 1537.44, "end": 1544.44, "text": " back into this side. I mean, so, if you're reading assembly code, this is what you will", "tokens": [51286, 646, 666, 341, 1252, 13, 286, 914, 11, 370, 11, 498, 291, 434, 3760, 12103, 3089, 11, 341, 307, 437, 291, 486, 51636], "temperature": 0.0, "avg_logprob": -0.20919464374410696, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.00660164188593626}, {"id": 252, "seek": 154444, "start": 1544.48, "end": 1551.0800000000002, "text": " see, but this is what it does. And now, I'll get to the previous point of so, what are", "tokens": [50366, 536, 11, 457, 341, 307, 437, 309, 775, 13, 400, 586, 11, 286, 603, 483, 281, 264, 3894, 935, 295, 370, 11, 437, 366, 50696], "temperature": 0.0, "avg_logprob": -0.2546240111528817, "compression_ratio": 1.693798449612403, "no_speech_prob": 0.01357150636613369}, {"id": 253, "seek": 154444, "start": 1551.0800000000002, "end": 1557.68, "text": " these exit functions? So, they kind of fill the gap in. They kind of, the extra bits you", "tokens": [50696, 613, 11043, 6828, 30, 407, 11, 436, 733, 295, 2836, 264, 7417, 294, 13, 814, 733, 295, 11, 264, 2857, 9239, 291, 51026], "temperature": 0.0, "avg_logprob": -0.2546240111528817, "compression_ratio": 1.693798449612403, "no_speech_prob": 0.01357150636613369}, {"id": 254, "seek": 154444, "start": 1557.68, "end": 1562.24, "text": " have to do to transition off to arm mode. Which is we have to take the arguments that", "tokens": [51026, 362, 281, 360, 281, 6034, 766, 281, 3726, 4391, 13, 3013, 307, 321, 362, 281, 747, 264, 12869, 300, 51254], "temperature": 0.0, "avg_logprob": -0.2546240111528817, "compression_ratio": 1.693798449612403, "no_speech_prob": 0.01357150636613369}, {"id": 255, "seek": 154444, "start": 1562.24, "end": 1566.52, "text": " we carefully put in their arm places, take them out of their arm places, and put them", "tokens": [51254, 321, 7500, 829, 294, 641, 3726, 3190, 11, 747, 552, 484, 295, 641, 3726, 3190, 11, 293, 829, 552, 51468], "temperature": 0.0, "avg_logprob": -0.2546240111528817, "compression_ratio": 1.693798449612403, "no_speech_prob": 0.01357150636613369}, {"id": 256, "seek": 154444, "start": 1566.52, "end": 1571.1200000000001, "text": " into where they should be for the Intel style call. Which, you know, a bunch of work, but", "tokens": [51468, 666, 689, 436, 820, 312, 337, 264, 19762, 3758, 818, 13, 3013, 11, 291, 458, 11, 257, 3840, 295, 589, 11, 457, 51698], "temperature": 0.0, "avg_logprob": -0.2546240111528817, "compression_ratio": 1.693798449612403, "no_speech_prob": 0.01357150636613369}, {"id": 257, "seek": 157112, "start": 1571.1999999999998, "end": 1576.8, "text": " it's fine. And then ensure that the function that we want to call is still in X9. And then", "tokens": [50368, 309, 311, 2489, 13, 400, 550, 5586, 300, 264, 2445, 300, 321, 528, 281, 818, 307, 920, 294, 1783, 24, 13, 400, 550, 50648], "temperature": 0.0, "avg_logprob": -0.17144155087678328, "compression_ratio": 1.7959183673469388, "no_speech_prob": 0.024022672325372696}, {"id": 258, "seek": 157112, "start": 1576.8, "end": 1582.04, "text": " we call the next magical mystery function from Microsoft. And we have to do it in a", "tokens": [50648, 321, 818, 264, 958, 12066, 11422, 2445, 490, 8116, 13, 400, 321, 362, 281, 360, 309, 294, 257, 50910], "temperature": 0.0, "avg_logprob": -0.17144155087678328, "compression_ratio": 1.7959183673469388, "no_speech_prob": 0.024022672325372696}, {"id": 259, "seek": 157112, "start": 1582.04, "end": 1587.04, "text": " special way. We have to put the address of this function in X16 and then call X16. Which", "tokens": [50910, 2121, 636, 13, 492, 362, 281, 829, 264, 2985, 295, 341, 2445, 294, 1783, 6866, 293, 550, 818, 1783, 6866, 13, 3013, 51160], "temperature": 0.0, "avg_logprob": -0.17144155087678328, "compression_ratio": 1.7959183673469388, "no_speech_prob": 0.024022672325372696}, {"id": 260, "seek": 157112, "start": 1587.04, "end": 1593.54, "text": " is going to seem weird, but we're going to have to see why in a bit. And once the magical", "tokens": [51160, 307, 516, 281, 1643, 3657, 11, 457, 321, 434, 516, 281, 362, 281, 536, 983, 294, 257, 857, 13, 400, 1564, 264, 12066, 51485], "temperature": 0.0, "avg_logprob": -0.17144155087678328, "compression_ratio": 1.7959183673469388, "no_speech_prob": 0.024022672325372696}, {"id": 261, "seek": 157112, "start": 1593.54, "end": 1598.08, "text": " mystery function kind of comes back, we take the results from where they would live in", "tokens": [51485, 11422, 2445, 733, 295, 1487, 646, 11, 321, 747, 264, 3542, 490, 689, 436, 576, 1621, 294, 51712], "temperature": 0.0, "avg_logprob": -0.17144155087678328, "compression_ratio": 1.7959183673469388, "no_speech_prob": 0.024022672325372696}, {"id": 262, "seek": 159808, "start": 1598.12, "end": 1602.08, "text": " Intel world, pull them out of that world, and put them where they would be for an arm", "tokens": [50366, 19762, 1002, 11, 2235, 552, 484, 295, 300, 1002, 11, 293, 829, 552, 689, 436, 576, 312, 337, 364, 3726, 50564], "temperature": 0.0, "avg_logprob": -0.21699169117917297, "compression_ratio": 1.6210045662100456, "no_speech_prob": 0.00681537389755249}, {"id": 263, "seek": 159808, "start": 1602.08, "end": 1608.6, "text": " world, and then we return as normal. So, okay. Next up, let's look at this magical mystery", "tokens": [50564, 1002, 11, 293, 550, 321, 2736, 382, 2710, 13, 407, 11, 1392, 13, 3087, 493, 11, 718, 311, 574, 412, 341, 12066, 11422, 50890], "temperature": 0.0, "avg_logprob": -0.21699169117917297, "compression_ratio": 1.6210045662100456, "no_speech_prob": 0.00681537389755249}, {"id": 264, "seek": 159808, "start": 1608.6, "end": 1615.6, "text": " function. Which is this guy. So, first box in the top left. I mentioned that ARM puts", "tokens": [50890, 2445, 13, 3013, 307, 341, 2146, 13, 407, 11, 700, 2424, 294, 264, 1192, 1411, 13, 286, 2835, 300, 45209, 8137, 51240], "temperature": 0.0, "avg_logprob": -0.21699169117917297, "compression_ratio": 1.6210045662100456, "no_speech_prob": 0.00681537389755249}, {"id": 265, "seek": 159808, "start": 1619.32, "end": 1624.24, "text": " return address on the register, whereas Intel puts it on the stack. This first box is fixing", "tokens": [51426, 2736, 2985, 322, 264, 7280, 11, 9735, 19762, 8137, 309, 322, 264, 8630, 13, 639, 700, 2424, 307, 19442, 51672], "temperature": 0.0, "avg_logprob": -0.21699169117917297, "compression_ratio": 1.6210045662100456, "no_speech_prob": 0.00681537389755249}, {"id": 266, "seek": 162424, "start": 1624.24, "end": 1631.24, "text": " up that problem. Then the rest of the left-hand column is your kind of usual loop for emulating", "tokens": [50364, 493, 300, 1154, 13, 1396, 264, 1472, 295, 264, 1411, 12, 5543, 7738, 307, 428, 733, 295, 7713, 6367, 337, 846, 12162, 50714], "temperature": 0.0, "avg_logprob": -0.29830219706550976, "compression_ratio": 1.6433823529411764, "no_speech_prob": 0.010833488777279854}, {"id": 267, "seek": 162424, "start": 1631.76, "end": 1637.4, "text": " a CPU. You know, we get the next instruction. We do it somehow. Then we move to the next", "tokens": [50740, 257, 13199, 13, 509, 458, 11, 321, 483, 264, 958, 10951, 13, 492, 360, 309, 6063, 13, 1396, 321, 1286, 281, 264, 958, 51022], "temperature": 0.0, "avg_logprob": -0.29830219706550976, "compression_ratio": 1.6433823529411764, "no_speech_prob": 0.010833488777279854}, {"id": 268, "seek": 162424, "start": 1637.4, "end": 1644.4, "text": " instruction and we do that one. In practice, there's going to be a far more complex logic", "tokens": [51022, 10951, 293, 321, 360, 300, 472, 13, 682, 3124, 11, 456, 311, 516, 281, 312, 257, 1400, 544, 3997, 9952, 51372], "temperature": 0.0, "avg_logprob": -0.29830219706550976, "compression_ratio": 1.6433823529411764, "no_speech_prob": 0.010833488777279854}, {"id": 269, "seek": 162424, "start": 1644.52, "end": 1648.8, "text": " in here. So, you know, like optimize stuff. And you're like, you know, jit compiler or", "tokens": [51378, 294, 510, 13, 407, 11, 291, 458, 11, 411, 19719, 1507, 13, 400, 291, 434, 411, 11, 291, 458, 11, 361, 270, 31958, 420, 51592], "temperature": 0.0, "avg_logprob": -0.29830219706550976, "compression_ratio": 1.6433823529411764, "no_speech_prob": 0.010833488777279854}, {"id": 270, "seek": 162424, "start": 1648.8, "end": 1653.08, "text": " AOT compiler or all sorts of clever stuff in there. But as far as we're concerned, as", "tokens": [51592, 316, 5068, 31958, 420, 439, 7527, 295, 13494, 1507, 294, 456, 13, 583, 382, 1400, 382, 321, 434, 5922, 11, 382, 51806], "temperature": 0.0, "avg_logprob": -0.29830219706550976, "compression_ratio": 1.6433823529411764, "no_speech_prob": 0.010833488777279854}, {"id": 271, "seek": 165308, "start": 1653.1599999999999, "end": 1659.6799999999998, "text": " well as what it does, this kind of describes what it does. At some point, it'll say, wait", "tokens": [50368, 731, 382, 437, 309, 775, 11, 341, 733, 295, 15626, 437, 309, 775, 13, 1711, 512, 935, 11, 309, 603, 584, 11, 1699, 50694], "temperature": 0.0, "avg_logprob": -0.24294945451079822, "compression_ratio": 1.6455223880597014, "no_speech_prob": 0.0024083368480205536}, {"id": 272, "seek": 165308, "start": 1659.6799999999998, "end": 1664.4399999999998, "text": " a minute. You're now asking me to go back to ARM mode, because I've found code that's", "tokens": [50694, 257, 3456, 13, 509, 434, 586, 3365, 385, 281, 352, 646, 281, 45209, 4391, 11, 570, 286, 600, 1352, 3089, 300, 311, 50932], "temperature": 0.0, "avg_logprob": -0.24294945451079822, "compression_ratio": 1.6455223880597014, "no_speech_prob": 0.0024083368480205536}, {"id": 273, "seek": 165308, "start": 1664.4399999999998, "end": 1670.4399999999998, "text": " no longer like Intel code. We are doing some kind of mode switch. Now, I said earlier,", "tokens": [50932, 572, 2854, 411, 19762, 3089, 13, 492, 366, 884, 512, 733, 295, 4391, 3679, 13, 823, 11, 286, 848, 3071, 11, 51232], "temperature": 0.0, "avg_logprob": -0.24294945451079822, "compression_ratio": 1.6455223880597014, "no_speech_prob": 0.0024083368480205536}, {"id": 274, "seek": 165308, "start": 1670.4399999999998, "end": 1675.84, "text": " mode switches, we've said they're only going to happen at function call or function return.", "tokens": [51232, 4391, 19458, 11, 321, 600, 848, 436, 434, 787, 516, 281, 1051, 412, 2445, 818, 420, 2445, 2736, 13, 51502], "temperature": 0.0, "avg_logprob": -0.24294945451079822, "compression_ratio": 1.6455223880597014, "no_speech_prob": 0.0024083368480205536}, {"id": 275, "seek": 165308, "start": 1675.84, "end": 1682.4399999999998, "text": " Oh, go. If we've now gone from Intel's ARM, this is either a call or a return. And how", "tokens": [51502, 876, 11, 352, 13, 759, 321, 600, 586, 2780, 490, 19762, 311, 45209, 11, 341, 307, 2139, 257, 818, 420, 257, 2736, 13, 400, 577, 51832], "temperature": 0.0, "avg_logprob": -0.24294945451079822, "compression_ratio": 1.6455223880597014, "no_speech_prob": 0.0024083368480205536}, {"id": 276, "seek": 168244, "start": 1682.52, "end": 1689.52, "text": " do we know which? And the cheeky part there is that we look at the four bytes just before", "tokens": [50368, 360, 321, 458, 597, 30, 400, 264, 12839, 88, 644, 456, 307, 300, 321, 574, 412, 264, 1451, 36088, 445, 949, 50718], "temperature": 0.0, "avg_logprob": -0.1823937761914599, "compression_ratio": 1.644859813084112, "no_speech_prob": 0.0014483042759820819}, {"id": 277, "seek": 168244, "start": 1690.0, "end": 1696.52, "text": " where we're going to start running and say, is this a call X16 instruction? Why is that", "tokens": [50742, 689, 321, 434, 516, 281, 722, 2614, 293, 584, 11, 307, 341, 257, 818, 1783, 6866, 10951, 30, 1545, 307, 300, 51068], "temperature": 0.0, "avg_logprob": -0.1823937761914599, "compression_ratio": 1.644859813084112, "no_speech_prob": 0.0014483042759820819}, {"id": 278, "seek": 168244, "start": 1696.52, "end": 1702.72, "text": " the question? Because we have to call this magical mystery function as a call X16, which", "tokens": [51068, 264, 1168, 30, 1436, 321, 362, 281, 818, 341, 12066, 11422, 2445, 382, 257, 818, 1783, 6866, 11, 597, 51378], "temperature": 0.0, "avg_logprob": -0.1823937761914599, "compression_ratio": 1.644859813084112, "no_speech_prob": 0.0014483042759820819}, {"id": 279, "seek": 168244, "start": 1702.72, "end": 1707.44, "text": " means if we just found that, it means we've just come back from the call that we were", "tokens": [51378, 1355, 498, 321, 445, 1352, 300, 11, 309, 1355, 321, 600, 445, 808, 646, 490, 264, 818, 300, 321, 645, 51614], "temperature": 0.0, "avg_logprob": -0.1823937761914599, "compression_ratio": 1.644859813084112, "no_speech_prob": 0.0014483042759820819}, {"id": 280, "seek": 170744, "start": 1707.52, "end": 1714.52, "text": " doing. We are in a function return type thing. And we set the return pointer to the code", "tokens": [50368, 884, 13, 492, 366, 294, 257, 2445, 2736, 2010, 551, 13, 400, 321, 992, 264, 2736, 23918, 281, 264, 3089, 50718], "temperature": 0.0, "avg_logprob": -0.1891657072922279, "compression_ratio": 1.756, "no_speech_prob": 0.016626844182610512}, {"id": 281, "seek": 170744, "start": 1714.8400000000001, "end": 1719.88, "text": " we want to run to, and we go to it. And this final column means that we're doing a function", "tokens": [50734, 321, 528, 281, 1190, 281, 11, 293, 321, 352, 281, 309, 13, 400, 341, 2572, 7738, 1355, 300, 321, 434, 884, 257, 2445, 50986], "temperature": 0.0, "avg_logprob": -0.1891657072922279, "compression_ratio": 1.756, "no_speech_prob": 0.016626844182610512}, {"id": 282, "seek": 170744, "start": 1719.88, "end": 1726.3600000000001, "text": " call, because the four bytes before where we're going to are anything else. And then", "tokens": [50986, 818, 11, 570, 264, 1451, 36088, 949, 689, 321, 434, 516, 281, 366, 1340, 1646, 13, 400, 550, 51310], "temperature": 0.0, "avg_logprob": -0.1891657072922279, "compression_ratio": 1.756, "no_speech_prob": 0.016626844182610512}, {"id": 283, "seek": 170744, "start": 1726.3600000000001, "end": 1731.0800000000002, "text": " we need to do, again, the opposite problem of where your return address wants to be. Is", "tokens": [51310, 321, 643, 281, 360, 11, 797, 11, 264, 6182, 1154, 295, 689, 428, 2736, 2985, 2738, 281, 312, 13, 1119, 51546], "temperature": 0.0, "avg_logprob": -0.1891657072922279, "compression_ratio": 1.756, "no_speech_prob": 0.016626844182610512}, {"id": 284, "seek": 170744, "start": 1731.0800000000002, "end": 1736.48, "text": " it on the stack or is it in a register? So we fix up that problem. And then we've set", "tokens": [51546, 309, 322, 264, 8630, 420, 307, 309, 294, 257, 7280, 30, 407, 321, 3191, 493, 300, 1154, 13, 400, 550, 321, 600, 992, 51816], "temperature": 0.0, "avg_logprob": -0.1891657072922279, "compression_ratio": 1.756, "no_speech_prob": 0.016626844182610512}, {"id": 285, "seek": 173648, "start": 1736.52, "end": 1740.76, "text": " X4 to be the stack pointer. Why do we do that? Because the next step is to say we have to", "tokens": [50366, 1783, 19, 281, 312, 264, 8630, 23918, 13, 1545, 360, 321, 360, 300, 30, 1436, 264, 958, 1823, 307, 281, 584, 321, 362, 281, 50578], "temperature": 0.0, "avg_logprob": -0.15975279808044435, "compression_ratio": 1.6925925925925926, "no_speech_prob": 0.002528094220906496}, {"id": 286, "seek": 173648, "start": 1740.76, "end": 1745.92, "text": " forcibly realign the stack pointer. Because remember that point where I said like, Intel", "tokens": [50578, 337, 537, 25021, 957, 788, 264, 8630, 23918, 13, 1436, 1604, 300, 935, 689, 286, 848, 411, 11, 19762, 50836], "temperature": 0.0, "avg_logprob": -0.15975279808044435, "compression_ratio": 1.6925925925925926, "no_speech_prob": 0.002528094220906496}, {"id": 287, "seek": 173648, "start": 1745.92, "end": 1752.92, "text": " code doesn't care about your alignment for as ARM does, this is where we fix that problem.", "tokens": [50836, 3089, 1177, 380, 1127, 466, 428, 18515, 337, 382, 45209, 775, 11, 341, 307, 689, 321, 3191, 300, 1154, 13, 51186], "temperature": 0.0, "avg_logprob": -0.15975279808044435, "compression_ratio": 1.6925925925925926, "no_speech_prob": 0.002528094220906496}, {"id": 288, "seek": 173648, "start": 1752.92, "end": 1758.52, "text": " And then we tail call X9's alternative entry point. Remember, X9 being the sting that we've", "tokens": [51186, 400, 550, 321, 6838, 818, 1783, 24, 311, 8535, 8729, 935, 13, 5459, 11, 1783, 24, 885, 264, 27175, 300, 321, 600, 51466], "temperature": 0.0, "avg_logprob": -0.15975279808044435, "compression_ratio": 1.6925925925925926, "no_speech_prob": 0.002528094220906496}, {"id": 289, "seek": 173648, "start": 1758.52, "end": 1765.52, "text": " inferred is a function tool that we're trying to make. So we do a call to almost that function.", "tokens": [51466, 13596, 986, 307, 257, 2445, 2290, 300, 321, 434, 1382, 281, 652, 13, 407, 321, 360, 257, 818, 281, 1920, 300, 2445, 13, 51816], "temperature": 0.0, "avg_logprob": -0.15975279808044435, "compression_ratio": 1.6925925925925926, "no_speech_prob": 0.002528094220906496}, {"id": 290, "seek": 176552, "start": 1765.72, "end": 1770.72, "text": " Again, you're going to say, Peter, what are these alternative entry points? So that's next.", "tokens": [50374, 3764, 11, 291, 434, 516, 281, 584, 11, 6508, 11, 437, 366, 613, 8535, 8729, 2793, 30, 407, 300, 311, 958, 13, 50624], "temperature": 0.0, "avg_logprob": -0.1964983318163001, "compression_ratio": 1.6995515695067265, "no_speech_prob": 0.0014845406403765082}, {"id": 291, "seek": 176552, "start": 1771.72, "end": 1778.32, "text": " So every ARM function that could be called from Intel needs a so-called alternative entry point", "tokens": [50674, 407, 633, 45209, 2445, 300, 727, 312, 1219, 490, 19762, 2203, 257, 370, 12, 11880, 8535, 8729, 935, 51004], "temperature": 0.0, "avg_logprob": -0.1964983318163001, "compression_ratio": 1.6995515695067265, "no_speech_prob": 0.0014845406403765082}, {"id": 292, "seek": 176552, "start": 1778.32, "end": 1784.04, "text": " for handling when it is called from Intel. And it does all of the gubbins that have to be done", "tokens": [51004, 337, 13175, 562, 309, 307, 1219, 490, 19762, 13, 400, 309, 775, 439, 295, 264, 695, 6692, 1292, 300, 362, 281, 312, 1096, 51290], "temperature": 0.0, "avg_logprob": -0.1964983318163001, "compression_ratio": 1.6995515695067265, "no_speech_prob": 0.0014845406403765082}, {"id": 293, "seek": 176552, "start": 1784.04, "end": 1790.32, "text": " to make this transition work. The only question is how do you find this alternative entry point,", "tokens": [51290, 281, 652, 341, 6034, 589, 13, 440, 787, 1168, 307, 577, 360, 291, 915, 341, 8535, 8729, 935, 11, 51604], "temperature": 0.0, "avg_logprob": -0.1964983318163001, "compression_ratio": 1.6995515695067265, "no_speech_prob": 0.0014845406403765082}, {"id": 294, "seek": 179032, "start": 1791.08, "end": 1796.08, "text": " which is you put the offset of it in the four bytes before the start of the function,", "tokens": [50402, 597, 307, 291, 829, 264, 18687, 295, 309, 294, 264, 1451, 36088, 949, 264, 722, 295, 264, 2445, 11, 50652], "temperature": 0.0, "avg_logprob": -0.22549475794253143, "compression_ratio": 1.7609756097560976, "no_speech_prob": 0.015621215105056763}, {"id": 295, "seek": 179032, "start": 1796.08, "end": 1801.28, "text": " which is handy because we already had to read those four bytes to check whether they were", "tokens": [50652, 597, 307, 13239, 570, 321, 1217, 632, 281, 1401, 729, 1451, 36088, 281, 1520, 1968, 436, 645, 50912], "temperature": 0.0, "avg_logprob": -0.22549475794253143, "compression_ratio": 1.7609756097560976, "no_speech_prob": 0.015621215105056763}, {"id": 296, "seek": 179032, "start": 1801.28, "end": 1809.6799999999998, "text": " that guy. So if they're not that guy, then they are the offset of this guy. And what is in one of", "tokens": [50912, 300, 2146, 13, 407, 498, 436, 434, 406, 300, 2146, 11, 550, 436, 366, 264, 18687, 295, 341, 2146, 13, 400, 437, 307, 294, 472, 295, 51332], "temperature": 0.0, "avg_logprob": -0.22549475794253143, "compression_ratio": 1.7609756097560976, "no_speech_prob": 0.015621215105056763}, {"id": 297, "seek": 179032, "start": 1809.6799999999998, "end": 1816.4399999999998, "text": " these guys? Ignore the right hand column for now and look at just the left hand column,", "tokens": [51332, 613, 1074, 30, 24754, 418, 264, 558, 1011, 7738, 337, 586, 293, 574, 412, 445, 264, 1411, 1011, 7738, 11, 51670], "temperature": 0.0, "avg_logprob": -0.22549475794253143, "compression_ratio": 1.7609756097560976, "no_speech_prob": 0.015621215105056763}, {"id": 298, "seek": 181644, "start": 1816.88, "end": 1821.3600000000001, "text": " which point in the left hand column is mostly the opposite of what we saw earlier. We have to", "tokens": [50386, 597, 935, 294, 264, 1411, 1011, 7738, 307, 5240, 264, 6182, 295, 437, 321, 1866, 3071, 13, 492, 362, 281, 50610], "temperature": 0.0, "avg_logprob": -0.1747364009822811, "compression_ratio": 1.8893280632411067, "no_speech_prob": 0.004879825748503208}, {"id": 299, "seek": 181644, "start": 1821.3600000000001, "end": 1825.44, "text": " take the arguments from where they are in Intel and pull them out of there, put them where they", "tokens": [50610, 747, 264, 12869, 490, 689, 436, 366, 294, 19762, 293, 2235, 552, 484, 295, 456, 11, 829, 552, 689, 436, 50814], "temperature": 0.0, "avg_logprob": -0.1747364009822811, "compression_ratio": 1.8893280632411067, "no_speech_prob": 0.004879825748503208}, {"id": 300, "seek": 181644, "start": 1825.44, "end": 1831.0800000000002, "text": " should be for ARM land, call the real part of the function, and then take the results out of", "tokens": [50814, 820, 312, 337, 45209, 2117, 11, 818, 264, 957, 644, 295, 264, 2445, 11, 293, 550, 747, 264, 3542, 484, 295, 51096], "temperature": 0.0, "avg_logprob": -0.1747364009822811, "compression_ratio": 1.8893280632411067, "no_speech_prob": 0.004879825748503208}, {"id": 301, "seek": 181644, "start": 1831.0800000000002, "end": 1835.72, "text": " there and put them where they should be for Intel, and then call the next magical mystery function.", "tokens": [51096, 456, 293, 829, 552, 689, 436, 820, 312, 337, 19762, 11, 293, 550, 818, 264, 958, 12066, 11422, 2445, 13, 51328], "temperature": 0.0, "avg_logprob": -0.1747364009822811, "compression_ratio": 1.8893280632411067, "no_speech_prob": 0.004879825748503208}, {"id": 302, "seek": 181644, "start": 1835.72, "end": 1841.48, "text": " The only interesting part here is this first box where we're saying if there are arguments that", "tokens": [51328, 440, 787, 1880, 644, 510, 307, 341, 700, 2424, 689, 321, 434, 1566, 498, 456, 366, 12869, 300, 51616], "temperature": 0.0, "avg_logprob": -0.1747364009822811, "compression_ratio": 1.8893280632411067, "no_speech_prob": 0.004879825748503208}, {"id": 303, "seek": 184148, "start": 1841.52, "end": 1847.44, "text": " come off the stack, we can't read them from the stack point, we have to read them from x4. Why is", "tokens": [50366, 808, 766, 264, 8630, 11, 321, 393, 380, 1401, 552, 490, 264, 8630, 935, 11, 321, 362, 281, 1401, 552, 490, 2031, 19, 13, 1545, 307, 50662], "temperature": 0.0, "avg_logprob": -0.14665660858154297, "compression_ratio": 1.6872246696035242, "no_speech_prob": 0.008984014391899109}, {"id": 304, "seek": 184148, "start": 1847.44, "end": 1853.0, "text": " this because of this forcibly realigning sp? You can no longer read your arguments from there", "tokens": [50662, 341, 570, 295, 341, 337, 537, 25021, 957, 9676, 637, 30, 509, 393, 572, 2854, 1401, 428, 12869, 490, 456, 50940], "temperature": 0.0, "avg_logprob": -0.14665660858154297, "compression_ratio": 1.6872246696035242, "no_speech_prob": 0.008984014391899109}, {"id": 305, "seek": 184148, "start": 1853.0, "end": 1859.16, "text": " because we might have changed it to realign it, but x4 tells you where they used to be. So that's", "tokens": [50940, 570, 321, 1062, 362, 3105, 309, 281, 957, 788, 309, 11, 457, 2031, 19, 5112, 291, 689, 436, 1143, 281, 312, 13, 407, 300, 311, 51248], "temperature": 0.0, "avg_logprob": -0.14665660858154297, "compression_ratio": 1.6872246696035242, "no_speech_prob": 0.008984014391899109}, {"id": 306, "seek": 184148, "start": 1859.16, "end": 1868.24, "text": " fine. The interesting point is that the logic on the slide only depends upon the types of the", "tokens": [51248, 2489, 13, 440, 1880, 935, 307, 300, 264, 9952, 322, 264, 4137, 787, 5946, 3564, 264, 3467, 295, 264, 51702], "temperature": 0.0, "avg_logprob": -0.14665660858154297, "compression_ratio": 1.6872246696035242, "no_speech_prob": 0.008984014391899109}, {"id": 307, "seek": 186824, "start": 1868.28, "end": 1874.76, "text": " arguments and the types of the return. It doesn't actually care about what the function actually", "tokens": [50366, 12869, 293, 264, 3467, 295, 264, 2736, 13, 467, 1177, 380, 767, 1127, 466, 437, 264, 2445, 767, 50690], "temperature": 0.0, "avg_logprob": -0.23261338537865942, "compression_ratio": 1.682608695652174, "no_speech_prob": 0.008703628554940224}, {"id": 308, "seek": 186824, "start": 1874.76, "end": 1881.04, "text": " does, and therefore you can kind of share these guys between multiple functions if those functions", "tokens": [50690, 775, 11, 293, 4412, 291, 393, 733, 295, 2073, 613, 1074, 1296, 3866, 6828, 498, 729, 6828, 51004], "temperature": 0.0, "avg_logprob": -0.23261338537865942, "compression_ratio": 1.682608695652174, "no_speech_prob": 0.008703628554940224}, {"id": 309, "seek": 186824, "start": 1881.04, "end": 1887.16, "text": " have the same type, which is good for like, you know, code sharing keeps your memory usage down,", "tokens": [51004, 362, 264, 912, 2010, 11, 597, 307, 665, 337, 411, 11, 291, 458, 11, 3089, 5414, 5965, 428, 4675, 14924, 760, 11, 51310], "temperature": 0.0, "avg_logprob": -0.23261338537865942, "compression_ratio": 1.682608695652174, "no_speech_prob": 0.008703628554940224}, {"id": 310, "seek": 186824, "start": 1887.16, "end": 1892.96, "text": " your iCash is happier, whatnot. But if you want to, you could write one of these per function,", "tokens": [51310, 428, 741, 34, 1299, 307, 20423, 11, 25882, 13, 583, 498, 291, 528, 281, 11, 291, 727, 2464, 472, 295, 613, 680, 2445, 11, 51600], "temperature": 0.0, "avg_logprob": -0.23261338537865942, "compression_ratio": 1.682608695652174, "no_speech_prob": 0.008703628554940224}, {"id": 311, "seek": 189296, "start": 1893.56, "end": 1898.1200000000001, "text": " which point in the right hand side becomes an option that you could do, and then you can", "tokens": [50394, 597, 935, 294, 264, 558, 1011, 1252, 3643, 364, 3614, 300, 291, 727, 360, 11, 293, 550, 291, 393, 50622], "temperature": 0.0, "avg_logprob": -0.23150740278528092, "compression_ratio": 1.6255506607929515, "no_speech_prob": 0.03304719924926758}, {"id": 312, "seek": 189296, "start": 1898.1200000000001, "end": 1902.3600000000001, "text": " kind of skip the kind of calling in the other bits, just put the copy of your function in there,", "tokens": [50622, 733, 295, 10023, 264, 733, 295, 5141, 294, 264, 661, 9239, 11, 445, 829, 264, 5055, 295, 428, 2445, 294, 456, 11, 50834], "temperature": 0.0, "avg_logprob": -0.23150740278528092, "compression_ratio": 1.6255506607929515, "no_speech_prob": 0.03304719924926758}, {"id": 313, "seek": 189296, "start": 1902.3600000000001, "end": 1911.04, "text": " if you so wish. Okay, so next magical mystery point function is this guy. Don't worry,", "tokens": [50834, 498, 291, 370, 3172, 13, 1033, 11, 370, 958, 12066, 11422, 935, 2445, 307, 341, 2146, 13, 1468, 380, 3292, 11, 51268], "temperature": 0.0, "avg_logprob": -0.23150740278528092, "compression_ratio": 1.6255506607929515, "no_speech_prob": 0.03304719924926758}, {"id": 314, "seek": 189296, "start": 1911.04, "end": 1916.56, "text": " you've seen most of this side previously. It's all the same side except for the first box in the", "tokens": [51268, 291, 600, 1612, 881, 295, 341, 1252, 8046, 13, 467, 311, 439, 264, 912, 1252, 3993, 337, 264, 700, 2424, 294, 264, 51544], "temperature": 0.0, "avg_logprob": -0.23150740278528092, "compression_ratio": 1.6255506607929515, "no_speech_prob": 0.03304719924926758}, {"id": 315, "seek": 191656, "start": 1916.6399999999999, "end": 1925.6399999999999, "text": " top left, for which you're going to ask, so what does this box in the top left do? What is the", "tokens": [50368, 1192, 1411, 11, 337, 597, 291, 434, 516, 281, 1029, 11, 370, 437, 775, 341, 2424, 294, 264, 1192, 1411, 360, 30, 708, 307, 264, 50818], "temperature": 0.0, "avg_logprob": -0.13246199164060082, "compression_ratio": 1.6754385964912282, "no_speech_prob": 0.04862087592482567}, {"id": 316, "seek": 191656, "start": 1925.6399999999999, "end": 1932.0, "text": " value of lr that we have up there? And if you trace all the stuff through, you'll see it's the", "tokens": [50818, 2158, 295, 287, 81, 300, 321, 362, 493, 456, 30, 400, 498, 291, 13508, 439, 264, 1507, 807, 11, 291, 603, 536, 309, 311, 264, 51136], "temperature": 0.0, "avg_logprob": -0.13246199164060082, "compression_ratio": 1.6754385964912282, "no_speech_prob": 0.04862087592482567}, {"id": 317, "seek": 191656, "start": 1932.0, "end": 1938.76, "text": " same lr that we popped over on this side, which was the return address that we popped off the stack", "tokens": [51136, 912, 287, 81, 300, 321, 21545, 670, 322, 341, 1252, 11, 597, 390, 264, 2736, 2985, 300, 321, 21545, 766, 264, 8630, 51474], "temperature": 0.0, "avg_logprob": -0.13246199164060082, "compression_ratio": 1.6754385964912282, "no_speech_prob": 0.04862087592482567}, {"id": 318, "seek": 191656, "start": 1938.76, "end": 1943.72, "text": " because we think the Intel code just made a function call, at which point what we're putting", "tokens": [51474, 570, 321, 519, 264, 19762, 3089, 445, 1027, 257, 2445, 818, 11, 412, 597, 935, 437, 321, 434, 3372, 51722], "temperature": 0.0, "avg_logprob": -0.13246199164060082, "compression_ratio": 1.6754385964912282, "no_speech_prob": 0.04862087592482567}, {"id": 319, "seek": 194372, "start": 1943.76, "end": 1948.76, "text": " back in the top left is the return address to go back into Intel mode. So it all kind of works", "tokens": [50366, 646, 294, 264, 1192, 1411, 307, 264, 2736, 2985, 281, 352, 646, 666, 19762, 4391, 13, 407, 309, 439, 733, 295, 1985, 50616], "temperature": 0.0, "avg_logprob": -0.2046565612157186, "compression_ratio": 1.5887445887445888, "no_speech_prob": 0.0030333881732076406}, {"id": 320, "seek": 194372, "start": 1948.76, "end": 1956.44, "text": " out. As you've seen this slide previously, at which point we have run out of magical mystery", "tokens": [50616, 484, 13, 1018, 291, 600, 1612, 341, 4137, 8046, 11, 412, 597, 935, 321, 362, 1190, 484, 295, 12066, 11422, 51000], "temperature": 0.0, "avg_logprob": -0.2046565612157186, "compression_ratio": 1.5887445887445888, "no_speech_prob": 0.0030333881732076406}, {"id": 321, "seek": 194372, "start": 1956.44, "end": 1966.96, "text": " functions, so you know, there's a hard part over, that all kind of works out. So that tells you", "tokens": [51000, 6828, 11, 370, 291, 458, 11, 456, 311, 257, 1152, 644, 670, 11, 300, 439, 733, 295, 1985, 484, 13, 407, 300, 5112, 291, 51526], "temperature": 0.0, "avg_logprob": -0.2046565612157186, "compression_ratio": 1.5887445887445888, "no_speech_prob": 0.0030333881732076406}, {"id": 322, "seek": 194372, "start": 1966.96, "end": 1972.96, "text": " roughly very quickly what arm64 EC is, what the kind of code for it will look like,", "tokens": [51526, 9810, 588, 2661, 437, 3726, 19395, 19081, 307, 11, 437, 264, 733, 295, 3089, 337, 309, 486, 574, 411, 11, 51826], "temperature": 0.0, "avg_logprob": -0.2046565612157186, "compression_ratio": 1.5887445887445888, "no_speech_prob": 0.0030333881732076406}, {"id": 323, "seek": 197296, "start": 1973.92, "end": 1982.76, "text": " so next up, the kind of the lured part of how did I make lured work with this thing. So if you", "tokens": [50412, 370, 958, 493, 11, 264, 733, 295, 264, 287, 3831, 644, 295, 577, 630, 286, 652, 287, 3831, 589, 365, 341, 551, 13, 407, 498, 291, 50854], "temperature": 0.0, "avg_logprob": -0.30235350365732233, "compression_ratio": 1.6592920353982301, "no_speech_prob": 0.0005071985069662333}, {"id": 324, "seek": 197296, "start": 1982.76, "end": 1987.8400000000001, "text": " know lured, it's written in a mixture of assembly and C, and notably the interpreter is several", "tokens": [50854, 458, 287, 3831, 11, 309, 311, 3720, 294, 257, 9925, 295, 12103, 293, 383, 11, 293, 31357, 264, 34132, 307, 2940, 51108], "temperature": 0.0, "avg_logprob": -0.30235350365732233, "compression_ratio": 1.6592920353982301, "no_speech_prob": 0.0005071985069662333}, {"id": 325, "seek": 197296, "start": 1987.8400000000001, "end": 1994.24, "text": " thousand lines of assembly code, which is, you know, fun. So porting that code, that assembly", "tokens": [51108, 4714, 3876, 295, 12103, 3089, 11, 597, 307, 11, 291, 458, 11, 1019, 13, 407, 2436, 278, 300, 3089, 11, 300, 12103, 51428], "temperature": 0.0, "avg_logprob": -0.30235350365732233, "compression_ratio": 1.6592920353982301, "no_speech_prob": 0.0005071985069662333}, {"id": 326, "seek": 197296, "start": 1994.24, "end": 1999.28, "text": " code to arm64 EC, means that we can no longer use the versus that we said we couldn't use,", "tokens": [51428, 3089, 281, 3726, 19395, 19081, 11, 1355, 300, 321, 393, 572, 2854, 764, 264, 5717, 300, 321, 848, 321, 2809, 380, 764, 11, 51680], "temperature": 0.0, "avg_logprob": -0.30235350365732233, "compression_ratio": 1.6592920353982301, "no_speech_prob": 0.0005071985069662333}, {"id": 327, "seek": 199928, "start": 1999.44, "end": 2007.84, "text": " they don't fit in the context structures. So we lose v16 to v31. That's fine, didn't use them to", "tokens": [50372, 436, 500, 380, 3318, 294, 264, 4319, 9227, 13, 407, 321, 3624, 371, 6866, 281, 371, 12967, 13, 663, 311, 2489, 11, 994, 380, 764, 552, 281, 50792], "temperature": 0.0, "avg_logprob": -0.17916601044791086, "compression_ratio": 1.5343915343915344, "no_speech_prob": 0.009834232740104198}, {"id": 328, "seek": 199928, "start": 2007.84, "end": 2014.68, "text": " start with. x13, x14, again didn't use them to start with, not a problem. Unfortunately we did", "tokens": [50792, 722, 365, 13, 2031, 7668, 11, 2031, 7271, 11, 797, 994, 380, 764, 552, 281, 722, 365, 11, 406, 257, 1154, 13, 8590, 321, 630, 51134], "temperature": 0.0, "avg_logprob": -0.17916601044791086, "compression_ratio": 1.5343915343915344, "no_speech_prob": 0.009834232740104198}, {"id": 329, "seek": 199928, "start": 2014.68, "end": 2021.72, "text": " use x23 and x24 for various things, but because of what they were used for, they could be reworked", "tokens": [51134, 764, 2031, 9356, 293, 2031, 7911, 337, 3683, 721, 11, 457, 570, 295, 437, 436, 645, 1143, 337, 11, 436, 727, 312, 48376, 292, 51486], "temperature": 0.0, "avg_logprob": -0.17916601044791086, "compression_ratio": 1.5343915343915344, "no_speech_prob": 0.009834232740104198}, {"id": 330, "seek": 202172, "start": 2022.0, "end": 2029.44, "text": " to not require them with some almost zero cost tricks, so that wasn't too much of a pain. Losing", "tokens": [50378, 281, 406, 3651, 552, 365, 512, 1920, 4018, 2063, 11733, 11, 370, 300, 2067, 380, 886, 709, 295, 257, 1822, 13, 441, 6110, 50750], "temperature": 0.0, "avg_logprob": -0.22778713989257812, "compression_ratio": 1.7102473498233215, "no_speech_prob": 0.22024253010749817}, {"id": 331, "seek": 202172, "start": 2029.44, "end": 2036.48, "text": " x28, more annoying, that kind of required extra loads and stores to kind of split. In this regard,", "tokens": [50750, 2031, 11205, 11, 544, 11304, 11, 300, 733, 295, 4739, 2857, 12668, 293, 9512, 281, 733, 295, 7472, 13, 682, 341, 3843, 11, 51102], "temperature": 0.0, "avg_logprob": -0.22778713989257812, "compression_ratio": 1.7102473498233215, "no_speech_prob": 0.22024253010749817}, {"id": 332, "seek": 202172, "start": 2036.48, "end": 2041.2, "text": " the jic and pilot was actually easier to port than the interpreter, because the jic and pilot", "tokens": [51102, 264, 361, 299, 293, 9691, 390, 767, 3571, 281, 2436, 813, 264, 34132, 11, 570, 264, 361, 299, 293, 9691, 51338], "temperature": 0.0, "avg_logprob": -0.22778713989257812, "compression_ratio": 1.7102473498233215, "no_speech_prob": 0.22024253010749817}, {"id": 333, "seek": 202172, "start": 2041.2, "end": 2046.08, "text": " could already just not use certain things, so you just had to add some things onto the list of", "tokens": [51338, 727, 1217, 445, 406, 764, 1629, 721, 11, 370, 291, 445, 632, 281, 909, 512, 721, 3911, 264, 1329, 295, 51582], "temperature": 0.0, "avg_logprob": -0.22778713989257812, "compression_ratio": 1.7102473498233215, "no_speech_prob": 0.22024253010749817}, {"id": 334, "seek": 202172, "start": 2046.08, "end": 2050.16, "text": " what it can't use, and like, you know, it'll then just not use them. Again, there will be some kind", "tokens": [51582, 437, 309, 393, 380, 764, 11, 293, 411, 11, 291, 458, 11, 309, 603, 550, 445, 406, 764, 552, 13, 3764, 11, 456, 486, 312, 512, 733, 51786], "temperature": 0.0, "avg_logprob": -0.22778713989257812, "compression_ratio": 1.7102473498233215, "no_speech_prob": 0.22024253010749817}, {"id": 335, "seek": 205016, "start": 2050.2, "end": 2057.3599999999997, "text": " of like perf cost to not using them, but it wasn't hard on the kind of porting side. Next up is", "tokens": [50366, 295, 411, 13826, 2063, 281, 406, 1228, 552, 11, 457, 309, 2067, 380, 1152, 322, 264, 733, 295, 2436, 278, 1252, 13, 3087, 493, 307, 50724], "temperature": 0.0, "avg_logprob": -0.2776395540971022, "compression_ratio": 1.6307053941908713, "no_speech_prob": 0.0014294219436123967}, {"id": 336, "seek": 205016, "start": 2057.3599999999997, "end": 2063.7999999999997, "text": " handling these mode switches. So the C compiler will do most of the work for all of the C parts of", "tokens": [50724, 13175, 613, 4391, 19458, 13, 407, 264, 383, 31958, 486, 360, 881, 295, 264, 589, 337, 439, 295, 264, 383, 3166, 295, 51046], "temperature": 0.0, "avg_logprob": -0.2776395540971022, "compression_ratio": 1.6307053941908713, "no_speech_prob": 0.0014294219436123967}, {"id": 337, "seek": 205016, "start": 2063.7999999999997, "end": 2071.44, "text": " Lerget, but again, it won't handle the assembly parts. So there are kind of three parts, therefore,", "tokens": [51046, 441, 260, 847, 11, 457, 797, 11, 309, 1582, 380, 4813, 264, 12103, 3166, 13, 407, 456, 366, 733, 295, 1045, 3166, 11, 4412, 11, 51428], "temperature": 0.0, "avg_logprob": -0.2776395540971022, "compression_ratio": 1.6307053941908713, "no_speech_prob": 0.0014294219436123967}, {"id": 338, "seek": 205016, "start": 2071.44, "end": 2078.8399999999997, "text": " that it doesn't really handle. One is the interpreter opcode for calling Ler API C functions. That", "tokens": [51428, 300, 309, 1177, 380, 534, 4813, 13, 1485, 307, 264, 34132, 999, 22332, 337, 5141, 441, 260, 9362, 383, 6828, 13, 663, 51798], "temperature": 0.0, "avg_logprob": -0.2776395540971022, "compression_ratio": 1.6307053941908713, "no_speech_prob": 0.0014294219436123967}, {"id": 339, "seek": 207884, "start": 2078.88, "end": 2084.2400000000002, "text": " one's fairly simple, like the, it's only one place, it can only call one type of function, and the", "tokens": [50366, 472, 311, 6457, 2199, 11, 411, 264, 11, 309, 311, 787, 472, 1081, 11, 309, 393, 787, 818, 472, 2010, 295, 2445, 11, 293, 264, 50634], "temperature": 0.0, "avg_logprob": -0.17177599285720685, "compression_ratio": 1.7649769585253456, "no_speech_prob": 0.002667522057890892}, {"id": 340, "seek": 207884, "start": 2084.2400000000002, "end": 2092.2000000000003, "text": " type of that function is super simple. So that one's fine. Harder is the ffi. So if you're not", "tokens": [50634, 2010, 295, 300, 2445, 307, 1687, 2199, 13, 407, 300, 472, 311, 2489, 13, 11817, 260, 307, 264, 283, 13325, 13, 407, 498, 291, 434, 406, 51032], "temperature": 0.0, "avg_logprob": -0.17177599285720685, "compression_ratio": 1.7649769585253456, "no_speech_prob": 0.002667522057890892}, {"id": 341, "seek": 207884, "start": 2092.2000000000003, "end": 2098.52, "text": " familiar with the ffi, it's the Lerget's foreign function interface, and it lets Ler code call", "tokens": [51032, 4963, 365, 264, 283, 13325, 11, 309, 311, 264, 441, 260, 847, 311, 5329, 2445, 9226, 11, 293, 309, 6653, 441, 260, 3089, 818, 51348], "temperature": 0.0, "avg_logprob": -0.17177599285720685, "compression_ratio": 1.7649769585253456, "no_speech_prob": 0.002667522057890892}, {"id": 342, "seek": 207884, "start": 2098.52, "end": 2107.04, "text": " C functions of any type. Whatever type you want, it'll call it for you, and it'll just make it", "tokens": [51348, 383, 6828, 295, 604, 2010, 13, 8541, 2010, 291, 528, 11, 309, 603, 818, 309, 337, 291, 11, 293, 309, 603, 445, 652, 309, 51774], "temperature": 0.0, "avg_logprob": -0.17177599285720685, "compression_ratio": 1.7649769585253456, "no_speech_prob": 0.002667522057890892}, {"id": 343, "seek": 210704, "start": 2107.08, "end": 2115.44, "text": " work. And you can also jit compile your ffi calls in most cases. I say with simple types, like most", "tokens": [50366, 589, 13, 400, 291, 393, 611, 361, 270, 31413, 428, 283, 13325, 5498, 294, 881, 3331, 13, 286, 584, 365, 2199, 3467, 11, 411, 881, 50784], "temperature": 0.0, "avg_logprob": -0.16469712213638726, "compression_ratio": 1.7173913043478262, "no_speech_prob": 0.005345623008906841}, {"id": 344, "seek": 210704, "start": 2115.44, "end": 2122.56, "text": " types are simple, so you can jit compile most of them. We also support ffi callbacks, but you can", "tokens": [50784, 3467, 366, 2199, 11, 370, 291, 393, 361, 270, 31413, 881, 295, 552, 13, 492, 611, 1406, 283, 13325, 818, 17758, 11, 457, 291, 393, 51140], "temperature": 0.0, "avg_logprob": -0.16469712213638726, "compression_ratio": 1.7173913043478262, "no_speech_prob": 0.005345623008906841}, {"id": 345, "seek": 210704, "start": 2122.56, "end": 2130.52, "text": " take a Ler function and make it into a C function, and then C code can call you. So again, it's like", "tokens": [51140, 747, 257, 441, 260, 2445, 293, 652, 309, 666, 257, 383, 2445, 11, 293, 550, 383, 3089, 393, 818, 291, 13, 407, 797, 11, 309, 311, 411, 51538], "temperature": 0.0, "avg_logprob": -0.16469712213638726, "compression_ratio": 1.7173913043478262, "no_speech_prob": 0.005345623008906841}, {"id": 346, "seek": 210704, "start": 2130.52, "end": 2136.04, "text": " Intel code is trying to call your kind of ARM code that you created from your Ler code. You have", "tokens": [51538, 19762, 3089, 307, 1382, 281, 818, 428, 733, 295, 45209, 3089, 300, 291, 2942, 490, 428, 441, 260, 3089, 13, 509, 362, 51814], "temperature": 0.0, "avg_logprob": -0.16469712213638726, "compression_ratio": 1.7173913043478262, "no_speech_prob": 0.005345623008906841}, {"id": 347, "seek": 213604, "start": 2136.08, "end": 2146.2799999999997, "text": " to make that one work. That one's actually not too bad. 10, great, thank you. So the hard part is", "tokens": [50366, 281, 652, 300, 472, 589, 13, 663, 472, 311, 767, 406, 886, 1578, 13, 1266, 11, 869, 11, 1309, 291, 13, 407, 264, 1152, 644, 307, 50876], "temperature": 0.0, "avg_logprob": -0.17835698561234908, "compression_ratio": 1.3424657534246576, "no_speech_prob": 0.00355016952380538}, {"id": 348, "seek": 213604, "start": 2146.2799999999997, "end": 2156.7599999999998, "text": " these two, just because they're kind of arbitrary types of function. So this is what I made Lerget", "tokens": [50876, 613, 732, 11, 445, 570, 436, 434, 733, 295, 23211, 3467, 295, 2445, 13, 407, 341, 307, 437, 286, 1027, 441, 260, 847, 51400], "temperature": 0.0, "avg_logprob": -0.17835698561234908, "compression_ratio": 1.3424657534246576, "no_speech_prob": 0.00355016952380538}, {"id": 349, "seek": 215676, "start": 2157.0800000000004, "end": 2165.7200000000003, "text": " do for interpreted ffi calls. So the good thing about ffi calls is that they are one shot calls.", "tokens": [50380, 360, 337, 26749, 283, 13325, 5498, 13, 407, 264, 665, 551, 466, 283, 13325, 5498, 307, 300, 436, 366, 472, 3347, 5498, 13, 50812], "temperature": 0.0, "avg_logprob": -0.19549145829786949, "compression_ratio": 1.775229357798165, "no_speech_prob": 0.22128714621067047}, {"id": 350, "seek": 215676, "start": 2165.7200000000003, "end": 2172.0, "text": " You give the ffi a pointer to call, and the type to use it to call it, and it'll go and do it,", "tokens": [50812, 509, 976, 264, 283, 13325, 257, 23918, 281, 818, 11, 293, 264, 2010, 281, 764, 309, 281, 818, 309, 11, 293, 309, 603, 352, 293, 360, 309, 11, 51126], "temperature": 0.0, "avg_logprob": -0.19549145829786949, "compression_ratio": 1.775229357798165, "no_speech_prob": 0.22128714621067047}, {"id": 351, "seek": 215676, "start": 2172.0, "end": 2176.36, "text": " and it'll do it once. Because you're doing it once, you can look at the thing that you're trying to", "tokens": [51126, 293, 309, 603, 360, 309, 1564, 13, 1436, 291, 434, 884, 309, 1564, 11, 291, 393, 574, 412, 264, 551, 300, 291, 434, 1382, 281, 51344], "temperature": 0.0, "avg_logprob": -0.19549145829786949, "compression_ratio": 1.775229357798165, "no_speech_prob": 0.22128714621067047}, {"id": 352, "seek": 215676, "start": 2176.36, "end": 2181.1200000000003, "text": " call it like so. Is this ARM code or is it Intel code, and just do the right thing for whatever", "tokens": [51344, 818, 309, 411, 370, 13, 1119, 341, 45209, 3089, 420, 307, 309, 19762, 3089, 11, 293, 445, 360, 264, 558, 551, 337, 2035, 51582], "temperature": 0.0, "avg_logprob": -0.19549145829786949, "compression_ratio": 1.775229357798165, "no_speech_prob": 0.22128714621067047}, {"id": 353, "seek": 218112, "start": 2181.16, "end": 2188.44, "text": " it is that you're trying to call? Which gives you this nice, simple diagram. There is a slight", "tokens": [50366, 309, 307, 300, 291, 434, 1382, 281, 818, 30, 3013, 2709, 291, 341, 1481, 11, 2199, 10686, 13, 821, 307, 257, 4036, 50730], "temperature": 0.0, "avg_logprob": -0.1828253173828125, "compression_ratio": 1.6860986547085202, "no_speech_prob": 0.026335593312978745}, {"id": 354, "seek": 218112, "start": 2188.44, "end": 2195.68, "text": " problem with this diagram, though. So this is what we're meant to do. This is our slide from", "tokens": [50730, 1154, 365, 341, 10686, 11, 1673, 13, 407, 341, 307, 437, 321, 434, 4140, 281, 360, 13, 639, 307, 527, 4137, 490, 51092], "temperature": 0.0, "avg_logprob": -0.1828253173828125, "compression_ratio": 1.6860986547085202, "no_speech_prob": 0.026335593312978745}, {"id": 355, "seek": 218112, "start": 2195.68, "end": 2202.3599999999997, "text": " previously, and this is what we're actually doing. The right-hand side is just like we've", "tokens": [51092, 8046, 11, 293, 341, 307, 437, 321, 434, 767, 884, 13, 440, 558, 12, 5543, 1252, 307, 445, 411, 321, 600, 51426], "temperature": 0.0, "avg_logprob": -0.1828253173828125, "compression_ratio": 1.6860986547085202, "no_speech_prob": 0.026335593312978745}, {"id": 356, "seek": 218112, "start": 2202.3599999999997, "end": 2210.88, "text": " inlined the exit tank, it's all fine. The left-hand side has a slight problem. I skipped over this", "tokens": [51426, 294, 13564, 264, 11043, 5466, 11, 309, 311, 439, 2489, 13, 440, 1411, 12, 5543, 1252, 575, 257, 4036, 1154, 13, 286, 30193, 670, 341, 51852], "temperature": 0.0, "avg_logprob": -0.1828253173828125, "compression_ratio": 1.6860986547085202, "no_speech_prob": 0.026335593312978745}, {"id": 357, "seek": 221088, "start": 2211.04, "end": 2218.04, "text": " box a while ago, and it's like we'll just forget about that box. And you'll notice that it's missing", "tokens": [50372, 2424, 257, 1339, 2057, 11, 293, 309, 311, 411, 321, 603, 445, 2870, 466, 300, 2424, 13, 400, 291, 603, 3449, 300, 309, 311, 5361, 50722], "temperature": 0.0, "avg_logprob": -0.1813365679520827, "compression_ratio": 1.6582278481012658, "no_speech_prob": 0.0038873131852597}, {"id": 358, "seek": 221088, "start": 2218.04, "end": 2224.48, "text": " on this side, which will mean that certain things don't work. And the question is what doesn't work?", "tokens": [50722, 322, 341, 1252, 11, 597, 486, 914, 300, 1629, 721, 500, 380, 589, 13, 400, 264, 1168, 307, 437, 1177, 380, 589, 30, 51044], "temperature": 0.0, "avg_logprob": -0.1813365679520827, "compression_ratio": 1.6582278481012658, "no_speech_prob": 0.0038873131852597}, {"id": 359, "seek": 221088, "start": 2224.48, "end": 2231.04, "text": " So this is why I have to now tell you why this weird box is there on the left about putting a", "tokens": [51044, 407, 341, 307, 983, 286, 362, 281, 586, 980, 291, 983, 341, 3657, 2424, 307, 456, 322, 264, 1411, 466, 3372, 257, 51372], "temperature": 0.0, "avg_logprob": -0.1813365679520827, "compression_ratio": 1.6582278481012658, "no_speech_prob": 0.0038873131852597}, {"id": 360, "seek": 221088, "start": 2231.04, "end": 2237.96, "text": " thing in X10 when there's no obvious reason why you need to do it. So let's answer that question,", "tokens": [51372, 551, 294, 1783, 3279, 562, 456, 311, 572, 6322, 1778, 983, 291, 643, 281, 360, 309, 13, 407, 718, 311, 1867, 300, 1168, 11, 51718], "temperature": 0.0, "avg_logprob": -0.1813365679520827, "compression_ratio": 1.6582278481012658, "no_speech_prob": 0.0038873131852597}, {"id": 361, "seek": 223796, "start": 2238.88, "end": 2246.08, "text": " which is if we are making a function call and we are ARM code, and we might call Intel code,", "tokens": [50410, 597, 307, 498, 321, 366, 1455, 257, 2445, 818, 293, 321, 366, 45209, 3089, 11, 293, 321, 1062, 818, 19762, 3089, 11, 50770], "temperature": 0.0, "avg_logprob": -0.17797742843627928, "compression_ratio": 1.8058252427184467, "no_speech_prob": 0.001356032444164157}, {"id": 362, "seek": 223796, "start": 2246.08, "end": 2252.76, "text": " then we will need an exit tank. Hopefully we've now covered what those do and why you need them,", "tokens": [50770, 550, 321, 486, 643, 364, 11043, 5466, 13, 10429, 321, 600, 586, 5343, 437, 729, 360, 293, 983, 291, 643, 552, 11, 51104], "temperature": 0.0, "avg_logprob": -0.17797742843627928, "compression_ratio": 1.8058252427184467, "no_speech_prob": 0.001356032444164157}, {"id": 363, "seek": 223796, "start": 2252.76, "end": 2260.4, "text": " and things of that mind, etc. If you want to do a function call, you need an exit tank,", "tokens": [51104, 293, 721, 295, 300, 1575, 11, 5183, 13, 759, 291, 528, 281, 360, 257, 2445, 818, 11, 291, 643, 364, 11043, 5466, 11, 51486], "temperature": 0.0, "avg_logprob": -0.17797742843627928, "compression_ratio": 1.8058252427184467, "no_speech_prob": 0.001356032444164157}, {"id": 364, "seek": 223796, "start": 2260.4, "end": 2266.4, "text": " and to know which one to use, you have to know the type of the function that you want to call.", "tokens": [51486, 293, 281, 458, 597, 472, 281, 764, 11, 291, 362, 281, 458, 264, 2010, 295, 264, 2445, 300, 291, 528, 281, 818, 13, 51786], "temperature": 0.0, "avg_logprob": -0.17797742843627928, "compression_ratio": 1.8058252427184467, "no_speech_prob": 0.001356032444164157}, {"id": 365, "seek": 226640, "start": 2266.84, "end": 2274.44, "text": " Now, there's a particular subset of functions that don't know the type of the thing that they", "tokens": [50386, 823, 11, 456, 311, 257, 1729, 25993, 295, 6828, 300, 500, 380, 458, 264, 2010, 295, 264, 551, 300, 436, 50766], "temperature": 0.0, "avg_logprob": -0.16550605151118064, "compression_ratio": 1.896039603960396, "no_speech_prob": 0.002569050993770361}, {"id": 366, "seek": 226640, "start": 2274.44, "end": 2279.28, "text": " want to call. You might say that that's kind of weird, but let's just run with it for a while.", "tokens": [50766, 528, 281, 818, 13, 509, 1062, 584, 300, 300, 311, 733, 295, 3657, 11, 457, 718, 311, 445, 1190, 365, 309, 337, 257, 1339, 13, 51008], "temperature": 0.0, "avg_logprob": -0.16550605151118064, "compression_ratio": 1.896039603960396, "no_speech_prob": 0.002569050993770361}, {"id": 367, "seek": 226640, "start": 2279.28, "end": 2287.2400000000002, "text": " And furthermore, these functions don't know their own type, also weird, but what they do know is", "tokens": [51008, 400, 3052, 3138, 11, 613, 6828, 500, 380, 458, 641, 1065, 2010, 11, 611, 3657, 11, 457, 437, 436, 360, 458, 307, 51406], "temperature": 0.0, "avg_logprob": -0.16550605151118064, "compression_ratio": 1.896039603960396, "no_speech_prob": 0.002569050993770361}, {"id": 368, "seek": 226640, "start": 2287.2400000000002, "end": 2293.48, "text": " that their own type matches the type of the thing that they want to call. Now this may sound like", "tokens": [51406, 300, 641, 1065, 2010, 10676, 264, 2010, 295, 264, 551, 300, 436, 528, 281, 818, 13, 823, 341, 815, 1626, 411, 51718], "temperature": 0.0, "avg_logprob": -0.16550605151118064, "compression_ratio": 1.896039603960396, "no_speech_prob": 0.002569050993770361}, {"id": 369, "seek": 229348, "start": 2293.52, "end": 2299.52, "text": " a somewhat contrived set of properties, but it does actually crop up enough in practice that", "tokens": [50366, 257, 8344, 660, 470, 937, 992, 295, 7221, 11, 457, 309, 775, 767, 9086, 493, 1547, 294, 3124, 300, 50666], "temperature": 0.0, "avg_logprob": -0.16785249710083008, "compression_ratio": 1.5684647302904564, "no_speech_prob": 0.0025030402466654778}, {"id": 370, "seek": 229348, "start": 2299.52, "end": 2305.8, "text": " it's worth caring about. So to let these weird typeless functions that don't know their own type", "tokens": [50666, 309, 311, 3163, 15365, 466, 13, 407, 281, 718, 613, 3657, 2010, 1832, 6828, 300, 500, 380, 458, 641, 1065, 2010, 50980], "temperature": 0.0, "avg_logprob": -0.16785249710083008, "compression_ratio": 1.5684647302904564, "no_speech_prob": 0.0025030402466654778}, {"id": 371, "seek": 229348, "start": 2305.8, "end": 2311.92, "text": " and don't know what they're calling, to make them work, we give them an exit tank in X10. So", "tokens": [50980, 293, 500, 380, 458, 437, 436, 434, 5141, 11, 281, 652, 552, 589, 11, 321, 976, 552, 364, 11043, 5466, 294, 1783, 3279, 13, 407, 51286], "temperature": 0.0, "avg_logprob": -0.16785249710083008, "compression_ratio": 1.5684647302904564, "no_speech_prob": 0.0025030402466654778}, {"id": 372, "seek": 229348, "start": 2311.92, "end": 2317.04, "text": " if they are ARM code, they can just like, you know, run and say, well, whoever calls us put the", "tokens": [51286, 498, 436, 366, 45209, 3089, 11, 436, 393, 445, 411, 11, 291, 458, 11, 1190, 293, 584, 11, 731, 11, 11387, 5498, 505, 829, 264, 51542], "temperature": 0.0, "avg_logprob": -0.16785249710083008, "compression_ratio": 1.5684647302904564, "no_speech_prob": 0.0025030402466654778}, {"id": 373, "seek": 231704, "start": 2317.08, "end": 2325.88, "text": " appropriate thing in X10, and that will let us do the call that we want to do. So that means that", "tokens": [50366, 6854, 551, 294, 1783, 3279, 11, 293, 300, 486, 718, 505, 360, 264, 818, 300, 321, 528, 281, 360, 13, 407, 300, 1355, 300, 50806], "temperature": 0.0, "avg_logprob": -0.1668615965085609, "compression_ratio": 1.7149122807017543, "no_speech_prob": 0.07972902804613113}, {"id": 374, "seek": 231704, "start": 2325.88, "end": 2332.2, "text": " if we end up calling one of those functions, and it then wants to call an Intel function, then this", "tokens": [50806, 498, 321, 917, 493, 5141, 472, 295, 729, 6828, 11, 293, 309, 550, 2738, 281, 818, 364, 19762, 2445, 11, 550, 341, 51122], "temperature": 0.0, "avg_logprob": -0.1668615965085609, "compression_ratio": 1.7149122807017543, "no_speech_prob": 0.07972902804613113}, {"id": 375, "seek": 231704, "start": 2332.2, "end": 2339.6, "text": " isn't actually going to work, but in practice it's actually fine. It's not yet been a problem. It", "tokens": [51122, 1943, 380, 767, 516, 281, 589, 11, 457, 294, 3124, 309, 311, 767, 2489, 13, 467, 311, 406, 1939, 668, 257, 1154, 13, 467, 51492], "temperature": 0.0, "avg_logprob": -0.1668615965085609, "compression_ratio": 1.7149122807017543, "no_speech_prob": 0.07972902804613113}, {"id": 376, "seek": 231704, "start": 2339.6, "end": 2345.44, "text": " could be fixed, but it's going to be like a pain to fix. You might ask, why is it going to be a", "tokens": [51492, 727, 312, 6806, 11, 457, 309, 311, 516, 281, 312, 411, 257, 1822, 281, 3191, 13, 509, 1062, 1029, 11, 983, 307, 309, 516, 281, 312, 257, 51784], "temperature": 0.0, "avg_logprob": -0.1668615965085609, "compression_ratio": 1.7149122807017543, "no_speech_prob": 0.07972902804613113}, {"id": 377, "seek": 234544, "start": 2345.52, "end": 2352.36, "text": " pain to fix? That's because the FRI can call any type of function. So we can't just like", "tokens": [50368, 1822, 281, 3191, 30, 663, 311, 570, 264, 479, 5577, 393, 818, 604, 2010, 295, 2445, 13, 407, 321, 393, 380, 445, 411, 50710], "temperature": 0.0, "avg_logprob": -0.27487921247295305, "compression_ratio": 1.6816143497757847, "no_speech_prob": 0.004199296236038208}, {"id": 378, "seek": 234544, "start": 2352.36, "end": 2355.84, "text": " preprepare an appropriate function for every single type of function. That's going to be way", "tokens": [50710, 2666, 19919, 543, 364, 6854, 2445, 337, 633, 2167, 2010, 295, 2445, 13, 663, 311, 516, 281, 312, 636, 50884], "temperature": 0.0, "avg_logprob": -0.27487921247295305, "compression_ratio": 1.6816143497757847, "no_speech_prob": 0.004199296236038208}, {"id": 379, "seek": 234544, "start": 2355.84, "end": 2363.08, "text": " too many functions. So we have to jit compile the function that we want to use. And I mean,", "tokens": [50884, 886, 867, 6828, 13, 407, 321, 362, 281, 361, 270, 31413, 264, 2445, 300, 321, 528, 281, 764, 13, 400, 286, 914, 11, 51246], "temperature": 0.0, "avg_logprob": -0.27487921247295305, "compression_ratio": 1.6816143497757847, "no_speech_prob": 0.004199296236038208}, {"id": 380, "seek": 234544, "start": 2363.08, "end": 2370.84, "text": " like really, like, can we just like not do that? Yeah, I just rather not do that yet. So I've skipped", "tokens": [51246, 411, 534, 11, 411, 11, 393, 321, 445, 411, 406, 360, 300, 30, 865, 11, 286, 445, 2831, 406, 360, 300, 1939, 13, 407, 286, 600, 30193, 51634], "temperature": 0.0, "avg_logprob": -0.27487921247295305, "compression_ratio": 1.6816143497757847, "no_speech_prob": 0.004199296236038208}, {"id": 381, "seek": 237084, "start": 2370.96, "end": 2378.48, "text": " it. But it works. So, you know, great. That was interpreted, FRI calls. Then we've got jit", "tokens": [50370, 309, 13, 583, 309, 1985, 13, 407, 11, 291, 458, 11, 869, 13, 663, 390, 26749, 11, 479, 5577, 5498, 13, 1396, 321, 600, 658, 361, 270, 50746], "temperature": 0.0, "avg_logprob": -0.17351242899894714, "compression_ratio": 1.813953488372093, "no_speech_prob": 0.01032083947211504}, {"id": 382, "seek": 237084, "start": 2378.48, "end": 2383.56, "text": " compiled FRI calls. They're different because you will jit compile your call once, but then run it", "tokens": [50746, 36548, 479, 5577, 5498, 13, 814, 434, 819, 570, 291, 486, 361, 270, 31413, 428, 818, 1564, 11, 457, 550, 1190, 309, 51000], "temperature": 0.0, "avg_logprob": -0.17351242899894714, "compression_ratio": 1.813953488372093, "no_speech_prob": 0.01032083947211504}, {"id": 383, "seek": 237084, "start": 2383.56, "end": 2388.48, "text": " multiple times. So if we are jit compiling a call through a function pointer, we don't know", "tokens": [51000, 3866, 1413, 13, 407, 498, 321, 366, 361, 270, 715, 4883, 257, 818, 807, 257, 2445, 23918, 11, 321, 500, 380, 458, 51246], "temperature": 0.0, "avg_logprob": -0.17351242899894714, "compression_ratio": 1.813953488372093, "no_speech_prob": 0.01032083947211504}, {"id": 384, "seek": 237084, "start": 2388.48, "end": 2393.4, "text": " whether that function pointer will be Intel or will be ARM. So we have to kind of do what we're", "tokens": [51246, 1968, 300, 2445, 23918, 486, 312, 19762, 420, 486, 312, 45209, 13, 407, 321, 362, 281, 733, 295, 360, 437, 321, 434, 51492], "temperature": 0.0, "avg_logprob": -0.17351242899894714, "compression_ratio": 1.813953488372093, "no_speech_prob": 0.01032083947211504}, {"id": 385, "seek": 237084, "start": 2393.4, "end": 2399.96, "text": " meant to do more closely or almost do what we're meant to do. So, you know, we prepare the", "tokens": [51492, 4140, 281, 360, 544, 8185, 420, 1920, 360, 437, 321, 434, 4140, 281, 360, 13, 407, 11, 291, 458, 11, 321, 5940, 264, 51820], "temperature": 0.0, "avg_logprob": -0.17351242899894714, "compression_ratio": 1.813953488372093, "no_speech_prob": 0.01032083947211504}, {"id": 386, "seek": 239996, "start": 2400.0, "end": 2405.48, "text": " arguments as if it were a ARM call. If it ends up going to Intel, then we'll use an exit function", "tokens": [50366, 12869, 382, 498, 309, 645, 257, 45209, 818, 13, 759, 309, 5314, 493, 516, 281, 19762, 11, 550, 321, 603, 764, 364, 11043, 2445, 50640], "temperature": 0.0, "avg_logprob": -0.1694989651441574, "compression_ratio": 1.7843866171003717, "no_speech_prob": 0.0032767155207693577}, {"id": 387, "seek": 239996, "start": 2405.48, "end": 2413.28, "text": " to fix it up. We do the prep work that we went to do for the magical mystery function. All", "tokens": [50640, 281, 3191, 309, 493, 13, 492, 360, 264, 2666, 589, 300, 321, 1437, 281, 360, 337, 264, 12066, 11422, 2445, 13, 1057, 51030], "temperature": 0.0, "avg_logprob": -0.1694989651441574, "compression_ratio": 1.7843866171003717, "no_speech_prob": 0.0032767155207693577}, {"id": 388, "seek": 239996, "start": 2413.28, "end": 2418.76, "text": " but again, I didn't want to jit compile an exit function for every possible type of thing that", "tokens": [51030, 457, 797, 11, 286, 994, 380, 528, 281, 361, 270, 31413, 364, 11043, 2445, 337, 633, 1944, 2010, 295, 551, 300, 51304], "temperature": 0.0, "avg_logprob": -0.1694989651441574, "compression_ratio": 1.7843866171003717, "no_speech_prob": 0.0032767155207693577}, {"id": 389, "seek": 239996, "start": 2418.76, "end": 2423.44, "text": " we might call. Because like, we're already jit compiling a function. We don't want to jit compile", "tokens": [51304, 321, 1062, 818, 13, 1436, 411, 11, 321, 434, 1217, 361, 270, 715, 4883, 257, 2445, 13, 492, 500, 380, 528, 281, 361, 270, 31413, 51538], "temperature": 0.0, "avg_logprob": -0.1694989651441574, "compression_ratio": 1.7843866171003717, "no_speech_prob": 0.0032767155207693577}, {"id": 390, "seek": 239996, "start": 2423.44, "end": 2429.2400000000002, "text": " a function in addition to that at the same time. It just gets kind of hairy. So again, I cheated a", "tokens": [51538, 257, 2445, 294, 4500, 281, 300, 412, 264, 912, 565, 13, 467, 445, 2170, 733, 295, 42346, 13, 407, 797, 11, 286, 28079, 257, 51828], "temperature": 0.0, "avg_logprob": -0.1694989651441574, "compression_ratio": 1.7843866171003717, "no_speech_prob": 0.0032767155207693577}, {"id": 391, "seek": 242924, "start": 2429.2799999999997, "end": 2436.12, "text": " bit and said, well, let's just write one function. They can handle like every case that can get jit", "tokens": [50366, 857, 293, 848, 11, 731, 11, 718, 311, 445, 2464, 472, 2445, 13, 814, 393, 4813, 411, 633, 1389, 300, 393, 483, 361, 270, 50708], "temperature": 0.0, "avg_logprob": -0.2276514977523961, "compression_ratio": 1.6638297872340426, "no_speech_prob": 0.0024984506890177727}, {"id": 392, "seek": 242924, "start": 2436.12, "end": 2443.56, "text": " compiled and just pass it the signature that it has to kind of pretend to be and just put that in", "tokens": [50708, 715, 7292, 293, 445, 1320, 309, 264, 13397, 300, 309, 575, 281, 733, 295, 11865, 281, 312, 293, 445, 829, 300, 294, 51080], "temperature": 0.0, "avg_logprob": -0.2276514977523961, "compression_ratio": 1.6638297872340426, "no_speech_prob": 0.0024984506890177727}, {"id": 393, "seek": 242924, "start": 2443.56, "end": 2450.04, "text": " some other register. And again, this will work fine in practice unless we hit the case of calling", "tokens": [51080, 512, 661, 7280, 13, 400, 797, 11, 341, 486, 589, 2489, 294, 3124, 5969, 321, 2045, 264, 1389, 295, 5141, 51404], "temperature": 0.0, "avg_logprob": -0.2276514977523961, "compression_ratio": 1.6638297872340426, "no_speech_prob": 0.0024984506890177727}, {"id": 394, "seek": 242924, "start": 2450.04, "end": 2454.56, "text": " one of these typos functions that doesn't know their own type and it wants to call Intel and it", "tokens": [51404, 472, 295, 613, 2125, 329, 6828, 300, 1177, 380, 458, 641, 1065, 2010, 293, 309, 2738, 281, 818, 19762, 293, 309, 51630], "temperature": 0.0, "avg_logprob": -0.2276514977523961, "compression_ratio": 1.6638297872340426, "no_speech_prob": 0.0024984506890177727}, {"id": 395, "seek": 245456, "start": 2454.6, "end": 2460.96, "text": " happens to trash X15 that I've used to like, stash this X foot piece of state in. So again, not", "tokens": [50366, 2314, 281, 11321, 1783, 5211, 300, 286, 600, 1143, 281, 411, 11, 342, 1299, 341, 1783, 2671, 2522, 295, 1785, 294, 13, 407, 797, 11, 406, 50684], "temperature": 0.0, "avg_logprob": -0.2783186941435843, "compression_ratio": 1.5421686746987953, "no_speech_prob": 0.011065871454775333}, {"id": 396, "seek": 245456, "start": 2460.96, "end": 2467.72, "text": " quite following the rules, but again, it works fine in practice. And then the slide that you've", "tokens": [50684, 1596, 3480, 264, 4474, 11, 457, 797, 11, 309, 1985, 2489, 294, 3124, 13, 400, 550, 264, 4137, 300, 291, 600, 51022], "temperature": 0.0, "avg_logprob": -0.2783186941435843, "compression_ratio": 1.5421686746987953, "no_speech_prob": 0.011065871454775333}, {"id": 397, "seek": 245456, "start": 2467.72, "end": 2473.0, "text": " possibly all been waiting for, like, does this whole thing work? So you'll recall the first two", "tokens": [51022, 6264, 439, 668, 3806, 337, 11, 411, 11, 775, 341, 1379, 551, 589, 30, 407, 291, 603, 9901, 264, 700, 732, 51286], "temperature": 0.0, "avg_logprob": -0.2783186941435843, "compression_ratio": 1.5421686746987953, "no_speech_prob": 0.011065871454775333}, {"id": 398, "seek": 245456, "start": 2473.0, "end": 2479.72, "text": " lines from previous day. We said like, native ARM code ran in 37 seconds. The Intel code running", "tokens": [51286, 3876, 490, 3894, 786, 13, 492, 848, 411, 11, 8470, 45209, 3089, 5872, 294, 13435, 3949, 13, 440, 19762, 3089, 2614, 51622], "temperature": 0.0, "avg_logprob": -0.2783186941435843, "compression_ratio": 1.5421686746987953, "no_speech_prob": 0.011065871454775333}, {"id": 399, "seek": 247972, "start": 2479.7599999999998, "end": 2489.24, "text": " under relation to 106, whereas the R54 you see code takes 38, which is pretty good, right? So we're", "tokens": [50366, 833, 9721, 281, 1266, 21, 11, 9735, 264, 497, 19563, 291, 536, 3089, 2516, 12843, 11, 597, 307, 1238, 665, 11, 558, 30, 407, 321, 434, 50840], "temperature": 0.0, "avg_logprob": -0.3178126573562622, "compression_ratio": 1.4390243902439024, "no_speech_prob": 0.008525475859642029}, {"id": 400, "seek": 247972, "start": 2489.24, "end": 2497.3199999999997, "text": " kind of saying here, this is, it's native ARM code, so it should be close to 37 seconds, but it's", "tokens": [50840, 733, 295, 1566, 510, 11, 341, 307, 11, 309, 311, 8470, 45209, 3089, 11, 370, 309, 820, 312, 1998, 281, 13435, 3949, 11, 457, 309, 311, 51244], "temperature": 0.0, "avg_logprob": -0.3178126573562622, "compression_ratio": 1.4390243902439024, "no_speech_prob": 0.008525475859642029}, {"id": 401, "seek": 247972, "start": 2497.3199999999997, "end": 2504.16, "text": " making a combination such that it could call Intel code as and when it needs to. And making those", "tokens": [51244, 1455, 257, 6562, 1270, 300, 309, 727, 818, 19762, 3089, 382, 293, 562, 309, 2203, 281, 13, 400, 1455, 729, 51586], "temperature": 0.0, "avg_logprob": -0.3178126573562622, "compression_ratio": 1.4390243902439024, "no_speech_prob": 0.008525475859642029}, {"id": 402, "seek": 250416, "start": 2504.2, "end": 2509.44, "text": " combinations will slow you down by a few percentage points. But you know, you're in a much", "tokens": [50366, 21267, 486, 2964, 291, 760, 538, 257, 1326, 9668, 2793, 13, 583, 291, 458, 11, 291, 434, 294, 257, 709, 50628], "temperature": 0.0, "avg_logprob": -0.24944851133558485, "compression_ratio": 1.425, "no_speech_prob": 0.009297287091612816}, {"id": 403, "seek": 250416, "start": 2509.44, "end": 2513.7999999999997, "text": " better place than you would otherwise be. And yeah, this crazy idea of Microsoft actually works.", "tokens": [50628, 1101, 1081, 813, 291, 576, 5911, 312, 13, 400, 1338, 11, 341, 3219, 1558, 295, 8116, 767, 1985, 13, 50846], "temperature": 0.0, "avg_logprob": -0.24944851133558485, "compression_ratio": 1.425, "no_speech_prob": 0.009297287091612816}, {"id": 404, "seek": 250416, "start": 2513.7999999999997, "end": 2533.04, "text": " I can do one more slide or questions. Do you want to do? One more slide. Okay, great. So problems", "tokens": [50846, 286, 393, 360, 472, 544, 4137, 420, 1651, 13, 1144, 291, 528, 281, 360, 30, 1485, 544, 4137, 13, 1033, 11, 869, 13, 407, 2740, 51808], "temperature": 0.0, "avg_logprob": -0.24944851133558485, "compression_ratio": 1.425, "no_speech_prob": 0.009297287091612816}, {"id": 405, "seek": 253304, "start": 2533.08, "end": 2541.2, "text": " you didn't know that you had. Yeah, Linux has LD preload, which if you've used, you know, I want", "tokens": [50366, 291, 994, 380, 458, 300, 291, 632, 13, 865, 11, 18734, 575, 33936, 659, 2907, 11, 597, 498, 291, 600, 1143, 11, 291, 458, 11, 286, 528, 50772], "temperature": 0.0, "avg_logprob": -0.32999100003923687, "compression_ratio": 1.6131687242798354, "no_speech_prob": 0.0961255431175232}, {"id": 406, "seek": 253304, "start": 2541.2, "end": 2548.0, "text": " to let you know, change the malloc that I call or like, make F sync not slow. LD preload, great.", "tokens": [50772, 281, 718, 291, 458, 11, 1319, 264, 16026, 905, 300, 286, 818, 420, 411, 11, 652, 479, 20271, 406, 2964, 13, 33936, 659, 2907, 11, 869, 13, 51112], "temperature": 0.0, "avg_logprob": -0.32999100003923687, "compression_ratio": 1.6131687242798354, "no_speech_prob": 0.0961255431175232}, {"id": 407, "seek": 253304, "start": 2548.0, "end": 2553.84, "text": " Mac OS has LD, the old insert libraries, same thing, not quite the same details, but like the same", "tokens": [51112, 5707, 12731, 575, 33936, 11, 264, 1331, 8969, 15148, 11, 912, 551, 11, 406, 1596, 264, 912, 4365, 11, 457, 411, 264, 912, 51404], "temperature": 0.0, "avg_logprob": -0.32999100003923687, "compression_ratio": 1.6131687242798354, "no_speech_prob": 0.0961255431175232}, {"id": 408, "seek": 253304, "start": 2553.84, "end": 2562.04, "text": " thing. Windows doesn't have such a thing. It has ad hoc machine code patching. Yeah. And as a bonus", "tokens": [51404, 551, 13, 8591, 1177, 380, 362, 1270, 257, 551, 13, 467, 575, 614, 16708, 3479, 3089, 9972, 278, 13, 865, 13, 400, 382, 257, 10882, 51814], "temperature": 0.0, "avg_logprob": -0.32999100003923687, "compression_ratio": 1.6131687242798354, "no_speech_prob": 0.0961255431175232}, {"id": 409, "seek": 256204, "start": 2562.08, "end": 2569.12, "text": " point, Microsoft research used to sell a product called detours for doing this. Possibly like", "tokens": [50366, 935, 11, 8116, 2132, 1143, 281, 3607, 257, 1674, 1219, 1141, 5067, 337, 884, 341, 13, 33112, 3545, 411, 50718], "temperature": 0.0, "avg_logprob": -0.21900038097215735, "compression_ratio": 1.6059322033898304, "no_speech_prob": 0.016597971320152283}, {"id": 410, "seek": 256204, "start": 2569.12, "end": 2575.84, "text": " Microsoft research is only consumer facing product. Unsure. They made that open source on", "tokens": [50718, 8116, 2132, 307, 787, 9711, 7170, 1674, 13, 25017, 540, 13, 814, 1027, 300, 1269, 4009, 322, 51054], "temperature": 0.0, "avg_logprob": -0.21900038097215735, "compression_ratio": 1.6059322033898304, "no_speech_prob": 0.016597971320152283}, {"id": 411, "seek": 256204, "start": 2575.84, "end": 2583.96, "text": " GitHub in like 2016. So you can go and find detours on GitHub and it will do 0.3. So you know how", "tokens": [51054, 23331, 294, 411, 6549, 13, 407, 291, 393, 352, 293, 915, 1141, 5067, 322, 23331, 293, 309, 486, 360, 1958, 13, 18, 13, 407, 291, 458, 577, 51460], "temperature": 0.0, "avg_logprob": -0.21900038097215735, "compression_ratio": 1.6059322033898304, "no_speech_prob": 0.016597971320152283}, {"id": 412, "seek": 256204, "start": 2583.96, "end": 2588.96, "text": " code lying around in your Intel code that expects to be able to go into other functions and patch", "tokens": [51460, 3089, 8493, 926, 294, 428, 19762, 3089, 300, 33280, 281, 312, 1075, 281, 352, 666, 661, 6828, 293, 9972, 51710], "temperature": 0.0, "avg_logprob": -0.21900038097215735, "compression_ratio": 1.6059322033898304, "no_speech_prob": 0.016597971320152283}, {"id": 413, "seek": 258896, "start": 2589.04, "end": 2595.44, "text": " them up. So to make this work, we have to take our functions and wrap them in a small Intel shell.", "tokens": [50368, 552, 493, 13, 407, 281, 652, 341, 589, 11, 321, 362, 281, 747, 527, 6828, 293, 7019, 552, 294, 257, 1359, 19762, 8720, 13, 50688], "temperature": 0.0, "avg_logprob": -0.21359841654619832, "compression_ratio": 1.7153024911032029, "no_speech_prob": 0.008608652278780937}, {"id": 414, "seek": 258896, "start": 2595.44, "end": 2600.04, "text": " So if you look at the shell, you're like, yeah, that's in the Intel code. I'll just patch that for", "tokens": [50688, 407, 498, 291, 574, 412, 264, 8720, 11, 291, 434, 411, 11, 1338, 11, 300, 311, 294, 264, 19762, 3089, 13, 286, 603, 445, 9972, 300, 337, 50918], "temperature": 0.0, "avg_logprob": -0.21359841654619832, "compression_ratio": 1.7153024911032029, "no_speech_prob": 0.008608652278780937}, {"id": 415, "seek": 258896, "start": 2600.04, "end": 2607.48, "text": " you. And that's fun, right? So one of these magical mystery functions can kind of spot these", "tokens": [50918, 291, 13, 400, 300, 311, 1019, 11, 558, 30, 407, 472, 295, 613, 12066, 11422, 6828, 393, 733, 295, 4008, 613, 51290], "temperature": 0.0, "avg_logprob": -0.21359841654619832, "compression_ratio": 1.7153024911032029, "no_speech_prob": 0.008608652278780937}, {"id": 416, "seek": 258896, "start": 2607.48, "end": 2613.08, "text": " shells and kind of skip right over them. But yeah, those shells are going to be here to make this", "tokens": [51290, 22523, 293, 733, 295, 10023, 558, 670, 552, 13, 583, 1338, 11, 729, 22523, 366, 516, 281, 312, 510, 281, 652, 341, 51570], "temperature": 0.0, "avg_logprob": -0.21359841654619832, "compression_ratio": 1.7153024911032029, "no_speech_prob": 0.008608652278780937}, {"id": 417, "seek": 258896, "start": 2613.08, "end": 2616.6, "text": " thing work. That shouldn't be a problem in the first place, but it is because Windows doesn't", "tokens": [51570, 551, 589, 13, 663, 4659, 380, 312, 257, 1154, 294, 264, 700, 1081, 11, 457, 309, 307, 570, 8591, 1177, 380, 51746], "temperature": 0.0, "avg_logprob": -0.21359841654619832, "compression_ratio": 1.7153024911032029, "no_speech_prob": 0.008608652278780937}, {"id": 418, "seek": 261660, "start": 2616.64, "end": 2623.12, "text": " have any of these systems. Bonus funds. Let's get back to here when we don't have to worry about", "tokens": [50366, 362, 604, 295, 613, 3652, 13, 44917, 8271, 13, 961, 311, 483, 646, 281, 510, 562, 321, 500, 380, 362, 281, 3292, 466, 50690], "temperature": 0.0, "avg_logprob": -0.26847129709580364, "compression_ratio": 1.3636363636363635, "no_speech_prob": 0.0020893451292067766}, {"id": 419, "seek": 261660, "start": 2623.12, "end": 2631.64, "text": " the bonus problems. Okay. Great. Thank you, Peter. We have time.", "tokens": [50690, 264, 10882, 2740, 13, 1033, 13, 3769, 13, 1044, 291, 11, 6508, 13, 492, 362, 565, 13, 51116], "temperature": 0.0, "avg_logprob": -0.26847129709580364, "compression_ratio": 1.3636363636363635, "no_speech_prob": 0.0020893451292067766}, {"id": 420, "seek": 261660, "start": 2631.64, "end": 2643.2, "text": " All right, let's do some questions. I'm going to start with one from online because otherwise", "tokens": [51116, 1057, 558, 11, 718, 311, 360, 512, 1651, 13, 286, 478, 516, 281, 722, 365, 472, 490, 2950, 570, 5911, 51694], "temperature": 0.0, "avg_logprob": -0.26847129709580364, "compression_ratio": 1.3636363636363635, "no_speech_prob": 0.0020893451292067766}, {"id": 421, "seek": 264320, "start": 2643.2799999999997, "end": 2654.7999999999997, "text": " we won't forget it. Can Intel code call ARM code? Oh, yes. Quick yes. Yes. Hands. This is the loop.", "tokens": [50368, 321, 1582, 380, 2870, 309, 13, 1664, 19762, 3089, 818, 45209, 3089, 30, 876, 11, 2086, 13, 12101, 2086, 13, 1079, 13, 21369, 13, 639, 307, 264, 6367, 13, 50944], "temperature": 0.0, "avg_logprob": -0.3161438263214386, "compression_ratio": 1.6711111111111112, "no_speech_prob": 0.0772060826420784}, {"id": 422, "seek": 264320, "start": 2654.7999999999997, "end": 2660.64, "text": " Am I now trying to call ARM code? No. So I'm going to call Intel code. No, I'm trying to call ARM", "tokens": [50944, 2012, 286, 586, 1382, 281, 818, 45209, 3089, 30, 883, 13, 407, 286, 478, 516, 281, 818, 19762, 3089, 13, 883, 11, 286, 478, 1382, 281, 818, 45209, 51236], "temperature": 0.0, "avg_logprob": -0.3161438263214386, "compression_ratio": 1.6711111111111112, "no_speech_prob": 0.0772060826420784}, {"id": 423, "seek": 264320, "start": 2660.64, "end": 2666.0, "text": " code. So we go over here and we go through the stack for calling ARM code. Yep, it all works.", "tokens": [51236, 3089, 13, 407, 321, 352, 670, 510, 293, 321, 352, 807, 264, 8630, 337, 5141, 45209, 3089, 13, 7010, 11, 309, 439, 1985, 13, 51504], "temperature": 0.0, "avg_logprob": -0.3161438263214386, "compression_ratio": 1.6711111111111112, "no_speech_prob": 0.0772060826420784}, {"id": 424, "seek": 264320, "start": 2666.0, "end": 2669.3999999999996, "text": " All right, one more time, hands, because I wasn't paying attention. I'll start here.", "tokens": [51504, 1057, 558, 11, 472, 544, 565, 11, 2377, 11, 570, 286, 2067, 380, 6229, 3202, 13, 286, 603, 722, 510, 13, 51674], "temperature": 0.0, "avg_logprob": -0.3161438263214386, "compression_ratio": 1.6711111111111112, "no_speech_prob": 0.0772060826420784}, {"id": 425, "seek": 267320, "start": 2674.2, "end": 2689.8799999999997, "text": " How do you decide which code you can compile to ARM and which parts of the code you cannot", "tokens": [50414, 1012, 360, 291, 4536, 597, 3089, 291, 393, 31413, 281, 45209, 293, 597, 3166, 295, 264, 3089, 291, 2644, 51198], "temperature": 0.0, "avg_logprob": -0.29117215822820797, "compression_ratio": 1.4840425531914894, "no_speech_prob": 0.01535270269960165}, {"id": 426, "seek": 267320, "start": 2689.8799999999997, "end": 2695.3999999999996, "text": " and have to leave as Intel? So for the Luiget case, it's fairly simple because there's already an ARM", "tokens": [51198, 293, 362, 281, 1856, 382, 19762, 30, 407, 337, 264, 5047, 328, 302, 1389, 11, 309, 311, 6457, 2199, 570, 456, 311, 1217, 364, 45209, 51474], "temperature": 0.0, "avg_logprob": -0.29117215822820797, "compression_ratio": 1.4840425531914894, "no_speech_prob": 0.01535270269960165}, {"id": 427, "seek": 267320, "start": 2695.3999999999996, "end": 2703.16, "text": " version of Luiget. If you're going to write your own program, the advice is start with", "tokens": [51474, 3037, 295, 5047, 328, 302, 13, 759, 291, 434, 516, 281, 2464, 428, 1065, 1461, 11, 264, 5192, 307, 722, 365, 51862], "temperature": 0.0, "avg_logprob": -0.29117215822820797, "compression_ratio": 1.4840425531914894, "no_speech_prob": 0.01535270269960165}, {"id": 428, "seek": 270316, "start": 2704.12, "end": 2710.3199999999997, "text": " the hot parts and port those first. If that works, then you can slowly port more and more.", "tokens": [50412, 264, 2368, 3166, 293, 2436, 729, 700, 13, 759, 300, 1985, 11, 550, 291, 393, 5692, 2436, 544, 293, 544, 13, 50722], "temperature": 0.0, "avg_logprob": -0.4055267572402954, "compression_ratio": 1.4588235294117646, "no_speech_prob": 0.012841828167438507}, {"id": 429, "seek": 270316, "start": 2710.3199999999997, "end": 2714.64, "text": " I can get incremental speed improvements after you're porting more and more code. Over.", "tokens": [50722, 286, 393, 483, 35759, 3073, 13797, 934, 291, 434, 2436, 278, 544, 293, 544, 3089, 13, 4886, 13, 50938], "temperature": 0.0, "avg_logprob": -0.4055267572402954, "compression_ratio": 1.4588235294117646, "no_speech_prob": 0.012841828167438507}, {"id": 430, "seek": 270316, "start": 2714.64, "end": 2724.7999999999997, "text": " Next question. Close by. Okay. Hi. Very nice presentation. Thank you.", "tokens": [50938, 3087, 1168, 13, 16346, 538, 13, 1033, 13, 2421, 13, 4372, 1481, 5860, 13, 1044, 291, 13, 51446], "temperature": 0.0, "avg_logprob": -0.4055267572402954, "compression_ratio": 1.4588235294117646, "no_speech_prob": 0.012841828167438507}, {"id": 431, "seek": 272480, "start": 2725.8, "end": 2734.8, "text": " Hello. Okay. Yeah. Thank you very much. It was a very nice presentation. I was just curious", "tokens": [50414, 2425, 13, 1033, 13, 865, 13, 1044, 291, 588, 709, 13, 467, 390, 257, 588, 1481, 5860, 13, 286, 390, 445, 6369, 50864], "temperature": 0.0, "avg_logprob": -0.3896988355196439, "compression_ratio": 1.5343915343915344, "no_speech_prob": 0.047481831163167953}, {"id": 432, "seek": 272480, "start": 2734.8, "end": 2742.44, "text": " what your experience is with the tooling support for these. What support? Like tooling support for", "tokens": [50864, 437, 428, 1752, 307, 365, 264, 46593, 1406, 337, 613, 13, 708, 1406, 30, 1743, 46593, 1406, 337, 51246], "temperature": 0.0, "avg_logprob": -0.3896988355196439, "compression_ratio": 1.5343915343915344, "no_speech_prob": 0.047481831163167953}, {"id": 433, "seek": 272480, "start": 2742.44, "end": 2748.92, "text": " these AVI, like the bloggers, compilers, what the support is like, if it's easy to use or. So yeah,", "tokens": [51246, 613, 316, 25322, 11, 411, 264, 6968, 9458, 11, 715, 388, 433, 11, 437, 264, 1406, 307, 411, 11, 498, 309, 311, 1858, 281, 764, 420, 13, 407, 1338, 11, 51570], "temperature": 0.0, "avg_logprob": -0.3896988355196439, "compression_ratio": 1.5343915343915344, "no_speech_prob": 0.047481831163167953}, {"id": 434, "seek": 274892, "start": 2748.96, "end": 2757.2400000000002, "text": " the Microsoft C compiler can handle all of this fine. I think clang in LVM, kind of getting a few", "tokens": [50366, 264, 8116, 383, 31958, 393, 4813, 439, 295, 341, 2489, 13, 286, 519, 596, 656, 294, 441, 53, 44, 11, 733, 295, 1242, 257, 1326, 50780], "temperature": 0.0, "avg_logprob": -0.2879708180060753, "compression_ratio": 1.5806451612903225, "no_speech_prob": 0.05076924338936806}, {"id": 435, "seek": 274892, "start": 2757.2400000000002, "end": 2764.16, "text": " patches solely, but I'm going to be there for a while. The Visual Studio debugger for this stuff is", "tokens": [50780, 26531, 23309, 11, 457, 286, 478, 516, 281, 312, 456, 337, 257, 1339, 13, 440, 23187, 13500, 24083, 1321, 337, 341, 1507, 307, 51126], "temperature": 0.0, "avg_logprob": -0.2879708180060753, "compression_ratio": 1.5806451612903225, "no_speech_prob": 0.05076924338936806}, {"id": 436, "seek": 274892, "start": 2764.16, "end": 2769.96, "text": " great. You can single step through from ARM code to Intel code. I like not even notice that you've", "tokens": [51126, 869, 13, 509, 393, 2167, 1823, 807, 490, 45209, 3089, 281, 19762, 3089, 13, 286, 411, 406, 754, 3449, 300, 291, 600, 51416], "temperature": 0.0, "avg_logprob": -0.2879708180060753, "compression_ratio": 1.5806451612903225, "no_speech_prob": 0.05076924338936806}, {"id": 437, "seek": 274892, "start": 2769.96, "end": 2775.7200000000003, "text": " done a mode switch, which was kind of scary. Like, okay, single step, single step, single step,", "tokens": [51416, 1096, 257, 4391, 3679, 11, 597, 390, 733, 295, 6958, 13, 1743, 11, 1392, 11, 2167, 1823, 11, 2167, 1823, 11, 2167, 1823, 11, 51704], "temperature": 0.0, "avg_logprob": -0.2879708180060753, "compression_ratio": 1.5806451612903225, "no_speech_prob": 0.05076924338936806}, {"id": 438, "seek": 277572, "start": 2776.3599999999997, "end": 2782.3999999999996, "text": " wait, what? I'm now in like ARM code. Okay, fine. So yeah, the Microsoft tooling is very good.", "tokens": [50396, 1699, 11, 437, 30, 286, 478, 586, 294, 411, 45209, 3089, 13, 1033, 11, 2489, 13, 407, 1338, 11, 264, 8116, 46593, 307, 588, 665, 13, 50698], "temperature": 0.0, "avg_logprob": -0.2535095403690149, "compression_ratio": 1.5, "no_speech_prob": 0.005831720307469368}, {"id": 439, "seek": 277572, "start": 2782.3999999999996, "end": 2785.24, "text": " The open source tooling not yet, not yet really there.", "tokens": [50698, 440, 1269, 4009, 46593, 406, 1939, 11, 406, 1939, 534, 456, 13, 50840], "temperature": 0.0, "avg_logprob": -0.2535095403690149, "compression_ratio": 1.5, "no_speech_prob": 0.005831720307469368}, {"id": 440, "seek": 277572, "start": 2790.0, "end": 2794.52, "text": " So what I don't, maybe I've missed it, but what I don't quite understand is what I see here is the", "tokens": [51078, 407, 437, 286, 500, 380, 11, 1310, 286, 600, 6721, 309, 11, 457, 437, 286, 500, 380, 1596, 1223, 307, 437, 286, 536, 510, 307, 264, 51304], "temperature": 0.0, "avg_logprob": -0.2535095403690149, "compression_ratio": 1.5, "no_speech_prob": 0.005831720307469368}, {"id": 441, "seek": 277572, "start": 2794.52, "end": 2801.0, "text": " ARM64 AVI has been changed to match the Intel AVI a little bit more, right, to make this work. Yep.", "tokens": [51304, 45209, 19395, 316, 25322, 575, 668, 3105, 281, 2995, 264, 19762, 316, 25322, 257, 707, 857, 544, 11, 558, 11, 281, 652, 341, 589, 13, 7010, 13, 51628], "temperature": 0.0, "avg_logprob": -0.2535095403690149, "compression_ratio": 1.5, "no_speech_prob": 0.005831720307469368}, {"id": 442, "seek": 280100, "start": 2801.08, "end": 2808.12, "text": " So how does that work when calling ARM64 Windows API functions? Do they have ARM64 EC versions of", "tokens": [50368, 407, 577, 775, 300, 589, 562, 5141, 45209, 19395, 8591, 9362, 6828, 30, 1144, 436, 362, 45209, 19395, 19081, 9606, 295, 50720], "temperature": 0.0, "avg_logprob": -0.2364635467529297, "compression_ratio": 1.490566037735849, "no_speech_prob": 0.00710918428376317}, {"id": 443, "seek": 280100, "start": 2808.12, "end": 2810.12, "text": " all of them? Yep. Wow. Yep.", "tokens": [50720, 439, 295, 552, 30, 7010, 13, 3153, 13, 7010, 13, 50820], "temperature": 0.0, "avg_logprob": -0.2364635467529297, "compression_ratio": 1.490566037735849, "no_speech_prob": 0.00710918428376317}, {"id": 444, "seek": 280100, "start": 2817.56, "end": 2822.6, "text": " Yes, I have another question. It's a bit related to the question that was just asked about tool", "tokens": [51192, 1079, 11, 286, 362, 1071, 1168, 13, 467, 311, 257, 857, 4077, 281, 264, 1168, 300, 390, 445, 2351, 466, 2290, 51444], "temperature": 0.0, "avg_logprob": -0.2364635467529297, "compression_ratio": 1.490566037735849, "no_speech_prob": 0.00710918428376317}, {"id": 445, "seek": 280100, "start": 2822.6, "end": 2830.2, "text": " sense. Do you know other open source tool sense that support ARM64 EC, like GCC or maybe other", "tokens": [51444, 2020, 13, 1144, 291, 458, 661, 1269, 4009, 2290, 2020, 300, 1406, 45209, 19395, 19081, 11, 411, 460, 11717, 420, 1310, 661, 51824], "temperature": 0.0, "avg_logprob": -0.2364635467529297, "compression_ratio": 1.490566037735849, "no_speech_prob": 0.00710918428376317}, {"id": 446, "seek": 283020, "start": 2830.2799999999997, "end": 2837.3199999999997, "text": " GIT compilers? Yeah, that's my first question. Yeah, I've seen some patches land in Y and in", "tokens": [50368, 460, 3927, 715, 388, 433, 30, 865, 11, 300, 311, 452, 700, 1168, 13, 865, 11, 286, 600, 1612, 512, 26531, 2117, 294, 398, 293, 294, 50720], "temperature": 0.0, "avg_logprob": -0.2513767568076529, "compression_ratio": 1.4619289340101522, "no_speech_prob": 0.0036707466933876276}, {"id": 447, "seek": 283020, "start": 2837.3199999999997, "end": 2844.68, "text": " Clang and LVM, but I kind of, I suspect they're all kind of starting to do things rather than like full support.", "tokens": [50720, 2033, 656, 293, 441, 53, 44, 11, 457, 286, 733, 295, 11, 286, 9091, 436, 434, 439, 733, 295, 2891, 281, 360, 721, 2831, 813, 411, 1577, 1406, 13, 51088], "temperature": 0.0, "avg_logprob": -0.2513767568076529, "compression_ratio": 1.4619289340101522, "no_speech_prob": 0.0036707466933876276}, {"id": 448, "seek": 283020, "start": 2846.6, "end": 2850.68, "text": " Okay, another question and maybe, maybe I'm not sure I understood, but so you have", "tokens": [51184, 1033, 11, 1071, 1168, 293, 1310, 11, 1310, 286, 478, 406, 988, 286, 7320, 11, 457, 370, 291, 362, 51388], "temperature": 0.0, "avg_logprob": -0.2513767568076529, "compression_ratio": 1.4619289340101522, "no_speech_prob": 0.0036707466933876276}, {"id": 449, "seek": 285068, "start": 2851.3999999999996, "end": 2859.3199999999997, "text": " LuaGIT users that want to call, do FFI basically with X64 code. So that's basically why you implemented", "tokens": [50400, 441, 4398, 38, 3927, 5022, 300, 528, 281, 818, 11, 360, 479, 38568, 1936, 365, 1783, 19395, 3089, 13, 407, 300, 311, 1936, 983, 291, 12270, 50796], "temperature": 0.0, "avg_logprob": -0.39266656728891225, "compression_ratio": 1.305732484076433, "no_speech_prob": 0.02017347328364849}, {"id": 450, "seek": 285068, "start": 2859.3199999999997, "end": 2862.7599999999998, "text": " the... Yeah, yes, most of your program is in Lua.", "tokens": [50796, 264, 485, 865, 11, 2086, 11, 881, 295, 428, 1461, 307, 294, 441, 4398, 13, 50968], "temperature": 0.0, "avg_logprob": -0.39266656728891225, "compression_ratio": 1.305732484076433, "no_speech_prob": 0.02017347328364849}, {"id": 451, "seek": 285068, "start": 2868.8399999999997, "end": 2869.16, "text": " Thank you.", "tokens": [51272, 1044, 291, 13, 51288], "temperature": 0.0, "avg_logprob": -0.39266656728891225, "compression_ratio": 1.305732484076433, "no_speech_prob": 0.02017347328364849}, {"id": 452, "seek": 285068, "start": 2872.68, "end": 2874.2799999999997, "text": " Any more questions? Oh, yeah, of course.", "tokens": [51464, 2639, 544, 1651, 30, 876, 11, 1338, 11, 295, 1164, 13, 51544], "temperature": 0.0, "avg_logprob": -0.39266656728891225, "compression_ratio": 1.305732484076433, "no_speech_prob": 0.02017347328364849}, {"id": 453, "seek": 287428, "start": 2874.76, "end": 2882.28, "text": " Just, I think I didn't get, so you reduced the number of ARM registers, but wouldn't it possible to", "tokens": [50388, 1449, 11, 286, 519, 286, 994, 380, 483, 11, 370, 291, 9212, 264, 1230, 295, 45209, 38351, 11, 457, 2759, 380, 309, 1944, 281, 50764], "temperature": 0.0, "avg_logprob": -0.45269248599097844, "compression_ratio": 1.3594771241830066, "no_speech_prob": 0.017055731266736984}, {"id": 454, "seek": 287428, "start": 2882.28, "end": 2884.76, "text": " spill them to memory when you do the mode switch?", "tokens": [50764, 22044, 552, 281, 4675, 562, 291, 360, 264, 4391, 3679, 30, 50888], "temperature": 0.0, "avg_logprob": -0.45269248599097844, "compression_ratio": 1.3594771241830066, "no_speech_prob": 0.017055731266736984}, {"id": 455, "seek": 287428, "start": 2892.76, "end": 2895.2400000000002, "text": " Here's my cutout. So I'm going to run around.", "tokens": [51288, 1692, 311, 452, 1723, 346, 13, 407, 286, 478, 516, 281, 1190, 926, 13, 51412], "temperature": 0.0, "avg_logprob": -0.45269248599097844, "compression_ratio": 1.3594771241830066, "no_speech_prob": 0.017055731266736984}, {"id": 456, "seek": 287428, "start": 2897.8, "end": 2898.76, "text": " Here you go.", "tokens": [51540, 1692, 291, 352, 13, 51588], "temperature": 0.0, "avg_logprob": -0.45269248599097844, "compression_ratio": 1.3594771241830066, "no_speech_prob": 0.017055731266736984}, {"id": 457, "seek": 289876, "start": 2899.6400000000003, "end": 2908.76, "text": " Yeah, so it's, you can't spill them because you don't have any way to spill them to.", "tokens": [50408, 865, 11, 370, 309, 311, 11, 291, 393, 380, 22044, 552, 570, 291, 500, 380, 362, 604, 636, 281, 22044, 552, 281, 13, 50864], "temperature": 0.0, "avg_logprob": -0.1935336176554362, "compression_ratio": 1.558659217877095, "no_speech_prob": 0.0025261954870074987}, {"id": 458, "seek": 289876, "start": 2909.5600000000004, "end": 2915.6400000000003, "text": " Like if it was only the operating system that did mode switches between threads, you'd be fine.", "tokens": [50904, 1743, 498, 309, 390, 787, 264, 7447, 1185, 300, 630, 4391, 19458, 1296, 19314, 11, 291, 1116, 312, 2489, 13, 51208], "temperature": 0.0, "avg_logprob": -0.1935336176554362, "compression_ratio": 1.558659217877095, "no_speech_prob": 0.0025261954870074987}, {"id": 459, "seek": 289876, "start": 2917.1600000000003, "end": 2921.4, "text": " But you know, you can call such jump and long jump and there's like, there's not space in the jump", "tokens": [51284, 583, 291, 458, 11, 291, 393, 818, 1270, 3012, 293, 938, 3012, 293, 456, 311, 411, 11, 456, 311, 406, 1901, 294, 264, 3012, 51496], "temperature": 0.0, "avg_logprob": -0.1935336176554362, "compression_ratio": 1.558659217877095, "no_speech_prob": 0.0025261954870074987}, {"id": 460, "seek": 292140, "start": 2921.4, "end": 2929.32, "text": " buff to put the extra things. Or if you're really adventurous, you can do kind of user space", "tokens": [50364, 9204, 281, 829, 264, 2857, 721, 13, 1610, 498, 291, 434, 534, 46163, 11, 291, 393, 360, 733, 295, 4195, 1901, 50760], "temperature": 0.0, "avg_logprob": -0.12174206120627266, "compression_ratio": 1.892, "no_speech_prob": 0.17470329999923706}, {"id": 461, "seek": 292140, "start": 2929.32, "end": 2935.1600000000003, "text": " scheduling in Windows. You know, you can call suspend thread and then like resume thread and", "tokens": [50760, 29055, 294, 8591, 13, 509, 458, 11, 291, 393, 818, 42546, 7207, 293, 550, 411, 15358, 7207, 293, 51052], "temperature": 0.0, "avg_logprob": -0.12174206120627266, "compression_ratio": 1.892, "no_speech_prob": 0.17470329999923706}, {"id": 462, "seek": 292140, "start": 2935.1600000000003, "end": 2941.1600000000003, "text": " like move your contacts in between threads. And you know, you could have Intel threads doing this", "tokens": [51052, 411, 1286, 428, 15836, 294, 1296, 19314, 13, 400, 291, 458, 11, 291, 727, 362, 19762, 19314, 884, 341, 51352], "temperature": 0.0, "avg_logprob": -0.12174206120627266, "compression_ratio": 1.892, "no_speech_prob": 0.17470329999923706}, {"id": 463, "seek": 292140, "start": 2941.1600000000003, "end": 2945.2400000000002, "text": " onto your ARM threads. The Intel threads don't know that they're doing this to ARM threads.", "tokens": [51352, 3911, 428, 45209, 19314, 13, 440, 19762, 19314, 500, 380, 458, 300, 436, 434, 884, 341, 281, 45209, 19314, 13, 51556], "temperature": 0.0, "avg_logprob": -0.12174206120627266, "compression_ratio": 1.892, "no_speech_prob": 0.17470329999923706}, {"id": 464, "seek": 292140, "start": 2945.96, "end": 2950.2000000000003, "text": " So you don't have any extra space to put the ARM states because they didn't know that they'd need", "tokens": [51592, 407, 291, 500, 380, 362, 604, 2857, 1901, 281, 829, 264, 45209, 4368, 570, 436, 994, 380, 458, 300, 436, 1116, 643, 51804], "temperature": 0.0, "avg_logprob": -0.12174206120627266, "compression_ratio": 1.892, "no_speech_prob": 0.17470329999923706}, {"id": 465, "seek": 295020, "start": 2950.2, "end": 2951.3199999999997, "text": " this extra space.", "tokens": [50364, 341, 2857, 1901, 13, 50420], "temperature": 0.0, "avg_logprob": -0.16008402580438658, "compression_ratio": 1.4919786096256684, "no_speech_prob": 0.008925063535571098}, {"id": 466, "seek": 295020, "start": 2956.4399999999996, "end": 2959.3999999999996, "text": " Yeah, I'm going to be running. We have somebody all the way in the back who's been waiting for a long", "tokens": [50676, 865, 11, 286, 478, 516, 281, 312, 2614, 13, 492, 362, 2618, 439, 264, 636, 294, 264, 646, 567, 311, 668, 3806, 337, 257, 938, 50824], "temperature": 0.0, "avg_logprob": -0.16008402580438658, "compression_ratio": 1.4919786096256684, "no_speech_prob": 0.008925063535571098}, {"id": 467, "seek": 295020, "start": 2959.3999999999996, "end": 2964.3599999999997, "text": " time. Sorry, I didn't see you. I'm going to have to run back. I said a question to you.", "tokens": [50824, 565, 13, 4919, 11, 286, 994, 380, 536, 291, 13, 286, 478, 516, 281, 362, 281, 1190, 646, 13, 286, 848, 257, 1168, 281, 291, 13, 51072], "temperature": 0.0, "avg_logprob": -0.16008402580438658, "compression_ratio": 1.4919786096256684, "no_speech_prob": 0.008925063535571098}, {"id": 468, "seek": 295020, "start": 2965.64, "end": 2967.0, "text": " How do you deal with the red zone?", "tokens": [51136, 1012, 360, 291, 2028, 365, 264, 2182, 6668, 30, 51204], "temperature": 0.0, "avg_logprob": -0.16008402580438658, "compression_ratio": 1.4919786096256684, "no_speech_prob": 0.008925063535571098}, {"id": 469, "seek": 295020, "start": 2971.16, "end": 2972.3599999999997, "text": " I was like, why is he not answering?", "tokens": [51412, 286, 390, 411, 11, 983, 307, 415, 406, 13430, 30, 51472], "temperature": 0.0, "avg_logprob": -0.16008402580438658, "compression_ratio": 1.4919786096256684, "no_speech_prob": 0.008925063535571098}, {"id": 470, "seek": 297236, "start": 2973.1600000000003, "end": 2983.6400000000003, "text": " So short answer, Windows doesn't have a red zone in either Intel or ARM.", "tokens": [50404, 407, 2099, 1867, 11, 8591, 1177, 380, 362, 257, 2182, 6668, 294, 2139, 19762, 420, 45209, 13, 50928], "temperature": 0.0, "avg_logprob": -0.13777580261230468, "compression_ratio": 1.4067796610169492, "no_speech_prob": 0.0014343424700200558}, {"id": 471, "seek": 297236, "start": 2985.0, "end": 2992.04, "text": " So that's mostly fine. There was a related concept of home space for the first four", "tokens": [50996, 407, 300, 311, 5240, 2489, 13, 821, 390, 257, 4077, 3410, 295, 1280, 1901, 337, 264, 700, 1451, 51348], "temperature": 0.0, "avg_logprob": -0.13777580261230468, "compression_ratio": 1.4067796610169492, "no_speech_prob": 0.0014343424700200558}, {"id": 472, "seek": 297236, "start": 2992.04, "end": 2997.88, "text": " integer registers in a kind of Intel call. And yeah, you have to handle that. So when you're", "tokens": [51348, 24922, 38351, 294, 257, 733, 295, 19762, 818, 13, 400, 1338, 11, 291, 362, 281, 4813, 300, 13, 407, 562, 291, 434, 51640], "temperature": 0.0, "avg_logprob": -0.13777580261230468, "compression_ratio": 1.4067796610169492, "no_speech_prob": 0.0014343424700200558}, {"id": 473, "seek": 299788, "start": 2997.88, "end": 3002.28, "text": " doing your marshalling and remarshalling of arguments, you need to leave space for the", "tokens": [50364, 884, 428, 21653, 24021, 293, 890, 7064, 24021, 295, 12869, 11, 291, 643, 281, 1856, 1901, 337, 264, 50584], "temperature": 0.0, "avg_logprob": -0.16304159725413603, "compression_ratio": 1.5294117647058822, "no_speech_prob": 0.0015351998154073954}, {"id": 474, "seek": 299788, "start": 3002.28, "end": 3008.76, "text": " home space as you would for a normal Intel call. So yeah, there is no red zone, but the closest", "tokens": [50584, 1280, 1901, 382, 291, 576, 337, 257, 2710, 19762, 818, 13, 407, 1338, 11, 456, 307, 572, 2182, 6668, 11, 457, 264, 13699, 50908], "temperature": 0.0, "avg_logprob": -0.16304159725413603, "compression_ratio": 1.5294117647058822, "no_speech_prob": 0.0015351998154073954}, {"id": 475, "seek": 299788, "start": 3008.76, "end": 3010.28, "text": " equivalent thing, yes, you have to handle.", "tokens": [50908, 10344, 551, 11, 2086, 11, 291, 362, 281, 4813, 13, 50984], "temperature": 0.0, "avg_logprob": -0.16304159725413603, "compression_ratio": 1.5294117647058822, "no_speech_prob": 0.0015351998154073954}, {"id": 476, "seek": 299788, "start": 3013.32, "end": 3016.84, "text": " Are there more questions? Are we? Oh, great.", "tokens": [51136, 2014, 456, 544, 1651, 30, 2014, 321, 30, 876, 11, 869, 13, 51312], "temperature": 0.0, "avg_logprob": -0.16304159725413603, "compression_ratio": 1.5294117647058822, "no_speech_prob": 0.0015351998154073954}, {"id": 477, "seek": 299788, "start": 3019.32, "end": 3020.92, "text": " How long did this take you to figure out?", "tokens": [51436, 1012, 938, 630, 341, 747, 291, 281, 2573, 484, 30, 51516], "temperature": 0.0, "avg_logprob": -0.16304159725413603, "compression_ratio": 1.5294117647058822, "no_speech_prob": 0.0015351998154073954}, {"id": 478, "seek": 302092, "start": 3021.16, "end": 3029.4, "text": " Probably not very long. I mean, the documentation is pretty good on the", "tokens": [50376, 9210, 406, 588, 938, 13, 286, 914, 11, 264, 14333, 307, 1238, 665, 322, 264, 50788], "temperature": 0.0, "avg_logprob": -0.23931410312652587, "compression_ratio": 1.2393162393162394, "no_speech_prob": 0.0039582690224051476}, {"id": 479, "seek": 302092, "start": 3029.4, "end": 3035.16, "text": " Microsoft side. So possibly a week or two, probably.", "tokens": [50788, 8116, 1252, 13, 407, 6264, 257, 1243, 420, 732, 11, 1391, 13, 51076], "temperature": 0.0, "avg_logprob": -0.23931410312652587, "compression_ratio": 1.2393162393162394, "no_speech_prob": 0.0039582690224051476}, {"id": 480, "seek": 302092, "start": 3040.04, "end": 3040.84, "text": " One more over there.", "tokens": [51320, 1485, 544, 670, 456, 13, 51360], "temperature": 0.0, "avg_logprob": -0.23931410312652587, "compression_ratio": 1.2393162393162394, "no_speech_prob": 0.0039582690224051476}, {"id": 481, "seek": 304084, "start": 3040.92, "end": 3053.2400000000002, "text": " So is there any way to call like regular, let's call them closed source ARM 64 Windows components,", "tokens": [50368, 407, 307, 456, 604, 636, 281, 818, 411, 3890, 11, 718, 311, 818, 552, 5395, 4009, 45209, 12145, 8591, 6677, 11, 50984], "temperature": 0.0, "avg_logprob": -0.20744122880877872, "compression_ratio": 1.403225806451613, "no_speech_prob": 0.005366249941289425}, {"id": 482, "seek": 304084, "start": 3053.2400000000002, "end": 3055.1600000000003, "text": " or is it complete separation?", "tokens": [50984, 420, 307, 309, 3566, 14634, 30, 51080], "temperature": 0.0, "avg_logprob": -0.20744122880877872, "compression_ratio": 1.403225806451613, "no_speech_prob": 0.005366249941289425}, {"id": 483, "seek": 304084, "start": 3057.32, "end": 3059.88, "text": " Completely separate. Any more questions?", "tokens": [51188, 39978, 4994, 13, 2639, 544, 1651, 30, 51316], "temperature": 0.0, "avg_logprob": -0.20744122880877872, "compression_ratio": 1.403225806451613, "no_speech_prob": 0.005366249941289425}, {"id": 484, "seek": 304084, "start": 3063.96, "end": 3067.2400000000002, "text": " Oh, were you going to elaborate on the answer? Of course, yeah. I thought that was a really", "tokens": [51520, 876, 11, 645, 291, 516, 281, 20945, 322, 264, 1867, 30, 2720, 1164, 11, 1338, 13, 286, 1194, 300, 390, 257, 534, 51684], "temperature": 0.0, "avg_logprob": -0.20744122880877872, "compression_ratio": 1.403225806451613, "no_speech_prob": 0.005366249941289425}, {"id": 485, "seek": 306724, "start": 3067.24, "end": 3069.7999999999997, "text": " short answer. I'm just trying to save myself from running.", "tokens": [50364, 2099, 1867, 13, 286, 478, 445, 1382, 281, 3155, 2059, 490, 2614, 13, 50492], "temperature": 0.0, "avg_logprob": -0.1570236947801378, "compression_ratio": 1.5601503759398496, "no_speech_prob": 0.010264378972351551}, {"id": 486, "seek": 306724, "start": 3070.7599999999998, "end": 3077.64, "text": " Yeah, completely separate. So yeah, any kind of ARM only DLLs you can't call into,", "tokens": [50540, 865, 11, 2584, 4994, 13, 407, 1338, 11, 604, 733, 295, 45209, 787, 413, 24010, 82, 291, 393, 380, 818, 666, 11, 50884], "temperature": 0.0, "avg_logprob": -0.1570236947801378, "compression_ratio": 1.5601503759398496, "no_speech_prob": 0.010264378972351551}, {"id": 487, "seek": 306724, "start": 3077.64, "end": 3082.4399999999996, "text": " you have to have these special ARM 64 EC DLLs. Thankfully Microsoft have already done that for", "tokens": [50884, 291, 362, 281, 362, 613, 2121, 45209, 12145, 19081, 413, 24010, 82, 13, 28344, 8116, 362, 1217, 1096, 300, 337, 51124], "temperature": 0.0, "avg_logprob": -0.1570236947801378, "compression_ratio": 1.5601503759398496, "no_speech_prob": 0.010264378972351551}, {"id": 488, "seek": 306724, "start": 3082.4399999999996, "end": 3089.16, "text": " all of the kind of system libraries. So anything from Microsoft you can already call. But yeah,", "tokens": [51124, 439, 295, 264, 733, 295, 1185, 15148, 13, 407, 1340, 490, 8116, 291, 393, 1217, 818, 13, 583, 1338, 11, 51460], "temperature": 0.0, "avg_logprob": -0.1570236947801378, "compression_ratio": 1.5601503759398496, "no_speech_prob": 0.010264378972351551}, {"id": 489, "seek": 306724, "start": 3089.16, "end": 3091.8799999999997, "text": " other code has to be in this weird mode to make it work.", "tokens": [51460, 661, 3089, 575, 281, 312, 294, 341, 3657, 4391, 281, 652, 309, 589, 13, 51596], "temperature": 0.0, "avg_logprob": -0.1570236947801378, "compression_ratio": 1.5601503759398496, "no_speech_prob": 0.010264378972351551}, {"id": 490, "seek": 306724, "start": 3094.8399999999997, "end": 3096.2, "text": " Any more questions? Yeah.", "tokens": [51744, 2639, 544, 1651, 30, 865, 13, 51812], "temperature": 0.0, "avg_logprob": -0.1570236947801378, "compression_ratio": 1.5601503759398496, "no_speech_prob": 0.010264378972351551}, {"id": 491, "seek": 309724, "start": 3097.7999999999997, "end": 3101.8799999999997, "text": " Really making me work this year. Where were you?", "tokens": [50392, 4083, 1455, 385, 589, 341, 1064, 13, 2305, 645, 291, 30, 50596], "temperature": 0.0, "avg_logprob": -0.2942277932468849, "compression_ratio": 1.62, "no_speech_prob": 0.005019560921937227}, {"id": 492, "seek": 309724, "start": 3104.7599999999998, "end": 3110.3599999999997, "text": " I was wondering, like, is there already examples of software that uses it because you can", "tokens": [50740, 286, 390, 6359, 11, 411, 11, 307, 456, 1217, 5110, 295, 4722, 300, 4960, 309, 570, 291, 393, 51020], "temperature": 0.0, "avg_logprob": -0.2942277932468849, "compression_ratio": 1.62, "no_speech_prob": 0.005019560921937227}, {"id": 493, "seek": 309724, "start": 3111.3199999999997, "end": 3117.64, "text": " find it quite easily because the executable is like a different type that it uses? Because I,", "tokens": [51068, 915, 309, 1596, 3612, 570, 264, 7568, 712, 307, 411, 257, 819, 2010, 300, 309, 4960, 30, 1436, 286, 11, 51384], "temperature": 0.0, "avg_logprob": -0.2942277932468849, "compression_ratio": 1.62, "no_speech_prob": 0.005019560921937227}, {"id": 494, "seek": 309724, "start": 3119.9599999999996, "end": 3126.7599999999998, "text": " is there any like software, I haven't heard of this feature before, but like so far already", "tokens": [51500, 307, 456, 604, 411, 4722, 11, 286, 2378, 380, 2198, 295, 341, 4111, 949, 11, 457, 411, 370, 1400, 1217, 51840], "temperature": 0.0, "avg_logprob": -0.2942277932468849, "compression_ratio": 1.62, "no_speech_prob": 0.005019560921937227}, {"id": 495, "seek": 312676, "start": 3126.76, "end": 3129.48, "text": " using this major things?", "tokens": [50364, 1228, 341, 2563, 721, 30, 50500], "temperature": 0.0, "avg_logprob": -0.2846853114940502, "compression_ratio": 1.4228187919463087, "no_speech_prob": 0.0006015211693011224}, {"id": 496, "seek": 312676, "start": 3138.0400000000004, "end": 3143.7200000000003, "text": " Yeah, so the person that opened the issue on the Lujo project is apparently using this thing.", "tokens": [50928, 865, 11, 370, 264, 954, 300, 5625, 264, 2734, 322, 264, 441, 4579, 78, 1716, 307, 7970, 1228, 341, 551, 13, 51212], "temperature": 0.0, "avg_logprob": -0.2846853114940502, "compression_ratio": 1.4228187919463087, "no_speech_prob": 0.0006015211693011224}, {"id": 497, "seek": 312676, "start": 3147.0800000000004, "end": 3152.76, "text": " I mean, I'm told that most of like Microsoft like Office and similar are running in this mode", "tokens": [51380, 286, 914, 11, 286, 478, 1907, 300, 881, 295, 411, 8116, 411, 8935, 293, 2531, 366, 2614, 294, 341, 4391, 51664], "temperature": 0.0, "avg_logprob": -0.2846853114940502, "compression_ratio": 1.4228187919463087, "no_speech_prob": 0.0006015211693011224}, {"id": 498, "seek": 315276, "start": 3152.76, "end": 3159.0, "text": " so that you can have your Intel type plugins work. But yeah, apparently there's a user for", "tokens": [50364, 370, 300, 291, 393, 362, 428, 19762, 2010, 33759, 589, 13, 583, 1338, 11, 7970, 456, 311, 257, 4195, 337, 50676], "temperature": 0.0, "avg_logprob": -0.18557039896647134, "compression_ratio": 1.52, "no_speech_prob": 0.0007483760709874332}, {"id": 499, "seek": 315276, "start": 3159.0, "end": 3166.84, "text": " this stuff of the Lujo thing and using it. The last question or was that the last question?", "tokens": [50676, 341, 1507, 295, 264, 441, 4579, 78, 551, 293, 1228, 309, 13, 440, 1036, 1168, 420, 390, 300, 264, 1036, 1168, 30, 51068], "temperature": 0.0, "avg_logprob": -0.18557039896647134, "compression_ratio": 1.52, "no_speech_prob": 0.0007483760709874332}, {"id": 500, "seek": 315276, "start": 3169.48, "end": 3173.5600000000004, "text": " Can we pass it? Sorry, what did the EC stand for?", "tokens": [51200, 1664, 321, 1320, 309, 30, 4919, 11, 437, 630, 264, 19081, 1463, 337, 30, 51404], "temperature": 0.0, "avg_logprob": -0.18557039896647134, "compression_ratio": 1.52, "no_speech_prob": 0.0007483760709874332}, {"id": 501, "seek": 315276, "start": 3176.6800000000003, "end": 3181.1600000000003, "text": " Emulator compatible. Am I stealing it from you? Emulator compatibility.", "tokens": [51560, 3968, 16381, 18218, 13, 2012, 286, 19757, 309, 490, 291, 30, 3968, 16381, 34237, 13, 51784], "temperature": 0.0, "avg_logprob": -0.18557039896647134, "compression_ratio": 1.52, "no_speech_prob": 0.0007483760709874332}, {"id": 502, "seek": 318116, "start": 3181.8799999999997, "end": 3188.2799999999997, "text": " That's what it stands for. If that was the last question, then let's thank Peter one more time.", "tokens": [50400, 663, 311, 437, 309, 7382, 337, 13, 759, 300, 390, 264, 1036, 1168, 11, 550, 718, 311, 1309, 6508, 472, 544, 565, 13, 50720], "temperature": 0.0, "avg_logprob": -0.1351411501566569, "compression_ratio": 1.394904458598726, "no_speech_prob": 0.003867700230330229}, {"id": 503, "seek": 318116, "start": 3194.12, "end": 3200.2, "text": " So am I still, yeah, with that, that closes up the Emulator Development Room this year.", "tokens": [51012, 407, 669, 286, 920, 11, 1338, 11, 365, 300, 11, 300, 24157, 493, 264, 3968, 16381, 15041, 19190, 341, 1064, 13, 51316], "temperature": 0.0, "avg_logprob": -0.1351411501566569, "compression_ratio": 1.394904458598726, "no_speech_prob": 0.003867700230330229}, {"id": 504, "seek": 318116, "start": 3200.2, "end": 3201.7999999999997, "text": " I want to thank you all for coming.", "tokens": [51316, 286, 528, 281, 1309, 291, 439, 337, 1348, 13, 51396], "temperature": 0.0, "avg_logprob": -0.1351411501566569, "compression_ratio": 1.394904458598726, "no_speech_prob": 0.003867700230330229}], "language": "en"}