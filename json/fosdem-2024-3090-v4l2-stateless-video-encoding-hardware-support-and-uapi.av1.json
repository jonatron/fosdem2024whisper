{"text": " All right. Hello, everybody, and thanks for being here today. So I'm Paul Krakowski, and today I'll be talking about VFALL2 Stateless Video Encoding. We're going to talk about hardware support, and we're going to talk about the Stateless Video Encoding new API, and we're going to see why it's actually difficult to come up with this new API. So I am now self-employed working in my own company, which is called SeasBase, so I provide engineering services on topics related to multimedia and graphics, so if you're interested, there's my email here. And let's begin with a very simple question. Why do we need to encode videos? So the main reason is really that storing pictures in digital form is extremely big in terms of size. So it really, really takes a lot of storage, and this is really not something that is reasonable. So pictures are just way too big. So what do we have to do? Well, simple. We just have to compress them. So let's compress videos. And now what happens when we do that? They tend to look crappy. So we compress them too much, and they look bad. So this kind of brings us to the main topic of encoding, which is the management of the trade-off between the size of the video and the quality that we get, or at least the perceived quality. So we want things that are not too big, and that look good, essentially. So in order to do that, we have a number of techniques which are implemented as codecs, which are just formats that specify kind of how we should encode videos. So a good codec has a good trade-off between the size and the quality, and in general, the codecs that we have today are extremely, extremely performant at this. Most of them have specifications that can be accessed. They are often hard to read, because essentially, if you want to understand the spec, you need to understand the codec first. And if you don't know the codec first, it's quite hard to understand the spec. So that's the situation, but at least there are some standards and specifications. So some require realities to be used, some others don't. That really depends. So there is a bunch of codecs which are hyped now. There is a lot of talk about AV1, VP9, HTC5, and HTC6, so that's the kind of upcoming stuff that everyone is excited about. But of course, it really takes a while before people actually use those codecs in the real world. But there is a real interest in that, especially if we're looking to reduce our global power consumption, because better codecs means less data, and if we have less data, less energy consumption for storage and for transmission. So having good codecs is actually quite important, and it can really make a difference. So how do we encode those videos? There is a number of techniques which are used, usually one after the other in some kind of chain. So we have a first class, which is the spatial compression, which is essentially how we can represent a single static picture in the most efficient way by using lots of different compression techniques. So I've mentioned a few here. Essentially, we go to frequency domain, and then we can eliminate some coefficients from that frequency domain. This is what we call quantization, and we have a value that we call QP, the quantization parameter, which is here to tell us how many of those frequency-based coefficients we want to keep in order to represent our picture. And in general, the high-frequency coefficients represent details, and the low-frequency coefficients represent the rough shape of the picture. But we also apply temporal compression techniques. Temporal compression will use the previews and sometimes the next frames as well in order to kind of calculate the current picture. So instead of coding a single picture all the time, we are actually coding a difference between the previews and all the next picture to create the current one. So this is, for example, a representation of what we call motion vectors, which will indicate how the kind of pixels change from one frame to another, so we have a notion of directivity and direction, and so on. So when we encode a video, we kind of have to decide on a strategy, which is exactly what do we want to do when we encode that video and which kind of trade-off we're going to adopt between the size and the quality and how we want that trade-off to evolve over time and things like that. So we have very common strategies. For example, if you just want an average or a constant bitrate to stay the same for the whole stream, that's one strategy that an encoder can implement, but we can also decide that instead we want a constant quality, so the size might change depending on what we want to achieve. So it's important to understand that this notion of strategy for encoding is really at the core of what an encoder is doing, and this is generally what we call rate control. So rate control is about dynamically deciding on this trade-off, so we have to decide on which frame type we want to use, we have to decide on the quantization parameter and a number of other settings that we can set in the encoder to essentially have it adapt to different scenes and also to be able to react to changes in the scene. So if you, for example, have a movie and you're going from one scene to another, you want your encoder to kind of react to that and give more details on the first image of the new scene, for example, things like that. So the main takeaway from this slide is that the rate control implementation is really the key to have good encoding and to have something that is actually performance and that gives good results. So now that we have a brief overview of those compression techniques and what encoders are supposed to do, the main topic is how do we accelerate this because doing all of this on the CPU is usually a very intensive process, so it will take a lot of your CPU, and nowadays we have lots of use cases where people want super high sizes and they want high frame rate, like 60 frames per second on things like 4K, and there are use cases where we want to be able to encode just as we are receiving the data. So for example, a regular camera that you used to shoot, you want to be able to produce a video so you want to be able to encode in more or less real time. So if you really want to achieve that, you have to use dedicated hardware which will offload this and will give you some acceleration for this process. So this is when we start talking about hardware-based video encoding or hardware-accelerated video encoding. So those hardware encoders, not only do they know how to produce the correct format for the video that we chose for the codec, they sometimes also have some extra features like pre-processing, so for example, they can convert the format of the pictures that you give them. They can also apply things like antishaking or cropping. So this is a very common pre-processing pipeline for an encoder. Usually they will have the ability to also encode multiple streams in parallel, so this, well, not necessarily in parallel, but at least in a time-shared way. So you could use the same encoder and have multiple streams that you want to encode, and then you encode one frame for one stream which goes into one sync, one output, and then you have another stream that you also want to deal with concurrently. So it's important that you are able to kind of switch between different contexts of encoding because you don't want your encoder to be just dedicated to one thing, to one task, so it's a little bit like a GPU where you want to be able to render multiple things like that. All right, so when we're talking about hardware video encoding, there is essentially two types of hardware implementations. The first one, which is probably the most common, is what we call the stateful encoders. So these encoders are somewhat abstracted and a bit less flexible for, let's say, the end users because they essentially come with a microcontroller that will do most of the heavy lifting involved in encoding, especially implementing the rate control strategies. So they come with a firmware that implements that, and it really does a lot, especially the rate control. And the CPU will usually interact with that encoder through some mailbox interface, and it will essentially give it messages like encode this source with these parameters, but the parameters are still quite high level. On the contrary, we have a second type of implementation, which we call the stateless encoders, which are really more bare metal, so they are also more flexible, and we have more control over exactly the parameters that we give the encoder and all the, let's say, technical decisions that are used to create the final bit stream, the final video codec data. So in that situation, the CPUs that is driving the encoder have to do more. It has to do essentially all that the firmware was doing in the stateful case, so this is generally more involved. And, yeah, it means that you have more things to do on your kernel, and we have, of course, a bunch of others. For the stateless designs, we have less known examples, but they are also quite popular and found in lots of chips. So we have the Hentro from Vericilicon, which is found, for example, on lots of IMX8s. We also find it on RockChip platforms, and some on Alwinner as well. Alwinner, which is a Chinese chip maker, has their own video engine implementation, which also has an encoder. So that's pretty much what we know about so far. Oh, MediaTek, I didn't mention it. So it's stateful, but it's kind of helpful between the two, right, because you can also drive it stateless. Okay, stateful encoder, stateless decoder. Okay, great. All right. Okay, so for the stateful case, in Linux, we have a great API in V4L2, which is based on the V4L2 memory-to-memory framework, which works with QQs, so essentially you're going to submit data from user space, which is your source picture, and you're going to get some encoded bitstream as a result from this API. We have pixel formats to describe the coded streams, and we can use some specific controls to set features of the encoder. So when there is a technical choice to be made, we can use those controls and tell it exactly, well, how we want the video to be encoded. But again, the rate control is implemented in the firmware, so all we can do with that is to tell the firmware, to tell the microcontroller what it should do, but it's not going to be the kernel side that does it. On the other side with the stateless encoding, like I said, we have a lot more to do from the CPU side, and this is when it gets a bit complicated with V4L2. So currently we don't have a stateless encoding UAPI. There is some difficulty that I'm going to mention in order to do that. And one of the points that are difficult is to implement the rate control part, so to be able to adapt exactly what the video stream looks like depending on the policy that you want to follow. And of course we want that UAPI to be hardware agnostic, so we don't want to just have user space drivers that will be specific to each encoder. Instead we want to have a generic interface, like it's the case for the stateful encoders, where we have this generic V4L2 API. But stateless encoding also has significant advantages. It's a lot more flexible, and that means that we have more control over what's going on. So in theory we are able to take better decisions to produce the best stream that we can, and that is not necessarily the case with a stateful, firmware-driven approach. So user space might actually have a bunch of information, like knowing that the scene is changing, for example, things like that, that can really help the encoders. So it actually makes sense for user space to want to do its own rate control, because it can have more information, it can also implement, let's say, advanced strategies. For example, nowadays there is talk about machine learning and how to help encoders achieve better results. So things like that would make sense in user space. But we also want to support simple cases where we don't want user space to have a huge stack that is very complex, but it would really be nice to have a simple case that can be covered without so much logic in user space. So you can kind of see that there is a little bit of contradiction between these two things, and this is one of the main, let's say, topics that make creating this UAPI difficult. So let's take a look at some existing work that was already carried out for these state-based encoders. For the Hentro H1, which is probably the most popular one in this category, we have some work that was done by RockTip, which is free software, in a stack called MPP. So you can find the source code here, and that's the part where it implements encoding for the H1. So that's great, but this is not V4L2. It's a fully user space-based approach. So we have Google that did a custom V4L2 driver in Chromium OS. So this is for the Chromebooks that they ship with RockTip SOCs that have the H1. So this time it's a V4L2 driver, but it really is hardware-specific, so you have a very specific API to drive that encoder. Now, from this base, which has all the knowledge of how to drive the encoder, I was able to write a mainline-based implementation on V4L2 when I was working at Budlin, and this one is still hardware-specific. So we have some custom register configuration that is pushed to the driver, and we get some custom feedback as a result that the user space side can use in order to implement the rate control. So in this case, the rate control is done in user space entirely. Ooh, it's not working anymore. Okay, and now we have also VPH encoding from Collabora, which also does the rate control in user space. So you can find the links to the RFC series there and the user space implementation in Gstreamer as well to demonstrate how it works. So while working on this hardware, there is a few things that we learned. For example, the fact that some metadata fields of the bitstream are actually constrained by the hardware itself. So it means that there are some fields in the codec where the specification allows you to choose between different values, but the encoder actually only works with one of them. So it means that if you are going to generate those fields, you need to be aware of which hardware you're running on. So the lesson learned from that was that the bitstream generation should really be on the kernel side because this is how you can really know exactly which choices are valid or not for this particular hardware. Sometimes the hardware also has rate control helpers. So this is some hardware features that can help you implement better rate control. It's not necessarily always a good idea or always required to use them, but they exist. And in that case, this kind of suggests that the rate control would make sense to be done in user space, sorry, in the kernel side, because again, we don't want user space to be specific to a particular hardware. We want it to be generic and agnostic. Now for a second example, which is something I've worked on very recently, again, at Budlin. So this is based on some existing work from the Linux Sanctuary community, which did a lot of research and implemented some user space implementation for the all-winner video engine encoder. And I did some follow-up work on some more recent platforms that also implement H264 encoding, this time using a proper VFIL2 driver. And again, because we still didn't have the stateless encoding UAPI, I decided to use the stateful encoding UAPI more or less directly. And this made it clear that this API was quite limiting and that it didn't allow leveraging the full potential of the stateless hardware designs. So there's a few lessons to be learned from that. Like I said, stateful API is not really a good fit for these stateless encoders, so it's not really viable to try and use that. The Bitstream beta data needs to be produced canalside, like I said, because we have some hardware constraints that we cannot represent and let's say forward to user space. So it has to be the kernel that decides how to generate those Bitstream headers. And for rate control, it's really unclear because having rate control on the kernel side makes the user space quite simple and it makes it really easy to operate it without having a lot of logic aside. But on the other hand, having the rate control in user space is a lot more flexible and it means that you can implement kind of whatever strategy you want, you can decide on the implementation yourself, which is a bit less easy when it's on the kernel side. Of course, it's not impossible, it's all free software and you can change it like you want, but we still understand that there is interest in both cases. So the current state of the art for stateless encoding in VFrl2 is that it's in progress, it's a discussion, so if you have an opinion on that or if you have ideas on how this could be improved or how this published quantization parameter, which references we're going to use to generate the frames based on the previews on X-frames. So having a switch kind of allows user space to choose if it wants to have low-level control or if it wants to have something simple that works, which is maybe suboptimal, but that can still be used nicely. Another way would be that we have rate control implemented in the kernel side, but instead of applying it to the next frame, it would just provide some suggestion to user space, so it would be some kind of feedback data that is provided with an indication of what the next QP or frame type could be to follow the policy that was selected kernel side. This could also work because then user space could decide to follow this feedback suggestion or not, so then it could decide to do something completely different. So in that situation, user space would still have all the low-level control, but it would have suggestions about which values would make sense depending on the kernel side rate control implementation. So that's also something that could work, and we could even have some switch to auto-apply the feedback so that user space doesn't even have to copy that suggestion into the actual configuration. We could just have a switch that makes it kind of automatically go, and after that, user space really doesn't have much to do, and it can kind of let it handle it by itself. So that would be also some form of trade-off that allows having something simple for user space and also allow user space to be able to control things if it wants to. Another thing that would be interesting is to have some common code that is shared between these different state-based encoders because especially for things like the bitstream metadata generation, there is a lot that is common, of course, because it targets the same format, so we could have some helpers that are shared between these different drivers. Again, the state-full encoders don't have to generate that bitstream metadata, so it's really something specific to the state-less encoders. Finally, the rate control implementations, if they end up existing on the kernel side, it would also be nice to be able to share them between the different drivers instead of having driver-specific implementations for that. Besides discussing and exchanging ideas and hopefully finding a solution for what this UAPI should look like, the next step will be to merge the work done on the Hentro and Cedrus drivers to bring X264 encoding and VPA encoding for Hentro. After that, the next step will be to have some G-streamer and FFM-back integration to use this UAPI, and after that, normally the rest of the world should be able to use the state-less hardware encoders, which will be great. So time is up for me. Thanks everybody for listening. Thank you for a great talk. Unfortunately, we do not have time for questions, but I really encourage everyone who has a question to just catch the speaker in the corridor. Thank you. Thanks.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 5.0, "text": " All right.", "tokens": [50364, 1057, 558, 13, 50614], "temperature": 0.0, "avg_logprob": -0.2369253706223894, "compression_ratio": 1.6764705882352942, "no_speech_prob": 0.2942487597465515}, {"id": 1, "seek": 0, "start": 5.0, "end": 9.0, "text": " Hello, everybody, and thanks for being here today.", "tokens": [50614, 2425, 11, 2201, 11, 293, 3231, 337, 885, 510, 965, 13, 50814], "temperature": 0.0, "avg_logprob": -0.2369253706223894, "compression_ratio": 1.6764705882352942, "no_speech_prob": 0.2942487597465515}, {"id": 2, "seek": 0, "start": 9.0, "end": 13.0, "text": " So I'm Paul Krakowski, and today I'll be talking about VFALL2", "tokens": [50814, 407, 286, 478, 4552, 591, 11272, 21866, 11, 293, 965, 286, 603, 312, 1417, 466, 691, 37, 15921, 17, 51014], "temperature": 0.0, "avg_logprob": -0.2369253706223894, "compression_ratio": 1.6764705882352942, "no_speech_prob": 0.2942487597465515}, {"id": 3, "seek": 0, "start": 13.0, "end": 15.0, "text": " Stateless Video Encoding.", "tokens": [51014, 16249, 4272, 9777, 29584, 8616, 13, 51114], "temperature": 0.0, "avg_logprob": -0.2369253706223894, "compression_ratio": 1.6764705882352942, "no_speech_prob": 0.2942487597465515}, {"id": 4, "seek": 0, "start": 15.0, "end": 17.0, "text": " We're going to talk about hardware support,", "tokens": [51114, 492, 434, 516, 281, 751, 466, 8837, 1406, 11, 51214], "temperature": 0.0, "avg_logprob": -0.2369253706223894, "compression_ratio": 1.6764705882352942, "no_speech_prob": 0.2942487597465515}, {"id": 5, "seek": 0, "start": 17.0, "end": 21.0, "text": " and we're going to talk about the Stateless Video Encoding", "tokens": [51214, 293, 321, 434, 516, 281, 751, 466, 264, 16249, 4272, 9777, 29584, 8616, 51414], "temperature": 0.0, "avg_logprob": -0.2369253706223894, "compression_ratio": 1.6764705882352942, "no_speech_prob": 0.2942487597465515}, {"id": 6, "seek": 0, "start": 21.0, "end": 25.0, "text": " new API, and we're going to see why it's actually difficult", "tokens": [51414, 777, 9362, 11, 293, 321, 434, 516, 281, 536, 983, 309, 311, 767, 2252, 51614], "temperature": 0.0, "avg_logprob": -0.2369253706223894, "compression_ratio": 1.6764705882352942, "no_speech_prob": 0.2942487597465515}, {"id": 7, "seek": 0, "start": 25.0, "end": 28.0, "text": " to come up with this new API.", "tokens": [51614, 281, 808, 493, 365, 341, 777, 9362, 13, 51764], "temperature": 0.0, "avg_logprob": -0.2369253706223894, "compression_ratio": 1.6764705882352942, "no_speech_prob": 0.2942487597465515}, {"id": 8, "seek": 2800, "start": 28.0, "end": 33.0, "text": " So I am now self-employed working in my own company,", "tokens": [50364, 407, 286, 669, 586, 2698, 12, 12112, 292, 1364, 294, 452, 1065, 2237, 11, 50614], "temperature": 0.0, "avg_logprob": -0.11121836992410514, "compression_ratio": 1.5137254901960784, "no_speech_prob": 0.002135199261829257}, {"id": 9, "seek": 2800, "start": 33.0, "end": 37.0, "text": " which is called SeasBase, so I provide engineering services", "tokens": [50614, 597, 307, 1219, 1100, 296, 33, 651, 11, 370, 286, 2893, 7043, 3328, 50814], "temperature": 0.0, "avg_logprob": -0.11121836992410514, "compression_ratio": 1.5137254901960784, "no_speech_prob": 0.002135199261829257}, {"id": 10, "seek": 2800, "start": 37.0, "end": 39.0, "text": " on topics related to multimedia and graphics,", "tokens": [50814, 322, 8378, 4077, 281, 49202, 293, 11837, 11, 50914], "temperature": 0.0, "avg_logprob": -0.11121836992410514, "compression_ratio": 1.5137254901960784, "no_speech_prob": 0.002135199261829257}, {"id": 11, "seek": 2800, "start": 39.0, "end": 42.0, "text": " so if you're interested, there's my email here.", "tokens": [50914, 370, 498, 291, 434, 3102, 11, 456, 311, 452, 3796, 510, 13, 51064], "temperature": 0.0, "avg_logprob": -0.11121836992410514, "compression_ratio": 1.5137254901960784, "no_speech_prob": 0.002135199261829257}, {"id": 12, "seek": 2800, "start": 42.0, "end": 46.0, "text": " And let's begin with a very simple question.", "tokens": [51064, 400, 718, 311, 1841, 365, 257, 588, 2199, 1168, 13, 51264], "temperature": 0.0, "avg_logprob": -0.11121836992410514, "compression_ratio": 1.5137254901960784, "no_speech_prob": 0.002135199261829257}, {"id": 13, "seek": 2800, "start": 46.0, "end": 49.0, "text": " Why do we need to encode videos?", "tokens": [51264, 1545, 360, 321, 643, 281, 2058, 1429, 2145, 30, 51414], "temperature": 0.0, "avg_logprob": -0.11121836992410514, "compression_ratio": 1.5137254901960784, "no_speech_prob": 0.002135199261829257}, {"id": 14, "seek": 2800, "start": 49.0, "end": 53.0, "text": " So the main reason is really that storing pictures", "tokens": [51414, 407, 264, 2135, 1778, 307, 534, 300, 26085, 5242, 51614], "temperature": 0.0, "avg_logprob": -0.11121836992410514, "compression_ratio": 1.5137254901960784, "no_speech_prob": 0.002135199261829257}, {"id": 15, "seek": 2800, "start": 53.0, "end": 57.0, "text": " in digital form is extremely big in terms of size.", "tokens": [51614, 294, 4562, 1254, 307, 4664, 955, 294, 2115, 295, 2744, 13, 51814], "temperature": 0.0, "avg_logprob": -0.11121836992410514, "compression_ratio": 1.5137254901960784, "no_speech_prob": 0.002135199261829257}, {"id": 16, "seek": 5700, "start": 57.0, "end": 59.0, "text": " So it really, really takes a lot of storage,", "tokens": [50364, 407, 309, 534, 11, 534, 2516, 257, 688, 295, 6725, 11, 50464], "temperature": 0.0, "avg_logprob": -0.07672496580741775, "compression_ratio": 1.7597173144876326, "no_speech_prob": 0.006068515591323376}, {"id": 17, "seek": 5700, "start": 59.0, "end": 62.0, "text": " and this is really not something that is reasonable.", "tokens": [50464, 293, 341, 307, 534, 406, 746, 300, 307, 10585, 13, 50614], "temperature": 0.0, "avg_logprob": -0.07672496580741775, "compression_ratio": 1.7597173144876326, "no_speech_prob": 0.006068515591323376}, {"id": 18, "seek": 5700, "start": 62.0, "end": 64.0, "text": " So pictures are just way too big.", "tokens": [50614, 407, 5242, 366, 445, 636, 886, 955, 13, 50714], "temperature": 0.0, "avg_logprob": -0.07672496580741775, "compression_ratio": 1.7597173144876326, "no_speech_prob": 0.006068515591323376}, {"id": 19, "seek": 5700, "start": 64.0, "end": 66.0, "text": " So what do we have to do?", "tokens": [50714, 407, 437, 360, 321, 362, 281, 360, 30, 50814], "temperature": 0.0, "avg_logprob": -0.07672496580741775, "compression_ratio": 1.7597173144876326, "no_speech_prob": 0.006068515591323376}, {"id": 20, "seek": 5700, "start": 66.0, "end": 68.0, "text": " Well, simple. We just have to compress them.", "tokens": [50814, 1042, 11, 2199, 13, 492, 445, 362, 281, 14778, 552, 13, 50914], "temperature": 0.0, "avg_logprob": -0.07672496580741775, "compression_ratio": 1.7597173144876326, "no_speech_prob": 0.006068515591323376}, {"id": 21, "seek": 5700, "start": 68.0, "end": 70.0, "text": " So let's compress videos.", "tokens": [50914, 407, 718, 311, 14778, 2145, 13, 51014], "temperature": 0.0, "avg_logprob": -0.07672496580741775, "compression_ratio": 1.7597173144876326, "no_speech_prob": 0.006068515591323376}, {"id": 22, "seek": 5700, "start": 70.0, "end": 72.0, "text": " And now what happens when we do that?", "tokens": [51014, 400, 586, 437, 2314, 562, 321, 360, 300, 30, 51114], "temperature": 0.0, "avg_logprob": -0.07672496580741775, "compression_ratio": 1.7597173144876326, "no_speech_prob": 0.006068515591323376}, {"id": 23, "seek": 5700, "start": 72.0, "end": 73.0, "text": " They tend to look crappy.", "tokens": [51114, 814, 3928, 281, 574, 36531, 13, 51164], "temperature": 0.0, "avg_logprob": -0.07672496580741775, "compression_ratio": 1.7597173144876326, "no_speech_prob": 0.006068515591323376}, {"id": 24, "seek": 5700, "start": 73.0, "end": 76.0, "text": " So we compress them too much, and they look bad.", "tokens": [51164, 407, 321, 14778, 552, 886, 709, 11, 293, 436, 574, 1578, 13, 51314], "temperature": 0.0, "avg_logprob": -0.07672496580741775, "compression_ratio": 1.7597173144876326, "no_speech_prob": 0.006068515591323376}, {"id": 25, "seek": 5700, "start": 76.0, "end": 80.0, "text": " So this kind of brings us to the main topic of encoding,", "tokens": [51314, 407, 341, 733, 295, 5607, 505, 281, 264, 2135, 4829, 295, 43430, 11, 51514], "temperature": 0.0, "avg_logprob": -0.07672496580741775, "compression_ratio": 1.7597173144876326, "no_speech_prob": 0.006068515591323376}, {"id": 26, "seek": 5700, "start": 80.0, "end": 83.0, "text": " which is the management of the trade-off", "tokens": [51514, 597, 307, 264, 4592, 295, 264, 4923, 12, 4506, 51664], "temperature": 0.0, "avg_logprob": -0.07672496580741775, "compression_ratio": 1.7597173144876326, "no_speech_prob": 0.006068515591323376}, {"id": 27, "seek": 5700, "start": 83.0, "end": 86.0, "text": " between the size of the video and the quality that we get,", "tokens": [51664, 1296, 264, 2744, 295, 264, 960, 293, 264, 3125, 300, 321, 483, 11, 51814], "temperature": 0.0, "avg_logprob": -0.07672496580741775, "compression_ratio": 1.7597173144876326, "no_speech_prob": 0.006068515591323376}, {"id": 28, "seek": 8600, "start": 86.0, "end": 88.0, "text": " or at least the perceived quality.", "tokens": [50364, 420, 412, 1935, 264, 19049, 3125, 13, 50464], "temperature": 0.0, "avg_logprob": -0.06974627353526928, "compression_ratio": 1.696035242290749, "no_speech_prob": 0.0013357407879084349}, {"id": 29, "seek": 8600, "start": 88.0, "end": 90.0, "text": " So we want things that are not too big,", "tokens": [50464, 407, 321, 528, 721, 300, 366, 406, 886, 955, 11, 50564], "temperature": 0.0, "avg_logprob": -0.06974627353526928, "compression_ratio": 1.696035242290749, "no_speech_prob": 0.0013357407879084349}, {"id": 30, "seek": 8600, "start": 90.0, "end": 93.0, "text": " and that look good, essentially.", "tokens": [50564, 293, 300, 574, 665, 11, 4476, 13, 50714], "temperature": 0.0, "avg_logprob": -0.06974627353526928, "compression_ratio": 1.696035242290749, "no_speech_prob": 0.0013357407879084349}, {"id": 31, "seek": 8600, "start": 93.0, "end": 96.0, "text": " So in order to do that, we have a number of techniques", "tokens": [50714, 407, 294, 1668, 281, 360, 300, 11, 321, 362, 257, 1230, 295, 7512, 50864], "temperature": 0.0, "avg_logprob": -0.06974627353526928, "compression_ratio": 1.696035242290749, "no_speech_prob": 0.0013357407879084349}, {"id": 32, "seek": 8600, "start": 96.0, "end": 99.0, "text": " which are implemented as codecs, which are just formats", "tokens": [50864, 597, 366, 12270, 382, 3089, 14368, 11, 597, 366, 445, 25879, 51014], "temperature": 0.0, "avg_logprob": -0.06974627353526928, "compression_ratio": 1.696035242290749, "no_speech_prob": 0.0013357407879084349}, {"id": 33, "seek": 8600, "start": 99.0, "end": 105.0, "text": " that specify kind of how we should encode videos.", "tokens": [51014, 300, 16500, 733, 295, 577, 321, 820, 2058, 1429, 2145, 13, 51314], "temperature": 0.0, "avg_logprob": -0.06974627353526928, "compression_ratio": 1.696035242290749, "no_speech_prob": 0.0013357407879084349}, {"id": 34, "seek": 8600, "start": 105.0, "end": 108.0, "text": " So a good codec has a good trade-off", "tokens": [51314, 407, 257, 665, 3089, 66, 575, 257, 665, 4923, 12, 4506, 51464], "temperature": 0.0, "avg_logprob": -0.06974627353526928, "compression_ratio": 1.696035242290749, "no_speech_prob": 0.0013357407879084349}, {"id": 35, "seek": 8600, "start": 108.0, "end": 111.0, "text": " between the size and the quality,", "tokens": [51464, 1296, 264, 2744, 293, 264, 3125, 11, 51614], "temperature": 0.0, "avg_logprob": -0.06974627353526928, "compression_ratio": 1.696035242290749, "no_speech_prob": 0.0013357407879084349}, {"id": 36, "seek": 8600, "start": 111.0, "end": 114.0, "text": " and in general, the codecs that we have today", "tokens": [51614, 293, 294, 2674, 11, 264, 3089, 14368, 300, 321, 362, 965, 51764], "temperature": 0.0, "avg_logprob": -0.06974627353526928, "compression_ratio": 1.696035242290749, "no_speech_prob": 0.0013357407879084349}, {"id": 37, "seek": 11400, "start": 114.0, "end": 119.0, "text": " are extremely, extremely performant at this.", "tokens": [50364, 366, 4664, 11, 4664, 2042, 394, 412, 341, 13, 50614], "temperature": 0.0, "avg_logprob": -0.0644100774236086, "compression_ratio": 1.834710743801653, "no_speech_prob": 0.0010472883004695177}, {"id": 38, "seek": 11400, "start": 119.0, "end": 123.0, "text": " Most of them have specifications that can be accessed.", "tokens": [50614, 4534, 295, 552, 362, 29448, 300, 393, 312, 34211, 13, 50814], "temperature": 0.0, "avg_logprob": -0.0644100774236086, "compression_ratio": 1.834710743801653, "no_speech_prob": 0.0010472883004695177}, {"id": 39, "seek": 11400, "start": 123.0, "end": 125.0, "text": " They are often hard to read,", "tokens": [50814, 814, 366, 2049, 1152, 281, 1401, 11, 50914], "temperature": 0.0, "avg_logprob": -0.0644100774236086, "compression_ratio": 1.834710743801653, "no_speech_prob": 0.0010472883004695177}, {"id": 40, "seek": 11400, "start": 125.0, "end": 127.0, "text": " because essentially, if you want to understand the spec,", "tokens": [50914, 570, 4476, 11, 498, 291, 528, 281, 1223, 264, 1608, 11, 51014], "temperature": 0.0, "avg_logprob": -0.0644100774236086, "compression_ratio": 1.834710743801653, "no_speech_prob": 0.0010472883004695177}, {"id": 41, "seek": 11400, "start": 127.0, "end": 129.0, "text": " you need to understand the codec first.", "tokens": [51014, 291, 643, 281, 1223, 264, 3089, 66, 700, 13, 51114], "temperature": 0.0, "avg_logprob": -0.0644100774236086, "compression_ratio": 1.834710743801653, "no_speech_prob": 0.0010472883004695177}, {"id": 42, "seek": 11400, "start": 129.0, "end": 131.0, "text": " And if you don't know the codec first,", "tokens": [51114, 400, 498, 291, 500, 380, 458, 264, 3089, 66, 700, 11, 51214], "temperature": 0.0, "avg_logprob": -0.0644100774236086, "compression_ratio": 1.834710743801653, "no_speech_prob": 0.0010472883004695177}, {"id": 43, "seek": 11400, "start": 131.0, "end": 133.0, "text": " it's quite hard to understand the spec.", "tokens": [51214, 309, 311, 1596, 1152, 281, 1223, 264, 1608, 13, 51314], "temperature": 0.0, "avg_logprob": -0.0644100774236086, "compression_ratio": 1.834710743801653, "no_speech_prob": 0.0010472883004695177}, {"id": 44, "seek": 11400, "start": 133.0, "end": 135.0, "text": " So that's the situation,", "tokens": [51314, 407, 300, 311, 264, 2590, 11, 51414], "temperature": 0.0, "avg_logprob": -0.0644100774236086, "compression_ratio": 1.834710743801653, "no_speech_prob": 0.0010472883004695177}, {"id": 45, "seek": 11400, "start": 135.0, "end": 138.0, "text": " but at least there are some standards and specifications.", "tokens": [51414, 457, 412, 1935, 456, 366, 512, 7787, 293, 29448, 13, 51564], "temperature": 0.0, "avg_logprob": -0.0644100774236086, "compression_ratio": 1.834710743801653, "no_speech_prob": 0.0010472883004695177}, {"id": 46, "seek": 11400, "start": 138.0, "end": 140.0, "text": " So some require realities to be used,", "tokens": [51564, 407, 512, 3651, 27785, 281, 312, 1143, 11, 51664], "temperature": 0.0, "avg_logprob": -0.0644100774236086, "compression_ratio": 1.834710743801653, "no_speech_prob": 0.0010472883004695177}, {"id": 47, "seek": 11400, "start": 140.0, "end": 142.0, "text": " some others don't.", "tokens": [51664, 512, 2357, 500, 380, 13, 51764], "temperature": 0.0, "avg_logprob": -0.0644100774236086, "compression_ratio": 1.834710743801653, "no_speech_prob": 0.0010472883004695177}, {"id": 48, "seek": 14200, "start": 142.0, "end": 144.0, "text": " That really depends.", "tokens": [50364, 663, 534, 5946, 13, 50464], "temperature": 0.0, "avg_logprob": -0.11207179462208468, "compression_ratio": 1.6453900709219857, "no_speech_prob": 0.005198054481297731}, {"id": 49, "seek": 14200, "start": 144.0, "end": 146.0, "text": " So there is a bunch of codecs which are hyped now.", "tokens": [50464, 407, 456, 307, 257, 3840, 295, 3089, 14368, 597, 366, 43172, 586, 13, 50564], "temperature": 0.0, "avg_logprob": -0.11207179462208468, "compression_ratio": 1.6453900709219857, "no_speech_prob": 0.005198054481297731}, {"id": 50, "seek": 14200, "start": 146.0, "end": 148.0, "text": " There is a lot of talk about AV1,", "tokens": [50564, 821, 307, 257, 688, 295, 751, 466, 30198, 16, 11, 50664], "temperature": 0.0, "avg_logprob": -0.11207179462208468, "compression_ratio": 1.6453900709219857, "no_speech_prob": 0.005198054481297731}, {"id": 51, "seek": 14200, "start": 148.0, "end": 150.0, "text": " VP9, HTC5, and HTC6,", "tokens": [50664, 35812, 24, 11, 11751, 34, 20, 11, 293, 11751, 34, 21, 11, 50764], "temperature": 0.0, "avg_logprob": -0.11207179462208468, "compression_ratio": 1.6453900709219857, "no_speech_prob": 0.005198054481297731}, {"id": 52, "seek": 14200, "start": 150.0, "end": 152.0, "text": " so that's the kind of upcoming stuff", "tokens": [50764, 370, 300, 311, 264, 733, 295, 11500, 1507, 50864], "temperature": 0.0, "avg_logprob": -0.11207179462208468, "compression_ratio": 1.6453900709219857, "no_speech_prob": 0.005198054481297731}, {"id": 53, "seek": 14200, "start": 152.0, "end": 154.0, "text": " that everyone is excited about.", "tokens": [50864, 300, 1518, 307, 2919, 466, 13, 50964], "temperature": 0.0, "avg_logprob": -0.11207179462208468, "compression_ratio": 1.6453900709219857, "no_speech_prob": 0.005198054481297731}, {"id": 54, "seek": 14200, "start": 154.0, "end": 156.0, "text": " But of course, it really takes a while", "tokens": [50964, 583, 295, 1164, 11, 309, 534, 2516, 257, 1339, 51064], "temperature": 0.0, "avg_logprob": -0.11207179462208468, "compression_ratio": 1.6453900709219857, "no_speech_prob": 0.005198054481297731}, {"id": 55, "seek": 14200, "start": 156.0, "end": 160.0, "text": " before people actually use those codecs in the real world.", "tokens": [51064, 949, 561, 767, 764, 729, 3089, 14368, 294, 264, 957, 1002, 13, 51264], "temperature": 0.0, "avg_logprob": -0.11207179462208468, "compression_ratio": 1.6453900709219857, "no_speech_prob": 0.005198054481297731}, {"id": 56, "seek": 14200, "start": 160.0, "end": 162.0, "text": " But there is a real interest in that,", "tokens": [51264, 583, 456, 307, 257, 957, 1179, 294, 300, 11, 51364], "temperature": 0.0, "avg_logprob": -0.11207179462208468, "compression_ratio": 1.6453900709219857, "no_speech_prob": 0.005198054481297731}, {"id": 57, "seek": 14200, "start": 162.0, "end": 165.0, "text": " especially if we're looking to reduce our global power consumption,", "tokens": [51364, 2318, 498, 321, 434, 1237, 281, 5407, 527, 4338, 1347, 12126, 11, 51514], "temperature": 0.0, "avg_logprob": -0.11207179462208468, "compression_ratio": 1.6453900709219857, "no_speech_prob": 0.005198054481297731}, {"id": 58, "seek": 14200, "start": 165.0, "end": 168.0, "text": " because better codecs means less data,", "tokens": [51514, 570, 1101, 3089, 14368, 1355, 1570, 1412, 11, 51664], "temperature": 0.0, "avg_logprob": -0.11207179462208468, "compression_ratio": 1.6453900709219857, "no_speech_prob": 0.005198054481297731}, {"id": 59, "seek": 14200, "start": 168.0, "end": 170.0, "text": " and if we have less data,", "tokens": [51664, 293, 498, 321, 362, 1570, 1412, 11, 51764], "temperature": 0.0, "avg_logprob": -0.11207179462208468, "compression_ratio": 1.6453900709219857, "no_speech_prob": 0.005198054481297731}, {"id": 60, "seek": 17000, "start": 170.0, "end": 173.0, "text": " less energy consumption for storage and for transmission.", "tokens": [50364, 1570, 2281, 12126, 337, 6725, 293, 337, 11574, 13, 50514], "temperature": 0.0, "avg_logprob": -0.06762122351025777, "compression_ratio": 1.7263513513513513, "no_speech_prob": 0.0005877477815374732}, {"id": 61, "seek": 17000, "start": 173.0, "end": 176.0, "text": " So having good codecs is actually quite important,", "tokens": [50514, 407, 1419, 665, 3089, 14368, 307, 767, 1596, 1021, 11, 50664], "temperature": 0.0, "avg_logprob": -0.06762122351025777, "compression_ratio": 1.7263513513513513, "no_speech_prob": 0.0005877477815374732}, {"id": 62, "seek": 17000, "start": 176.0, "end": 178.0, "text": " and it can really make a difference.", "tokens": [50664, 293, 309, 393, 534, 652, 257, 2649, 13, 50764], "temperature": 0.0, "avg_logprob": -0.06762122351025777, "compression_ratio": 1.7263513513513513, "no_speech_prob": 0.0005877477815374732}, {"id": 63, "seek": 17000, "start": 178.0, "end": 180.0, "text": " So how do we encode those videos?", "tokens": [50764, 407, 577, 360, 321, 2058, 1429, 729, 2145, 30, 50864], "temperature": 0.0, "avg_logprob": -0.06762122351025777, "compression_ratio": 1.7263513513513513, "no_speech_prob": 0.0005877477815374732}, {"id": 64, "seek": 17000, "start": 180.0, "end": 182.0, "text": " There is a number of techniques which are used,", "tokens": [50864, 821, 307, 257, 1230, 295, 7512, 597, 366, 1143, 11, 50964], "temperature": 0.0, "avg_logprob": -0.06762122351025777, "compression_ratio": 1.7263513513513513, "no_speech_prob": 0.0005877477815374732}, {"id": 65, "seek": 17000, "start": 182.0, "end": 185.0, "text": " usually one after the other in some kind of chain.", "tokens": [50964, 2673, 472, 934, 264, 661, 294, 512, 733, 295, 5021, 13, 51114], "temperature": 0.0, "avg_logprob": -0.06762122351025777, "compression_ratio": 1.7263513513513513, "no_speech_prob": 0.0005877477815374732}, {"id": 66, "seek": 17000, "start": 185.0, "end": 188.0, "text": " So we have a first class, which is the spatial compression,", "tokens": [51114, 407, 321, 362, 257, 700, 1508, 11, 597, 307, 264, 23598, 19355, 11, 51264], "temperature": 0.0, "avg_logprob": -0.06762122351025777, "compression_ratio": 1.7263513513513513, "no_speech_prob": 0.0005877477815374732}, {"id": 67, "seek": 17000, "start": 188.0, "end": 192.0, "text": " which is essentially how we can represent a single static picture", "tokens": [51264, 597, 307, 4476, 577, 321, 393, 2906, 257, 2167, 13437, 3036, 51464], "temperature": 0.0, "avg_logprob": -0.06762122351025777, "compression_ratio": 1.7263513513513513, "no_speech_prob": 0.0005877477815374732}, {"id": 68, "seek": 17000, "start": 192.0, "end": 194.0, "text": " in the most efficient way", "tokens": [51464, 294, 264, 881, 7148, 636, 51564], "temperature": 0.0, "avg_logprob": -0.06762122351025777, "compression_ratio": 1.7263513513513513, "no_speech_prob": 0.0005877477815374732}, {"id": 69, "seek": 17000, "start": 194.0, "end": 196.0, "text": " by using lots of different compression techniques.", "tokens": [51564, 538, 1228, 3195, 295, 819, 19355, 7512, 13, 51664], "temperature": 0.0, "avg_logprob": -0.06762122351025777, "compression_ratio": 1.7263513513513513, "no_speech_prob": 0.0005877477815374732}, {"id": 70, "seek": 17000, "start": 196.0, "end": 198.0, "text": " So I've mentioned a few here.", "tokens": [51664, 407, 286, 600, 2835, 257, 1326, 510, 13, 51764], "temperature": 0.0, "avg_logprob": -0.06762122351025777, "compression_ratio": 1.7263513513513513, "no_speech_prob": 0.0005877477815374732}, {"id": 71, "seek": 19800, "start": 198.0, "end": 201.0, "text": " Essentially, we go to frequency domain,", "tokens": [50364, 23596, 11, 321, 352, 281, 7893, 9274, 11, 50514], "temperature": 0.0, "avg_logprob": -0.07208435352032001, "compression_ratio": 1.943089430894309, "no_speech_prob": 0.0006643038359470665}, {"id": 72, "seek": 19800, "start": 201.0, "end": 203.0, "text": " and then we can eliminate some coefficients", "tokens": [50514, 293, 550, 321, 393, 13819, 512, 31994, 50614], "temperature": 0.0, "avg_logprob": -0.07208435352032001, "compression_ratio": 1.943089430894309, "no_speech_prob": 0.0006643038359470665}, {"id": 73, "seek": 19800, "start": 203.0, "end": 205.0, "text": " from that frequency domain.", "tokens": [50614, 490, 300, 7893, 9274, 13, 50714], "temperature": 0.0, "avg_logprob": -0.07208435352032001, "compression_ratio": 1.943089430894309, "no_speech_prob": 0.0006643038359470665}, {"id": 74, "seek": 19800, "start": 205.0, "end": 207.0, "text": " This is what we call quantization,", "tokens": [50714, 639, 307, 437, 321, 818, 4426, 2144, 11, 50814], "temperature": 0.0, "avg_logprob": -0.07208435352032001, "compression_ratio": 1.943089430894309, "no_speech_prob": 0.0006643038359470665}, {"id": 75, "seek": 19800, "start": 207.0, "end": 210.0, "text": " and we have a value that we call QP, the quantization parameter,", "tokens": [50814, 293, 321, 362, 257, 2158, 300, 321, 818, 1249, 47, 11, 264, 4426, 2144, 13075, 11, 50964], "temperature": 0.0, "avg_logprob": -0.07208435352032001, "compression_ratio": 1.943089430894309, "no_speech_prob": 0.0006643038359470665}, {"id": 76, "seek": 19800, "start": 210.0, "end": 214.0, "text": " which is here to tell us how many of those frequency-based coefficients", "tokens": [50964, 597, 307, 510, 281, 980, 505, 577, 867, 295, 729, 7893, 12, 6032, 31994, 51164], "temperature": 0.0, "avg_logprob": -0.07208435352032001, "compression_ratio": 1.943089430894309, "no_speech_prob": 0.0006643038359470665}, {"id": 77, "seek": 19800, "start": 214.0, "end": 217.0, "text": " we want to keep in order to represent our picture.", "tokens": [51164, 321, 528, 281, 1066, 294, 1668, 281, 2906, 527, 3036, 13, 51314], "temperature": 0.0, "avg_logprob": -0.07208435352032001, "compression_ratio": 1.943089430894309, "no_speech_prob": 0.0006643038359470665}, {"id": 78, "seek": 19800, "start": 217.0, "end": 220.0, "text": " And in general, the high-frequency coefficients represent details,", "tokens": [51314, 400, 294, 2674, 11, 264, 1090, 12, 19325, 48154, 31994, 2906, 4365, 11, 51464], "temperature": 0.0, "avg_logprob": -0.07208435352032001, "compression_ratio": 1.943089430894309, "no_speech_prob": 0.0006643038359470665}, {"id": 79, "seek": 19800, "start": 220.0, "end": 224.0, "text": " and the low-frequency coefficients represent the rough shape of the picture.", "tokens": [51464, 293, 264, 2295, 12, 19325, 48154, 31994, 2906, 264, 5903, 3909, 295, 264, 3036, 13, 51664], "temperature": 0.0, "avg_logprob": -0.07208435352032001, "compression_ratio": 1.943089430894309, "no_speech_prob": 0.0006643038359470665}, {"id": 80, "seek": 22400, "start": 225.0, "end": 228.0, "text": " But we also apply temporal compression techniques.", "tokens": [50414, 583, 321, 611, 3079, 30881, 19355, 7512, 13, 50564], "temperature": 0.0, "avg_logprob": -0.05743284318961349, "compression_ratio": 1.8130434782608695, "no_speech_prob": 0.00019705986778717488}, {"id": 81, "seek": 22400, "start": 228.0, "end": 231.0, "text": " Temporal compression will use the previews", "tokens": [50564, 8095, 2816, 304, 19355, 486, 764, 264, 14281, 82, 50714], "temperature": 0.0, "avg_logprob": -0.05743284318961349, "compression_ratio": 1.8130434782608695, "no_speech_prob": 0.00019705986778717488}, {"id": 82, "seek": 22400, "start": 231.0, "end": 233.0, "text": " and sometimes the next frames as well", "tokens": [50714, 293, 2171, 264, 958, 12083, 382, 731, 50814], "temperature": 0.0, "avg_logprob": -0.05743284318961349, "compression_ratio": 1.8130434782608695, "no_speech_prob": 0.00019705986778717488}, {"id": 83, "seek": 22400, "start": 233.0, "end": 236.0, "text": " in order to kind of calculate the current picture.", "tokens": [50814, 294, 1668, 281, 733, 295, 8873, 264, 2190, 3036, 13, 50964], "temperature": 0.0, "avg_logprob": -0.05743284318961349, "compression_ratio": 1.8130434782608695, "no_speech_prob": 0.00019705986778717488}, {"id": 84, "seek": 22400, "start": 236.0, "end": 239.0, "text": " So instead of coding a single picture all the time,", "tokens": [50964, 407, 2602, 295, 17720, 257, 2167, 3036, 439, 264, 565, 11, 51114], "temperature": 0.0, "avg_logprob": -0.05743284318961349, "compression_ratio": 1.8130434782608695, "no_speech_prob": 0.00019705986778717488}, {"id": 85, "seek": 22400, "start": 239.0, "end": 242.0, "text": " we are actually coding a difference between the previews", "tokens": [51114, 321, 366, 767, 17720, 257, 2649, 1296, 264, 14281, 82, 51264], "temperature": 0.0, "avg_logprob": -0.05743284318961349, "compression_ratio": 1.8130434782608695, "no_speech_prob": 0.00019705986778717488}, {"id": 86, "seek": 22400, "start": 242.0, "end": 246.0, "text": " and all the next picture to create the current one.", "tokens": [51264, 293, 439, 264, 958, 3036, 281, 1884, 264, 2190, 472, 13, 51464], "temperature": 0.0, "avg_logprob": -0.05743284318961349, "compression_ratio": 1.8130434782608695, "no_speech_prob": 0.00019705986778717488}, {"id": 87, "seek": 22400, "start": 247.0, "end": 249.0, "text": " So this is, for example, a representation", "tokens": [51514, 407, 341, 307, 11, 337, 1365, 11, 257, 10290, 51614], "temperature": 0.0, "avg_logprob": -0.05743284318961349, "compression_ratio": 1.8130434782608695, "no_speech_prob": 0.00019705986778717488}, {"id": 88, "seek": 22400, "start": 249.0, "end": 251.0, "text": " of what we call motion vectors,", "tokens": [51614, 295, 437, 321, 818, 5394, 18875, 11, 51714], "temperature": 0.0, "avg_logprob": -0.05743284318961349, "compression_ratio": 1.8130434782608695, "no_speech_prob": 0.00019705986778717488}, {"id": 89, "seek": 25100, "start": 251.0, "end": 255.0, "text": " which will indicate how the kind of pixels change", "tokens": [50364, 597, 486, 13330, 577, 264, 733, 295, 18668, 1319, 50564], "temperature": 0.0, "avg_logprob": -0.0825409565941762, "compression_ratio": 1.8085106382978724, "no_speech_prob": 0.0009987343801185489}, {"id": 90, "seek": 25100, "start": 255.0, "end": 257.0, "text": " from one frame to another,", "tokens": [50564, 490, 472, 3920, 281, 1071, 11, 50664], "temperature": 0.0, "avg_logprob": -0.0825409565941762, "compression_ratio": 1.8085106382978724, "no_speech_prob": 0.0009987343801185489}, {"id": 91, "seek": 25100, "start": 257.0, "end": 261.0, "text": " so we have a notion of directivity and direction, and so on.", "tokens": [50664, 370, 321, 362, 257, 10710, 295, 2047, 4253, 293, 3513, 11, 293, 370, 322, 13, 50864], "temperature": 0.0, "avg_logprob": -0.0825409565941762, "compression_ratio": 1.8085106382978724, "no_speech_prob": 0.0009987343801185489}, {"id": 92, "seek": 25100, "start": 263.0, "end": 267.0, "text": " So when we encode a video, we kind of have to decide on a strategy,", "tokens": [50964, 407, 562, 321, 2058, 1429, 257, 960, 11, 321, 733, 295, 362, 281, 4536, 322, 257, 5206, 11, 51164], "temperature": 0.0, "avg_logprob": -0.0825409565941762, "compression_ratio": 1.8085106382978724, "no_speech_prob": 0.0009987343801185489}, {"id": 93, "seek": 25100, "start": 267.0, "end": 270.0, "text": " which is exactly what do we want to do when we encode that video", "tokens": [51164, 597, 307, 2293, 437, 360, 321, 528, 281, 360, 562, 321, 2058, 1429, 300, 960, 51314], "temperature": 0.0, "avg_logprob": -0.0825409565941762, "compression_ratio": 1.8085106382978724, "no_speech_prob": 0.0009987343801185489}, {"id": 94, "seek": 25100, "start": 270.0, "end": 273.0, "text": " and which kind of trade-off we're going to adopt", "tokens": [51314, 293, 597, 733, 295, 4923, 12, 4506, 321, 434, 516, 281, 6878, 51464], "temperature": 0.0, "avg_logprob": -0.0825409565941762, "compression_ratio": 1.8085106382978724, "no_speech_prob": 0.0009987343801185489}, {"id": 95, "seek": 25100, "start": 273.0, "end": 275.0, "text": " between the size and the quality", "tokens": [51464, 1296, 264, 2744, 293, 264, 3125, 51564], "temperature": 0.0, "avg_logprob": -0.0825409565941762, "compression_ratio": 1.8085106382978724, "no_speech_prob": 0.0009987343801185489}, {"id": 96, "seek": 25100, "start": 275.0, "end": 278.0, "text": " and how we want that trade-off to evolve over time", "tokens": [51564, 293, 577, 321, 528, 300, 4923, 12, 4506, 281, 16693, 670, 565, 51714], "temperature": 0.0, "avg_logprob": -0.0825409565941762, "compression_ratio": 1.8085106382978724, "no_speech_prob": 0.0009987343801185489}, {"id": 97, "seek": 25100, "start": 278.0, "end": 280.0, "text": " and things like that.", "tokens": [51714, 293, 721, 411, 300, 13, 51814], "temperature": 0.0, "avg_logprob": -0.0825409565941762, "compression_ratio": 1.8085106382978724, "no_speech_prob": 0.0009987343801185489}, {"id": 98, "seek": 28000, "start": 280.0, "end": 282.0, "text": " So we have very common strategies.", "tokens": [50364, 407, 321, 362, 588, 2689, 9029, 13, 50464], "temperature": 0.0, "avg_logprob": -0.06604404707212706, "compression_ratio": 1.7283464566929134, "no_speech_prob": 4.903899389319122e-05}, {"id": 99, "seek": 28000, "start": 282.0, "end": 286.0, "text": " For example, if you just want an average or a constant bitrate", "tokens": [50464, 1171, 1365, 11, 498, 291, 445, 528, 364, 4274, 420, 257, 5754, 857, 4404, 50664], "temperature": 0.0, "avg_logprob": -0.06604404707212706, "compression_ratio": 1.7283464566929134, "no_speech_prob": 4.903899389319122e-05}, {"id": 100, "seek": 28000, "start": 286.0, "end": 288.0, "text": " to stay the same for the whole stream,", "tokens": [50664, 281, 1754, 264, 912, 337, 264, 1379, 4309, 11, 50764], "temperature": 0.0, "avg_logprob": -0.06604404707212706, "compression_ratio": 1.7283464566929134, "no_speech_prob": 4.903899389319122e-05}, {"id": 101, "seek": 28000, "start": 288.0, "end": 291.0, "text": " that's one strategy that an encoder can implement,", "tokens": [50764, 300, 311, 472, 5206, 300, 364, 2058, 19866, 393, 4445, 11, 50914], "temperature": 0.0, "avg_logprob": -0.06604404707212706, "compression_ratio": 1.7283464566929134, "no_speech_prob": 4.903899389319122e-05}, {"id": 102, "seek": 28000, "start": 291.0, "end": 294.0, "text": " but we can also decide that instead we want a constant quality,", "tokens": [50914, 457, 321, 393, 611, 4536, 300, 2602, 321, 528, 257, 5754, 3125, 11, 51064], "temperature": 0.0, "avg_logprob": -0.06604404707212706, "compression_ratio": 1.7283464566929134, "no_speech_prob": 4.903899389319122e-05}, {"id": 103, "seek": 28000, "start": 294.0, "end": 299.0, "text": " so the size might change depending on what we want to achieve.", "tokens": [51064, 370, 264, 2744, 1062, 1319, 5413, 322, 437, 321, 528, 281, 4584, 13, 51314], "temperature": 0.0, "avg_logprob": -0.06604404707212706, "compression_ratio": 1.7283464566929134, "no_speech_prob": 4.903899389319122e-05}, {"id": 104, "seek": 28000, "start": 300.0, "end": 304.0, "text": " So it's important to understand that this notion of strategy", "tokens": [51364, 407, 309, 311, 1021, 281, 1223, 300, 341, 10710, 295, 5206, 51564], "temperature": 0.0, "avg_logprob": -0.06604404707212706, "compression_ratio": 1.7283464566929134, "no_speech_prob": 4.903899389319122e-05}, {"id": 105, "seek": 28000, "start": 304.0, "end": 308.0, "text": " for encoding is really at the core of what an encoder is doing,", "tokens": [51564, 337, 43430, 307, 534, 412, 264, 4965, 295, 437, 364, 2058, 19866, 307, 884, 11, 51764], "temperature": 0.0, "avg_logprob": -0.06604404707212706, "compression_ratio": 1.7283464566929134, "no_speech_prob": 4.903899389319122e-05}, {"id": 106, "seek": 30800, "start": 308.0, "end": 311.0, "text": " and this is generally what we call rate control.", "tokens": [50364, 293, 341, 307, 5101, 437, 321, 818, 3314, 1969, 13, 50514], "temperature": 0.0, "avg_logprob": -0.0555392930267054, "compression_ratio": 1.7647058823529411, "no_speech_prob": 0.0009089426603168249}, {"id": 107, "seek": 30800, "start": 311.0, "end": 317.0, "text": " So rate control is about dynamically deciding on this trade-off,", "tokens": [50514, 407, 3314, 1969, 307, 466, 43492, 17990, 322, 341, 4923, 12, 4506, 11, 50814], "temperature": 0.0, "avg_logprob": -0.0555392930267054, "compression_ratio": 1.7647058823529411, "no_speech_prob": 0.0009089426603168249}, {"id": 108, "seek": 30800, "start": 317.0, "end": 320.0, "text": " so we have to decide on which frame type we want to use,", "tokens": [50814, 370, 321, 362, 281, 4536, 322, 597, 3920, 2010, 321, 528, 281, 764, 11, 50964], "temperature": 0.0, "avg_logprob": -0.0555392930267054, "compression_ratio": 1.7647058823529411, "no_speech_prob": 0.0009089426603168249}, {"id": 109, "seek": 30800, "start": 320.0, "end": 322.0, "text": " we have to decide on the quantization parameter", "tokens": [50964, 321, 362, 281, 4536, 322, 264, 4426, 2144, 13075, 51064], "temperature": 0.0, "avg_logprob": -0.0555392930267054, "compression_ratio": 1.7647058823529411, "no_speech_prob": 0.0009089426603168249}, {"id": 110, "seek": 30800, "start": 322.0, "end": 325.0, "text": " and a number of other settings that we can set in the encoder", "tokens": [51064, 293, 257, 1230, 295, 661, 6257, 300, 321, 393, 992, 294, 264, 2058, 19866, 51214], "temperature": 0.0, "avg_logprob": -0.0555392930267054, "compression_ratio": 1.7647058823529411, "no_speech_prob": 0.0009089426603168249}, {"id": 111, "seek": 30800, "start": 325.0, "end": 329.0, "text": " to essentially have it adapt to different scenes", "tokens": [51214, 281, 4476, 362, 309, 6231, 281, 819, 8026, 51414], "temperature": 0.0, "avg_logprob": -0.0555392930267054, "compression_ratio": 1.7647058823529411, "no_speech_prob": 0.0009089426603168249}, {"id": 112, "seek": 30800, "start": 329.0, "end": 333.0, "text": " and also to be able to react to changes in the scene.", "tokens": [51414, 293, 611, 281, 312, 1075, 281, 4515, 281, 2962, 294, 264, 4145, 13, 51614], "temperature": 0.0, "avg_logprob": -0.0555392930267054, "compression_ratio": 1.7647058823529411, "no_speech_prob": 0.0009089426603168249}, {"id": 113, "seek": 30800, "start": 333.0, "end": 335.0, "text": " So if you, for example, have a movie", "tokens": [51614, 407, 498, 291, 11, 337, 1365, 11, 362, 257, 3169, 51714], "temperature": 0.0, "avg_logprob": -0.0555392930267054, "compression_ratio": 1.7647058823529411, "no_speech_prob": 0.0009089426603168249}, {"id": 114, "seek": 33500, "start": 335.0, "end": 337.0, "text": " and you're going from one scene to another,", "tokens": [50364, 293, 291, 434, 516, 490, 472, 4145, 281, 1071, 11, 50464], "temperature": 0.0, "avg_logprob": -0.04802038452842019, "compression_ratio": 1.7286821705426356, "no_speech_prob": 0.0014287502272054553}, {"id": 115, "seek": 33500, "start": 337.0, "end": 340.0, "text": " you want your encoder to kind of react to that", "tokens": [50464, 291, 528, 428, 2058, 19866, 281, 733, 295, 4515, 281, 300, 50614], "temperature": 0.0, "avg_logprob": -0.04802038452842019, "compression_ratio": 1.7286821705426356, "no_speech_prob": 0.0014287502272054553}, {"id": 116, "seek": 33500, "start": 340.0, "end": 344.0, "text": " and give more details on the first image of the new scene,", "tokens": [50614, 293, 976, 544, 4365, 322, 264, 700, 3256, 295, 264, 777, 4145, 11, 50814], "temperature": 0.0, "avg_logprob": -0.04802038452842019, "compression_ratio": 1.7286821705426356, "no_speech_prob": 0.0014287502272054553}, {"id": 117, "seek": 33500, "start": 344.0, "end": 346.0, "text": " for example, things like that.", "tokens": [50814, 337, 1365, 11, 721, 411, 300, 13, 50914], "temperature": 0.0, "avg_logprob": -0.04802038452842019, "compression_ratio": 1.7286821705426356, "no_speech_prob": 0.0014287502272054553}, {"id": 118, "seek": 33500, "start": 346.0, "end": 349.0, "text": " So the main takeaway from this slide", "tokens": [50914, 407, 264, 2135, 30681, 490, 341, 4137, 51064], "temperature": 0.0, "avg_logprob": -0.04802038452842019, "compression_ratio": 1.7286821705426356, "no_speech_prob": 0.0014287502272054553}, {"id": 119, "seek": 33500, "start": 349.0, "end": 351.0, "text": " is that the rate control implementation", "tokens": [51064, 307, 300, 264, 3314, 1969, 11420, 51164], "temperature": 0.0, "avg_logprob": -0.04802038452842019, "compression_ratio": 1.7286821705426356, "no_speech_prob": 0.0014287502272054553}, {"id": 120, "seek": 33500, "start": 351.0, "end": 353.0, "text": " is really the key to have good encoding", "tokens": [51164, 307, 534, 264, 2141, 281, 362, 665, 43430, 51264], "temperature": 0.0, "avg_logprob": -0.04802038452842019, "compression_ratio": 1.7286821705426356, "no_speech_prob": 0.0014287502272054553}, {"id": 121, "seek": 33500, "start": 353.0, "end": 356.0, "text": " and to have something that is actually performance", "tokens": [51264, 293, 281, 362, 746, 300, 307, 767, 3389, 51414], "temperature": 0.0, "avg_logprob": -0.04802038452842019, "compression_ratio": 1.7286821705426356, "no_speech_prob": 0.0014287502272054553}, {"id": 122, "seek": 33500, "start": 356.0, "end": 358.0, "text": " and that gives good results.", "tokens": [51414, 293, 300, 2709, 665, 3542, 13, 51514], "temperature": 0.0, "avg_logprob": -0.04802038452842019, "compression_ratio": 1.7286821705426356, "no_speech_prob": 0.0014287502272054553}, {"id": 123, "seek": 33500, "start": 359.0, "end": 364.0, "text": " So now that we have a brief overview of those compression techniques", "tokens": [51564, 407, 586, 300, 321, 362, 257, 5353, 12492, 295, 729, 19355, 7512, 51814], "temperature": 0.0, "avg_logprob": -0.04802038452842019, "compression_ratio": 1.7286821705426356, "no_speech_prob": 0.0014287502272054553}, {"id": 124, "seek": 36400, "start": 364.0, "end": 367.0, "text": " and what encoders are supposed to do,", "tokens": [50364, 293, 437, 2058, 378, 433, 366, 3442, 281, 360, 11, 50514], "temperature": 0.0, "avg_logprob": -0.051736092958293976, "compression_ratio": 1.6692307692307693, "no_speech_prob": 0.0008798001217655838}, {"id": 125, "seek": 36400, "start": 367.0, "end": 370.0, "text": " the main topic is how do we accelerate this", "tokens": [50514, 264, 2135, 4829, 307, 577, 360, 321, 21341, 341, 50664], "temperature": 0.0, "avg_logprob": -0.051736092958293976, "compression_ratio": 1.6692307692307693, "no_speech_prob": 0.0008798001217655838}, {"id": 126, "seek": 36400, "start": 370.0, "end": 372.0, "text": " because doing all of this on the CPU", "tokens": [50664, 570, 884, 439, 295, 341, 322, 264, 13199, 50764], "temperature": 0.0, "avg_logprob": -0.051736092958293976, "compression_ratio": 1.6692307692307693, "no_speech_prob": 0.0008798001217655838}, {"id": 127, "seek": 36400, "start": 372.0, "end": 374.0, "text": " is usually a very intensive process,", "tokens": [50764, 307, 2673, 257, 588, 18957, 1399, 11, 50864], "temperature": 0.0, "avg_logprob": -0.051736092958293976, "compression_ratio": 1.6692307692307693, "no_speech_prob": 0.0008798001217655838}, {"id": 128, "seek": 36400, "start": 374.0, "end": 376.0, "text": " so it will take a lot of your CPU,", "tokens": [50864, 370, 309, 486, 747, 257, 688, 295, 428, 13199, 11, 50964], "temperature": 0.0, "avg_logprob": -0.051736092958293976, "compression_ratio": 1.6692307692307693, "no_speech_prob": 0.0008798001217655838}, {"id": 129, "seek": 36400, "start": 376.0, "end": 378.0, "text": " and nowadays we have lots of use cases", "tokens": [50964, 293, 13434, 321, 362, 3195, 295, 764, 3331, 51064], "temperature": 0.0, "avg_logprob": -0.051736092958293976, "compression_ratio": 1.6692307692307693, "no_speech_prob": 0.0008798001217655838}, {"id": 130, "seek": 36400, "start": 378.0, "end": 382.0, "text": " where people want super high sizes", "tokens": [51064, 689, 561, 528, 1687, 1090, 11602, 51264], "temperature": 0.0, "avg_logprob": -0.051736092958293976, "compression_ratio": 1.6692307692307693, "no_speech_prob": 0.0008798001217655838}, {"id": 131, "seek": 36400, "start": 382.0, "end": 383.0, "text": " and they want high frame rate,", "tokens": [51264, 293, 436, 528, 1090, 3920, 3314, 11, 51314], "temperature": 0.0, "avg_logprob": -0.051736092958293976, "compression_ratio": 1.6692307692307693, "no_speech_prob": 0.0008798001217655838}, {"id": 132, "seek": 36400, "start": 383.0, "end": 386.0, "text": " like 60 frames per second on things like 4K,", "tokens": [51314, 411, 4060, 12083, 680, 1150, 322, 721, 411, 1017, 42, 11, 51464], "temperature": 0.0, "avg_logprob": -0.051736092958293976, "compression_ratio": 1.6692307692307693, "no_speech_prob": 0.0008798001217655838}, {"id": 133, "seek": 36400, "start": 386.0, "end": 390.0, "text": " and there are use cases where we want to be able to encode", "tokens": [51464, 293, 456, 366, 764, 3331, 689, 321, 528, 281, 312, 1075, 281, 2058, 1429, 51664], "temperature": 0.0, "avg_logprob": -0.051736092958293976, "compression_ratio": 1.6692307692307693, "no_speech_prob": 0.0008798001217655838}, {"id": 134, "seek": 36400, "start": 390.0, "end": 392.0, "text": " just as we are receiving the data.", "tokens": [51664, 445, 382, 321, 366, 10040, 264, 1412, 13, 51764], "temperature": 0.0, "avg_logprob": -0.051736092958293976, "compression_ratio": 1.6692307692307693, "no_speech_prob": 0.0008798001217655838}, {"id": 135, "seek": 39200, "start": 392.0, "end": 395.0, "text": " So for example, a regular camera that you used to shoot,", "tokens": [50364, 407, 337, 1365, 11, 257, 3890, 2799, 300, 291, 1143, 281, 3076, 11, 50514], "temperature": 0.0, "avg_logprob": -0.07316332596998948, "compression_ratio": 1.8888888888888888, "no_speech_prob": 0.0006455230759456754}, {"id": 136, "seek": 39200, "start": 395.0, "end": 397.0, "text": " you want to be able to produce a video", "tokens": [50514, 291, 528, 281, 312, 1075, 281, 5258, 257, 960, 50614], "temperature": 0.0, "avg_logprob": -0.07316332596998948, "compression_ratio": 1.8888888888888888, "no_speech_prob": 0.0006455230759456754}, {"id": 137, "seek": 39200, "start": 397.0, "end": 401.0, "text": " so you want to be able to encode in more or less real time.", "tokens": [50614, 370, 291, 528, 281, 312, 1075, 281, 2058, 1429, 294, 544, 420, 1570, 957, 565, 13, 50814], "temperature": 0.0, "avg_logprob": -0.07316332596998948, "compression_ratio": 1.8888888888888888, "no_speech_prob": 0.0006455230759456754}, {"id": 138, "seek": 39200, "start": 401.0, "end": 403.0, "text": " So if you really want to achieve that,", "tokens": [50814, 407, 498, 291, 534, 528, 281, 4584, 300, 11, 50914], "temperature": 0.0, "avg_logprob": -0.07316332596998948, "compression_ratio": 1.8888888888888888, "no_speech_prob": 0.0006455230759456754}, {"id": 139, "seek": 39200, "start": 403.0, "end": 406.0, "text": " you have to use dedicated hardware which will offload this", "tokens": [50914, 291, 362, 281, 764, 8374, 8837, 597, 486, 766, 2907, 341, 51064], "temperature": 0.0, "avg_logprob": -0.07316332596998948, "compression_ratio": 1.8888888888888888, "no_speech_prob": 0.0006455230759456754}, {"id": 140, "seek": 39200, "start": 406.0, "end": 410.0, "text": " and will give you some acceleration for this process.", "tokens": [51064, 293, 486, 976, 291, 512, 17162, 337, 341, 1399, 13, 51264], "temperature": 0.0, "avg_logprob": -0.07316332596998948, "compression_ratio": 1.8888888888888888, "no_speech_prob": 0.0006455230759456754}, {"id": 141, "seek": 39200, "start": 410.0, "end": 413.0, "text": " So this is when we start talking about hardware-based video encoding", "tokens": [51264, 407, 341, 307, 562, 321, 722, 1417, 466, 8837, 12, 6032, 960, 43430, 51414], "temperature": 0.0, "avg_logprob": -0.07316332596998948, "compression_ratio": 1.8888888888888888, "no_speech_prob": 0.0006455230759456754}, {"id": 142, "seek": 39200, "start": 413.0, "end": 416.0, "text": " or hardware-accelerated video encoding.", "tokens": [51414, 420, 8837, 12, 326, 4933, 260, 770, 960, 43430, 13, 51564], "temperature": 0.0, "avg_logprob": -0.07316332596998948, "compression_ratio": 1.8888888888888888, "no_speech_prob": 0.0006455230759456754}, {"id": 143, "seek": 39200, "start": 416.0, "end": 418.0, "text": " So those hardware encoders,", "tokens": [51564, 407, 729, 8837, 2058, 378, 433, 11, 51664], "temperature": 0.0, "avg_logprob": -0.07316332596998948, "compression_ratio": 1.8888888888888888, "no_speech_prob": 0.0006455230759456754}, {"id": 144, "seek": 39200, "start": 418.0, "end": 421.0, "text": " not only do they know how to produce the correct", "tokens": [51664, 406, 787, 360, 436, 458, 577, 281, 5258, 264, 3006, 51814], "temperature": 0.0, "avg_logprob": -0.07316332596998948, "compression_ratio": 1.8888888888888888, "no_speech_prob": 0.0006455230759456754}, {"id": 145, "seek": 42100, "start": 421.0, "end": 425.0, "text": " format for the video that we chose for the codec,", "tokens": [50364, 7877, 337, 264, 960, 300, 321, 5111, 337, 264, 3089, 66, 11, 50564], "temperature": 0.0, "avg_logprob": -0.1126359036094264, "compression_ratio": 1.6761904761904762, "no_speech_prob": 0.000919417361728847}, {"id": 146, "seek": 42100, "start": 425.0, "end": 430.0, "text": " they sometimes also have some extra features", "tokens": [50564, 436, 2171, 611, 362, 512, 2857, 4122, 50814], "temperature": 0.0, "avg_logprob": -0.1126359036094264, "compression_ratio": 1.6761904761904762, "no_speech_prob": 0.000919417361728847}, {"id": 147, "seek": 42100, "start": 430.0, "end": 432.0, "text": " like pre-processing, so for example,", "tokens": [50814, 411, 659, 12, 41075, 278, 11, 370, 337, 1365, 11, 50914], "temperature": 0.0, "avg_logprob": -0.1126359036094264, "compression_ratio": 1.6761904761904762, "no_speech_prob": 0.000919417361728847}, {"id": 148, "seek": 42100, "start": 432.0, "end": 435.0, "text": " they can convert the format of the pictures that you give them.", "tokens": [50914, 436, 393, 7620, 264, 7877, 295, 264, 5242, 300, 291, 976, 552, 13, 51064], "temperature": 0.0, "avg_logprob": -0.1126359036094264, "compression_ratio": 1.6761904761904762, "no_speech_prob": 0.000919417361728847}, {"id": 149, "seek": 42100, "start": 435.0, "end": 439.0, "text": " They can also apply things like antishaking or cropping.", "tokens": [51064, 814, 393, 611, 3079, 721, 411, 2511, 742, 2456, 420, 4848, 3759, 13, 51264], "temperature": 0.0, "avg_logprob": -0.1126359036094264, "compression_ratio": 1.6761904761904762, "no_speech_prob": 0.000919417361728847}, {"id": 150, "seek": 42100, "start": 439.0, "end": 442.0, "text": " So this is a very common pre-processing pipeline", "tokens": [51264, 407, 341, 307, 257, 588, 2689, 659, 12, 41075, 278, 15517, 51414], "temperature": 0.0, "avg_logprob": -0.1126359036094264, "compression_ratio": 1.6761904761904762, "no_speech_prob": 0.000919417361728847}, {"id": 151, "seek": 42100, "start": 442.0, "end": 445.0, "text": " for an encoder.", "tokens": [51414, 337, 364, 2058, 19866, 13, 51564], "temperature": 0.0, "avg_logprob": -0.1126359036094264, "compression_ratio": 1.6761904761904762, "no_speech_prob": 0.000919417361728847}, {"id": 152, "seek": 42100, "start": 445.0, "end": 448.0, "text": " Usually they will have the ability", "tokens": [51564, 11419, 436, 486, 362, 264, 3485, 51714], "temperature": 0.0, "avg_logprob": -0.1126359036094264, "compression_ratio": 1.6761904761904762, "no_speech_prob": 0.000919417361728847}, {"id": 153, "seek": 44800, "start": 448.0, "end": 451.0, "text": " to also encode multiple streams in parallel,", "tokens": [50364, 281, 611, 2058, 1429, 3866, 15842, 294, 8952, 11, 50514], "temperature": 0.0, "avg_logprob": -0.06931140899658203, "compression_ratio": 1.859437751004016, "no_speech_prob": 0.0015960275195538998}, {"id": 154, "seek": 44800, "start": 451.0, "end": 453.0, "text": " so this, well, not necessarily in parallel,", "tokens": [50514, 370, 341, 11, 731, 11, 406, 4725, 294, 8952, 11, 50614], "temperature": 0.0, "avg_logprob": -0.06931140899658203, "compression_ratio": 1.859437751004016, "no_speech_prob": 0.0015960275195538998}, {"id": 155, "seek": 44800, "start": 453.0, "end": 456.0, "text": " but at least in a time-shared way.", "tokens": [50614, 457, 412, 1935, 294, 257, 565, 12, 2716, 1642, 636, 13, 50764], "temperature": 0.0, "avg_logprob": -0.06931140899658203, "compression_ratio": 1.859437751004016, "no_speech_prob": 0.0015960275195538998}, {"id": 156, "seek": 44800, "start": 456.0, "end": 458.0, "text": " So you could use the same encoder", "tokens": [50764, 407, 291, 727, 764, 264, 912, 2058, 19866, 50864], "temperature": 0.0, "avg_logprob": -0.06931140899658203, "compression_ratio": 1.859437751004016, "no_speech_prob": 0.0015960275195538998}, {"id": 157, "seek": 44800, "start": 458.0, "end": 460.0, "text": " and have multiple streams that you want to encode,", "tokens": [50864, 293, 362, 3866, 15842, 300, 291, 528, 281, 2058, 1429, 11, 50964], "temperature": 0.0, "avg_logprob": -0.06931140899658203, "compression_ratio": 1.859437751004016, "no_speech_prob": 0.0015960275195538998}, {"id": 158, "seek": 44800, "start": 460.0, "end": 463.0, "text": " and then you encode one frame for one stream", "tokens": [50964, 293, 550, 291, 2058, 1429, 472, 3920, 337, 472, 4309, 51114], "temperature": 0.0, "avg_logprob": -0.06931140899658203, "compression_ratio": 1.859437751004016, "no_speech_prob": 0.0015960275195538998}, {"id": 159, "seek": 44800, "start": 463.0, "end": 466.0, "text": " which goes into one sync, one output,", "tokens": [51114, 597, 1709, 666, 472, 20271, 11, 472, 5598, 11, 51264], "temperature": 0.0, "avg_logprob": -0.06931140899658203, "compression_ratio": 1.859437751004016, "no_speech_prob": 0.0015960275195538998}, {"id": 160, "seek": 44800, "start": 466.0, "end": 468.0, "text": " and then you have another stream", "tokens": [51264, 293, 550, 291, 362, 1071, 4309, 51364], "temperature": 0.0, "avg_logprob": -0.06931140899658203, "compression_ratio": 1.859437751004016, "no_speech_prob": 0.0015960275195538998}, {"id": 161, "seek": 44800, "start": 468.0, "end": 471.0, "text": " that you also want to deal with concurrently.", "tokens": [51364, 300, 291, 611, 528, 281, 2028, 365, 37702, 356, 13, 51514], "temperature": 0.0, "avg_logprob": -0.06931140899658203, "compression_ratio": 1.859437751004016, "no_speech_prob": 0.0015960275195538998}, {"id": 162, "seek": 44800, "start": 471.0, "end": 475.0, "text": " So it's important that you are able to kind of switch", "tokens": [51514, 407, 309, 311, 1021, 300, 291, 366, 1075, 281, 733, 295, 3679, 51714], "temperature": 0.0, "avg_logprob": -0.06931140899658203, "compression_ratio": 1.859437751004016, "no_speech_prob": 0.0015960275195538998}, {"id": 163, "seek": 44800, "start": 475.0, "end": 477.0, "text": " between different contexts of encoding", "tokens": [51714, 1296, 819, 30628, 295, 43430, 51814], "temperature": 0.0, "avg_logprob": -0.06931140899658203, "compression_ratio": 1.859437751004016, "no_speech_prob": 0.0015960275195538998}, {"id": 164, "seek": 47700, "start": 477.0, "end": 479.0, "text": " because you don't want your encoder to be just dedicated", "tokens": [50364, 570, 291, 500, 380, 528, 428, 2058, 19866, 281, 312, 445, 8374, 50464], "temperature": 0.0, "avg_logprob": -0.05754855907324589, "compression_ratio": 1.685121107266436, "no_speech_prob": 0.0004035634046886116}, {"id": 165, "seek": 47700, "start": 479.0, "end": 481.0, "text": " to one thing, to one task,", "tokens": [50464, 281, 472, 551, 11, 281, 472, 5633, 11, 50564], "temperature": 0.0, "avg_logprob": -0.05754855907324589, "compression_ratio": 1.685121107266436, "no_speech_prob": 0.0004035634046886116}, {"id": 166, "seek": 47700, "start": 481.0, "end": 483.0, "text": " so it's a little bit like a GPU", "tokens": [50564, 370, 309, 311, 257, 707, 857, 411, 257, 18407, 50664], "temperature": 0.0, "avg_logprob": -0.05754855907324589, "compression_ratio": 1.685121107266436, "no_speech_prob": 0.0004035634046886116}, {"id": 167, "seek": 47700, "start": 483.0, "end": 487.0, "text": " where you want to be able to render multiple things like that.", "tokens": [50664, 689, 291, 528, 281, 312, 1075, 281, 15529, 3866, 721, 411, 300, 13, 50864], "temperature": 0.0, "avg_logprob": -0.05754855907324589, "compression_ratio": 1.685121107266436, "no_speech_prob": 0.0004035634046886116}, {"id": 168, "seek": 47700, "start": 487.0, "end": 491.0, "text": " All right, so when we're talking about hardware video encoding,", "tokens": [50864, 1057, 558, 11, 370, 562, 321, 434, 1417, 466, 8837, 960, 43430, 11, 51064], "temperature": 0.0, "avg_logprob": -0.05754855907324589, "compression_ratio": 1.685121107266436, "no_speech_prob": 0.0004035634046886116}, {"id": 169, "seek": 47700, "start": 491.0, "end": 494.0, "text": " there is essentially two types of hardware implementations.", "tokens": [51064, 456, 307, 4476, 732, 3467, 295, 8837, 4445, 763, 13, 51214], "temperature": 0.0, "avg_logprob": -0.05754855907324589, "compression_ratio": 1.685121107266436, "no_speech_prob": 0.0004035634046886116}, {"id": 170, "seek": 47700, "start": 494.0, "end": 496.0, "text": " The first one, which is probably the most common,", "tokens": [51214, 440, 700, 472, 11, 597, 307, 1391, 264, 881, 2689, 11, 51314], "temperature": 0.0, "avg_logprob": -0.05754855907324589, "compression_ratio": 1.685121107266436, "no_speech_prob": 0.0004035634046886116}, {"id": 171, "seek": 47700, "start": 496.0, "end": 499.0, "text": " is what we call the stateful encoders.", "tokens": [51314, 307, 437, 321, 818, 264, 1785, 906, 2058, 378, 433, 13, 51464], "temperature": 0.0, "avg_logprob": -0.05754855907324589, "compression_ratio": 1.685121107266436, "no_speech_prob": 0.0004035634046886116}, {"id": 172, "seek": 47700, "start": 499.0, "end": 501.0, "text": " So these encoders are somewhat abstracted", "tokens": [51464, 407, 613, 2058, 378, 433, 366, 8344, 12649, 292, 51564], "temperature": 0.0, "avg_logprob": -0.05754855907324589, "compression_ratio": 1.685121107266436, "no_speech_prob": 0.0004035634046886116}, {"id": 173, "seek": 47700, "start": 501.0, "end": 505.0, "text": " and a bit less flexible for, let's say, the end users", "tokens": [51564, 293, 257, 857, 1570, 11358, 337, 11, 718, 311, 584, 11, 264, 917, 5022, 51764], "temperature": 0.0, "avg_logprob": -0.05754855907324589, "compression_ratio": 1.685121107266436, "no_speech_prob": 0.0004035634046886116}, {"id": 174, "seek": 50500, "start": 505.0, "end": 508.0, "text": " because they essentially come with a microcontroller", "tokens": [50364, 570, 436, 4476, 808, 365, 257, 4532, 9000, 22922, 50514], "temperature": 0.0, "avg_logprob": -0.06438603120691636, "compression_ratio": 1.8271604938271604, "no_speech_prob": 0.0007669492624700069}, {"id": 175, "seek": 50500, "start": 508.0, "end": 511.0, "text": " that will do most of the heavy lifting involved in encoding,", "tokens": [50514, 300, 486, 360, 881, 295, 264, 4676, 15798, 3288, 294, 43430, 11, 50664], "temperature": 0.0, "avg_logprob": -0.06438603120691636, "compression_ratio": 1.8271604938271604, "no_speech_prob": 0.0007669492624700069}, {"id": 176, "seek": 50500, "start": 511.0, "end": 514.0, "text": " especially implementing the rate control strategies.", "tokens": [50664, 2318, 18114, 264, 3314, 1969, 9029, 13, 50814], "temperature": 0.0, "avg_logprob": -0.06438603120691636, "compression_ratio": 1.8271604938271604, "no_speech_prob": 0.0007669492624700069}, {"id": 177, "seek": 50500, "start": 514.0, "end": 517.0, "text": " So they come with a firmware that implements that,", "tokens": [50814, 407, 436, 808, 365, 257, 30289, 300, 704, 17988, 300, 11, 50964], "temperature": 0.0, "avg_logprob": -0.06438603120691636, "compression_ratio": 1.8271604938271604, "no_speech_prob": 0.0007669492624700069}, {"id": 178, "seek": 50500, "start": 517.0, "end": 522.0, "text": " and it really does a lot, especially the rate control.", "tokens": [50964, 293, 309, 534, 775, 257, 688, 11, 2318, 264, 3314, 1969, 13, 51214], "temperature": 0.0, "avg_logprob": -0.06438603120691636, "compression_ratio": 1.8271604938271604, "no_speech_prob": 0.0007669492624700069}, {"id": 179, "seek": 50500, "start": 522.0, "end": 526.0, "text": " And the CPU will usually interact with that encoder", "tokens": [51214, 400, 264, 13199, 486, 2673, 4648, 365, 300, 2058, 19866, 51414], "temperature": 0.0, "avg_logprob": -0.06438603120691636, "compression_ratio": 1.8271604938271604, "no_speech_prob": 0.0007669492624700069}, {"id": 180, "seek": 50500, "start": 526.0, "end": 528.0, "text": " through some mailbox interface,", "tokens": [51414, 807, 512, 43602, 9226, 11, 51514], "temperature": 0.0, "avg_logprob": -0.06438603120691636, "compression_ratio": 1.8271604938271604, "no_speech_prob": 0.0007669492624700069}, {"id": 181, "seek": 50500, "start": 528.0, "end": 530.0, "text": " and it will essentially give it messages", "tokens": [51514, 293, 309, 486, 4476, 976, 309, 7897, 51614], "temperature": 0.0, "avg_logprob": -0.06438603120691636, "compression_ratio": 1.8271604938271604, "no_speech_prob": 0.0007669492624700069}, {"id": 182, "seek": 50500, "start": 530.0, "end": 533.0, "text": " like encode this source with these parameters,", "tokens": [51614, 411, 2058, 1429, 341, 4009, 365, 613, 9834, 11, 51764], "temperature": 0.0, "avg_logprob": -0.06438603120691636, "compression_ratio": 1.8271604938271604, "no_speech_prob": 0.0007669492624700069}, {"id": 183, "seek": 53300, "start": 533.0, "end": 536.0, "text": " but the parameters are still quite high level.", "tokens": [50364, 457, 264, 9834, 366, 920, 1596, 1090, 1496, 13, 50514], "temperature": 0.0, "avg_logprob": -0.07994685909612392, "compression_ratio": 1.7671755725190839, "no_speech_prob": 0.00034021955798380077}, {"id": 184, "seek": 53300, "start": 536.0, "end": 538.0, "text": " On the contrary, we have a second type of implementation,", "tokens": [50514, 1282, 264, 19506, 11, 321, 362, 257, 1150, 2010, 295, 11420, 11, 50614], "temperature": 0.0, "avg_logprob": -0.07994685909612392, "compression_ratio": 1.7671755725190839, "no_speech_prob": 0.00034021955798380077}, {"id": 185, "seek": 53300, "start": 538.0, "end": 540.0, "text": " which we call the stateless encoders,", "tokens": [50614, 597, 321, 818, 264, 2219, 4272, 2058, 378, 433, 11, 50714], "temperature": 0.0, "avg_logprob": -0.07994685909612392, "compression_ratio": 1.7671755725190839, "no_speech_prob": 0.00034021955798380077}, {"id": 186, "seek": 53300, "start": 540.0, "end": 542.0, "text": " which are really more bare metal,", "tokens": [50714, 597, 366, 534, 544, 6949, 5760, 11, 50814], "temperature": 0.0, "avg_logprob": -0.07994685909612392, "compression_ratio": 1.7671755725190839, "no_speech_prob": 0.00034021955798380077}, {"id": 187, "seek": 53300, "start": 542.0, "end": 544.0, "text": " so they are also more flexible,", "tokens": [50814, 370, 436, 366, 611, 544, 11358, 11, 50914], "temperature": 0.0, "avg_logprob": -0.07994685909612392, "compression_ratio": 1.7671755725190839, "no_speech_prob": 0.00034021955798380077}, {"id": 188, "seek": 53300, "start": 544.0, "end": 547.0, "text": " and we have more control over exactly the parameters", "tokens": [50914, 293, 321, 362, 544, 1969, 670, 2293, 264, 9834, 51064], "temperature": 0.0, "avg_logprob": -0.07994685909612392, "compression_ratio": 1.7671755725190839, "no_speech_prob": 0.00034021955798380077}, {"id": 189, "seek": 53300, "start": 547.0, "end": 551.0, "text": " that we give the encoder and all the, let's say, technical decisions", "tokens": [51064, 300, 321, 976, 264, 2058, 19866, 293, 439, 264, 11, 718, 311, 584, 11, 6191, 5327, 51264], "temperature": 0.0, "avg_logprob": -0.07994685909612392, "compression_ratio": 1.7671755725190839, "no_speech_prob": 0.00034021955798380077}, {"id": 190, "seek": 53300, "start": 551.0, "end": 554.0, "text": " that are used to create the final bit stream,", "tokens": [51264, 300, 366, 1143, 281, 1884, 264, 2572, 857, 4309, 11, 51414], "temperature": 0.0, "avg_logprob": -0.07994685909612392, "compression_ratio": 1.7671755725190839, "no_speech_prob": 0.00034021955798380077}, {"id": 191, "seek": 53300, "start": 554.0, "end": 558.0, "text": " the final video codec data.", "tokens": [51414, 264, 2572, 960, 3089, 66, 1412, 13, 51614], "temperature": 0.0, "avg_logprob": -0.07994685909612392, "compression_ratio": 1.7671755725190839, "no_speech_prob": 0.00034021955798380077}, {"id": 192, "seek": 53300, "start": 558.0, "end": 562.0, "text": " So in that situation, the CPUs that is driving the encoder", "tokens": [51614, 407, 294, 300, 2590, 11, 264, 13199, 82, 300, 307, 4840, 264, 2058, 19866, 51814], "temperature": 0.0, "avg_logprob": -0.07994685909612392, "compression_ratio": 1.7671755725190839, "no_speech_prob": 0.00034021955798380077}, {"id": 193, "seek": 56200, "start": 562.0, "end": 564.0, "text": " have to do more.", "tokens": [50364, 362, 281, 360, 544, 13, 50464], "temperature": 0.0, "avg_logprob": -0.1534954539516516, "compression_ratio": 1.6244897959183673, "no_speech_prob": 0.004035259131342173}, {"id": 194, "seek": 56200, "start": 564.0, "end": 567.0, "text": " It has to do essentially all that the firmware was doing", "tokens": [50464, 467, 575, 281, 360, 4476, 439, 300, 264, 30289, 390, 884, 50614], "temperature": 0.0, "avg_logprob": -0.1534954539516516, "compression_ratio": 1.6244897959183673, "no_speech_prob": 0.004035259131342173}, {"id": 195, "seek": 56200, "start": 567.0, "end": 572.0, "text": " in the stateful case, so this is generally more involved.", "tokens": [50614, 294, 264, 1785, 906, 1389, 11, 370, 341, 307, 5101, 544, 3288, 13, 50864], "temperature": 0.0, "avg_logprob": -0.1534954539516516, "compression_ratio": 1.6244897959183673, "no_speech_prob": 0.004035259131342173}, {"id": 196, "seek": 56200, "start": 572.0, "end": 577.0, "text": " And, yeah, it means that you have more things to do on your kernel,", "tokens": [50864, 400, 11, 1338, 11, 309, 1355, 300, 291, 362, 544, 721, 281, 360, 322, 428, 28256, 11, 51114], "temperature": 0.0, "avg_logprob": -0.1534954539516516, "compression_ratio": 1.6244897959183673, "no_speech_prob": 0.004035259131342173}, {"id": 197, "seek": 56200, "start": 577.0, "end": 581.0, "text": " and we have, of course, a bunch of others.", "tokens": [51114, 293, 321, 362, 11, 295, 1164, 11, 257, 3840, 295, 2357, 13, 51314], "temperature": 0.0, "avg_logprob": -0.1534954539516516, "compression_ratio": 1.6244897959183673, "no_speech_prob": 0.004035259131342173}, {"id": 198, "seek": 56200, "start": 581.0, "end": 584.0, "text": " For the stateless designs, we have less known examples,", "tokens": [51314, 1171, 264, 2219, 4272, 11347, 11, 321, 362, 1570, 2570, 5110, 11, 51464], "temperature": 0.0, "avg_logprob": -0.1534954539516516, "compression_ratio": 1.6244897959183673, "no_speech_prob": 0.004035259131342173}, {"id": 199, "seek": 56200, "start": 584.0, "end": 587.0, "text": " but they are also quite popular and found in lots of chips.", "tokens": [51464, 457, 436, 366, 611, 1596, 3743, 293, 1352, 294, 3195, 295, 11583, 13, 51614], "temperature": 0.0, "avg_logprob": -0.1534954539516516, "compression_ratio": 1.6244897959183673, "no_speech_prob": 0.004035259131342173}, {"id": 200, "seek": 56200, "start": 587.0, "end": 590.0, "text": " So we have the Hentro from Vericilicon,", "tokens": [51614, 407, 321, 362, 264, 389, 317, 340, 490, 4281, 299, 388, 11911, 11, 51764], "temperature": 0.0, "avg_logprob": -0.1534954539516516, "compression_ratio": 1.6244897959183673, "no_speech_prob": 0.004035259131342173}, {"id": 201, "seek": 59000, "start": 590.0, "end": 594.0, "text": " which is found, for example, on lots of IMX8s.", "tokens": [50364, 597, 307, 1352, 11, 337, 1365, 11, 322, 3195, 295, 21463, 55, 23, 82, 13, 50564], "temperature": 0.0, "avg_logprob": -0.14356293165979306, "compression_ratio": 1.5263157894736843, "no_speech_prob": 0.0018263000529259443}, {"id": 202, "seek": 59000, "start": 594.0, "end": 596.0, "text": " We also find it on RockChip platforms,", "tokens": [50564, 492, 611, 915, 309, 322, 6922, 34, 1210, 9473, 11, 50664], "temperature": 0.0, "avg_logprob": -0.14356293165979306, "compression_ratio": 1.5263157894736843, "no_speech_prob": 0.0018263000529259443}, {"id": 203, "seek": 59000, "start": 596.0, "end": 599.0, "text": " and some on Alwinner as well.", "tokens": [50664, 293, 512, 322, 967, 9136, 1193, 382, 731, 13, 50814], "temperature": 0.0, "avg_logprob": -0.14356293165979306, "compression_ratio": 1.5263157894736843, "no_speech_prob": 0.0018263000529259443}, {"id": 204, "seek": 59000, "start": 599.0, "end": 602.0, "text": " Alwinner, which is a Chinese chip maker,", "tokens": [50814, 967, 9136, 1193, 11, 597, 307, 257, 4649, 11409, 17127, 11, 50964], "temperature": 0.0, "avg_logprob": -0.14356293165979306, "compression_ratio": 1.5263157894736843, "no_speech_prob": 0.0018263000529259443}, {"id": 205, "seek": 59000, "start": 602.0, "end": 605.0, "text": " has their own video engine implementation,", "tokens": [50964, 575, 641, 1065, 960, 2848, 11420, 11, 51114], "temperature": 0.0, "avg_logprob": -0.14356293165979306, "compression_ratio": 1.5263157894736843, "no_speech_prob": 0.0018263000529259443}, {"id": 206, "seek": 59000, "start": 605.0, "end": 607.0, "text": " which also has an encoder.", "tokens": [51114, 597, 611, 575, 364, 2058, 19866, 13, 51214], "temperature": 0.0, "avg_logprob": -0.14356293165979306, "compression_ratio": 1.5263157894736843, "no_speech_prob": 0.0018263000529259443}, {"id": 207, "seek": 59000, "start": 607.0, "end": 611.0, "text": " So that's pretty much what we know about so far.", "tokens": [51214, 407, 300, 311, 1238, 709, 437, 321, 458, 466, 370, 1400, 13, 51414], "temperature": 0.0, "avg_logprob": -0.14356293165979306, "compression_ratio": 1.5263157894736843, "no_speech_prob": 0.0018263000529259443}, {"id": 208, "seek": 59000, "start": 611.0, "end": 614.0, "text": " Oh, MediaTek, I didn't mention it.", "tokens": [51414, 876, 11, 14741, 51, 916, 11, 286, 994, 380, 2152, 309, 13, 51564], "temperature": 0.0, "avg_logprob": -0.14356293165979306, "compression_ratio": 1.5263157894736843, "no_speech_prob": 0.0018263000529259443}, {"id": 209, "seek": 59000, "start": 614.0, "end": 617.0, "text": " So it's stateful, but it's kind of helpful between the two, right,", "tokens": [51564, 407, 309, 311, 1785, 906, 11, 457, 309, 311, 733, 295, 4961, 1296, 264, 732, 11, 558, 11, 51714], "temperature": 0.0, "avg_logprob": -0.14356293165979306, "compression_ratio": 1.5263157894736843, "no_speech_prob": 0.0018263000529259443}, {"id": 210, "seek": 61700, "start": 617.0, "end": 620.0, "text": " because you can also drive it stateless.", "tokens": [50364, 570, 291, 393, 611, 3332, 309, 2219, 4272, 13, 50514], "temperature": 0.0, "avg_logprob": -0.18859144906017267, "compression_ratio": 1.529126213592233, "no_speech_prob": 0.005368049256503582}, {"id": 211, "seek": 61700, "start": 620.0, "end": 625.0, "text": " Okay, stateful encoder, stateless decoder.", "tokens": [50514, 1033, 11, 1785, 906, 2058, 19866, 11, 2219, 4272, 979, 19866, 13, 50764], "temperature": 0.0, "avg_logprob": -0.18859144906017267, "compression_ratio": 1.529126213592233, "no_speech_prob": 0.005368049256503582}, {"id": 212, "seek": 61700, "start": 625.0, "end": 629.0, "text": " Okay, great.", "tokens": [50764, 1033, 11, 869, 13, 50964], "temperature": 0.0, "avg_logprob": -0.18859144906017267, "compression_ratio": 1.529126213592233, "no_speech_prob": 0.005368049256503582}, {"id": 213, "seek": 61700, "start": 629.0, "end": 630.0, "text": " All right.", "tokens": [50964, 1057, 558, 13, 51014], "temperature": 0.0, "avg_logprob": -0.18859144906017267, "compression_ratio": 1.529126213592233, "no_speech_prob": 0.005368049256503582}, {"id": 214, "seek": 61700, "start": 630.0, "end": 635.0, "text": " Okay, so for the stateful case, in Linux,", "tokens": [51014, 1033, 11, 370, 337, 264, 1785, 906, 1389, 11, 294, 18734, 11, 51264], "temperature": 0.0, "avg_logprob": -0.18859144906017267, "compression_ratio": 1.529126213592233, "no_speech_prob": 0.005368049256503582}, {"id": 215, "seek": 61700, "start": 635.0, "end": 637.0, "text": " we have a great API in V4L2,", "tokens": [51264, 321, 362, 257, 869, 9362, 294, 691, 19, 43, 17, 11, 51364], "temperature": 0.0, "avg_logprob": -0.18859144906017267, "compression_ratio": 1.529126213592233, "no_speech_prob": 0.005368049256503582}, {"id": 216, "seek": 61700, "start": 637.0, "end": 640.0, "text": " which is based on the V4L2 memory-to-memory framework,", "tokens": [51364, 597, 307, 2361, 322, 264, 691, 19, 43, 17, 4675, 12, 1353, 12, 17886, 827, 8388, 11, 51514], "temperature": 0.0, "avg_logprob": -0.18859144906017267, "compression_ratio": 1.529126213592233, "no_speech_prob": 0.005368049256503582}, {"id": 217, "seek": 61700, "start": 640.0, "end": 641.0, "text": " which works with QQs,", "tokens": [51514, 597, 1985, 365, 1249, 48, 82, 11, 51564], "temperature": 0.0, "avg_logprob": -0.18859144906017267, "compression_ratio": 1.529126213592233, "no_speech_prob": 0.005368049256503582}, {"id": 218, "seek": 61700, "start": 641.0, "end": 644.0, "text": " so essentially you're going to submit data from user space,", "tokens": [51564, 370, 4476, 291, 434, 516, 281, 10315, 1412, 490, 4195, 1901, 11, 51714], "temperature": 0.0, "avg_logprob": -0.18859144906017267, "compression_ratio": 1.529126213592233, "no_speech_prob": 0.005368049256503582}, {"id": 219, "seek": 64400, "start": 644.0, "end": 646.0, "text": " which is your source picture,", "tokens": [50364, 597, 307, 428, 4009, 3036, 11, 50464], "temperature": 0.0, "avg_logprob": -0.04374289923700793, "compression_ratio": 1.65625, "no_speech_prob": 0.003116790670901537}, {"id": 220, "seek": 64400, "start": 646.0, "end": 648.0, "text": " and you're going to get some encoded bitstream", "tokens": [50464, 293, 291, 434, 516, 281, 483, 512, 2058, 12340, 857, 9291, 50564], "temperature": 0.0, "avg_logprob": -0.04374289923700793, "compression_ratio": 1.65625, "no_speech_prob": 0.003116790670901537}, {"id": 221, "seek": 64400, "start": 648.0, "end": 650.0, "text": " as a result from this API.", "tokens": [50564, 382, 257, 1874, 490, 341, 9362, 13, 50664], "temperature": 0.0, "avg_logprob": -0.04374289923700793, "compression_ratio": 1.65625, "no_speech_prob": 0.003116790670901537}, {"id": 222, "seek": 64400, "start": 650.0, "end": 654.0, "text": " We have pixel formats to describe the coded streams,", "tokens": [50664, 492, 362, 19261, 25879, 281, 6786, 264, 34874, 15842, 11, 50864], "temperature": 0.0, "avg_logprob": -0.04374289923700793, "compression_ratio": 1.65625, "no_speech_prob": 0.003116790670901537}, {"id": 223, "seek": 64400, "start": 654.0, "end": 657.0, "text": " and we can use some specific controls", "tokens": [50864, 293, 321, 393, 764, 512, 2685, 9003, 51014], "temperature": 0.0, "avg_logprob": -0.04374289923700793, "compression_ratio": 1.65625, "no_speech_prob": 0.003116790670901537}, {"id": 224, "seek": 64400, "start": 657.0, "end": 659.0, "text": " to set features of the encoder.", "tokens": [51014, 281, 992, 4122, 295, 264, 2058, 19866, 13, 51114], "temperature": 0.0, "avg_logprob": -0.04374289923700793, "compression_ratio": 1.65625, "no_speech_prob": 0.003116790670901537}, {"id": 225, "seek": 64400, "start": 659.0, "end": 661.0, "text": " So when there is a technical choice to be made,", "tokens": [51114, 407, 562, 456, 307, 257, 6191, 3922, 281, 312, 1027, 11, 51214], "temperature": 0.0, "avg_logprob": -0.04374289923700793, "compression_ratio": 1.65625, "no_speech_prob": 0.003116790670901537}, {"id": 226, "seek": 64400, "start": 661.0, "end": 665.0, "text": " we can use those controls and tell it exactly,", "tokens": [51214, 321, 393, 764, 729, 9003, 293, 980, 309, 2293, 11, 51414], "temperature": 0.0, "avg_logprob": -0.04374289923700793, "compression_ratio": 1.65625, "no_speech_prob": 0.003116790670901537}, {"id": 227, "seek": 64400, "start": 665.0, "end": 667.0, "text": " well, how we want the video to be encoded.", "tokens": [51414, 731, 11, 577, 321, 528, 264, 960, 281, 312, 2058, 12340, 13, 51514], "temperature": 0.0, "avg_logprob": -0.04374289923700793, "compression_ratio": 1.65625, "no_speech_prob": 0.003116790670901537}, {"id": 228, "seek": 64400, "start": 667.0, "end": 671.0, "text": " But again, the rate control is implemented in the firmware,", "tokens": [51514, 583, 797, 11, 264, 3314, 1969, 307, 12270, 294, 264, 30289, 11, 51714], "temperature": 0.0, "avg_logprob": -0.04374289923700793, "compression_ratio": 1.65625, "no_speech_prob": 0.003116790670901537}, {"id": 229, "seek": 67100, "start": 671.0, "end": 675.0, "text": " so all we can do with that is to tell the firmware,", "tokens": [50364, 370, 439, 321, 393, 360, 365, 300, 307, 281, 980, 264, 30289, 11, 50564], "temperature": 0.0, "avg_logprob": -0.05387051608584343, "compression_ratio": 1.5938864628820961, "no_speech_prob": 0.0011281982297077775}, {"id": 230, "seek": 67100, "start": 675.0, "end": 678.0, "text": " to tell the microcontroller what it should do,", "tokens": [50564, 281, 980, 264, 4532, 9000, 22922, 437, 309, 820, 360, 11, 50714], "temperature": 0.0, "avg_logprob": -0.05387051608584343, "compression_ratio": 1.5938864628820961, "no_speech_prob": 0.0011281982297077775}, {"id": 231, "seek": 67100, "start": 678.0, "end": 681.0, "text": " but it's not going to be the kernel side that does it.", "tokens": [50714, 457, 309, 311, 406, 516, 281, 312, 264, 28256, 1252, 300, 775, 309, 13, 50864], "temperature": 0.0, "avg_logprob": -0.05387051608584343, "compression_ratio": 1.5938864628820961, "no_speech_prob": 0.0011281982297077775}, {"id": 232, "seek": 67100, "start": 681.0, "end": 684.0, "text": " On the other side with the stateless encoding,", "tokens": [50864, 1282, 264, 661, 1252, 365, 264, 2219, 4272, 43430, 11, 51014], "temperature": 0.0, "avg_logprob": -0.05387051608584343, "compression_ratio": 1.5938864628820961, "no_speech_prob": 0.0011281982297077775}, {"id": 233, "seek": 67100, "start": 684.0, "end": 687.0, "text": " like I said, we have a lot more to do from the CPU side,", "tokens": [51014, 411, 286, 848, 11, 321, 362, 257, 688, 544, 281, 360, 490, 264, 13199, 1252, 11, 51164], "temperature": 0.0, "avg_logprob": -0.05387051608584343, "compression_ratio": 1.5938864628820961, "no_speech_prob": 0.0011281982297077775}, {"id": 234, "seek": 67100, "start": 687.0, "end": 691.0, "text": " and this is when it gets a bit complicated with V4L2.", "tokens": [51164, 293, 341, 307, 562, 309, 2170, 257, 857, 6179, 365, 691, 19, 43, 17, 13, 51364], "temperature": 0.0, "avg_logprob": -0.05387051608584343, "compression_ratio": 1.5938864628820961, "no_speech_prob": 0.0011281982297077775}, {"id": 235, "seek": 67100, "start": 691.0, "end": 696.0, "text": " So currently we don't have a stateless encoding UAPI.", "tokens": [51364, 407, 4362, 321, 500, 380, 362, 257, 2219, 4272, 43430, 624, 4715, 40, 13, 51614], "temperature": 0.0, "avg_logprob": -0.05387051608584343, "compression_ratio": 1.5938864628820961, "no_speech_prob": 0.0011281982297077775}, {"id": 236, "seek": 69600, "start": 697.0, "end": 701.0, "text": " There is some difficulty that I'm going to mention", "tokens": [50414, 821, 307, 512, 10360, 300, 286, 478, 516, 281, 2152, 50614], "temperature": 0.0, "avg_logprob": -0.06120044231414795, "compression_ratio": 1.608695652173913, "no_speech_prob": 0.0012982467887923121}, {"id": 237, "seek": 69600, "start": 701.0, "end": 703.0, "text": " in order to do that.", "tokens": [50614, 294, 1668, 281, 360, 300, 13, 50714], "temperature": 0.0, "avg_logprob": -0.06120044231414795, "compression_ratio": 1.608695652173913, "no_speech_prob": 0.0012982467887923121}, {"id": 238, "seek": 69600, "start": 703.0, "end": 707.0, "text": " And one of the points that are difficult", "tokens": [50714, 400, 472, 295, 264, 2793, 300, 366, 2252, 50914], "temperature": 0.0, "avg_logprob": -0.06120044231414795, "compression_ratio": 1.608695652173913, "no_speech_prob": 0.0012982467887923121}, {"id": 239, "seek": 69600, "start": 707.0, "end": 710.0, "text": " is to implement the rate control part,", "tokens": [50914, 307, 281, 4445, 264, 3314, 1969, 644, 11, 51064], "temperature": 0.0, "avg_logprob": -0.06120044231414795, "compression_ratio": 1.608695652173913, "no_speech_prob": 0.0012982467887923121}, {"id": 240, "seek": 69600, "start": 710.0, "end": 714.0, "text": " so to be able to adapt exactly what the video stream looks like", "tokens": [51064, 370, 281, 312, 1075, 281, 6231, 2293, 437, 264, 960, 4309, 1542, 411, 51264], "temperature": 0.0, "avg_logprob": -0.06120044231414795, "compression_ratio": 1.608695652173913, "no_speech_prob": 0.0012982467887923121}, {"id": 241, "seek": 69600, "start": 714.0, "end": 718.0, "text": " depending on the policy that you want to follow.", "tokens": [51264, 5413, 322, 264, 3897, 300, 291, 528, 281, 1524, 13, 51464], "temperature": 0.0, "avg_logprob": -0.06120044231414795, "compression_ratio": 1.608695652173913, "no_speech_prob": 0.0012982467887923121}, {"id": 242, "seek": 69600, "start": 718.0, "end": 721.0, "text": " And of course we want that UAPI to be hardware agnostic,", "tokens": [51464, 400, 295, 1164, 321, 528, 300, 624, 4715, 40, 281, 312, 8837, 623, 77, 19634, 11, 51614], "temperature": 0.0, "avg_logprob": -0.06120044231414795, "compression_ratio": 1.608695652173913, "no_speech_prob": 0.0012982467887923121}, {"id": 243, "seek": 69600, "start": 721.0, "end": 724.0, "text": " so we don't want to just have user space drivers", "tokens": [51614, 370, 321, 500, 380, 528, 281, 445, 362, 4195, 1901, 11590, 51764], "temperature": 0.0, "avg_logprob": -0.06120044231414795, "compression_ratio": 1.608695652173913, "no_speech_prob": 0.0012982467887923121}, {"id": 244, "seek": 72400, "start": 724.0, "end": 726.0, "text": " that will be specific to each encoder.", "tokens": [50364, 300, 486, 312, 2685, 281, 1184, 2058, 19866, 13, 50464], "temperature": 0.0, "avg_logprob": -0.07499900164904895, "compression_ratio": 1.597609561752988, "no_speech_prob": 0.0007414325955323875}, {"id": 245, "seek": 72400, "start": 726.0, "end": 729.0, "text": " Instead we want to have a generic interface,", "tokens": [50464, 7156, 321, 528, 281, 362, 257, 19577, 9226, 11, 50614], "temperature": 0.0, "avg_logprob": -0.07499900164904895, "compression_ratio": 1.597609561752988, "no_speech_prob": 0.0007414325955323875}, {"id": 246, "seek": 72400, "start": 729.0, "end": 732.0, "text": " like it's the case for the stateful encoders,", "tokens": [50614, 411, 309, 311, 264, 1389, 337, 264, 1785, 906, 2058, 378, 433, 11, 50764], "temperature": 0.0, "avg_logprob": -0.07499900164904895, "compression_ratio": 1.597609561752988, "no_speech_prob": 0.0007414325955323875}, {"id": 247, "seek": 72400, "start": 732.0, "end": 735.0, "text": " where we have this generic V4L2 API.", "tokens": [50764, 689, 321, 362, 341, 19577, 691, 19, 43, 17, 9362, 13, 50914], "temperature": 0.0, "avg_logprob": -0.07499900164904895, "compression_ratio": 1.597609561752988, "no_speech_prob": 0.0007414325955323875}, {"id": 248, "seek": 72400, "start": 737.0, "end": 741.0, "text": " But stateless encoding also has significant advantages.", "tokens": [51014, 583, 2219, 4272, 43430, 611, 575, 4776, 14906, 13, 51214], "temperature": 0.0, "avg_logprob": -0.07499900164904895, "compression_ratio": 1.597609561752988, "no_speech_prob": 0.0007414325955323875}, {"id": 249, "seek": 72400, "start": 741.0, "end": 743.0, "text": " It's a lot more flexible,", "tokens": [51214, 467, 311, 257, 688, 544, 11358, 11, 51314], "temperature": 0.0, "avg_logprob": -0.07499900164904895, "compression_ratio": 1.597609561752988, "no_speech_prob": 0.0007414325955323875}, {"id": 250, "seek": 72400, "start": 743.0, "end": 746.0, "text": " and that means that we have more control over what's going on.", "tokens": [51314, 293, 300, 1355, 300, 321, 362, 544, 1969, 670, 437, 311, 516, 322, 13, 51464], "temperature": 0.0, "avg_logprob": -0.07499900164904895, "compression_ratio": 1.597609561752988, "no_speech_prob": 0.0007414325955323875}, {"id": 251, "seek": 72400, "start": 746.0, "end": 749.0, "text": " So in theory we are able to take better decisions", "tokens": [51464, 407, 294, 5261, 321, 366, 1075, 281, 747, 1101, 5327, 51614], "temperature": 0.0, "avg_logprob": -0.07499900164904895, "compression_ratio": 1.597609561752988, "no_speech_prob": 0.0007414325955323875}, {"id": 252, "seek": 72400, "start": 749.0, "end": 753.0, "text": " to produce the best stream that we can,", "tokens": [51614, 281, 5258, 264, 1151, 4309, 300, 321, 393, 11, 51814], "temperature": 0.0, "avg_logprob": -0.07499900164904895, "compression_ratio": 1.597609561752988, "no_speech_prob": 0.0007414325955323875}, {"id": 253, "seek": 75300, "start": 753.0, "end": 755.0, "text": " and that is not necessarily the case", "tokens": [50364, 293, 300, 307, 406, 4725, 264, 1389, 50464], "temperature": 0.0, "avg_logprob": -0.09309284687042237, "compression_ratio": 1.7173913043478262, "no_speech_prob": 0.0011633863905444741}, {"id": 254, "seek": 75300, "start": 755.0, "end": 758.0, "text": " with a stateful, firmware-driven approach.", "tokens": [50464, 365, 257, 1785, 906, 11, 30289, 12, 25456, 3109, 13, 50614], "temperature": 0.0, "avg_logprob": -0.09309284687042237, "compression_ratio": 1.7173913043478262, "no_speech_prob": 0.0011633863905444741}, {"id": 255, "seek": 75300, "start": 758.0, "end": 761.0, "text": " So user space might actually have a bunch of information,", "tokens": [50614, 407, 4195, 1901, 1062, 767, 362, 257, 3840, 295, 1589, 11, 50764], "temperature": 0.0, "avg_logprob": -0.09309284687042237, "compression_ratio": 1.7173913043478262, "no_speech_prob": 0.0011633863905444741}, {"id": 256, "seek": 75300, "start": 761.0, "end": 764.0, "text": " like knowing that the scene is changing, for example,", "tokens": [50764, 411, 5276, 300, 264, 4145, 307, 4473, 11, 337, 1365, 11, 50914], "temperature": 0.0, "avg_logprob": -0.09309284687042237, "compression_ratio": 1.7173913043478262, "no_speech_prob": 0.0011633863905444741}, {"id": 257, "seek": 75300, "start": 764.0, "end": 767.0, "text": " things like that, that can really help the encoders.", "tokens": [50914, 721, 411, 300, 11, 300, 393, 534, 854, 264, 2058, 378, 433, 13, 51064], "temperature": 0.0, "avg_logprob": -0.09309284687042237, "compression_ratio": 1.7173913043478262, "no_speech_prob": 0.0011633863905444741}, {"id": 258, "seek": 75300, "start": 767.0, "end": 770.0, "text": " So it actually makes sense for user space", "tokens": [51064, 407, 309, 767, 1669, 2020, 337, 4195, 1901, 51214], "temperature": 0.0, "avg_logprob": -0.09309284687042237, "compression_ratio": 1.7173913043478262, "no_speech_prob": 0.0011633863905444741}, {"id": 259, "seek": 75300, "start": 770.0, "end": 773.0, "text": " to want to do its own rate control,", "tokens": [51214, 281, 528, 281, 360, 1080, 1065, 3314, 1969, 11, 51364], "temperature": 0.0, "avg_logprob": -0.09309284687042237, "compression_ratio": 1.7173913043478262, "no_speech_prob": 0.0011633863905444741}, {"id": 260, "seek": 75300, "start": 773.0, "end": 775.0, "text": " because it can have more information,", "tokens": [51364, 570, 309, 393, 362, 544, 1589, 11, 51464], "temperature": 0.0, "avg_logprob": -0.09309284687042237, "compression_ratio": 1.7173913043478262, "no_speech_prob": 0.0011633863905444741}, {"id": 261, "seek": 75300, "start": 775.0, "end": 778.0, "text": " it can also implement, let's say, advanced strategies.", "tokens": [51464, 309, 393, 611, 4445, 11, 718, 311, 584, 11, 7339, 9029, 13, 51614], "temperature": 0.0, "avg_logprob": -0.09309284687042237, "compression_ratio": 1.7173913043478262, "no_speech_prob": 0.0011633863905444741}, {"id": 262, "seek": 75300, "start": 778.0, "end": 782.0, "text": " For example, nowadays there is talk about machine learning", "tokens": [51614, 1171, 1365, 11, 13434, 456, 307, 751, 466, 3479, 2539, 51814], "temperature": 0.0, "avg_logprob": -0.09309284687042237, "compression_ratio": 1.7173913043478262, "no_speech_prob": 0.0011633863905444741}, {"id": 263, "seek": 78200, "start": 782.0, "end": 784.0, "text": " and how to help encoders achieve better results.", "tokens": [50364, 293, 577, 281, 854, 2058, 378, 433, 4584, 1101, 3542, 13, 50464], "temperature": 0.0, "avg_logprob": -0.08438316258517178, "compression_ratio": 1.725085910652921, "no_speech_prob": 0.002094225026667118}, {"id": 264, "seek": 78200, "start": 784.0, "end": 787.0, "text": " So things like that would make sense in user space.", "tokens": [50464, 407, 721, 411, 300, 576, 652, 2020, 294, 4195, 1901, 13, 50614], "temperature": 0.0, "avg_logprob": -0.08438316258517178, "compression_ratio": 1.725085910652921, "no_speech_prob": 0.002094225026667118}, {"id": 265, "seek": 78200, "start": 787.0, "end": 790.0, "text": " But we also want to support simple cases", "tokens": [50614, 583, 321, 611, 528, 281, 1406, 2199, 3331, 50764], "temperature": 0.0, "avg_logprob": -0.08438316258517178, "compression_ratio": 1.725085910652921, "no_speech_prob": 0.002094225026667118}, {"id": 266, "seek": 78200, "start": 790.0, "end": 793.0, "text": " where we don't want user space to have a huge stack", "tokens": [50764, 689, 321, 500, 380, 528, 4195, 1901, 281, 362, 257, 2603, 8630, 50914], "temperature": 0.0, "avg_logprob": -0.08438316258517178, "compression_ratio": 1.725085910652921, "no_speech_prob": 0.002094225026667118}, {"id": 267, "seek": 78200, "start": 793.0, "end": 796.0, "text": " that is very complex, but it would really be nice", "tokens": [50914, 300, 307, 588, 3997, 11, 457, 309, 576, 534, 312, 1481, 51064], "temperature": 0.0, "avg_logprob": -0.08438316258517178, "compression_ratio": 1.725085910652921, "no_speech_prob": 0.002094225026667118}, {"id": 268, "seek": 78200, "start": 796.0, "end": 798.0, "text": " to have a simple case that can be covered", "tokens": [51064, 281, 362, 257, 2199, 1389, 300, 393, 312, 5343, 51164], "temperature": 0.0, "avg_logprob": -0.08438316258517178, "compression_ratio": 1.725085910652921, "no_speech_prob": 0.002094225026667118}, {"id": 269, "seek": 78200, "start": 798.0, "end": 801.0, "text": " without so much logic in user space.", "tokens": [51164, 1553, 370, 709, 9952, 294, 4195, 1901, 13, 51314], "temperature": 0.0, "avg_logprob": -0.08438316258517178, "compression_ratio": 1.725085910652921, "no_speech_prob": 0.002094225026667118}, {"id": 270, "seek": 78200, "start": 801.0, "end": 804.0, "text": " So you can kind of see that there is a little bit of contradiction", "tokens": [51314, 407, 291, 393, 733, 295, 536, 300, 456, 307, 257, 707, 857, 295, 34937, 51464], "temperature": 0.0, "avg_logprob": -0.08438316258517178, "compression_ratio": 1.725085910652921, "no_speech_prob": 0.002094225026667118}, {"id": 271, "seek": 78200, "start": 804.0, "end": 807.0, "text": " between these two things, and this is one of the main,", "tokens": [51464, 1296, 613, 732, 721, 11, 293, 341, 307, 472, 295, 264, 2135, 11, 51614], "temperature": 0.0, "avg_logprob": -0.08438316258517178, "compression_ratio": 1.725085910652921, "no_speech_prob": 0.002094225026667118}, {"id": 272, "seek": 78200, "start": 807.0, "end": 811.0, "text": " let's say, topics that make creating this UAPI difficult.", "tokens": [51614, 718, 311, 584, 11, 8378, 300, 652, 4084, 341, 624, 4715, 40, 2252, 13, 51814], "temperature": 0.0, "avg_logprob": -0.08438316258517178, "compression_ratio": 1.725085910652921, "no_speech_prob": 0.002094225026667118}, {"id": 273, "seek": 81200, "start": 812.0, "end": 814.0, "text": " So let's take a look at some existing work", "tokens": [50364, 407, 718, 311, 747, 257, 574, 412, 512, 6741, 589, 50464], "temperature": 0.0, "avg_logprob": -0.12615214712251493, "compression_ratio": 1.5875486381322956, "no_speech_prob": 0.00020319435861892998}, {"id": 274, "seek": 81200, "start": 814.0, "end": 818.0, "text": " that was already carried out for these state-based encoders.", "tokens": [50464, 300, 390, 1217, 9094, 484, 337, 613, 1785, 12, 6032, 2058, 378, 433, 13, 50664], "temperature": 0.0, "avg_logprob": -0.12615214712251493, "compression_ratio": 1.5875486381322956, "no_speech_prob": 0.00020319435861892998}, {"id": 275, "seek": 81200, "start": 818.0, "end": 822.0, "text": " For the Hentro H1, which is probably the most popular one", "tokens": [50664, 1171, 264, 389, 317, 340, 389, 16, 11, 597, 307, 1391, 264, 881, 3743, 472, 50864], "temperature": 0.0, "avg_logprob": -0.12615214712251493, "compression_ratio": 1.5875486381322956, "no_speech_prob": 0.00020319435861892998}, {"id": 276, "seek": 81200, "start": 822.0, "end": 826.0, "text": " in this category, we have some work that was done by RockTip,", "tokens": [50864, 294, 341, 7719, 11, 321, 362, 512, 589, 300, 390, 1096, 538, 6922, 51, 647, 11, 51064], "temperature": 0.0, "avg_logprob": -0.12615214712251493, "compression_ratio": 1.5875486381322956, "no_speech_prob": 0.00020319435861892998}, {"id": 277, "seek": 81200, "start": 826.0, "end": 831.0, "text": " which is free software, in a stack called MPP.", "tokens": [51064, 597, 307, 1737, 4722, 11, 294, 257, 8630, 1219, 14146, 47, 13, 51314], "temperature": 0.0, "avg_logprob": -0.12615214712251493, "compression_ratio": 1.5875486381322956, "no_speech_prob": 0.00020319435861892998}, {"id": 278, "seek": 81200, "start": 831.0, "end": 833.0, "text": " So you can find the source code here,", "tokens": [51314, 407, 291, 393, 915, 264, 4009, 3089, 510, 11, 51414], "temperature": 0.0, "avg_logprob": -0.12615214712251493, "compression_ratio": 1.5875486381322956, "no_speech_prob": 0.00020319435861892998}, {"id": 279, "seek": 81200, "start": 833.0, "end": 837.0, "text": " and that's the part where it implements encoding for the H1.", "tokens": [51414, 293, 300, 311, 264, 644, 689, 309, 704, 17988, 43430, 337, 264, 389, 16, 13, 51614], "temperature": 0.0, "avg_logprob": -0.12615214712251493, "compression_ratio": 1.5875486381322956, "no_speech_prob": 0.00020319435861892998}, {"id": 280, "seek": 81200, "start": 837.0, "end": 839.0, "text": " So that's great, but this is not V4L2.", "tokens": [51614, 407, 300, 311, 869, 11, 457, 341, 307, 406, 691, 19, 43, 17, 13, 51714], "temperature": 0.0, "avg_logprob": -0.12615214712251493, "compression_ratio": 1.5875486381322956, "no_speech_prob": 0.00020319435861892998}, {"id": 281, "seek": 83900, "start": 839.0, "end": 843.0, "text": " It's a fully user space-based approach.", "tokens": [50364, 467, 311, 257, 4498, 4195, 1901, 12, 6032, 3109, 13, 50564], "temperature": 0.0, "avg_logprob": -0.08042313567305033, "compression_ratio": 1.510548523206751, "no_speech_prob": 0.0020770591218024492}, {"id": 282, "seek": 83900, "start": 843.0, "end": 847.0, "text": " So we have Google that did a custom V4L2 driver in Chromium OS.", "tokens": [50564, 407, 321, 362, 3329, 300, 630, 257, 2375, 691, 19, 43, 17, 6787, 294, 1721, 298, 2197, 12731, 13, 50764], "temperature": 0.0, "avg_logprob": -0.08042313567305033, "compression_ratio": 1.510548523206751, "no_speech_prob": 0.0020770591218024492}, {"id": 283, "seek": 83900, "start": 847.0, "end": 851.0, "text": " So this is for the Chromebooks that they ship with RockTip SOCs", "tokens": [50764, 407, 341, 307, 337, 264, 15327, 15170, 300, 436, 5374, 365, 6922, 51, 647, 10621, 33290, 50964], "temperature": 0.0, "avg_logprob": -0.08042313567305033, "compression_ratio": 1.510548523206751, "no_speech_prob": 0.0020770591218024492}, {"id": 284, "seek": 83900, "start": 851.0, "end": 853.0, "text": " that have the H1.", "tokens": [50964, 300, 362, 264, 389, 16, 13, 51064], "temperature": 0.0, "avg_logprob": -0.08042313567305033, "compression_ratio": 1.510548523206751, "no_speech_prob": 0.0020770591218024492}, {"id": 285, "seek": 83900, "start": 853.0, "end": 856.0, "text": " So this time it's a V4L2 driver,", "tokens": [51064, 407, 341, 565, 309, 311, 257, 691, 19, 43, 17, 6787, 11, 51214], "temperature": 0.0, "avg_logprob": -0.08042313567305033, "compression_ratio": 1.510548523206751, "no_speech_prob": 0.0020770591218024492}, {"id": 286, "seek": 83900, "start": 856.0, "end": 859.0, "text": " but it really is hardware-specific,", "tokens": [51214, 457, 309, 534, 307, 8837, 12, 29258, 11, 51364], "temperature": 0.0, "avg_logprob": -0.08042313567305033, "compression_ratio": 1.510548523206751, "no_speech_prob": 0.0020770591218024492}, {"id": 287, "seek": 83900, "start": 859.0, "end": 864.0, "text": " so you have a very specific API to drive that encoder.", "tokens": [51364, 370, 291, 362, 257, 588, 2685, 9362, 281, 3332, 300, 2058, 19866, 13, 51614], "temperature": 0.0, "avg_logprob": -0.08042313567305033, "compression_ratio": 1.510548523206751, "no_speech_prob": 0.0020770591218024492}, {"id": 288, "seek": 83900, "start": 864.0, "end": 867.0, "text": " Now, from this base, which has all the knowledge", "tokens": [51614, 823, 11, 490, 341, 3096, 11, 597, 575, 439, 264, 3601, 51764], "temperature": 0.0, "avg_logprob": -0.08042313567305033, "compression_ratio": 1.510548523206751, "no_speech_prob": 0.0020770591218024492}, {"id": 289, "seek": 86700, "start": 867.0, "end": 869.0, "text": " of how to drive the encoder,", "tokens": [50364, 295, 577, 281, 3332, 264, 2058, 19866, 11, 50464], "temperature": 0.0, "avg_logprob": -0.05496858346341836, "compression_ratio": 1.550660792951542, "no_speech_prob": 0.0012814353685826063}, {"id": 290, "seek": 86700, "start": 869.0, "end": 875.0, "text": " I was able to write a mainline-based implementation", "tokens": [50464, 286, 390, 1075, 281, 2464, 257, 2135, 1889, 12, 6032, 11420, 50764], "temperature": 0.0, "avg_logprob": -0.05496858346341836, "compression_ratio": 1.550660792951542, "no_speech_prob": 0.0012814353685826063}, {"id": 291, "seek": 86700, "start": 875.0, "end": 880.0, "text": " on V4L2 when I was working at Budlin,", "tokens": [50764, 322, 691, 19, 43, 17, 562, 286, 390, 1364, 412, 6384, 5045, 11, 51014], "temperature": 0.0, "avg_logprob": -0.05496858346341836, "compression_ratio": 1.550660792951542, "no_speech_prob": 0.0012814353685826063}, {"id": 292, "seek": 86700, "start": 880.0, "end": 884.0, "text": " and this one is still hardware-specific.", "tokens": [51014, 293, 341, 472, 307, 920, 8837, 12, 29258, 13, 51214], "temperature": 0.0, "avg_logprob": -0.05496858346341836, "compression_ratio": 1.550660792951542, "no_speech_prob": 0.0012814353685826063}, {"id": 293, "seek": 86700, "start": 884.0, "end": 887.0, "text": " So we have some custom register configuration", "tokens": [51214, 407, 321, 362, 512, 2375, 7280, 11694, 51364], "temperature": 0.0, "avg_logprob": -0.05496858346341836, "compression_ratio": 1.550660792951542, "no_speech_prob": 0.0012814353685826063}, {"id": 294, "seek": 86700, "start": 887.0, "end": 889.0, "text": " that is pushed to the driver,", "tokens": [51364, 300, 307, 9152, 281, 264, 6787, 11, 51464], "temperature": 0.0, "avg_logprob": -0.05496858346341836, "compression_ratio": 1.550660792951542, "no_speech_prob": 0.0012814353685826063}, {"id": 295, "seek": 86700, "start": 889.0, "end": 892.0, "text": " and we get some custom feedback as a result", "tokens": [51464, 293, 321, 483, 512, 2375, 5824, 382, 257, 1874, 51614], "temperature": 0.0, "avg_logprob": -0.05496858346341836, "compression_ratio": 1.550660792951542, "no_speech_prob": 0.0012814353685826063}, {"id": 296, "seek": 86700, "start": 892.0, "end": 894.0, "text": " that the user space side can use", "tokens": [51614, 300, 264, 4195, 1901, 1252, 393, 764, 51714], "temperature": 0.0, "avg_logprob": -0.05496858346341836, "compression_ratio": 1.550660792951542, "no_speech_prob": 0.0012814353685826063}, {"id": 297, "seek": 86700, "start": 894.0, "end": 896.0, "text": " in order to implement the rate control.", "tokens": [51714, 294, 1668, 281, 4445, 264, 3314, 1969, 13, 51814], "temperature": 0.0, "avg_logprob": -0.05496858346341836, "compression_ratio": 1.550660792951542, "no_speech_prob": 0.0012814353685826063}, {"id": 298, "seek": 89600, "start": 896.0, "end": 900.0, "text": " So in this case, the rate control is done in user space entirely.", "tokens": [50364, 407, 294, 341, 1389, 11, 264, 3314, 1969, 307, 1096, 294, 4195, 1901, 7696, 13, 50564], "temperature": 0.0, "avg_logprob": -0.15094439188639322, "compression_ratio": 1.64, "no_speech_prob": 0.0006850513746030629}, {"id": 299, "seek": 89600, "start": 900.0, "end": 903.0, "text": " Ooh, it's not working anymore.", "tokens": [50564, 7951, 11, 309, 311, 406, 1364, 3602, 13, 50714], "temperature": 0.0, "avg_logprob": -0.15094439188639322, "compression_ratio": 1.64, "no_speech_prob": 0.0006850513746030629}, {"id": 300, "seek": 89600, "start": 903.0, "end": 906.0, "text": " Okay, and now we have also VPH encoding from Collabora,", "tokens": [50714, 1033, 11, 293, 586, 321, 362, 611, 691, 21904, 43430, 490, 4586, 455, 3252, 11, 50864], "temperature": 0.0, "avg_logprob": -0.15094439188639322, "compression_ratio": 1.64, "no_speech_prob": 0.0006850513746030629}, {"id": 301, "seek": 89600, "start": 906.0, "end": 911.0, "text": " which also does the rate control in user space.", "tokens": [50864, 597, 611, 775, 264, 3314, 1969, 294, 4195, 1901, 13, 51114], "temperature": 0.0, "avg_logprob": -0.15094439188639322, "compression_ratio": 1.64, "no_speech_prob": 0.0006850513746030629}, {"id": 302, "seek": 89600, "start": 911.0, "end": 915.0, "text": " So you can find the links to the RFC series there", "tokens": [51114, 407, 291, 393, 915, 264, 6123, 281, 264, 497, 18671, 2638, 456, 51314], "temperature": 0.0, "avg_logprob": -0.15094439188639322, "compression_ratio": 1.64, "no_speech_prob": 0.0006850513746030629}, {"id": 303, "seek": 89600, "start": 915.0, "end": 918.0, "text": " and the user space implementation in Gstreamer as well", "tokens": [51314, 293, 264, 4195, 1901, 11420, 294, 460, 9291, 260, 382, 731, 51464], "temperature": 0.0, "avg_logprob": -0.15094439188639322, "compression_ratio": 1.64, "no_speech_prob": 0.0006850513746030629}, {"id": 304, "seek": 89600, "start": 918.0, "end": 921.0, "text": " to demonstrate how it works.", "tokens": [51464, 281, 11698, 577, 309, 1985, 13, 51614], "temperature": 0.0, "avg_logprob": -0.15094439188639322, "compression_ratio": 1.64, "no_speech_prob": 0.0006850513746030629}, {"id": 305, "seek": 89600, "start": 921.0, "end": 923.0, "text": " So while working on this hardware,", "tokens": [51614, 407, 1339, 1364, 322, 341, 8837, 11, 51714], "temperature": 0.0, "avg_logprob": -0.15094439188639322, "compression_ratio": 1.64, "no_speech_prob": 0.0006850513746030629}, {"id": 306, "seek": 92300, "start": 923.0, "end": 926.0, "text": " there is a few things that we learned.", "tokens": [50364, 456, 307, 257, 1326, 721, 300, 321, 3264, 13, 50514], "temperature": 0.0, "avg_logprob": -0.062456883421731654, "compression_ratio": 1.7598425196850394, "no_speech_prob": 0.0008682548650540411}, {"id": 307, "seek": 92300, "start": 926.0, "end": 930.0, "text": " For example, the fact that some metadata fields of the bitstream", "tokens": [50514, 1171, 1365, 11, 264, 1186, 300, 512, 26603, 7909, 295, 264, 857, 9291, 50714], "temperature": 0.0, "avg_logprob": -0.062456883421731654, "compression_ratio": 1.7598425196850394, "no_speech_prob": 0.0008682548650540411}, {"id": 308, "seek": 92300, "start": 930.0, "end": 934.0, "text": " are actually constrained by the hardware itself.", "tokens": [50714, 366, 767, 38901, 538, 264, 8837, 2564, 13, 50914], "temperature": 0.0, "avg_logprob": -0.062456883421731654, "compression_ratio": 1.7598425196850394, "no_speech_prob": 0.0008682548650540411}, {"id": 309, "seek": 92300, "start": 934.0, "end": 939.0, "text": " So it means that there are some fields in the codec", "tokens": [50914, 407, 309, 1355, 300, 456, 366, 512, 7909, 294, 264, 3089, 66, 51164], "temperature": 0.0, "avg_logprob": -0.062456883421731654, "compression_ratio": 1.7598425196850394, "no_speech_prob": 0.0008682548650540411}, {"id": 310, "seek": 92300, "start": 939.0, "end": 942.0, "text": " where the specification allows you to choose between different values,", "tokens": [51164, 689, 264, 31256, 4045, 291, 281, 2826, 1296, 819, 4190, 11, 51314], "temperature": 0.0, "avg_logprob": -0.062456883421731654, "compression_ratio": 1.7598425196850394, "no_speech_prob": 0.0008682548650540411}, {"id": 311, "seek": 92300, "start": 942.0, "end": 945.0, "text": " but the encoder actually only works with one of them.", "tokens": [51314, 457, 264, 2058, 19866, 767, 787, 1985, 365, 472, 295, 552, 13, 51464], "temperature": 0.0, "avg_logprob": -0.062456883421731654, "compression_ratio": 1.7598425196850394, "no_speech_prob": 0.0008682548650540411}, {"id": 312, "seek": 92300, "start": 945.0, "end": 949.0, "text": " So it means that if you are going to generate those fields,", "tokens": [51464, 407, 309, 1355, 300, 498, 291, 366, 516, 281, 8460, 729, 7909, 11, 51664], "temperature": 0.0, "avg_logprob": -0.062456883421731654, "compression_ratio": 1.7598425196850394, "no_speech_prob": 0.0008682548650540411}, {"id": 313, "seek": 92300, "start": 949.0, "end": 952.0, "text": " you need to be aware of which hardware you're running on.", "tokens": [51664, 291, 643, 281, 312, 3650, 295, 597, 8837, 291, 434, 2614, 322, 13, 51814], "temperature": 0.0, "avg_logprob": -0.062456883421731654, "compression_ratio": 1.7598425196850394, "no_speech_prob": 0.0008682548650540411}, {"id": 314, "seek": 95200, "start": 952.0, "end": 956.0, "text": " So the lesson learned from that was that the bitstream generation", "tokens": [50364, 407, 264, 6898, 3264, 490, 300, 390, 300, 264, 857, 9291, 5125, 50564], "temperature": 0.0, "avg_logprob": -0.06464759122978136, "compression_ratio": 1.7125984251968505, "no_speech_prob": 0.0010137652279809117}, {"id": 315, "seek": 95200, "start": 956.0, "end": 958.0, "text": " should really be on the kernel side", "tokens": [50564, 820, 534, 312, 322, 264, 28256, 1252, 50664], "temperature": 0.0, "avg_logprob": -0.06464759122978136, "compression_ratio": 1.7125984251968505, "no_speech_prob": 0.0010137652279809117}, {"id": 316, "seek": 95200, "start": 958.0, "end": 962.0, "text": " because this is how you can really know exactly which choices are valid", "tokens": [50664, 570, 341, 307, 577, 291, 393, 534, 458, 2293, 597, 7994, 366, 7363, 50864], "temperature": 0.0, "avg_logprob": -0.06464759122978136, "compression_ratio": 1.7125984251968505, "no_speech_prob": 0.0010137652279809117}, {"id": 317, "seek": 95200, "start": 962.0, "end": 965.0, "text": " or not for this particular hardware.", "tokens": [50864, 420, 406, 337, 341, 1729, 8837, 13, 51014], "temperature": 0.0, "avg_logprob": -0.06464759122978136, "compression_ratio": 1.7125984251968505, "no_speech_prob": 0.0010137652279809117}, {"id": 318, "seek": 95200, "start": 965.0, "end": 968.0, "text": " Sometimes the hardware also has rate control helpers.", "tokens": [51014, 4803, 264, 8837, 611, 575, 3314, 1969, 854, 433, 13, 51164], "temperature": 0.0, "avg_logprob": -0.06464759122978136, "compression_ratio": 1.7125984251968505, "no_speech_prob": 0.0010137652279809117}, {"id": 319, "seek": 95200, "start": 968.0, "end": 970.0, "text": " So this is some hardware features", "tokens": [51164, 407, 341, 307, 512, 8837, 4122, 51264], "temperature": 0.0, "avg_logprob": -0.06464759122978136, "compression_ratio": 1.7125984251968505, "no_speech_prob": 0.0010137652279809117}, {"id": 320, "seek": 95200, "start": 970.0, "end": 973.0, "text": " that can help you implement better rate control.", "tokens": [51264, 300, 393, 854, 291, 4445, 1101, 3314, 1969, 13, 51414], "temperature": 0.0, "avg_logprob": -0.06464759122978136, "compression_ratio": 1.7125984251968505, "no_speech_prob": 0.0010137652279809117}, {"id": 321, "seek": 95200, "start": 973.0, "end": 977.0, "text": " It's not necessarily always a good idea", "tokens": [51414, 467, 311, 406, 4725, 1009, 257, 665, 1558, 51614], "temperature": 0.0, "avg_logprob": -0.06464759122978136, "compression_ratio": 1.7125984251968505, "no_speech_prob": 0.0010137652279809117}, {"id": 322, "seek": 95200, "start": 977.0, "end": 979.0, "text": " or always required to use them, but they exist.", "tokens": [51614, 420, 1009, 4739, 281, 764, 552, 11, 457, 436, 2514, 13, 51714], "temperature": 0.0, "avg_logprob": -0.06464759122978136, "compression_ratio": 1.7125984251968505, "no_speech_prob": 0.0010137652279809117}, {"id": 323, "seek": 97900, "start": 979.0, "end": 982.0, "text": " And in that case, this kind of suggests that the rate control", "tokens": [50364, 400, 294, 300, 1389, 11, 341, 733, 295, 13409, 300, 264, 3314, 1969, 50514], "temperature": 0.0, "avg_logprob": -0.14491536324484305, "compression_ratio": 1.5751879699248121, "no_speech_prob": 0.001592199201695621}, {"id": 324, "seek": 97900, "start": 982.0, "end": 984.0, "text": " would make sense to be done in user space,", "tokens": [50514, 576, 652, 2020, 281, 312, 1096, 294, 4195, 1901, 11, 50614], "temperature": 0.0, "avg_logprob": -0.14491536324484305, "compression_ratio": 1.5751879699248121, "no_speech_prob": 0.001592199201695621}, {"id": 325, "seek": 97900, "start": 984.0, "end": 986.0, "text": " sorry, in the kernel side,", "tokens": [50614, 2597, 11, 294, 264, 28256, 1252, 11, 50714], "temperature": 0.0, "avg_logprob": -0.14491536324484305, "compression_ratio": 1.5751879699248121, "no_speech_prob": 0.001592199201695621}, {"id": 326, "seek": 97900, "start": 986.0, "end": 991.0, "text": " because again, we don't want user space to be specific to a particular hardware.", "tokens": [50714, 570, 797, 11, 321, 500, 380, 528, 4195, 1901, 281, 312, 2685, 281, 257, 1729, 8837, 13, 50964], "temperature": 0.0, "avg_logprob": -0.14491536324484305, "compression_ratio": 1.5751879699248121, "no_speech_prob": 0.001592199201695621}, {"id": 327, "seek": 97900, "start": 991.0, "end": 995.0, "text": " We want it to be generic and agnostic.", "tokens": [50964, 492, 528, 309, 281, 312, 19577, 293, 623, 77, 19634, 13, 51164], "temperature": 0.0, "avg_logprob": -0.14491536324484305, "compression_ratio": 1.5751879699248121, "no_speech_prob": 0.001592199201695621}, {"id": 328, "seek": 97900, "start": 995.0, "end": 1000.0, "text": " Now for a second example, which is something I've worked on very recently,", "tokens": [51164, 823, 337, 257, 1150, 1365, 11, 597, 307, 746, 286, 600, 2732, 322, 588, 3938, 11, 51414], "temperature": 0.0, "avg_logprob": -0.14491536324484305, "compression_ratio": 1.5751879699248121, "no_speech_prob": 0.001592199201695621}, {"id": 329, "seek": 97900, "start": 1000.0, "end": 1002.0, "text": " again, at Budlin.", "tokens": [51414, 797, 11, 412, 6384, 5045, 13, 51514], "temperature": 0.0, "avg_logprob": -0.14491536324484305, "compression_ratio": 1.5751879699248121, "no_speech_prob": 0.001592199201695621}, {"id": 330, "seek": 97900, "start": 1002.0, "end": 1006.0, "text": " So this is based on some existing work from the Linux Sanctuary community,", "tokens": [51514, 407, 341, 307, 2361, 322, 512, 6741, 589, 490, 264, 18734, 5271, 349, 6164, 1768, 11, 51714], "temperature": 0.0, "avg_logprob": -0.14491536324484305, "compression_ratio": 1.5751879699248121, "no_speech_prob": 0.001592199201695621}, {"id": 331, "seek": 100600, "start": 1006.0, "end": 1011.0, "text": " which did a lot of research and implemented some user space implementation", "tokens": [50364, 597, 630, 257, 688, 295, 2132, 293, 12270, 512, 4195, 1901, 11420, 50614], "temperature": 0.0, "avg_logprob": -0.16349282375601834, "compression_ratio": 1.5071090047393365, "no_speech_prob": 0.004644240718334913}, {"id": 332, "seek": 100600, "start": 1011.0, "end": 1014.0, "text": " for the all-winner video engine encoder.", "tokens": [50614, 337, 264, 439, 12, 9136, 1193, 960, 2848, 2058, 19866, 13, 50764], "temperature": 0.0, "avg_logprob": -0.16349282375601834, "compression_ratio": 1.5071090047393365, "no_speech_prob": 0.004644240718334913}, {"id": 333, "seek": 100600, "start": 1014.0, "end": 1018.0, "text": " And I did some follow-up work on some more recent platforms", "tokens": [50764, 400, 286, 630, 512, 1524, 12, 1010, 589, 322, 512, 544, 5162, 9473, 50964], "temperature": 0.0, "avg_logprob": -0.16349282375601834, "compression_ratio": 1.5071090047393365, "no_speech_prob": 0.004644240718334913}, {"id": 334, "seek": 100600, "start": 1018.0, "end": 1021.0, "text": " that also implement H264 encoding,", "tokens": [50964, 300, 611, 4445, 389, 10880, 19, 43430, 11, 51114], "temperature": 0.0, "avg_logprob": -0.16349282375601834, "compression_ratio": 1.5071090047393365, "no_speech_prob": 0.004644240718334913}, {"id": 335, "seek": 100600, "start": 1021.0, "end": 1025.0, "text": " this time using a proper VFIL2 driver.", "tokens": [51114, 341, 565, 1228, 257, 2296, 691, 37, 4620, 17, 6787, 13, 51314], "temperature": 0.0, "avg_logprob": -0.16349282375601834, "compression_ratio": 1.5071090047393365, "no_speech_prob": 0.004644240718334913}, {"id": 336, "seek": 100600, "start": 1025.0, "end": 1031.0, "text": " And again, because we still didn't have the stateless encoding UAPI,", "tokens": [51314, 400, 797, 11, 570, 321, 920, 994, 380, 362, 264, 2219, 4272, 43430, 624, 4715, 40, 11, 51614], "temperature": 0.0, "avg_logprob": -0.16349282375601834, "compression_ratio": 1.5071090047393365, "no_speech_prob": 0.004644240718334913}, {"id": 337, "seek": 103100, "start": 1031.0, "end": 1036.0, "text": " I decided to use the stateful encoding UAPI more or less directly.", "tokens": [50364, 286, 3047, 281, 764, 264, 1785, 906, 43430, 624, 4715, 40, 544, 420, 1570, 3838, 13, 50614], "temperature": 0.0, "avg_logprob": -0.06451183490538864, "compression_ratio": 1.587962962962963, "no_speech_prob": 0.00279652769677341}, {"id": 338, "seek": 103100, "start": 1036.0, "end": 1040.0, "text": " And this made it clear that this API was quite limiting", "tokens": [50614, 400, 341, 1027, 309, 1850, 300, 341, 9362, 390, 1596, 22083, 50814], "temperature": 0.0, "avg_logprob": -0.06451183490538864, "compression_ratio": 1.587962962962963, "no_speech_prob": 0.00279652769677341}, {"id": 339, "seek": 103100, "start": 1040.0, "end": 1047.0, "text": " and that it didn't allow leveraging the full potential of the stateless hardware designs.", "tokens": [50814, 293, 300, 309, 994, 380, 2089, 32666, 264, 1577, 3995, 295, 264, 2219, 4272, 8837, 11347, 13, 51164], "temperature": 0.0, "avg_logprob": -0.06451183490538864, "compression_ratio": 1.587962962962963, "no_speech_prob": 0.00279652769677341}, {"id": 340, "seek": 103100, "start": 1047.0, "end": 1052.0, "text": " So there's a few lessons to be learned from that.", "tokens": [51164, 407, 456, 311, 257, 1326, 8820, 281, 312, 3264, 490, 300, 13, 51414], "temperature": 0.0, "avg_logprob": -0.06451183490538864, "compression_ratio": 1.587962962962963, "no_speech_prob": 0.00279652769677341}, {"id": 341, "seek": 103100, "start": 1052.0, "end": 1057.0, "text": " Like I said, stateful API is not really a good fit for these stateless encoders,", "tokens": [51414, 1743, 286, 848, 11, 1785, 906, 9362, 307, 406, 534, 257, 665, 3318, 337, 613, 2219, 4272, 2058, 378, 433, 11, 51664], "temperature": 0.0, "avg_logprob": -0.06451183490538864, "compression_ratio": 1.587962962962963, "no_speech_prob": 0.00279652769677341}, {"id": 342, "seek": 105700, "start": 1057.0, "end": 1061.0, "text": " so it's not really viable to try and use that.", "tokens": [50364, 370, 309, 311, 406, 534, 22024, 281, 853, 293, 764, 300, 13, 50564], "temperature": 0.0, "avg_logprob": -0.12375648654237086, "compression_ratio": 1.691304347826087, "no_speech_prob": 0.0022140268702059984}, {"id": 343, "seek": 105700, "start": 1061.0, "end": 1065.0, "text": " The Bitstream beta data needs to be produced canalside, like I said,", "tokens": [50564, 440, 9101, 9291, 9861, 1412, 2203, 281, 312, 7126, 393, 1124, 482, 11, 411, 286, 848, 11, 50764], "temperature": 0.0, "avg_logprob": -0.12375648654237086, "compression_ratio": 1.691304347826087, "no_speech_prob": 0.0022140268702059984}, {"id": 344, "seek": 105700, "start": 1065.0, "end": 1069.0, "text": " because we have some hardware constraints that we cannot represent", "tokens": [50764, 570, 321, 362, 512, 8837, 18491, 300, 321, 2644, 2906, 50964], "temperature": 0.0, "avg_logprob": -0.12375648654237086, "compression_ratio": 1.691304347826087, "no_speech_prob": 0.0022140268702059984}, {"id": 345, "seek": 105700, "start": 1069.0, "end": 1072.0, "text": " and let's say forward to user space.", "tokens": [50964, 293, 718, 311, 584, 2128, 281, 4195, 1901, 13, 51114], "temperature": 0.0, "avg_logprob": -0.12375648654237086, "compression_ratio": 1.691304347826087, "no_speech_prob": 0.0022140268702059984}, {"id": 346, "seek": 105700, "start": 1072.0, "end": 1079.0, "text": " So it has to be the kernel that decides how to generate those Bitstream headers.", "tokens": [51114, 407, 309, 575, 281, 312, 264, 28256, 300, 14898, 577, 281, 8460, 729, 9101, 9291, 45101, 13, 51464], "temperature": 0.0, "avg_logprob": -0.12375648654237086, "compression_ratio": 1.691304347826087, "no_speech_prob": 0.0022140268702059984}, {"id": 347, "seek": 105700, "start": 1079.0, "end": 1082.0, "text": " And for rate control, it's really unclear", "tokens": [51464, 400, 337, 3314, 1969, 11, 309, 311, 534, 25636, 51614], "temperature": 0.0, "avg_logprob": -0.12375648654237086, "compression_ratio": 1.691304347826087, "no_speech_prob": 0.0022140268702059984}, {"id": 348, "seek": 105700, "start": 1082.0, "end": 1085.0, "text": " because having rate control on the kernel side", "tokens": [51614, 570, 1419, 3314, 1969, 322, 264, 28256, 1252, 51764], "temperature": 0.0, "avg_logprob": -0.12375648654237086, "compression_ratio": 1.691304347826087, "no_speech_prob": 0.0022140268702059984}, {"id": 349, "seek": 108500, "start": 1085.0, "end": 1089.0, "text": " makes the user space quite simple and it makes it really easy to operate it", "tokens": [50364, 1669, 264, 4195, 1901, 1596, 2199, 293, 309, 1669, 309, 534, 1858, 281, 9651, 309, 50564], "temperature": 0.0, "avg_logprob": -0.07261478589928669, "compression_ratio": 1.811764705882353, "no_speech_prob": 0.005166352726519108}, {"id": 350, "seek": 108500, "start": 1089.0, "end": 1092.0, "text": " without having a lot of logic aside.", "tokens": [50564, 1553, 1419, 257, 688, 295, 9952, 7359, 13, 50714], "temperature": 0.0, "avg_logprob": -0.07261478589928669, "compression_ratio": 1.811764705882353, "no_speech_prob": 0.005166352726519108}, {"id": 351, "seek": 108500, "start": 1092.0, "end": 1096.0, "text": " But on the other hand, having the rate control in user space is a lot more flexible", "tokens": [50714, 583, 322, 264, 661, 1011, 11, 1419, 264, 3314, 1969, 294, 4195, 1901, 307, 257, 688, 544, 11358, 50914], "temperature": 0.0, "avg_logprob": -0.07261478589928669, "compression_ratio": 1.811764705882353, "no_speech_prob": 0.005166352726519108}, {"id": 352, "seek": 108500, "start": 1096.0, "end": 1100.0, "text": " and it means that you can implement kind of whatever strategy you want,", "tokens": [50914, 293, 309, 1355, 300, 291, 393, 4445, 733, 295, 2035, 5206, 291, 528, 11, 51114], "temperature": 0.0, "avg_logprob": -0.07261478589928669, "compression_ratio": 1.811764705882353, "no_speech_prob": 0.005166352726519108}, {"id": 353, "seek": 108500, "start": 1100.0, "end": 1103.0, "text": " you can decide on the implementation yourself,", "tokens": [51114, 291, 393, 4536, 322, 264, 11420, 1803, 11, 51264], "temperature": 0.0, "avg_logprob": -0.07261478589928669, "compression_ratio": 1.811764705882353, "no_speech_prob": 0.005166352726519108}, {"id": 354, "seek": 108500, "start": 1103.0, "end": 1106.0, "text": " which is a bit less easy when it's on the kernel side.", "tokens": [51264, 597, 307, 257, 857, 1570, 1858, 562, 309, 311, 322, 264, 28256, 1252, 13, 51414], "temperature": 0.0, "avg_logprob": -0.07261478589928669, "compression_ratio": 1.811764705882353, "no_speech_prob": 0.005166352726519108}, {"id": 355, "seek": 108500, "start": 1106.0, "end": 1110.0, "text": " Of course, it's not impossible, it's all free software and you can change it like you want,", "tokens": [51414, 2720, 1164, 11, 309, 311, 406, 6243, 11, 309, 311, 439, 1737, 4722, 293, 291, 393, 1319, 309, 411, 291, 528, 11, 51614], "temperature": 0.0, "avg_logprob": -0.07261478589928669, "compression_ratio": 1.811764705882353, "no_speech_prob": 0.005166352726519108}, {"id": 356, "seek": 111000, "start": 1110.0, "end": 1115.0, "text": " but we still understand that there is interest in both cases.", "tokens": [50364, 457, 321, 920, 1223, 300, 456, 307, 1179, 294, 1293, 3331, 13, 50614], "temperature": 0.0, "avg_logprob": -0.1631594722710767, "compression_ratio": 1.6056910569105691, "no_speech_prob": 0.00297177373431623}, {"id": 357, "seek": 111000, "start": 1115.0, "end": 1120.0, "text": " So the current state of the art for stateless encoding in VFrl2", "tokens": [50614, 407, 264, 2190, 1785, 295, 264, 1523, 337, 2219, 4272, 43430, 294, 691, 37, 81, 75, 17, 50864], "temperature": 0.0, "avg_logprob": -0.1631594722710767, "compression_ratio": 1.6056910569105691, "no_speech_prob": 0.00297177373431623}, {"id": 358, "seek": 111000, "start": 1120.0, "end": 1123.0, "text": " is that it's in progress, it's a discussion,", "tokens": [50864, 307, 300, 309, 311, 294, 4205, 11, 309, 311, 257, 5017, 11, 51014], "temperature": 0.0, "avg_logprob": -0.1631594722710767, "compression_ratio": 1.6056910569105691, "no_speech_prob": 0.00297177373431623}, {"id": 359, "seek": 111000, "start": 1123.0, "end": 1128.0, "text": " so if you have an opinion on that or if you have ideas on how this could be improved", "tokens": [51014, 370, 498, 291, 362, 364, 4800, 322, 300, 420, 498, 291, 362, 3487, 322, 577, 341, 727, 312, 9689, 51264], "temperature": 0.0, "avg_logprob": -0.1631594722710767, "compression_ratio": 1.6056910569105691, "no_speech_prob": 0.00297177373431623}, {"id": 360, "seek": 111000, "start": 1128.0, "end": 1131.0, "text": " or how this published quantization parameter,", "tokens": [51264, 420, 577, 341, 6572, 4426, 2144, 13075, 11, 51414], "temperature": 0.0, "avg_logprob": -0.1631594722710767, "compression_ratio": 1.6056910569105691, "no_speech_prob": 0.00297177373431623}, {"id": 361, "seek": 111000, "start": 1131.0, "end": 1137.0, "text": " which references we're going to use to generate the frames based on the previews on X-frames.", "tokens": [51414, 597, 15400, 321, 434, 516, 281, 764, 281, 8460, 264, 12083, 2361, 322, 264, 14281, 82, 322, 1783, 12, 43277, 13, 51714], "temperature": 0.0, "avg_logprob": -0.1631594722710767, "compression_ratio": 1.6056910569105691, "no_speech_prob": 0.00297177373431623}, {"id": 362, "seek": 113700, "start": 1137.0, "end": 1143.0, "text": " So having a switch kind of allows user space to choose if it wants to have low-level control", "tokens": [50364, 407, 1419, 257, 3679, 733, 295, 4045, 4195, 1901, 281, 2826, 498, 309, 2738, 281, 362, 2295, 12, 12418, 1969, 50664], "temperature": 0.0, "avg_logprob": -0.10652971780428322, "compression_ratio": 1.6768558951965065, "no_speech_prob": 0.00024848582688719034}, {"id": 363, "seek": 113700, "start": 1143.0, "end": 1147.0, "text": " or if it wants to have something simple that works, which is maybe suboptimal,", "tokens": [50664, 420, 498, 309, 2738, 281, 362, 746, 2199, 300, 1985, 11, 597, 307, 1310, 1422, 5747, 10650, 11, 50864], "temperature": 0.0, "avg_logprob": -0.10652971780428322, "compression_ratio": 1.6768558951965065, "no_speech_prob": 0.00024848582688719034}, {"id": 364, "seek": 113700, "start": 1147.0, "end": 1150.0, "text": " but that can still be used nicely.", "tokens": [50864, 457, 300, 393, 920, 312, 1143, 9594, 13, 51014], "temperature": 0.0, "avg_logprob": -0.10652971780428322, "compression_ratio": 1.6768558951965065, "no_speech_prob": 0.00024848582688719034}, {"id": 365, "seek": 113700, "start": 1151.0, "end": 1156.0, "text": " Another way would be that we have rate control implemented in the kernel side,", "tokens": [51064, 3996, 636, 576, 312, 300, 321, 362, 3314, 1969, 12270, 294, 264, 28256, 1252, 11, 51314], "temperature": 0.0, "avg_logprob": -0.10652971780428322, "compression_ratio": 1.6768558951965065, "no_speech_prob": 0.00024848582688719034}, {"id": 366, "seek": 113700, "start": 1156.0, "end": 1161.0, "text": " but instead of applying it to the next frame, it would just provide some suggestion to user space,", "tokens": [51314, 457, 2602, 295, 9275, 309, 281, 264, 958, 3920, 11, 309, 576, 445, 2893, 512, 16541, 281, 4195, 1901, 11, 51564], "temperature": 0.0, "avg_logprob": -0.10652971780428322, "compression_ratio": 1.6768558951965065, "no_speech_prob": 0.00024848582688719034}, {"id": 367, "seek": 116100, "start": 1161.0, "end": 1166.0, "text": " so it would be some kind of feedback data that is provided with an indication", "tokens": [50364, 370, 309, 576, 312, 512, 733, 295, 5824, 1412, 300, 307, 5649, 365, 364, 18877, 50614], "temperature": 0.0, "avg_logprob": -0.0670562855740811, "compression_ratio": 1.73109243697479, "no_speech_prob": 0.005119691602885723}, {"id": 368, "seek": 116100, "start": 1166.0, "end": 1175.0, "text": " of what the next QP or frame type could be to follow the policy that was selected kernel side.", "tokens": [50614, 295, 437, 264, 958, 1249, 47, 420, 3920, 2010, 727, 312, 281, 1524, 264, 3897, 300, 390, 8209, 28256, 1252, 13, 51064], "temperature": 0.0, "avg_logprob": -0.0670562855740811, "compression_ratio": 1.73109243697479, "no_speech_prob": 0.005119691602885723}, {"id": 369, "seek": 116100, "start": 1175.0, "end": 1181.0, "text": " This could also work because then user space could decide to follow this feedback suggestion or not,", "tokens": [51064, 639, 727, 611, 589, 570, 550, 4195, 1901, 727, 4536, 281, 1524, 341, 5824, 16541, 420, 406, 11, 51364], "temperature": 0.0, "avg_logprob": -0.0670562855740811, "compression_ratio": 1.73109243697479, "no_speech_prob": 0.005119691602885723}, {"id": 370, "seek": 116100, "start": 1181.0, "end": 1185.0, "text": " so then it could decide to do something completely different.", "tokens": [51364, 370, 550, 309, 727, 4536, 281, 360, 746, 2584, 819, 13, 51564], "temperature": 0.0, "avg_logprob": -0.0670562855740811, "compression_ratio": 1.73109243697479, "no_speech_prob": 0.005119691602885723}, {"id": 371, "seek": 116100, "start": 1185.0, "end": 1188.0, "text": " So in that situation, user space would still have all the low-level control,", "tokens": [51564, 407, 294, 300, 2590, 11, 4195, 1901, 576, 920, 362, 439, 264, 2295, 12, 12418, 1969, 11, 51714], "temperature": 0.0, "avg_logprob": -0.0670562855740811, "compression_ratio": 1.73109243697479, "no_speech_prob": 0.005119691602885723}, {"id": 372, "seek": 118800, "start": 1188.0, "end": 1193.0, "text": " but it would have suggestions about which values would make sense", "tokens": [50364, 457, 309, 576, 362, 13396, 466, 597, 4190, 576, 652, 2020, 50614], "temperature": 0.0, "avg_logprob": -0.0657348212073831, "compression_ratio": 1.784, "no_speech_prob": 0.002145553007721901}, {"id": 373, "seek": 118800, "start": 1193.0, "end": 1197.0, "text": " depending on the kernel side rate control implementation.", "tokens": [50614, 5413, 322, 264, 28256, 1252, 3314, 1969, 11420, 13, 50814], "temperature": 0.0, "avg_logprob": -0.0657348212073831, "compression_ratio": 1.784, "no_speech_prob": 0.002145553007721901}, {"id": 374, "seek": 118800, "start": 1197.0, "end": 1201.0, "text": " So that's also something that could work, and we could even have some switch to auto-apply the feedback", "tokens": [50814, 407, 300, 311, 611, 746, 300, 727, 589, 11, 293, 321, 727, 754, 362, 512, 3679, 281, 8399, 12, 1746, 356, 264, 5824, 51014], "temperature": 0.0, "avg_logprob": -0.0657348212073831, "compression_ratio": 1.784, "no_speech_prob": 0.002145553007721901}, {"id": 375, "seek": 118800, "start": 1201.0, "end": 1207.0, "text": " so that user space doesn't even have to copy that suggestion into the actual configuration.", "tokens": [51014, 370, 300, 4195, 1901, 1177, 380, 754, 362, 281, 5055, 300, 16541, 666, 264, 3539, 11694, 13, 51314], "temperature": 0.0, "avg_logprob": -0.0657348212073831, "compression_ratio": 1.784, "no_speech_prob": 0.002145553007721901}, {"id": 376, "seek": 118800, "start": 1207.0, "end": 1210.0, "text": " We could just have a switch that makes it kind of automatically go,", "tokens": [51314, 492, 727, 445, 362, 257, 3679, 300, 1669, 309, 733, 295, 6772, 352, 11, 51464], "temperature": 0.0, "avg_logprob": -0.0657348212073831, "compression_ratio": 1.784, "no_speech_prob": 0.002145553007721901}, {"id": 377, "seek": 118800, "start": 1210.0, "end": 1215.0, "text": " and after that, user space really doesn't have much to do,", "tokens": [51464, 293, 934, 300, 11, 4195, 1901, 534, 1177, 380, 362, 709, 281, 360, 11, 51714], "temperature": 0.0, "avg_logprob": -0.0657348212073831, "compression_ratio": 1.784, "no_speech_prob": 0.002145553007721901}, {"id": 378, "seek": 121500, "start": 1215.0, "end": 1218.0, "text": " and it can kind of let it handle it by itself.", "tokens": [50364, 293, 309, 393, 733, 295, 718, 309, 4813, 309, 538, 2564, 13, 50514], "temperature": 0.0, "avg_logprob": -0.0847513477007548, "compression_ratio": 1.7415254237288136, "no_speech_prob": 0.0032993415370583534}, {"id": 379, "seek": 121500, "start": 1218.0, "end": 1223.0, "text": " So that would be also some form of trade-off that allows having something simple for user space", "tokens": [50514, 407, 300, 576, 312, 611, 512, 1254, 295, 4923, 12, 4506, 300, 4045, 1419, 746, 2199, 337, 4195, 1901, 50764], "temperature": 0.0, "avg_logprob": -0.0847513477007548, "compression_ratio": 1.7415254237288136, "no_speech_prob": 0.0032993415370583534}, {"id": 380, "seek": 121500, "start": 1223.0, "end": 1233.0, "text": " and also allow user space to be able to control things if it wants to.", "tokens": [50764, 293, 611, 2089, 4195, 1901, 281, 312, 1075, 281, 1969, 721, 498, 309, 2738, 281, 13, 51264], "temperature": 0.0, "avg_logprob": -0.0847513477007548, "compression_ratio": 1.7415254237288136, "no_speech_prob": 0.0032993415370583534}, {"id": 381, "seek": 121500, "start": 1233.0, "end": 1236.0, "text": " Another thing that would be interesting is to have some common code", "tokens": [51264, 3996, 551, 300, 576, 312, 1880, 307, 281, 362, 512, 2689, 3089, 51414], "temperature": 0.0, "avg_logprob": -0.0847513477007548, "compression_ratio": 1.7415254237288136, "no_speech_prob": 0.0032993415370583534}, {"id": 382, "seek": 121500, "start": 1236.0, "end": 1239.0, "text": " that is shared between these different state-based encoders", "tokens": [51414, 300, 307, 5507, 1296, 613, 819, 1785, 12, 6032, 2058, 378, 433, 51564], "temperature": 0.0, "avg_logprob": -0.0847513477007548, "compression_ratio": 1.7415254237288136, "no_speech_prob": 0.0032993415370583534}, {"id": 383, "seek": 121500, "start": 1239.0, "end": 1243.0, "text": " because especially for things like the bitstream metadata generation,", "tokens": [51564, 570, 2318, 337, 721, 411, 264, 857, 9291, 26603, 5125, 11, 51764], "temperature": 0.0, "avg_logprob": -0.0847513477007548, "compression_ratio": 1.7415254237288136, "no_speech_prob": 0.0032993415370583534}, {"id": 384, "seek": 124300, "start": 1243.0, "end": 1246.0, "text": " there is a lot that is common, of course, because it targets the same format,", "tokens": [50364, 456, 307, 257, 688, 300, 307, 2689, 11, 295, 1164, 11, 570, 309, 12911, 264, 912, 7877, 11, 50514], "temperature": 0.0, "avg_logprob": -0.07361861852210337, "compression_ratio": 1.8216783216783217, "no_speech_prob": 0.002708441112190485}, {"id": 385, "seek": 124300, "start": 1246.0, "end": 1250.0, "text": " so we could have some helpers that are shared between these different drivers.", "tokens": [50514, 370, 321, 727, 362, 512, 854, 433, 300, 366, 5507, 1296, 613, 819, 11590, 13, 50714], "temperature": 0.0, "avg_logprob": -0.07361861852210337, "compression_ratio": 1.8216783216783217, "no_speech_prob": 0.002708441112190485}, {"id": 386, "seek": 124300, "start": 1250.0, "end": 1254.0, "text": " Again, the state-full encoders don't have to generate that bitstream metadata,", "tokens": [50714, 3764, 11, 264, 1785, 12, 32818, 2058, 378, 433, 500, 380, 362, 281, 8460, 300, 857, 9291, 26603, 11, 50914], "temperature": 0.0, "avg_logprob": -0.07361861852210337, "compression_ratio": 1.8216783216783217, "no_speech_prob": 0.002708441112190485}, {"id": 387, "seek": 124300, "start": 1254.0, "end": 1258.0, "text": " so it's really something specific to the state-less encoders.", "tokens": [50914, 370, 309, 311, 534, 746, 2685, 281, 264, 1785, 12, 1832, 2058, 378, 433, 13, 51114], "temperature": 0.0, "avg_logprob": -0.07361861852210337, "compression_ratio": 1.8216783216783217, "no_speech_prob": 0.002708441112190485}, {"id": 388, "seek": 124300, "start": 1258.0, "end": 1264.0, "text": " Finally, the rate control implementations, if they end up existing on the kernel side,", "tokens": [51114, 6288, 11, 264, 3314, 1969, 4445, 763, 11, 498, 436, 917, 493, 6741, 322, 264, 28256, 1252, 11, 51414], "temperature": 0.0, "avg_logprob": -0.07361861852210337, "compression_ratio": 1.8216783216783217, "no_speech_prob": 0.002708441112190485}, {"id": 389, "seek": 124300, "start": 1264.0, "end": 1267.0, "text": " it would also be nice to be able to share them between the different drivers", "tokens": [51414, 309, 576, 611, 312, 1481, 281, 312, 1075, 281, 2073, 552, 1296, 264, 819, 11590, 51564], "temperature": 0.0, "avg_logprob": -0.07361861852210337, "compression_ratio": 1.8216783216783217, "no_speech_prob": 0.002708441112190485}, {"id": 390, "seek": 124300, "start": 1267.0, "end": 1272.0, "text": " instead of having driver-specific implementations for that.", "tokens": [51564, 2602, 295, 1419, 6787, 12, 29258, 4445, 763, 337, 300, 13, 51814], "temperature": 0.0, "avg_logprob": -0.07361861852210337, "compression_ratio": 1.8216783216783217, "no_speech_prob": 0.002708441112190485}, {"id": 391, "seek": 127200, "start": 1273.0, "end": 1280.0, "text": " Besides discussing and exchanging ideas and hopefully finding a solution", "tokens": [50414, 13212, 10850, 293, 6210, 9741, 3487, 293, 4696, 5006, 257, 3827, 50764], "temperature": 0.0, "avg_logprob": -0.16966667175292968, "compression_ratio": 1.5260663507109005, "no_speech_prob": 0.003531995927914977}, {"id": 392, "seek": 127200, "start": 1280.0, "end": 1283.0, "text": " for what this UAPI should look like,", "tokens": [50764, 337, 437, 341, 624, 4715, 40, 820, 574, 411, 11, 50914], "temperature": 0.0, "avg_logprob": -0.16966667175292968, "compression_ratio": 1.5260663507109005, "no_speech_prob": 0.003531995927914977}, {"id": 393, "seek": 127200, "start": 1283.0, "end": 1289.0, "text": " the next step will be to merge the work done on the Hentro and Cedrus drivers", "tokens": [50914, 264, 958, 1823, 486, 312, 281, 22183, 264, 589, 1096, 322, 264, 389, 317, 340, 293, 383, 292, 13783, 11590, 51214], "temperature": 0.0, "avg_logprob": -0.16966667175292968, "compression_ratio": 1.5260663507109005, "no_speech_prob": 0.003531995927914977}, {"id": 394, "seek": 127200, "start": 1289.0, "end": 1294.0, "text": " to bring X264 encoding and VPA encoding for Hentro.", "tokens": [51214, 281, 1565, 1783, 10880, 19, 43430, 293, 691, 10297, 43430, 337, 389, 317, 340, 13, 51464], "temperature": 0.0, "avg_logprob": -0.16966667175292968, "compression_ratio": 1.5260663507109005, "no_speech_prob": 0.003531995927914977}, {"id": 395, "seek": 127200, "start": 1294.0, "end": 1298.0, "text": " After that, the next step will be to have some G-streamer and FFM-back integration", "tokens": [51464, 2381, 300, 11, 264, 958, 1823, 486, 312, 281, 362, 512, 460, 12, 9291, 260, 293, 479, 37, 44, 12, 3207, 10980, 51664], "temperature": 0.0, "avg_logprob": -0.16966667175292968, "compression_ratio": 1.5260663507109005, "no_speech_prob": 0.003531995927914977}, {"id": 396, "seek": 129800, "start": 1298.0, "end": 1302.0, "text": " to use this UAPI, and after that, normally the rest of the world", "tokens": [50364, 281, 764, 341, 624, 4715, 40, 11, 293, 934, 300, 11, 5646, 264, 1472, 295, 264, 1002, 50564], "temperature": 0.0, "avg_logprob": -0.10390492489463404, "compression_ratio": 1.5683760683760684, "no_speech_prob": 0.007070334628224373}, {"id": 397, "seek": 129800, "start": 1302.0, "end": 1309.0, "text": " should be able to use the state-less hardware encoders, which will be great.", "tokens": [50564, 820, 312, 1075, 281, 764, 264, 1785, 12, 1832, 8837, 2058, 378, 433, 11, 597, 486, 312, 869, 13, 50914], "temperature": 0.0, "avg_logprob": -0.10390492489463404, "compression_ratio": 1.5683760683760684, "no_speech_prob": 0.007070334628224373}, {"id": 398, "seek": 129800, "start": 1309.0, "end": 1312.0, "text": " So time is up for me. Thanks everybody for listening.", "tokens": [50914, 407, 565, 307, 493, 337, 385, 13, 2561, 2201, 337, 4764, 13, 51064], "temperature": 0.0, "avg_logprob": -0.10390492489463404, "compression_ratio": 1.5683760683760684, "no_speech_prob": 0.007070334628224373}, {"id": 399, "seek": 129800, "start": 1319.0, "end": 1322.0, "text": " Thank you for a great talk. Unfortunately, we do not have time for questions,", "tokens": [51414, 1044, 291, 337, 257, 869, 751, 13, 8590, 11, 321, 360, 406, 362, 565, 337, 1651, 11, 51564], "temperature": 0.0, "avg_logprob": -0.10390492489463404, "compression_ratio": 1.5683760683760684, "no_speech_prob": 0.007070334628224373}, {"id": 400, "seek": 129800, "start": 1322.0, "end": 1326.0, "text": " but I really encourage everyone who has a question to just catch the speaker in the corridor.", "tokens": [51564, 457, 286, 534, 5373, 1518, 567, 575, 257, 1168, 281, 445, 3745, 264, 8145, 294, 264, 25602, 13, 51764], "temperature": 0.0, "avg_logprob": -0.10390492489463404, "compression_ratio": 1.5683760683760684, "no_speech_prob": 0.007070334628224373}, {"id": 401, "seek": 132600, "start": 1326.0, "end": 1328.0, "text": " Thank you. Thanks.", "tokens": [50364, 1044, 291, 13, 2561, 13, 50464], "temperature": 0.0, "avg_logprob": -0.17569805681705475, "compression_ratio": 0.782608695652174, "no_speech_prob": 0.034113433212041855}], "language": "en"}