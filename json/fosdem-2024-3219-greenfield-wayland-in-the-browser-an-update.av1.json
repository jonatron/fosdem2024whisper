{"text": " Hello everyone, welcome. My name is Eric Dereke. I am the author of Greenfield. Previous talk we saw how Chromium can run on Wayland. Now we're going to see how Wayland can run in Chromium. So this is an update about Greenfield. I gave a previous talk in 2019 about Greenfield. So basically recap what is Greenfield? Greenfield is a Wayland compositor. I'm sure most of you already know what a compositor is. That runs entirely in your browser. You can control remote applications with it from different servers if you want. X applications as well, X Wayland applications. For that, that's also a fun fact. I actually had to port XCB library to JavaScript, to TypeScript. So I have a Python parse X protocol files and have it output JavaScript and then you can run it in your browser. Works perfectly by the way. You can also run Wayland applications directly in your browser. So actual native desktop applications compiled to WebAssembly and have them talk Wayland protocol to Greenfield inside your browser. We're going to see some demos at the end of the talk as well. It doesn't have to be WebAssembly applications. By the way, you can just write JavaScript applications. They just have to talk Wayland to have their pixels displayed on the screen and to handle input. So that's basically Greenfield in a nutshell. Why? For God's sake, why would you write this? Well, because I can, that's basically the crutch of it. No. I had basically an idea. Wouldn't it be cool if we had a desktop that you could run anywhere? So not tied to a single physical piece of hardware you had with a single interface for all your applications. So no longer bound to say, yeah, a smartphone or a desktop or whatever. And yeah, so, and be free basically to run it where you want. So you're not bound to any SaaS provider or anything. Just have your own server or servers or whatever and have the application distributed and basically access them anywhere you want, anytime you want without restrictions purely for you. I thought that would be pretty cool. And it didn't exist. So a set hell, I'll write it myself. Well, how is Wayland written? Well, in the browser, you're limited to the JavaScript and WebAssembly. So in the case of Greenfield, most of it is TypeScript that's then processed to JavaScript. And there's also a bunch of C involved, mostly existing C libraries, things like lipxkb common is compiled to WebAssembly to handle all the keyboard layouts and keyboard encodings. There's also lippixman basically to region handling. I'm not going to reinvent the wheel, I'm not going to write those things in JavaScript. So I took the existing libraries, ported them to WebAssembly and made them accessible inside the browser. The display part of Greenfield is written in WebGL to have any kind of decent performance. It's very similar to how a normal or say a native Wayland compositor would would composite using OpenGL. So in the browser case, it's WebGL. To deal with the remote applications, that was you need basically a proxy. So the native applications have to find a socket to connect to a Wayland socket to connect to and have those messages handled, have the native buffers handled and have the protocol sent to the browser. So I wrote server in TypeScript. I'm sorry guys. I needed something that was I could prototype fast and without dealing with seq faults and everything. So I did it in TypeScript and it grew a bit and now it's a bit bigger. So I guess some point in the future, I promise I will rewrite it and rust somewhere in the future, I guess. Also the performance critical parts of the whole pipeline are written in C using Gstreamer as well. So there is a tight integration there. Gstreamer, really cool project. It does basically everything I needed. Very modular. I could do all kinds of cool stuff with it. I'll show that a bit later. If there are any Gstreamer faults in the room, the only thing I missed a bit was color conversion on the GPU. So a hint that would be cool to have. At some point, I also wrote a Kubernetes implementation basically. So that basically means that you could use an entire Kubernetes cluster as your desktop. So every application would be its own part. So you could run 20 performance intensive applications, have them all run on separate machines, all running smoothly, basically giving you virtually unlimited resources on your desktop. So that's going in the direction I had in mind. Sadly not open source for the moment. Maybe someday in the future, if it's gone out of prototype phase, perhaps I can give a talk about it too. And last but not least, blood, sweat and tears. This is like a side project, a hobby project. So I was not working on it full time. So at some point, I had to sacrifice a bit of sleep to make some progress. I do not recommend, by the way. So here we have an overview, a pipeline overview, how frames are sent from your native site to the browser. So on the top part, we basically have everything that happens on the GPU. On the bottom part, we have everything that happens on the CPU. So we're going to start from left to right. On the left, we have an application that renders either on the GPU or on the CPU using GPU memory buffers or shared memory buffers on the CPU. When an application submits those pixels to the native compositor, so that's our proxy compositor that I talked about before, then those buffers are basically handled and they are color split. So we need to get these buffers to the browser and we need to compress them. Ideally, we do that using video encodings. But to do that, there are a few issues. Most color buffers that we get from the applications, they have an alpha channel. This day, we have cool virtual reality headsets that just launched. We have awesome artificial intelligence. We do not have video codecs that can handle alpha encode. So I had to split the color into an RGB and an alpha and those are actually two separate video streams. So the alpha color conversion is handled as a black and white video stream. This is done on the GPU if possible and there is a fallback to CPU encoding if it's not available. There's also the color conversion that also always happens on the GPU. And then those two frames, those two video frames are then sent using a WebSocket server to the browser. A small remark there, WebSocket server, it's TCP. We're dealing with a real-time application here. Ideally, ideally, people would use something like WebTransport which uses UDP but it's a bit still experimental. Not a lot of implementations there for the moment so we're stuck with WebSocket. The frames arrive on the browser and there we have to decode the video streams, the video frames. This is done for Firefox only, sadly, using WebWorkers where I ported FFMPEG to WebAssembly for H.264 as well. To do that, for the other browsers, I used the WebCodec standard so I can have the browser do all the artwork and have the video frame decoded. And then last but not least, there is a WebGL shader that puts the colors back together. So we have the RGB frame, we have the alpha frame, we stitch them back together and we push them to WebGL texture and paint them nicely on the screen. That was a long trip. This is all how we go from the application to the compositor. So far so good. But Wayland also has a few mechanisms to tell the application, hey, I'm done painting your pixels, you can send me the next batch if you were to please. But there is a bit of an issue here. Wayland is an asynchronous protocol but the dealing with sending a frame and the compositor telling the application, send me the next frame, that's a whole slow synchronous process. So what that means is that if this pipeline were to take no milliseconds, you still have your network latency. Say we have 50 millisecond network latency, we immediately send the frame to the compositor and then the compositor tells the application, okay, I'm done, you can send me the next one. You have about 50 milliseconds between each frame. So that gives you around 20 frames per second. That's not really acceptable. So we're going to have to be a bit smart and we're going to have to tell the application in advance, like hey, you can already send the next frame because I think the compositor is probably already done handling your previous frame. So that is basically the round trip latency problem that we have. And there are generally two mechanisms in the Wayland protocol. The first one is the one I just talked about which is the frame callbacks, which is the compositor telling the application, I'm done painting your pixels. The other one is the sync request. The sync request in the Wayland protocol is a way for an application to know when all previous requests that have been sent are done. So when an application sends a request to a compositor, those requests are queued up. And when an application sends a sync request, then the compositor will simply, once it encounters that sync request, will simply reply with done. And then the application know, oh, I got a done response. So that means all previous requests were handled. So to deal with that, as I just explained, there is the predictive frame callback. This is how we deal with the sync request issue. So this is a complex picture, a bit out of scope to go too much in detail. But what generally happens is that the proxy compositor on the native site analyzes all requests that come in. And as soon as it receives a sync request, it will look at all the previous requests and see, hey, those previous requests that I just saw, none of them is going to send a reply. So you know what, I'm just going to send the done event immediately, and I'm not going to wait for the compositor to send a done event back. And that basically circumvents the whole network around the problem. The only potential issue you can have there is that you're basically got rid of your throttling. But there is some intermediate protocol to deal with that between the compositor and the proxy on the native site. So this is explained in the picture here. On the top, we have the requests that are coming in in the compositor in a classic Willing scenario. On the top right, we see, hey, there is a sync request, and it takes a whole network round trip time before the done event is sent. And the fastest placing, we have the same scenario. We have all the requests coming in. And at the end, we have our fast sync handled by the proxy. He sees, okay, no, events are going to be sent. So I don't need to wait for the compositor to send any other events. I'm going to send the done event immediately. And that makes the whole pipeline asynchronous. It makes the whole pipeline fast enough. If you have fast encoding, fast decoding, fast enough for gaming as well, you can do 60 frames per second or more if your hardware is fast enough and your network can deal with it. So far, the remoting part. Greenfield can do more than just remote applications. As I said before, you can also run applications directly in your browser. To do that, there is a prototype Greenfield SDK. It's based on EM scripting because it's the most complete, somewhat post-excompatible SDK out there that is aimed for the browser. This works fairly well, but it has some disadvantages as well. Wayland applications are Linux applications, well, almost exclusively. And the EM scripting SDK aims to be post-excompliant. And that's not Linux compliant. So things like E-Poll are not implemented in EM scripting. So I had to add those, well, at least E-Poll in the Greenfield SDK because Wayland requires it as well. There's also the core Wayland protocol is implemented in Greenfield together with the XG protocol. That works well for desktop applications, gives you a good standard to work with most office applications. They work out of the box. In the WebAssembly implementation, there is currently only support for shared memory buffers. We can theoretically do WebGL if we were to port Mesa to WebAssembly and utilize a custom WebGL Wayland protocol. The protocol exists. It works. It's simply currently not implemented inside Mesa itself. That's some future work, I guess, to support that. But we can perfectly support WebGL. No issue. The work just here needs to be done. So how would this all look while we have a nice green diagram here to show you how this looks? We have our main page on the left that loads your composite, that loads Greenfields. Next to it, you will have an iFrame. The iFrame loads your WebAssembly application, loads it in, and then basically uses internal iFrame messages to your main thread. Talking 100% pure native Wayland protocol works fine, works great. Next to it, we have transparently also the remote applications that are running. For the Greenfield compositor, both applications are just your ordinary Greenfield applications. He sees no difference. With a small remark that the Way file descriptors are handled on the protocol is a bit different. In case of not remote applications, the file descriptor is basically a URL that's passed around and that's opened and transferred and closed whenever needed. In case of native or rather browser native applications, it's a transferable browser object that is used. Those two file descriptor discrepancies have not yet been bridged, so you cannot do copy-paste operations, for example, between a browser application and a remote application. What you can do, copy-paste between a remote application that works just fine. That's how it currently works. What would the future look like? There are lots of cool stuff that can be done, that still needs to be done. There is the issue of sound. There's currently no sound. I initially left it out because it's a bit out of scope for compositor or Wayland related stuff, but somebody also already did their master thesis about its implemented sound in Greenfield, using pipe wire and G-streamer worked really well. Prototype exists and can be implemented, I guess, pretty easily. There's also the need for a bit more Wayland protocol, so there is just only the very basic currently implemented. There is no unified file system, again a bit out of scope for Greenfield, but it doesn't really exist, so it would be nice if we had it. Imagine you run applications on different servers, they all see their own local file system and you cannot transfer files between them, so that would be nice to have. There is the port of Mesa, the WebGL, using Wayland protocol, that would be nice to have. Then last, the hardest part, also the coolest part, is the whole EM scripting posix issue. It would be nice if you would simply got rid of EM scripting and just could compile applications directly to WebAssembly and actually have a Linux micro kernel running in your browser. Somebody else who is also crazy ported Linux kernel to ASMGS. ASMGS is the predecessor of WebAssembly and that crazy person got the Linux kernel to boot, up until pit one at least. I tried it to do that myself using WebAssembly, turns out it's actually really hard to port the Linux kernel to other architecture, no shit, especially if WebAssembly is not an elf binary. The Linux kernel expects the elf binary to be used, the format to be used when it's compiled in all kinds of different places and that assumption goes through the window when you try to compile to WebAssembly. There's also a bit of documentation importing the Linux kernel to other architectures. There's a ton of documentation about the Linux kernel, but most of it is about developing drivers. But yeah, I'm not a kernel developer as well, so that might also have to do something with it. But I'd say think about possibilities you could compile an application or Linux application to WebAssembly, boot it up in your browser by simply accessing a URL and have it completely sandboxed, super secure, running inside a desktop that's running in your browser. That would be really cool I think. So how would say a Linux port look like in WebAssembly? We have a nice yellow diagram this time. It would simply load access a URL, it would load the WebAssembly application, the WebAssembly application would then link against your kernel, which is also a WebAssembly module, bit out of scope for the graphics room, but there are certain WebAssembly standards that allow you to isolate certain region memories to the application and to the kernel module and have some regions shared with them. And then we could probably leverage the Vue.tio stack and have it interact with basically the browser APIs and have your browser basically be your virtual machine. So that's probably how it would look like. For the file system some attempts have been made and for now Jusifes seems to be the most valid candidate. Interesting note here is that Jusifes uses two kinds of databases, one to store your data itself, one to store the metadata of your file system and the experiment. It was shown that the metadata database needs to be really fast, so we probably need a locally cached metadata database which then uses CRTT basically to synchronize between the instances to make it fast enough. So let's see if we can show some demos. That would be cool I guess. So in here we have a state-of-the-art green field running, super fancy as you can see. And I'm going to try a remote application, I hope the wifi holds. So this one is actually streaming remotely, Doom 3. I noticed it sometimes tends to freeze, I don't know if it's because it's an old application running on the Nvidia Wayland drivers. As you can see there is no pointer locking here, so that's still one of the protocols that needs to be implemented, but we can simply start a new application here. We have a nice 60 frames per second streaming to your browser. All works fast and fine, so I wasn't lying when I said it's fast enough for gaming. You can see it, you can simply walk around here and everything. There's also, here we have a Western demo applications compiled to a web assembly, there we go. So this is, I believe it's written using Cairo, I think my pointer is being captured by the game. So it's using Cairo to draw all everything and G-Lip as well. So this runs inside an iframe, if you were to inspect the source code here, we have the iframe here that runs the web assembly application and yeah, talks Wayland protocol, it runs entirely in your browser, nicely isolated as well. It's all transparently done. Then we have, let's see if we can get this No, it doesn't want to go. So this is your web assembly application and of course we can also run desktop applications, so I have one running locally here. I think this is a cute app, there we go. So this one is running on my desktop locally and see I can open, so this popup chooser is running in my browser, it's all Wayland, see I can't move it and you arrive some packet. See it's the fast system of my my laptop as I said before and you can run it here. So that's that. So far the demo, let's see if I can move it, yes, can go. So that was it, I hope you enjoyed. If you have any questions, I guess I have maybe some answers. I'll go from left to right. How does it work for input events? Yeah, so the question was how does it work for input events? It uses the browser's input framework. In case of pointer events, it uses the raw pointer event API if it's available. It's still quite experimental but it removes some lag. So when it does it captures the browser pointer events and then basically translates this to input events like they were coming say from from lip inputs and it's then sent using Wayland protocol to the application. So it's fast but you still have inevitably the network latency that's unavoidable, sadly. Yes, I have two questions. The first one is does it support KDE's background blur protocol? The question was does it support KDE background blur? No, it does not. Currently the only protocols implemented are the core Wayland protocol and basically the XDG desktop protocol. The second question is vertical synchronization v-sync. Yes, so the vertical v-sync is supported. So it uses the browser request frame callback API which is basically the v-sync callback that the browser offers to draw. Next question. Yeah, so the question was does it use h.265 and is it secure I guess in a legal standpoint? It uses h.264 in this case. The reason being that the web codec API is from the browsers. Most of the browsers do not support h.265, at least not at the point I implemented it. So currently it uses h.264. I currently do not use it for commercial purposes. So yeah, I hope I'm safe. I'm going to have one more question and then I'm going to stop. Yes. So obviously the way the application expects Unix socket at the wet level, do you fix this if they're compiling for WebAssembly? Did you just implement the Wayland? Yeah, so the question was if you're compiling for WebAssembly and the application is expecting a Unix socket, how do you implement it? I extended the EM script in SDK so that it basically has support for Unix sockets on the user level and then also added e-polling to that as well. So for the application it's purely Unix sockets. It's not entirely so there's only client side support for connecting to a Unix socket, not for creating a Unix socket because that is done by the SDK itself. If you have more questions, I'm available. So after the talk, come and find me. Happy to answer them. Thank you.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 15.1, "text": " Hello everyone, welcome. My name is Eric Dereke. I am the author of Greenfield. Previous", "tokens": [50364, 2425, 1518, 11, 2928, 13, 1222, 1315, 307, 9336, 413, 323, 330, 13, 286, 669, 264, 3793, 295, 6969, 7610, 13, 6001, 1502, 51119], "temperature": 0.0, "avg_logprob": -0.3148141177195423, "compression_ratio": 1.2941176470588236, "no_speech_prob": 0.39610451459884644}, {"id": 1, "seek": 0, "start": 15.1, "end": 20.56, "text": " talk we saw how Chromium can run on Wayland. Now we're going to see how Wayland can run", "tokens": [51119, 751, 321, 1866, 577, 1721, 298, 2197, 393, 1190, 322, 9558, 1661, 13, 823, 321, 434, 516, 281, 536, 577, 9558, 1661, 393, 1190, 51392], "temperature": 0.0, "avg_logprob": -0.3148141177195423, "compression_ratio": 1.2941176470588236, "no_speech_prob": 0.39610451459884644}, {"id": 2, "seek": 2056, "start": 20.56, "end": 32.08, "text": " in Chromium. So this is an update about Greenfield. I gave a previous talk in 2019 about Greenfield.", "tokens": [50364, 294, 1721, 298, 2197, 13, 407, 341, 307, 364, 5623, 466, 6969, 7610, 13, 286, 2729, 257, 3894, 751, 294, 6071, 466, 6969, 7610, 13, 50940], "temperature": 0.0, "avg_logprob": -0.19280003212593697, "compression_ratio": 1.4894736842105263, "no_speech_prob": 0.457034707069397}, {"id": 3, "seek": 2056, "start": 32.08, "end": 39.04, "text": " So basically recap what is Greenfield? Greenfield is a Wayland compositor. I'm sure most of", "tokens": [50940, 407, 1936, 20928, 437, 307, 6969, 7610, 30, 6969, 7610, 307, 257, 9558, 1661, 10199, 3029, 13, 286, 478, 988, 881, 295, 51288], "temperature": 0.0, "avg_logprob": -0.19280003212593697, "compression_ratio": 1.4894736842105263, "no_speech_prob": 0.457034707069397}, {"id": 4, "seek": 2056, "start": 39.04, "end": 46.239999999999995, "text": " you already know what a compositor is. That runs entirely in your browser. You can control", "tokens": [51288, 291, 1217, 458, 437, 257, 10199, 3029, 307, 13, 663, 6676, 7696, 294, 428, 11185, 13, 509, 393, 1969, 51648], "temperature": 0.0, "avg_logprob": -0.19280003212593697, "compression_ratio": 1.4894736842105263, "no_speech_prob": 0.457034707069397}, {"id": 5, "seek": 4624, "start": 46.24, "end": 53.6, "text": " remote applications with it from different servers if you want. X applications as well,", "tokens": [50364, 8607, 5821, 365, 309, 490, 819, 15909, 498, 291, 528, 13, 1783, 5821, 382, 731, 11, 50732], "temperature": 0.0, "avg_logprob": -0.29431188807767983, "compression_ratio": 1.4648648648648648, "no_speech_prob": 0.08508788794279099}, {"id": 6, "seek": 4624, "start": 53.6, "end": 61.2, "text": " X Wayland applications. For that, that's also a fun fact. I actually had to port XCB library", "tokens": [50732, 1783, 9558, 1661, 5821, 13, 1171, 300, 11, 300, 311, 611, 257, 1019, 1186, 13, 286, 767, 632, 281, 2436, 1783, 34, 33, 6405, 51112], "temperature": 0.0, "avg_logprob": -0.29431188807767983, "compression_ratio": 1.4648648648648648, "no_speech_prob": 0.08508788794279099}, {"id": 7, "seek": 4624, "start": 61.2, "end": 69.56, "text": " to JavaScript, to TypeScript. So I have a Python parse X protocol files and have it output", "tokens": [51112, 281, 15778, 11, 281, 15576, 14237, 13, 407, 286, 362, 257, 15329, 48377, 1783, 10336, 7098, 293, 362, 309, 5598, 51530], "temperature": 0.0, "avg_logprob": -0.29431188807767983, "compression_ratio": 1.4648648648648648, "no_speech_prob": 0.08508788794279099}, {"id": 8, "seek": 6956, "start": 69.56, "end": 75.56, "text": " JavaScript and then you can run it in your browser. Works perfectly by the way. You can", "tokens": [50364, 15778, 293, 550, 291, 393, 1190, 309, 294, 428, 11185, 13, 27914, 6239, 538, 264, 636, 13, 509, 393, 50664], "temperature": 0.0, "avg_logprob": -0.17805500464005905, "compression_ratio": 1.7064220183486238, "no_speech_prob": 0.042640406638383865}, {"id": 9, "seek": 6956, "start": 75.56, "end": 83.24000000000001, "text": " also run Wayland applications directly in your browser. So actual native desktop applications", "tokens": [50664, 611, 1190, 9558, 1661, 5821, 3838, 294, 428, 11185, 13, 407, 3539, 8470, 14502, 5821, 51048], "temperature": 0.0, "avg_logprob": -0.17805500464005905, "compression_ratio": 1.7064220183486238, "no_speech_prob": 0.042640406638383865}, {"id": 10, "seek": 6956, "start": 83.24000000000001, "end": 90.68, "text": " compiled to WebAssembly and have them talk Wayland protocol to Greenfield inside your browser.", "tokens": [51048, 36548, 281, 9573, 10884, 19160, 293, 362, 552, 751, 9558, 1661, 10336, 281, 6969, 7610, 1854, 428, 11185, 13, 51420], "temperature": 0.0, "avg_logprob": -0.17805500464005905, "compression_ratio": 1.7064220183486238, "no_speech_prob": 0.042640406638383865}, {"id": 11, "seek": 6956, "start": 90.68, "end": 96.72, "text": " We're going to see some demos at the end of the talk as well. It doesn't have to be WebAssembly", "tokens": [51420, 492, 434, 516, 281, 536, 512, 33788, 412, 264, 917, 295, 264, 751, 382, 731, 13, 467, 1177, 380, 362, 281, 312, 9573, 10884, 19160, 51722], "temperature": 0.0, "avg_logprob": -0.17805500464005905, "compression_ratio": 1.7064220183486238, "no_speech_prob": 0.042640406638383865}, {"id": 12, "seek": 9672, "start": 96.72, "end": 102.0, "text": " applications. By the way, you can just write JavaScript applications. They just have to talk", "tokens": [50364, 5821, 13, 3146, 264, 636, 11, 291, 393, 445, 2464, 15778, 5821, 13, 814, 445, 362, 281, 751, 50628], "temperature": 0.0, "avg_logprob": -0.17122834982331267, "compression_ratio": 1.5847457627118644, "no_speech_prob": 0.037564825266599655}, {"id": 13, "seek": 9672, "start": 102.0, "end": 110.52, "text": " Wayland to have their pixels displayed on the screen and to handle input. So that's basically", "tokens": [50628, 9558, 1661, 281, 362, 641, 18668, 16372, 322, 264, 2568, 293, 281, 4813, 4846, 13, 407, 300, 311, 1936, 51054], "temperature": 0.0, "avg_logprob": -0.17122834982331267, "compression_ratio": 1.5847457627118644, "no_speech_prob": 0.037564825266599655}, {"id": 14, "seek": 9672, "start": 110.52, "end": 118.48, "text": " Greenfield in a nutshell. Why? For God's sake, why would you write this? Well, because I can,", "tokens": [51054, 6969, 7610, 294, 257, 37711, 13, 1545, 30, 1171, 1265, 311, 9717, 11, 983, 576, 291, 2464, 341, 30, 1042, 11, 570, 286, 393, 11, 51452], "temperature": 0.0, "avg_logprob": -0.17122834982331267, "compression_ratio": 1.5847457627118644, "no_speech_prob": 0.037564825266599655}, {"id": 15, "seek": 9672, "start": 118.48, "end": 125.08, "text": " that's basically the crutch of it. No. I had basically an idea. Wouldn't it be cool if we had", "tokens": [51452, 300, 311, 1936, 264, 941, 9349, 295, 309, 13, 883, 13, 286, 632, 1936, 364, 1558, 13, 26291, 380, 309, 312, 1627, 498, 321, 632, 51782], "temperature": 0.0, "avg_logprob": -0.17122834982331267, "compression_ratio": 1.5847457627118644, "no_speech_prob": 0.037564825266599655}, {"id": 16, "seek": 12508, "start": 125.12, "end": 132.8, "text": " a desktop that you could run anywhere? So not tied to a single physical piece of hardware you had", "tokens": [50366, 257, 14502, 300, 291, 727, 1190, 4992, 30, 407, 406, 9601, 281, 257, 2167, 4001, 2522, 295, 8837, 291, 632, 50750], "temperature": 0.0, "avg_logprob": -0.2827197667714712, "compression_ratio": 1.5578947368421052, "no_speech_prob": 0.0528891496360302}, {"id": 17, "seek": 12508, "start": 132.8, "end": 141.48, "text": " with a single interface for all your applications. So no longer bound to say, yeah, a smartphone or", "tokens": [50750, 365, 257, 2167, 9226, 337, 439, 428, 5821, 13, 407, 572, 2854, 5472, 281, 584, 11, 1338, 11, 257, 13307, 420, 51184], "temperature": 0.0, "avg_logprob": -0.2827197667714712, "compression_ratio": 1.5578947368421052, "no_speech_prob": 0.0528891496360302}, {"id": 18, "seek": 12508, "start": 141.48, "end": 150.0, "text": " a desktop or whatever. And yeah, so, and be free basically to run it where you want. So you're not", "tokens": [51184, 257, 14502, 420, 2035, 13, 400, 1338, 11, 370, 11, 293, 312, 1737, 1936, 281, 1190, 309, 689, 291, 528, 13, 407, 291, 434, 406, 51610], "temperature": 0.0, "avg_logprob": -0.2827197667714712, "compression_ratio": 1.5578947368421052, "no_speech_prob": 0.0528891496360302}, {"id": 19, "seek": 15000, "start": 150.32, "end": 156.72, "text": " bound to any SaaS provider or anything. Just have your own server or servers or whatever and have", "tokens": [50380, 5472, 281, 604, 49733, 12398, 420, 1340, 13, 1449, 362, 428, 1065, 7154, 420, 15909, 420, 2035, 293, 362, 50700], "temperature": 0.0, "avg_logprob": -0.21136419475078583, "compression_ratio": 1.515625, "no_speech_prob": 0.06253665685653687}, {"id": 20, "seek": 15000, "start": 156.72, "end": 163.84, "text": " the application distributed and basically access them anywhere you want, anytime you want without", "tokens": [50700, 264, 3861, 12631, 293, 1936, 2105, 552, 4992, 291, 528, 11, 13038, 291, 528, 1553, 51056], "temperature": 0.0, "avg_logprob": -0.21136419475078583, "compression_ratio": 1.515625, "no_speech_prob": 0.06253665685653687}, {"id": 21, "seek": 15000, "start": 163.84, "end": 170.36, "text": " restrictions purely for you. I thought that would be pretty cool. And it didn't exist. So a set", "tokens": [51056, 14191, 17491, 337, 291, 13, 286, 1194, 300, 576, 312, 1238, 1627, 13, 400, 309, 994, 380, 2514, 13, 407, 257, 992, 51382], "temperature": 0.0, "avg_logprob": -0.21136419475078583, "compression_ratio": 1.515625, "no_speech_prob": 0.06253665685653687}, {"id": 22, "seek": 17036, "start": 170.44000000000003, "end": 179.56, "text": " hell, I'll write it myself. Well, how is Wayland written? Well, in the browser, you're limited to", "tokens": [50368, 4921, 11, 286, 603, 2464, 309, 2059, 13, 1042, 11, 577, 307, 9558, 1661, 3720, 30, 1042, 11, 294, 264, 11185, 11, 291, 434, 5567, 281, 50824], "temperature": 0.0, "avg_logprob": -0.21287573777235946, "compression_ratio": 1.4871794871794872, "no_speech_prob": 0.41175729036331177}, {"id": 23, "seek": 17036, "start": 179.56, "end": 186.08, "text": " the JavaScript and WebAssembly. So in the case of Greenfield, most of it is TypeScript that's then", "tokens": [50824, 264, 15778, 293, 9573, 10884, 19160, 13, 407, 294, 264, 1389, 295, 6969, 7610, 11, 881, 295, 309, 307, 15576, 14237, 300, 311, 550, 51150], "temperature": 0.0, "avg_logprob": -0.21287573777235946, "compression_ratio": 1.4871794871794872, "no_speech_prob": 0.41175729036331177}, {"id": 24, "seek": 17036, "start": 186.08, "end": 193.20000000000002, "text": " processed to JavaScript. And there's also a bunch of C involved, mostly existing C libraries,", "tokens": [51150, 18846, 281, 15778, 13, 400, 456, 311, 611, 257, 3840, 295, 383, 3288, 11, 5240, 6741, 383, 15148, 11, 51506], "temperature": 0.0, "avg_logprob": -0.21287573777235946, "compression_ratio": 1.4871794871794872, "no_speech_prob": 0.41175729036331177}, {"id": 25, "seek": 19320, "start": 193.64, "end": 202.79999999999998, "text": " things like lipxkb common is compiled to WebAssembly to handle all the keyboard layouts and keyboard", "tokens": [50386, 721, 411, 8280, 87, 74, 65, 2689, 307, 36548, 281, 9573, 10884, 19160, 281, 4813, 439, 264, 10186, 46100, 293, 10186, 50844], "temperature": 0.0, "avg_logprob": -0.21456537541654921, "compression_ratio": 1.646090534979424, "no_speech_prob": 0.0241668913513422}, {"id": 26, "seek": 19320, "start": 202.79999999999998, "end": 210.28, "text": " encodings. There's also lippixman basically to region handling. I'm not going to reinvent the wheel,", "tokens": [50844, 2058, 378, 1109, 13, 821, 311, 611, 8280, 79, 970, 1601, 1936, 281, 4458, 13175, 13, 286, 478, 406, 516, 281, 33477, 264, 5589, 11, 51218], "temperature": 0.0, "avg_logprob": -0.21456537541654921, "compression_ratio": 1.646090534979424, "no_speech_prob": 0.0241668913513422}, {"id": 27, "seek": 19320, "start": 210.28, "end": 216.0, "text": " I'm not going to write those things in JavaScript. So I took the existing libraries, ported them to", "tokens": [51218, 286, 478, 406, 516, 281, 2464, 729, 721, 294, 15778, 13, 407, 286, 1890, 264, 6741, 15148, 11, 2436, 292, 552, 281, 51504], "temperature": 0.0, "avg_logprob": -0.21456537541654921, "compression_ratio": 1.646090534979424, "no_speech_prob": 0.0241668913513422}, {"id": 28, "seek": 19320, "start": 216.0, "end": 222.92, "text": " WebAssembly and made them accessible inside the browser. The display part of Greenfield is written", "tokens": [51504, 9573, 10884, 19160, 293, 1027, 552, 9515, 1854, 264, 11185, 13, 440, 4674, 644, 295, 6969, 7610, 307, 3720, 51850], "temperature": 0.0, "avg_logprob": -0.21456537541654921, "compression_ratio": 1.646090534979424, "no_speech_prob": 0.0241668913513422}, {"id": 29, "seek": 22292, "start": 223.16, "end": 230.6, "text": " in WebGL to have any kind of decent performance. It's very similar to how a normal or say a native", "tokens": [50376, 294, 9573, 19440, 281, 362, 604, 733, 295, 8681, 3389, 13, 467, 311, 588, 2531, 281, 577, 257, 2710, 420, 584, 257, 8470, 50748], "temperature": 0.0, "avg_logprob": -0.14860029118035428, "compression_ratio": 1.6536796536796536, "no_speech_prob": 0.004494158551096916}, {"id": 30, "seek": 22292, "start": 230.6, "end": 238.44, "text": " Wayland compositor would would composite using OpenGL. So in the browser case, it's WebGL. To deal", "tokens": [50748, 9558, 1661, 10199, 3029, 576, 576, 25557, 1228, 7238, 19440, 13, 407, 294, 264, 11185, 1389, 11, 309, 311, 9573, 19440, 13, 1407, 2028, 51140], "temperature": 0.0, "avg_logprob": -0.14860029118035428, "compression_ratio": 1.6536796536796536, "no_speech_prob": 0.004494158551096916}, {"id": 31, "seek": 22292, "start": 238.44, "end": 244.88, "text": " with the remote applications, that was you need basically a proxy. So the native applications", "tokens": [51140, 365, 264, 8607, 5821, 11, 300, 390, 291, 643, 1936, 257, 29690, 13, 407, 264, 8470, 5821, 51462], "temperature": 0.0, "avg_logprob": -0.14860029118035428, "compression_ratio": 1.6536796536796536, "no_speech_prob": 0.004494158551096916}, {"id": 32, "seek": 22292, "start": 244.88, "end": 251.0, "text": " have to find a socket to connect to a Wayland socket to connect to and have those messages", "tokens": [51462, 362, 281, 915, 257, 19741, 281, 1745, 281, 257, 9558, 1661, 19741, 281, 1745, 281, 293, 362, 729, 7897, 51768], "temperature": 0.0, "avg_logprob": -0.14860029118035428, "compression_ratio": 1.6536796536796536, "no_speech_prob": 0.004494158551096916}, {"id": 33, "seek": 25100, "start": 251.08, "end": 257.96, "text": " handled, have the native buffers handled and have the protocol sent to the browser. So I wrote", "tokens": [50368, 18033, 11, 362, 264, 8470, 9204, 433, 18033, 293, 362, 264, 10336, 2279, 281, 264, 11185, 13, 407, 286, 4114, 50712], "temperature": 0.0, "avg_logprob": -0.24636354049046835, "compression_ratio": 1.6964285714285714, "no_speech_prob": 0.03398173302412033}, {"id": 34, "seek": 25100, "start": 257.96, "end": 266.44, "text": " server in TypeScript. I'm sorry guys. I needed something that was I could prototype fast and", "tokens": [50712, 7154, 294, 15576, 14237, 13, 286, 478, 2597, 1074, 13, 286, 2978, 746, 300, 390, 286, 727, 19475, 2370, 293, 51136], "temperature": 0.0, "avg_logprob": -0.24636354049046835, "compression_ratio": 1.6964285714285714, "no_speech_prob": 0.03398173302412033}, {"id": 35, "seek": 25100, "start": 266.44, "end": 271.16, "text": " without dealing with seq faults and everything. So I did it in TypeScript and it grew a bit and now", "tokens": [51136, 1553, 6260, 365, 369, 80, 36090, 293, 1203, 13, 407, 286, 630, 309, 294, 15576, 14237, 293, 309, 6109, 257, 857, 293, 586, 51372], "temperature": 0.0, "avg_logprob": -0.24636354049046835, "compression_ratio": 1.6964285714285714, "no_speech_prob": 0.03398173302412033}, {"id": 36, "seek": 25100, "start": 271.16, "end": 277.0, "text": " it's a bit bigger. So I guess some point in the future, I promise I will rewrite it and rust", "tokens": [51372, 309, 311, 257, 857, 3801, 13, 407, 286, 2041, 512, 935, 294, 264, 2027, 11, 286, 6228, 286, 486, 28132, 309, 293, 15259, 51664], "temperature": 0.0, "avg_logprob": -0.24636354049046835, "compression_ratio": 1.6964285714285714, "no_speech_prob": 0.03398173302412033}, {"id": 37, "seek": 27700, "start": 277.4, "end": 284.2, "text": " somewhere in the future, I guess. Also the performance critical parts of the whole pipeline", "tokens": [50384, 4079, 294, 264, 2027, 11, 286, 2041, 13, 2743, 264, 3389, 4924, 3166, 295, 264, 1379, 15517, 50724], "temperature": 0.0, "avg_logprob": -0.14336741598028885, "compression_ratio": 1.5864978902953586, "no_speech_prob": 0.019854610785841942}, {"id": 38, "seek": 27700, "start": 284.2, "end": 290.36, "text": " are written in C using Gstreamer as well. So there is a tight integration there. Gstreamer,", "tokens": [50724, 366, 3720, 294, 383, 1228, 460, 9291, 260, 382, 731, 13, 407, 456, 307, 257, 4524, 10980, 456, 13, 460, 9291, 260, 11, 51032], "temperature": 0.0, "avg_logprob": -0.14336741598028885, "compression_ratio": 1.5864978902953586, "no_speech_prob": 0.019854610785841942}, {"id": 39, "seek": 27700, "start": 290.36, "end": 298.44, "text": " really cool project. It does basically everything I needed. Very modular. I could do all kinds of", "tokens": [51032, 534, 1627, 1716, 13, 467, 775, 1936, 1203, 286, 2978, 13, 4372, 31111, 13, 286, 727, 360, 439, 3685, 295, 51436], "temperature": 0.0, "avg_logprob": -0.14336741598028885, "compression_ratio": 1.5864978902953586, "no_speech_prob": 0.019854610785841942}, {"id": 40, "seek": 27700, "start": 298.44, "end": 305.32, "text": " cool stuff with it. I'll show that a bit later. If there are any Gstreamer faults in the room,", "tokens": [51436, 1627, 1507, 365, 309, 13, 286, 603, 855, 300, 257, 857, 1780, 13, 759, 456, 366, 604, 460, 9291, 260, 36090, 294, 264, 1808, 11, 51780], "temperature": 0.0, "avg_logprob": -0.14336741598028885, "compression_ratio": 1.5864978902953586, "no_speech_prob": 0.019854610785841942}, {"id": 41, "seek": 30532, "start": 305.32, "end": 312.44, "text": " the only thing I missed a bit was color conversion on the GPU. So a hint that would be cool to have.", "tokens": [50364, 264, 787, 551, 286, 6721, 257, 857, 390, 2017, 14298, 322, 264, 18407, 13, 407, 257, 12075, 300, 576, 312, 1627, 281, 362, 13, 50720], "temperature": 0.0, "avg_logprob": -0.09856586022810503, "compression_ratio": 1.5425531914893618, "no_speech_prob": 0.002388870809227228}, {"id": 42, "seek": 30532, "start": 313.24, "end": 320.52, "text": " At some point, I also wrote a Kubernetes implementation basically. So that basically means", "tokens": [50760, 1711, 512, 935, 11, 286, 611, 4114, 257, 23145, 11420, 1936, 13, 407, 300, 1936, 1355, 51124], "temperature": 0.0, "avg_logprob": -0.09856586022810503, "compression_ratio": 1.5425531914893618, "no_speech_prob": 0.002388870809227228}, {"id": 43, "seek": 30532, "start": 320.52, "end": 327.56, "text": " that you could use an entire Kubernetes cluster as your desktop. So every application would be its", "tokens": [51124, 300, 291, 727, 764, 364, 2302, 23145, 13630, 382, 428, 14502, 13, 407, 633, 3861, 576, 312, 1080, 51476], "temperature": 0.0, "avg_logprob": -0.09856586022810503, "compression_ratio": 1.5425531914893618, "no_speech_prob": 0.002388870809227228}, {"id": 44, "seek": 32756, "start": 327.56, "end": 336.12, "text": " own part. So you could run 20 performance intensive applications, have them all run on separate", "tokens": [50364, 1065, 644, 13, 407, 291, 727, 1190, 945, 3389, 18957, 5821, 11, 362, 552, 439, 1190, 322, 4994, 50792], "temperature": 0.0, "avg_logprob": -0.13704970713411824, "compression_ratio": 1.5731707317073171, "no_speech_prob": 0.05702553689479828}, {"id": 45, "seek": 32756, "start": 336.12, "end": 342.2, "text": " machines, all running smoothly, basically giving you virtually unlimited resources on your desktop.", "tokens": [50792, 8379, 11, 439, 2614, 19565, 11, 1936, 2902, 291, 14103, 21950, 3593, 322, 428, 14502, 13, 51096], "temperature": 0.0, "avg_logprob": -0.13704970713411824, "compression_ratio": 1.5731707317073171, "no_speech_prob": 0.05702553689479828}, {"id": 46, "seek": 32756, "start": 343.0, "end": 349.08, "text": " So that's going in the direction I had in mind. Sadly not open source for the moment. Maybe", "tokens": [51136, 407, 300, 311, 516, 294, 264, 3513, 286, 632, 294, 1575, 13, 29628, 406, 1269, 4009, 337, 264, 1623, 13, 2704, 51440], "temperature": 0.0, "avg_logprob": -0.13704970713411824, "compression_ratio": 1.5731707317073171, "no_speech_prob": 0.05702553689479828}, {"id": 47, "seek": 32756, "start": 349.72, "end": 355.64, "text": " someday in the future, if it's gone out of prototype phase, perhaps I can give a talk about it too.", "tokens": [51472, 19412, 294, 264, 2027, 11, 498, 309, 311, 2780, 484, 295, 19475, 5574, 11, 4317, 286, 393, 976, 257, 751, 466, 309, 886, 13, 51768], "temperature": 0.0, "avg_logprob": -0.13704970713411824, "compression_ratio": 1.5731707317073171, "no_speech_prob": 0.05702553689479828}, {"id": 48, "seek": 35564, "start": 356.12, "end": 363.56, "text": " And last but not least, blood, sweat and tears. This is like a side project, a hobby project. So I", "tokens": [50388, 400, 1036, 457, 406, 1935, 11, 3390, 11, 11872, 293, 10462, 13, 639, 307, 411, 257, 1252, 1716, 11, 257, 18240, 1716, 13, 407, 286, 50760], "temperature": 0.0, "avg_logprob": -0.16280946613829814, "compression_ratio": 1.5101010101010102, "no_speech_prob": 0.004290605429559946}, {"id": 49, "seek": 35564, "start": 363.56, "end": 369.8, "text": " was not working on it full time. So at some point, I had to sacrifice a bit of sleep to make some", "tokens": [50760, 390, 406, 1364, 322, 309, 1577, 565, 13, 407, 412, 512, 935, 11, 286, 632, 281, 11521, 257, 857, 295, 2817, 281, 652, 512, 51072], "temperature": 0.0, "avg_logprob": -0.16280946613829814, "compression_ratio": 1.5101010101010102, "no_speech_prob": 0.004290605429559946}, {"id": 50, "seek": 35564, "start": 369.8, "end": 379.15999999999997, "text": " progress. I do not recommend, by the way. So here we have an overview, a pipeline overview, how frames", "tokens": [51072, 4205, 13, 286, 360, 406, 2748, 11, 538, 264, 636, 13, 407, 510, 321, 362, 364, 12492, 11, 257, 15517, 12492, 11, 577, 12083, 51540], "temperature": 0.0, "avg_logprob": -0.16280946613829814, "compression_ratio": 1.5101010101010102, "no_speech_prob": 0.004290605429559946}, {"id": 51, "seek": 37916, "start": 379.24, "end": 386.68, "text": " are sent from your native site to the browser. So on the top part, we basically have everything", "tokens": [50368, 366, 2279, 490, 428, 8470, 3621, 281, 264, 11185, 13, 407, 322, 264, 1192, 644, 11, 321, 1936, 362, 1203, 50740], "temperature": 0.0, "avg_logprob": -0.08422216435068662, "compression_ratio": 1.955, "no_speech_prob": 0.02551097981631756}, {"id": 52, "seek": 37916, "start": 386.68, "end": 392.12, "text": " that happens on the GPU. On the bottom part, we have everything that happens on the CPU. So we're", "tokens": [50740, 300, 2314, 322, 264, 18407, 13, 1282, 264, 2767, 644, 11, 321, 362, 1203, 300, 2314, 322, 264, 13199, 13, 407, 321, 434, 51012], "temperature": 0.0, "avg_logprob": -0.08422216435068662, "compression_ratio": 1.955, "no_speech_prob": 0.02551097981631756}, {"id": 53, "seek": 37916, "start": 392.12, "end": 399.16, "text": " going to start from left to right. On the left, we have an application that renders either on the", "tokens": [51012, 516, 281, 722, 490, 1411, 281, 558, 13, 1282, 264, 1411, 11, 321, 362, 364, 3861, 300, 6125, 433, 2139, 322, 264, 51364], "temperature": 0.0, "avg_logprob": -0.08422216435068662, "compression_ratio": 1.955, "no_speech_prob": 0.02551097981631756}, {"id": 54, "seek": 37916, "start": 399.16, "end": 408.6, "text": " GPU or on the CPU using GPU memory buffers or shared memory buffers on the CPU. When an application", "tokens": [51364, 18407, 420, 322, 264, 13199, 1228, 18407, 4675, 9204, 433, 420, 5507, 4675, 9204, 433, 322, 264, 13199, 13, 1133, 364, 3861, 51836], "temperature": 0.0, "avg_logprob": -0.08422216435068662, "compression_ratio": 1.955, "no_speech_prob": 0.02551097981631756}, {"id": 55, "seek": 40860, "start": 408.6, "end": 415.0, "text": " submits those pixels to the native compositor, so that's our proxy compositor that I talked about", "tokens": [50364, 8286, 1208, 729, 18668, 281, 264, 8470, 10199, 3029, 11, 370, 300, 311, 527, 29690, 10199, 3029, 300, 286, 2825, 466, 50684], "temperature": 0.0, "avg_logprob": -0.08379422801814668, "compression_ratio": 1.6222222222222222, "no_speech_prob": 0.0025061885826289654}, {"id": 56, "seek": 40860, "start": 415.0, "end": 425.96000000000004, "text": " before, then those buffers are basically handled and they are color split. So we need to get these", "tokens": [50684, 949, 11, 550, 729, 9204, 433, 366, 1936, 18033, 293, 436, 366, 2017, 7472, 13, 407, 321, 643, 281, 483, 613, 51232], "temperature": 0.0, "avg_logprob": -0.08379422801814668, "compression_ratio": 1.6222222222222222, "no_speech_prob": 0.0025061885826289654}, {"id": 57, "seek": 40860, "start": 425.96000000000004, "end": 432.04, "text": " buffers to the browser and we need to compress them. Ideally, we do that using video encodings.", "tokens": [51232, 9204, 433, 281, 264, 11185, 293, 321, 643, 281, 14778, 552, 13, 40817, 11, 321, 360, 300, 1228, 960, 2058, 378, 1109, 13, 51536], "temperature": 0.0, "avg_logprob": -0.08379422801814668, "compression_ratio": 1.6222222222222222, "no_speech_prob": 0.0025061885826289654}, {"id": 58, "seek": 43204, "start": 433.0, "end": 440.04, "text": " But to do that, there are a few issues. Most color buffers that we get from the applications,", "tokens": [50412, 583, 281, 360, 300, 11, 456, 366, 257, 1326, 2663, 13, 4534, 2017, 9204, 433, 300, 321, 483, 490, 264, 5821, 11, 50764], "temperature": 0.0, "avg_logprob": -0.17766987759134042, "compression_ratio": 1.6297872340425532, "no_speech_prob": 0.007922339253127575}, {"id": 59, "seek": 43204, "start": 440.04, "end": 446.44, "text": " they have an alpha channel. This day, we have cool virtual reality headsets that just launched. We", "tokens": [50764, 436, 362, 364, 8961, 2269, 13, 639, 786, 11, 321, 362, 1627, 6374, 4103, 8050, 1385, 300, 445, 8730, 13, 492, 51084], "temperature": 0.0, "avg_logprob": -0.17766987759134042, "compression_ratio": 1.6297872340425532, "no_speech_prob": 0.007922339253127575}, {"id": 60, "seek": 43204, "start": 446.44, "end": 451.32000000000005, "text": " have awesome artificial intelligence. We do not have video codecs that can handle alpha encode.", "tokens": [51084, 362, 3476, 11677, 7599, 13, 492, 360, 406, 362, 960, 3089, 14368, 300, 393, 4813, 8961, 2058, 1429, 13, 51328], "temperature": 0.0, "avg_logprob": -0.17766987759134042, "compression_ratio": 1.6297872340425532, "no_speech_prob": 0.007922339253127575}, {"id": 61, "seek": 43204, "start": 453.72, "end": 461.32000000000005, "text": " So I had to split the color into an RGB and an alpha and those are actually two separate video", "tokens": [51448, 407, 286, 632, 281, 7472, 264, 2017, 666, 364, 31231, 293, 364, 8961, 293, 729, 366, 767, 732, 4994, 960, 51828], "temperature": 0.0, "avg_logprob": -0.17766987759134042, "compression_ratio": 1.6297872340425532, "no_speech_prob": 0.007922339253127575}, {"id": 62, "seek": 46132, "start": 461.71999999999997, "end": 468.59999999999997, "text": " streams. So the alpha color conversion is handled as a black and white video stream. This is done", "tokens": [50384, 15842, 13, 407, 264, 8961, 2017, 14298, 307, 18033, 382, 257, 2211, 293, 2418, 960, 4309, 13, 639, 307, 1096, 50728], "temperature": 0.0, "avg_logprob": -0.10153553220960829, "compression_ratio": 1.6696428571428572, "no_speech_prob": 0.005141387693583965}, {"id": 63, "seek": 46132, "start": 468.59999999999997, "end": 474.68, "text": " on the GPU if possible and there is a fallback to CPU encoding if it's not available.", "tokens": [50728, 322, 264, 18407, 498, 1944, 293, 456, 307, 257, 2100, 3207, 281, 13199, 43430, 498, 309, 311, 406, 2435, 13, 51032], "temperature": 0.0, "avg_logprob": -0.10153553220960829, "compression_ratio": 1.6696428571428572, "no_speech_prob": 0.005141387693583965}, {"id": 64, "seek": 46132, "start": 476.12, "end": 482.28, "text": " There's also the color conversion that also always happens on the GPU. And then those two frames,", "tokens": [51104, 821, 311, 611, 264, 2017, 14298, 300, 611, 1009, 2314, 322, 264, 18407, 13, 400, 550, 729, 732, 12083, 11, 51412], "temperature": 0.0, "avg_logprob": -0.10153553220960829, "compression_ratio": 1.6696428571428572, "no_speech_prob": 0.005141387693583965}, {"id": 65, "seek": 46132, "start": 482.28, "end": 490.12, "text": " those two video frames are then sent using a WebSocket server to the browser. A small remark", "tokens": [51412, 729, 732, 960, 12083, 366, 550, 2279, 1228, 257, 9573, 50, 31380, 7154, 281, 264, 11185, 13, 316, 1359, 7942, 51804], "temperature": 0.0, "avg_logprob": -0.10153553220960829, "compression_ratio": 1.6696428571428572, "no_speech_prob": 0.005141387693583965}, {"id": 66, "seek": 49012, "start": 490.12, "end": 497.16, "text": " there, WebSocket server, it's TCP. We're dealing with a real-time application here. Ideally,", "tokens": [50364, 456, 11, 9573, 50, 31380, 7154, 11, 309, 311, 48965, 13, 492, 434, 6260, 365, 257, 957, 12, 3766, 3861, 510, 13, 40817, 11, 50716], "temperature": 0.0, "avg_logprob": -0.15668473641077676, "compression_ratio": 1.5690376569037656, "no_speech_prob": 0.004453448578715324}, {"id": 67, "seek": 49012, "start": 497.16, "end": 502.44, "text": " ideally, people would use something like WebTransport which uses UDP but it's a bit still", "tokens": [50716, 22915, 11, 561, 576, 764, 746, 411, 9573, 33339, 2707, 597, 4960, 624, 11373, 457, 309, 311, 257, 857, 920, 50980], "temperature": 0.0, "avg_logprob": -0.15668473641077676, "compression_ratio": 1.5690376569037656, "no_speech_prob": 0.004453448578715324}, {"id": 68, "seek": 49012, "start": 502.44, "end": 508.28000000000003, "text": " experimental. Not a lot of implementations there for the moment so we're stuck with WebSocket.", "tokens": [50980, 17069, 13, 1726, 257, 688, 295, 4445, 763, 456, 337, 264, 1623, 370, 321, 434, 5541, 365, 9573, 50, 31380, 13, 51272], "temperature": 0.0, "avg_logprob": -0.15668473641077676, "compression_ratio": 1.5690376569037656, "no_speech_prob": 0.004453448578715324}, {"id": 69, "seek": 49012, "start": 509.4, "end": 514.6800000000001, "text": " The frames arrive on the browser and there we have to decode the video streams, the video frames.", "tokens": [51328, 440, 12083, 8881, 322, 264, 11185, 293, 456, 321, 362, 281, 979, 1429, 264, 960, 15842, 11, 264, 960, 12083, 13, 51592], "temperature": 0.0, "avg_logprob": -0.15668473641077676, "compression_ratio": 1.5690376569037656, "no_speech_prob": 0.004453448578715324}, {"id": 70, "seek": 51468, "start": 515.64, "end": 522.76, "text": " This is done for Firefox only, sadly, using WebWorkers where I ported", "tokens": [50412, 639, 307, 1096, 337, 46613, 787, 11, 22023, 11, 1228, 9573, 28846, 433, 689, 286, 2436, 292, 50768], "temperature": 0.0, "avg_logprob": -0.17824133848532653, "compression_ratio": 1.3870967741935485, "no_speech_prob": 0.005282108671963215}, {"id": 71, "seek": 51468, "start": 523.8, "end": 531.9599999999999, "text": " FFMPEG to WebAssembly for H.264 as well. To do that, for the other browsers, I used the WebCodec", "tokens": [50820, 479, 37, 44, 5208, 38, 281, 9573, 10884, 19160, 337, 389, 13, 10880, 19, 382, 731, 13, 1407, 360, 300, 11, 337, 264, 661, 36069, 11, 286, 1143, 264, 9573, 34, 1429, 66, 51228], "temperature": 0.0, "avg_logprob": -0.17824133848532653, "compression_ratio": 1.3870967741935485, "no_speech_prob": 0.005282108671963215}, {"id": 72, "seek": 51468, "start": 532.5999999999999, "end": 539.7199999999999, "text": " standard so I can have the browser do all the artwork and have the video frame decoded. And", "tokens": [51260, 3832, 370, 286, 393, 362, 264, 11185, 360, 439, 264, 15829, 293, 362, 264, 960, 3920, 979, 12340, 13, 400, 51616], "temperature": 0.0, "avg_logprob": -0.17824133848532653, "compression_ratio": 1.3870967741935485, "no_speech_prob": 0.005282108671963215}, {"id": 73, "seek": 53972, "start": 539.72, "end": 545.48, "text": " then last but not least, there is a WebGL shader that puts the colors back together. So we have the", "tokens": [50364, 550, 1036, 457, 406, 1935, 11, 456, 307, 257, 9573, 19440, 5744, 260, 300, 8137, 264, 4577, 646, 1214, 13, 407, 321, 362, 264, 50652], "temperature": 0.0, "avg_logprob": -0.1126833443689828, "compression_ratio": 1.6858407079646018, "no_speech_prob": 0.014188073575496674}, {"id": 74, "seek": 53972, "start": 545.48, "end": 552.6, "text": " RGB frame, we have the alpha frame, we stitch them back together and we push them to WebGL texture", "tokens": [50652, 31231, 3920, 11, 321, 362, 264, 8961, 3920, 11, 321, 5635, 552, 646, 1214, 293, 321, 2944, 552, 281, 9573, 19440, 8091, 51008], "temperature": 0.0, "avg_logprob": -0.1126833443689828, "compression_ratio": 1.6858407079646018, "no_speech_prob": 0.014188073575496674}, {"id": 75, "seek": 53972, "start": 552.6, "end": 559.96, "text": " and paint them nicely on the screen. That was a long trip. This is all how we go from the", "tokens": [51008, 293, 4225, 552, 9594, 322, 264, 2568, 13, 663, 390, 257, 938, 4931, 13, 639, 307, 439, 577, 321, 352, 490, 264, 51376], "temperature": 0.0, "avg_logprob": -0.1126833443689828, "compression_ratio": 1.6858407079646018, "no_speech_prob": 0.014188073575496674}, {"id": 76, "seek": 53972, "start": 559.96, "end": 566.76, "text": " application to the compositor. So far so good. But Wayland also has a few mechanisms to tell", "tokens": [51376, 3861, 281, 264, 10199, 3029, 13, 407, 1400, 370, 665, 13, 583, 9558, 1661, 611, 575, 257, 1326, 15902, 281, 980, 51716], "temperature": 0.0, "avg_logprob": -0.1126833443689828, "compression_ratio": 1.6858407079646018, "no_speech_prob": 0.014188073575496674}, {"id": 77, "seek": 56676, "start": 567.72, "end": 575.4, "text": " the application, hey, I'm done painting your pixels, you can send me the next batch if you were to", "tokens": [50412, 264, 3861, 11, 4177, 11, 286, 478, 1096, 5370, 428, 18668, 11, 291, 393, 2845, 385, 264, 958, 15245, 498, 291, 645, 281, 50796], "temperature": 0.0, "avg_logprob": -0.1368676397535536, "compression_ratio": 1.7235023041474655, "no_speech_prob": 0.008048978634178638}, {"id": 78, "seek": 56676, "start": 575.4, "end": 582.52, "text": " please. But there is a bit of an issue here. Wayland is an asynchronous protocol but the", "tokens": [50796, 1767, 13, 583, 456, 307, 257, 857, 295, 364, 2734, 510, 13, 9558, 1661, 307, 364, 49174, 10336, 457, 264, 51152], "temperature": 0.0, "avg_logprob": -0.1368676397535536, "compression_ratio": 1.7235023041474655, "no_speech_prob": 0.008048978634178638}, {"id": 79, "seek": 56676, "start": 582.52, "end": 587.96, "text": " dealing with sending a frame and the compositor telling the application, send me the next frame,", "tokens": [51152, 6260, 365, 7750, 257, 3920, 293, 264, 10199, 3029, 3585, 264, 3861, 11, 2845, 385, 264, 958, 3920, 11, 51424], "temperature": 0.0, "avg_logprob": -0.1368676397535536, "compression_ratio": 1.7235023041474655, "no_speech_prob": 0.008048978634178638}, {"id": 80, "seek": 56676, "start": 587.96, "end": 593.8, "text": " that's a whole slow synchronous process. So what that means is that if this pipeline were", "tokens": [51424, 300, 311, 257, 1379, 2964, 44743, 1399, 13, 407, 437, 300, 1355, 307, 300, 498, 341, 15517, 645, 51716], "temperature": 0.0, "avg_logprob": -0.1368676397535536, "compression_ratio": 1.7235023041474655, "no_speech_prob": 0.008048978634178638}, {"id": 81, "seek": 59380, "start": 593.8, "end": 599.7199999999999, "text": " to take no milliseconds, you still have your network latency. Say we have 50 millisecond", "tokens": [50364, 281, 747, 572, 34184, 11, 291, 920, 362, 428, 3209, 27043, 13, 6463, 321, 362, 2625, 27940, 18882, 50660], "temperature": 0.0, "avg_logprob": -0.11803650437739857, "compression_ratio": 1.8849206349206349, "no_speech_prob": 0.005709594115614891}, {"id": 82, "seek": 59380, "start": 599.7199999999999, "end": 604.4399999999999, "text": " network latency, we immediately send the frame to the compositor and then the compositor tells the", "tokens": [50660, 3209, 27043, 11, 321, 4258, 2845, 264, 3920, 281, 264, 10199, 3029, 293, 550, 264, 10199, 3029, 5112, 264, 50896], "temperature": 0.0, "avg_logprob": -0.11803650437739857, "compression_ratio": 1.8849206349206349, "no_speech_prob": 0.005709594115614891}, {"id": 83, "seek": 59380, "start": 604.4399999999999, "end": 609.4, "text": " application, okay, I'm done, you can send me the next one. You have about 50 milliseconds", "tokens": [50896, 3861, 11, 1392, 11, 286, 478, 1096, 11, 291, 393, 2845, 385, 264, 958, 472, 13, 509, 362, 466, 2625, 34184, 51144], "temperature": 0.0, "avg_logprob": -0.11803650437739857, "compression_ratio": 1.8849206349206349, "no_speech_prob": 0.005709594115614891}, {"id": 84, "seek": 59380, "start": 610.52, "end": 616.8399999999999, "text": " between each frame. So that gives you around 20 frames per second. That's not really acceptable.", "tokens": [51200, 1296, 1184, 3920, 13, 407, 300, 2709, 291, 926, 945, 12083, 680, 1150, 13, 663, 311, 406, 534, 15513, 13, 51516], "temperature": 0.0, "avg_logprob": -0.11803650437739857, "compression_ratio": 1.8849206349206349, "no_speech_prob": 0.005709594115614891}, {"id": 85, "seek": 59380, "start": 617.7199999999999, "end": 623.0799999999999, "text": " So we're going to have to be a bit smart and we're going to have to tell the application in advance,", "tokens": [51560, 407, 321, 434, 516, 281, 362, 281, 312, 257, 857, 4069, 293, 321, 434, 516, 281, 362, 281, 980, 264, 3861, 294, 7295, 11, 51828], "temperature": 0.0, "avg_logprob": -0.11803650437739857, "compression_ratio": 1.8849206349206349, "no_speech_prob": 0.005709594115614891}, {"id": 86, "seek": 62308, "start": 623.1600000000001, "end": 630.2, "text": " like hey, you can already send the next frame because I think the compositor is probably already", "tokens": [50368, 411, 4177, 11, 291, 393, 1217, 2845, 264, 958, 3920, 570, 286, 519, 264, 10199, 3029, 307, 1391, 1217, 50720], "temperature": 0.0, "avg_logprob": -0.08886693799218466, "compression_ratio": 1.6523605150214593, "no_speech_prob": 0.0007315900875255466}, {"id": 87, "seek": 62308, "start": 630.2, "end": 637.32, "text": " done handling your previous frame. So that is basically the round trip latency problem that we", "tokens": [50720, 1096, 13175, 428, 3894, 3920, 13, 407, 300, 307, 1936, 264, 3098, 4931, 27043, 1154, 300, 321, 51076], "temperature": 0.0, "avg_logprob": -0.08886693799218466, "compression_ratio": 1.6523605150214593, "no_speech_prob": 0.0007315900875255466}, {"id": 88, "seek": 62308, "start": 637.32, "end": 643.4000000000001, "text": " have. And there are generally two mechanisms in the Wayland protocol. The first one is the one I", "tokens": [51076, 362, 13, 400, 456, 366, 5101, 732, 15902, 294, 264, 9558, 1661, 10336, 13, 440, 700, 472, 307, 264, 472, 286, 51380], "temperature": 0.0, "avg_logprob": -0.08886693799218466, "compression_ratio": 1.6523605150214593, "no_speech_prob": 0.0007315900875255466}, {"id": 89, "seek": 62308, "start": 643.4000000000001, "end": 650.0400000000001, "text": " just talked about which is the frame callbacks, which is the compositor telling the application,", "tokens": [51380, 445, 2825, 466, 597, 307, 264, 3920, 818, 17758, 11, 597, 307, 264, 10199, 3029, 3585, 264, 3861, 11, 51712], "temperature": 0.0, "avg_logprob": -0.08886693799218466, "compression_ratio": 1.6523605150214593, "no_speech_prob": 0.0007315900875255466}, {"id": 90, "seek": 65004, "start": 650.04, "end": 655.9599999999999, "text": " I'm done painting your pixels. The other one is the sync request. The sync request in the", "tokens": [50364, 286, 478, 1096, 5370, 428, 18668, 13, 440, 661, 472, 307, 264, 20271, 5308, 13, 440, 20271, 5308, 294, 264, 50660], "temperature": 0.0, "avg_logprob": -0.052589533064100476, "compression_ratio": 1.8066037735849056, "no_speech_prob": 0.001595919718965888}, {"id": 91, "seek": 65004, "start": 655.9599999999999, "end": 662.8399999999999, "text": " Wayland protocol is a way for an application to know when all previous requests that have been", "tokens": [50660, 9558, 1661, 10336, 307, 257, 636, 337, 364, 3861, 281, 458, 562, 439, 3894, 12475, 300, 362, 668, 51004], "temperature": 0.0, "avg_logprob": -0.052589533064100476, "compression_ratio": 1.8066037735849056, "no_speech_prob": 0.001595919718965888}, {"id": 92, "seek": 65004, "start": 662.8399999999999, "end": 669.64, "text": " sent are done. So when an application sends a request to a compositor, those requests are queued", "tokens": [51004, 2279, 366, 1096, 13, 407, 562, 364, 3861, 14790, 257, 5308, 281, 257, 10199, 3029, 11, 729, 12475, 366, 631, 5827, 51344], "temperature": 0.0, "avg_logprob": -0.052589533064100476, "compression_ratio": 1.8066037735849056, "no_speech_prob": 0.001595919718965888}, {"id": 93, "seek": 65004, "start": 669.64, "end": 676.92, "text": " up. And when an application sends a sync request, then the compositor will simply, once it encounters", "tokens": [51344, 493, 13, 400, 562, 364, 3861, 14790, 257, 20271, 5308, 11, 550, 264, 10199, 3029, 486, 2935, 11, 1564, 309, 26310, 51708], "temperature": 0.0, "avg_logprob": -0.052589533064100476, "compression_ratio": 1.8066037735849056, "no_speech_prob": 0.001595919718965888}, {"id": 94, "seek": 67692, "start": 676.92, "end": 681.7199999999999, "text": " that sync request, will simply reply with done. And then the application know, oh, I got a done", "tokens": [50364, 300, 20271, 5308, 11, 486, 2935, 16972, 365, 1096, 13, 400, 550, 264, 3861, 458, 11, 1954, 11, 286, 658, 257, 1096, 50604], "temperature": 0.0, "avg_logprob": -0.10406218965848286, "compression_ratio": 1.6276150627615062, "no_speech_prob": 0.002389016328379512}, {"id": 95, "seek": 67692, "start": 682.4399999999999, "end": 690.5999999999999, "text": " response. So that means all previous requests were handled. So to deal with that, as I just", "tokens": [50640, 4134, 13, 407, 300, 1355, 439, 3894, 12475, 645, 18033, 13, 407, 281, 2028, 365, 300, 11, 382, 286, 445, 51048], "temperature": 0.0, "avg_logprob": -0.10406218965848286, "compression_ratio": 1.6276150627615062, "no_speech_prob": 0.002389016328379512}, {"id": 96, "seek": 67692, "start": 690.5999999999999, "end": 697.0, "text": " explained, there is the predictive frame callback. This is how we deal with the sync request issue.", "tokens": [51048, 8825, 11, 456, 307, 264, 35521, 3920, 818, 3207, 13, 639, 307, 577, 321, 2028, 365, 264, 20271, 5308, 2734, 13, 51368], "temperature": 0.0, "avg_logprob": -0.10406218965848286, "compression_ratio": 1.6276150627615062, "no_speech_prob": 0.002389016328379512}, {"id": 97, "seek": 67692, "start": 697.7199999999999, "end": 704.36, "text": " So this is a complex picture, a bit out of scope to go too much in detail. But what generally happens", "tokens": [51404, 407, 341, 307, 257, 3997, 3036, 11, 257, 857, 484, 295, 11923, 281, 352, 886, 709, 294, 2607, 13, 583, 437, 5101, 2314, 51736], "temperature": 0.0, "avg_logprob": -0.10406218965848286, "compression_ratio": 1.6276150627615062, "no_speech_prob": 0.002389016328379512}, {"id": 98, "seek": 70436, "start": 704.36, "end": 712.76, "text": " is that the proxy compositor on the native site analyzes all requests that come in. And as soon", "tokens": [50364, 307, 300, 264, 29690, 10199, 3029, 322, 264, 8470, 3621, 6459, 12214, 439, 12475, 300, 808, 294, 13, 400, 382, 2321, 50784], "temperature": 0.0, "avg_logprob": -0.07694326877593995, "compression_ratio": 1.7853881278538812, "no_speech_prob": 0.007359704002737999}, {"id": 99, "seek": 70436, "start": 712.76, "end": 718.92, "text": " as it receives a sync request, it will look at all the previous requests and see, hey, those previous", "tokens": [50784, 382, 309, 20717, 257, 20271, 5308, 11, 309, 486, 574, 412, 439, 264, 3894, 12475, 293, 536, 11, 4177, 11, 729, 3894, 51092], "temperature": 0.0, "avg_logprob": -0.07694326877593995, "compression_ratio": 1.7853881278538812, "no_speech_prob": 0.007359704002737999}, {"id": 100, "seek": 70436, "start": 718.92, "end": 724.76, "text": " requests that I just saw, none of them is going to send a reply. So you know what, I'm just going", "tokens": [51092, 12475, 300, 286, 445, 1866, 11, 6022, 295, 552, 307, 516, 281, 2845, 257, 16972, 13, 407, 291, 458, 437, 11, 286, 478, 445, 516, 51384], "temperature": 0.0, "avg_logprob": -0.07694326877593995, "compression_ratio": 1.7853881278538812, "no_speech_prob": 0.007359704002737999}, {"id": 101, "seek": 70436, "start": 724.76, "end": 730.28, "text": " to send the done event immediately, and I'm not going to wait for the compositor to send a done", "tokens": [51384, 281, 2845, 264, 1096, 2280, 4258, 11, 293, 286, 478, 406, 516, 281, 1699, 337, 264, 10199, 3029, 281, 2845, 257, 1096, 51660], "temperature": 0.0, "avg_logprob": -0.07694326877593995, "compression_ratio": 1.7853881278538812, "no_speech_prob": 0.007359704002737999}, {"id": 102, "seek": 73028, "start": 730.28, "end": 736.8399999999999, "text": " event back. And that basically circumvents the whole network around the problem. The only", "tokens": [50364, 2280, 646, 13, 400, 300, 1936, 7125, 85, 791, 264, 1379, 3209, 926, 264, 1154, 13, 440, 787, 50692], "temperature": 0.0, "avg_logprob": -0.09320595098096271, "compression_ratio": 1.6383928571428572, "no_speech_prob": 0.008509150706231594}, {"id": 103, "seek": 73028, "start": 737.8, "end": 742.76, "text": " potential issue you can have there is that you're basically got rid of your throttling.", "tokens": [50740, 3995, 2734, 291, 393, 362, 456, 307, 300, 291, 434, 1936, 658, 3973, 295, 428, 739, 1521, 1688, 13, 50988], "temperature": 0.0, "avg_logprob": -0.09320595098096271, "compression_ratio": 1.6383928571428572, "no_speech_prob": 0.008509150706231594}, {"id": 104, "seek": 73028, "start": 743.3199999999999, "end": 750.1999999999999, "text": " But there is some intermediate protocol to deal with that between the compositor and the proxy", "tokens": [51016, 583, 456, 307, 512, 19376, 10336, 281, 2028, 365, 300, 1296, 264, 10199, 3029, 293, 264, 29690, 51360], "temperature": 0.0, "avg_logprob": -0.09320595098096271, "compression_ratio": 1.6383928571428572, "no_speech_prob": 0.008509150706231594}, {"id": 105, "seek": 73028, "start": 750.1999999999999, "end": 756.8399999999999, "text": " on the native site. So this is explained in the picture here. On the top, we have the requests", "tokens": [51360, 322, 264, 8470, 3621, 13, 407, 341, 307, 8825, 294, 264, 3036, 510, 13, 1282, 264, 1192, 11, 321, 362, 264, 12475, 51692], "temperature": 0.0, "avg_logprob": -0.09320595098096271, "compression_ratio": 1.6383928571428572, "no_speech_prob": 0.008509150706231594}, {"id": 106, "seek": 75684, "start": 756.84, "end": 761.88, "text": " that are coming in in the compositor in a classic Willing scenario. On the top right, we see, hey,", "tokens": [50364, 300, 366, 1348, 294, 294, 264, 10199, 3029, 294, 257, 7230, 3099, 278, 9005, 13, 1282, 264, 1192, 558, 11, 321, 536, 11, 4177, 11, 50616], "temperature": 0.0, "avg_logprob": -0.14334836856339328, "compression_ratio": 1.7720588235294117, "no_speech_prob": 0.010241702198982239}, {"id": 107, "seek": 75684, "start": 761.88, "end": 767.24, "text": " there is a sync request, and it takes a whole network round trip time before the done event is", "tokens": [50616, 456, 307, 257, 20271, 5308, 11, 293, 309, 2516, 257, 1379, 3209, 3098, 4931, 565, 949, 264, 1096, 2280, 307, 50884], "temperature": 0.0, "avg_logprob": -0.14334836856339328, "compression_ratio": 1.7720588235294117, "no_speech_prob": 0.010241702198982239}, {"id": 108, "seek": 75684, "start": 767.24, "end": 772.6, "text": " sent. And the fastest placing, we have the same scenario. We have all the requests coming in.", "tokens": [50884, 2279, 13, 400, 264, 14573, 17221, 11, 321, 362, 264, 912, 9005, 13, 492, 362, 439, 264, 12475, 1348, 294, 13, 51152], "temperature": 0.0, "avg_logprob": -0.14334836856339328, "compression_ratio": 1.7720588235294117, "no_speech_prob": 0.010241702198982239}, {"id": 109, "seek": 75684, "start": 773.48, "end": 780.52, "text": " And at the end, we have our fast sync handled by the proxy. He sees, okay, no, events are going", "tokens": [51196, 400, 412, 264, 917, 11, 321, 362, 527, 2370, 20271, 18033, 538, 264, 29690, 13, 634, 8194, 11, 1392, 11, 572, 11, 3931, 366, 516, 51548], "temperature": 0.0, "avg_logprob": -0.14334836856339328, "compression_ratio": 1.7720588235294117, "no_speech_prob": 0.010241702198982239}, {"id": 110, "seek": 75684, "start": 780.52, "end": 784.9200000000001, "text": " to be sent. So I don't need to wait for the compositor to send any other events. I'm going to send", "tokens": [51548, 281, 312, 2279, 13, 407, 286, 500, 380, 643, 281, 1699, 337, 264, 10199, 3029, 281, 2845, 604, 661, 3931, 13, 286, 478, 516, 281, 2845, 51768], "temperature": 0.0, "avg_logprob": -0.14334836856339328, "compression_ratio": 1.7720588235294117, "no_speech_prob": 0.010241702198982239}, {"id": 111, "seek": 78492, "start": 784.92, "end": 792.04, "text": " the done event immediately. And that makes the whole pipeline asynchronous. It makes the whole", "tokens": [50364, 264, 1096, 2280, 4258, 13, 400, 300, 1669, 264, 1379, 15517, 49174, 13, 467, 1669, 264, 1379, 50720], "temperature": 0.0, "avg_logprob": -0.10663739494655443, "compression_ratio": 1.7244444444444444, "no_speech_prob": 0.0041782488115131855}, {"id": 112, "seek": 78492, "start": 792.04, "end": 797.24, "text": " pipeline fast enough. If you have fast encoding, fast decoding, fast enough for gaming as well,", "tokens": [50720, 15517, 2370, 1547, 13, 759, 291, 362, 2370, 43430, 11, 2370, 979, 8616, 11, 2370, 1547, 337, 9703, 382, 731, 11, 50980], "temperature": 0.0, "avg_logprob": -0.10663739494655443, "compression_ratio": 1.7244444444444444, "no_speech_prob": 0.0041782488115131855}, {"id": 113, "seek": 78492, "start": 797.24, "end": 802.8399999999999, "text": " you can do 60 frames per second or more if your hardware is fast enough and your network can deal", "tokens": [50980, 291, 393, 360, 4060, 12083, 680, 1150, 420, 544, 498, 428, 8837, 307, 2370, 1547, 293, 428, 3209, 393, 2028, 51260], "temperature": 0.0, "avg_logprob": -0.10663739494655443, "compression_ratio": 1.7244444444444444, "no_speech_prob": 0.0041782488115131855}, {"id": 114, "seek": 78492, "start": 802.8399999999999, "end": 814.52, "text": " with it. So far, the remoting part. Greenfield can do more than just remote applications. As I said", "tokens": [51260, 365, 309, 13, 407, 1400, 11, 264, 890, 17001, 644, 13, 6969, 7610, 393, 360, 544, 813, 445, 8607, 5821, 13, 1018, 286, 848, 51844], "temperature": 0.0, "avg_logprob": -0.10663739494655443, "compression_ratio": 1.7244444444444444, "no_speech_prob": 0.0041782488115131855}, {"id": 115, "seek": 81452, "start": 814.6, "end": 822.68, "text": " before, you can also run applications directly in your browser. To do that, there is a prototype", "tokens": [50368, 949, 11, 291, 393, 611, 1190, 5821, 3838, 294, 428, 11185, 13, 1407, 360, 300, 11, 456, 307, 257, 19475, 50772], "temperature": 0.0, "avg_logprob": -0.13606446409878664, "compression_ratio": 1.4558823529411764, "no_speech_prob": 0.013792064040899277}, {"id": 116, "seek": 81452, "start": 822.68, "end": 830.04, "text": " Greenfield SDK. It's based on EM scripting because it's the most complete, somewhat post-excompatible", "tokens": [50772, 6969, 7610, 37135, 13, 467, 311, 2361, 322, 16237, 5755, 278, 570, 309, 311, 264, 881, 3566, 11, 8344, 2183, 12, 3121, 1112, 11584, 964, 51140], "temperature": 0.0, "avg_logprob": -0.13606446409878664, "compression_ratio": 1.4558823529411764, "no_speech_prob": 0.013792064040899277}, {"id": 117, "seek": 81452, "start": 830.6, "end": 839.0799999999999, "text": " SDK out there that is aimed for the browser. This works fairly well, but it has some disadvantages", "tokens": [51168, 37135, 484, 456, 300, 307, 20540, 337, 264, 11185, 13, 639, 1985, 6457, 731, 11, 457, 309, 575, 512, 37431, 51592], "temperature": 0.0, "avg_logprob": -0.13606446409878664, "compression_ratio": 1.4558823529411764, "no_speech_prob": 0.013792064040899277}, {"id": 118, "seek": 83908, "start": 839.08, "end": 847.96, "text": " as well. Wayland applications are Linux applications, well, almost exclusively. And the EM scripting", "tokens": [50364, 382, 731, 13, 9558, 1661, 5821, 366, 18734, 5821, 11, 731, 11, 1920, 20638, 13, 400, 264, 16237, 5755, 278, 50808], "temperature": 0.0, "avg_logprob": -0.200938966539171, "compression_ratio": 1.5815217391304348, "no_speech_prob": 0.041729990392923355}, {"id": 119, "seek": 83908, "start": 847.96, "end": 855.08, "text": " SDK aims to be post-excompliant. And that's not Linux compliant. So things like E-Poll are not", "tokens": [50808, 37135, 24683, 281, 312, 2183, 12, 3121, 1112, 564, 5798, 13, 400, 300, 311, 406, 18734, 36248, 13, 407, 721, 411, 462, 12, 47, 1833, 366, 406, 51164], "temperature": 0.0, "avg_logprob": -0.200938966539171, "compression_ratio": 1.5815217391304348, "no_speech_prob": 0.041729990392923355}, {"id": 120, "seek": 83908, "start": 855.08, "end": 862.12, "text": " implemented in EM scripting. So I had to add those, well, at least E-Poll in the Greenfield SDK", "tokens": [51164, 12270, 294, 16237, 5755, 278, 13, 407, 286, 632, 281, 909, 729, 11, 731, 11, 412, 1935, 462, 12, 47, 1833, 294, 264, 6969, 7610, 37135, 51516], "temperature": 0.0, "avg_logprob": -0.200938966539171, "compression_ratio": 1.5815217391304348, "no_speech_prob": 0.041729990392923355}, {"id": 121, "seek": 86212, "start": 862.68, "end": 871.5600000000001, "text": " because Wayland requires it as well. There's also the core Wayland protocol is implemented in", "tokens": [50392, 570, 9558, 1661, 7029, 309, 382, 731, 13, 821, 311, 611, 264, 4965, 9558, 1661, 10336, 307, 12270, 294, 50836], "temperature": 0.0, "avg_logprob": -0.15142204143382884, "compression_ratio": 1.6088888888888888, "no_speech_prob": 0.0070722224190831184}, {"id": 122, "seek": 86212, "start": 871.5600000000001, "end": 878.76, "text": " Greenfield together with the XG protocol. That works well for desktop applications,", "tokens": [50836, 6969, 7610, 1214, 365, 264, 1783, 38, 10336, 13, 663, 1985, 731, 337, 14502, 5821, 11, 51196], "temperature": 0.0, "avg_logprob": -0.15142204143382884, "compression_ratio": 1.6088888888888888, "no_speech_prob": 0.0070722224190831184}, {"id": 123, "seek": 86212, "start": 878.76, "end": 884.84, "text": " gives you a good standard to work with most office applications. They work out of the box.", "tokens": [51196, 2709, 291, 257, 665, 3832, 281, 589, 365, 881, 3398, 5821, 13, 814, 589, 484, 295, 264, 2424, 13, 51500], "temperature": 0.0, "avg_logprob": -0.15142204143382884, "compression_ratio": 1.6088888888888888, "no_speech_prob": 0.0070722224190831184}, {"id": 124, "seek": 86212, "start": 886.36, "end": 891.0, "text": " In the WebAssembly implementation, there is currently only support for shared memory buffers.", "tokens": [51576, 682, 264, 9573, 10884, 19160, 11420, 11, 456, 307, 4362, 787, 1406, 337, 5507, 4675, 9204, 433, 13, 51808], "temperature": 0.0, "avg_logprob": -0.15142204143382884, "compression_ratio": 1.6088888888888888, "no_speech_prob": 0.0070722224190831184}, {"id": 125, "seek": 89212, "start": 892.68, "end": 899.5600000000001, "text": " We can theoretically do WebGL if we were to port Mesa to WebAssembly and utilize a", "tokens": [50392, 492, 393, 29400, 360, 9573, 19440, 498, 321, 645, 281, 2436, 376, 13708, 281, 9573, 10884, 19160, 293, 16117, 257, 50736], "temperature": 0.0, "avg_logprob": -0.1080212938612786, "compression_ratio": 1.434782608695652, "no_speech_prob": 0.0018025836907327175}, {"id": 126, "seek": 89212, "start": 900.28, "end": 908.52, "text": " custom WebGL Wayland protocol. The protocol exists. It works. It's simply currently not", "tokens": [50772, 2375, 9573, 19440, 9558, 1661, 10336, 13, 440, 10336, 8198, 13, 467, 1985, 13, 467, 311, 2935, 4362, 406, 51184], "temperature": 0.0, "avg_logprob": -0.1080212938612786, "compression_ratio": 1.434782608695652, "no_speech_prob": 0.0018025836907327175}, {"id": 127, "seek": 89212, "start": 908.52, "end": 918.36, "text": " implemented inside Mesa itself. That's some future work, I guess, to support that. But we can", "tokens": [51184, 12270, 1854, 376, 13708, 2564, 13, 663, 311, 512, 2027, 589, 11, 286, 2041, 11, 281, 1406, 300, 13, 583, 321, 393, 51676], "temperature": 0.0, "avg_logprob": -0.1080212938612786, "compression_ratio": 1.434782608695652, "no_speech_prob": 0.0018025836907327175}, {"id": 128, "seek": 91836, "start": 918.36, "end": 924.44, "text": " perfectly support WebGL. No issue. The work just here needs to be done. So how would this all", "tokens": [50364, 6239, 1406, 9573, 19440, 13, 883, 2734, 13, 440, 589, 445, 510, 2203, 281, 312, 1096, 13, 407, 577, 576, 341, 439, 50668], "temperature": 0.0, "avg_logprob": -0.13227704106544963, "compression_ratio": 1.5897435897435896, "no_speech_prob": 0.009684642776846886}, {"id": 129, "seek": 91836, "start": 924.44, "end": 932.12, "text": " look while we have a nice green diagram here to show you how this looks? We have our main page", "tokens": [50668, 574, 1339, 321, 362, 257, 1481, 3092, 10686, 510, 281, 855, 291, 577, 341, 1542, 30, 492, 362, 527, 2135, 3028, 51052], "temperature": 0.0, "avg_logprob": -0.13227704106544963, "compression_ratio": 1.5897435897435896, "no_speech_prob": 0.009684642776846886}, {"id": 130, "seek": 91836, "start": 932.12, "end": 938.76, "text": " on the left that loads your composite, that loads Greenfields. Next to it, you will have an", "tokens": [51052, 322, 264, 1411, 300, 12668, 428, 25557, 11, 300, 12668, 6969, 7610, 82, 13, 3087, 281, 309, 11, 291, 486, 362, 364, 51384], "temperature": 0.0, "avg_logprob": -0.13227704106544963, "compression_ratio": 1.5897435897435896, "no_speech_prob": 0.009684642776846886}, {"id": 131, "seek": 91836, "start": 938.76, "end": 945.8000000000001, "text": " iFrame. The iFrame loads your WebAssembly application, loads it in, and then basically uses", "tokens": [51384, 741, 40305, 529, 13, 440, 741, 40305, 529, 12668, 428, 9573, 10884, 19160, 3861, 11, 12668, 309, 294, 11, 293, 550, 1936, 4960, 51736], "temperature": 0.0, "avg_logprob": -0.13227704106544963, "compression_ratio": 1.5897435897435896, "no_speech_prob": 0.009684642776846886}, {"id": 132, "seek": 94580, "start": 946.04, "end": 956.04, "text": " internal iFrame messages to your main thread. Talking 100% pure native Wayland protocol", "tokens": [50376, 6920, 741, 40305, 529, 7897, 281, 428, 2135, 7207, 13, 22445, 2319, 4, 6075, 8470, 9558, 1661, 10336, 50876], "temperature": 0.0, "avg_logprob": -0.1305736814226423, "compression_ratio": 1.4759358288770053, "no_speech_prob": 0.0023570589255541563}, {"id": 133, "seek": 94580, "start": 957.16, "end": 963.24, "text": " works fine, works great. Next to it, we have transparently also the remote applications", "tokens": [50932, 1985, 2489, 11, 1985, 869, 13, 3087, 281, 309, 11, 321, 362, 7132, 6420, 611, 264, 8607, 5821, 51236], "temperature": 0.0, "avg_logprob": -0.1305736814226423, "compression_ratio": 1.4759358288770053, "no_speech_prob": 0.0023570589255541563}, {"id": 134, "seek": 94580, "start": 963.24, "end": 969.0, "text": " that are running. For the Greenfield compositor, both applications are just your ordinary Greenfield", "tokens": [51236, 300, 366, 2614, 13, 1171, 264, 6969, 7610, 10199, 3029, 11, 1293, 5821, 366, 445, 428, 10547, 6969, 7610, 51524], "temperature": 0.0, "avg_logprob": -0.1305736814226423, "compression_ratio": 1.4759358288770053, "no_speech_prob": 0.0023570589255541563}, {"id": 135, "seek": 96900, "start": 969.0, "end": 976.92, "text": " applications. He sees no difference. With a small remark that the Way file descriptors are handled", "tokens": [50364, 5821, 13, 634, 8194, 572, 2649, 13, 2022, 257, 1359, 7942, 300, 264, 9558, 3991, 31280, 830, 366, 18033, 50760], "temperature": 0.0, "avg_logprob": -0.1125855225783128, "compression_ratio": 1.5869565217391304, "no_speech_prob": 0.061686426401138306}, {"id": 136, "seek": 96900, "start": 976.92, "end": 984.28, "text": " on the protocol is a bit different. In case of not remote applications, the file descriptor is", "tokens": [50760, 322, 264, 10336, 307, 257, 857, 819, 13, 682, 1389, 295, 406, 8607, 5821, 11, 264, 3991, 31280, 284, 307, 51128], "temperature": 0.0, "avg_logprob": -0.1125855225783128, "compression_ratio": 1.5869565217391304, "no_speech_prob": 0.061686426401138306}, {"id": 137, "seek": 96900, "start": 984.28, "end": 992.04, "text": " basically a URL that's passed around and that's opened and transferred and closed whenever needed.", "tokens": [51128, 1936, 257, 12905, 300, 311, 4678, 926, 293, 300, 311, 5625, 293, 15809, 293, 5395, 5699, 2978, 13, 51516], "temperature": 0.0, "avg_logprob": -0.1125855225783128, "compression_ratio": 1.5869565217391304, "no_speech_prob": 0.061686426401138306}, {"id": 138, "seek": 99204, "start": 992.68, "end": 1000.04, "text": " In case of native or rather browser native applications, it's a transferable browser", "tokens": [50396, 682, 1389, 295, 8470, 420, 2831, 11185, 8470, 5821, 11, 309, 311, 257, 5003, 712, 11185, 50764], "temperature": 0.0, "avg_logprob": -0.11982195876365484, "compression_ratio": 1.7391304347826086, "no_speech_prob": 0.015380867756903172}, {"id": 139, "seek": 99204, "start": 1000.04, "end": 1006.04, "text": " object that is used. Those two file descriptor discrepancies have not yet been bridged,", "tokens": [50764, 2657, 300, 307, 1143, 13, 3950, 732, 3991, 31280, 284, 2983, 19919, 32286, 362, 406, 1939, 668, 16362, 3004, 11, 51064], "temperature": 0.0, "avg_logprob": -0.11982195876365484, "compression_ratio": 1.7391304347826086, "no_speech_prob": 0.015380867756903172}, {"id": 140, "seek": 99204, "start": 1006.04, "end": 1010.5999999999999, "text": " so you cannot do copy-paste operations, for example, between a browser application", "tokens": [51064, 370, 291, 2644, 360, 5055, 12, 79, 9079, 7705, 11, 337, 1365, 11, 1296, 257, 11185, 3861, 51292], "temperature": 0.0, "avg_logprob": -0.11982195876365484, "compression_ratio": 1.7391304347826086, "no_speech_prob": 0.015380867756903172}, {"id": 141, "seek": 99204, "start": 1010.5999999999999, "end": 1017.48, "text": " and a remote application. What you can do, copy-paste between a remote application that works just fine.", "tokens": [51292, 293, 257, 8607, 3861, 13, 708, 291, 393, 360, 11, 5055, 12, 79, 9079, 1296, 257, 8607, 3861, 300, 1985, 445, 2489, 13, 51636], "temperature": 0.0, "avg_logprob": -0.11982195876365484, "compression_ratio": 1.7391304347826086, "no_speech_prob": 0.015380867756903172}, {"id": 142, "seek": 101748, "start": 1017.96, "end": 1026.04, "text": " That's how it currently works. What would the future look like? There are lots of cool stuff", "tokens": [50388, 663, 311, 577, 309, 4362, 1985, 13, 708, 576, 264, 2027, 574, 411, 30, 821, 366, 3195, 295, 1627, 1507, 50792], "temperature": 0.0, "avg_logprob": -0.15958858489990235, "compression_ratio": 1.5923913043478262, "no_speech_prob": 0.001195485470816493}, {"id": 143, "seek": 101748, "start": 1026.04, "end": 1031.48, "text": " that can be done, that still needs to be done. There is the issue of sound. There's currently no sound.", "tokens": [50792, 300, 393, 312, 1096, 11, 300, 920, 2203, 281, 312, 1096, 13, 821, 307, 264, 2734, 295, 1626, 13, 821, 311, 4362, 572, 1626, 13, 51064], "temperature": 0.0, "avg_logprob": -0.15958858489990235, "compression_ratio": 1.5923913043478262, "no_speech_prob": 0.001195485470816493}, {"id": 144, "seek": 101748, "start": 1032.76, "end": 1040.92, "text": " I initially left it out because it's a bit out of scope for compositor or Wayland related stuff,", "tokens": [51128, 286, 9105, 1411, 309, 484, 570, 309, 311, 257, 857, 484, 295, 11923, 337, 10199, 3029, 420, 9558, 1661, 4077, 1507, 11, 51536], "temperature": 0.0, "avg_logprob": -0.15958858489990235, "compression_ratio": 1.5923913043478262, "no_speech_prob": 0.001195485470816493}, {"id": 145, "seek": 104092, "start": 1041.48, "end": 1048.28, "text": " but somebody also already did their master thesis about its implemented sound in Greenfield,", "tokens": [50392, 457, 2618, 611, 1217, 630, 641, 4505, 22288, 466, 1080, 12270, 1626, 294, 6969, 7610, 11, 50732], "temperature": 0.0, "avg_logprob": -0.20365149180094402, "compression_ratio": 1.5843621399176955, "no_speech_prob": 0.013219812884926796}, {"id": 146, "seek": 104092, "start": 1048.28, "end": 1055.48, "text": " using pipe wire and G-streamer worked really well. Prototype exists and can be implemented,", "tokens": [50732, 1228, 11240, 6234, 293, 460, 12, 9291, 260, 2732, 534, 731, 13, 10019, 13108, 8198, 293, 393, 312, 12270, 11, 51092], "temperature": 0.0, "avg_logprob": -0.20365149180094402, "compression_ratio": 1.5843621399176955, "no_speech_prob": 0.013219812884926796}, {"id": 147, "seek": 104092, "start": 1055.48, "end": 1062.2, "text": " I guess, pretty easily. There's also the need for a bit more Wayland protocol, so there is just only", "tokens": [51092, 286, 2041, 11, 1238, 3612, 13, 821, 311, 611, 264, 643, 337, 257, 857, 544, 9558, 1661, 10336, 11, 370, 456, 307, 445, 787, 51428], "temperature": 0.0, "avg_logprob": -0.20365149180094402, "compression_ratio": 1.5843621399176955, "no_speech_prob": 0.013219812884926796}, {"id": 148, "seek": 104092, "start": 1062.2, "end": 1070.44, "text": " the very basic currently implemented. There is no unified file system, again a bit out of scope for", "tokens": [51428, 264, 588, 3875, 4362, 12270, 13, 821, 307, 572, 26787, 3991, 1185, 11, 797, 257, 857, 484, 295, 11923, 337, 51840], "temperature": 0.0, "avg_logprob": -0.20365149180094402, "compression_ratio": 1.5843621399176955, "no_speech_prob": 0.013219812884926796}, {"id": 149, "seek": 107044, "start": 1070.44, "end": 1076.3600000000001, "text": " Greenfield, but it doesn't really exist, so it would be nice if we had it. Imagine you run", "tokens": [50364, 6969, 7610, 11, 457, 309, 1177, 380, 534, 2514, 11, 370, 309, 576, 312, 1481, 498, 321, 632, 309, 13, 11739, 291, 1190, 50660], "temperature": 0.0, "avg_logprob": -0.14690968455100545, "compression_ratio": 1.6798245614035088, "no_speech_prob": 0.004959534388035536}, {"id": 150, "seek": 107044, "start": 1076.3600000000001, "end": 1081.64, "text": " applications on different servers, they all see their own local file system and you cannot", "tokens": [50660, 5821, 322, 819, 15909, 11, 436, 439, 536, 641, 1065, 2654, 3991, 1185, 293, 291, 2644, 50924], "temperature": 0.0, "avg_logprob": -0.14690968455100545, "compression_ratio": 1.6798245614035088, "no_speech_prob": 0.004959534388035536}, {"id": 151, "seek": 107044, "start": 1081.64, "end": 1088.44, "text": " transfer files between them, so that would be nice to have. There is the port of Mesa, the WebGL,", "tokens": [50924, 5003, 7098, 1296, 552, 11, 370, 300, 576, 312, 1481, 281, 362, 13, 821, 307, 264, 2436, 295, 376, 13708, 11, 264, 9573, 19440, 11, 51264], "temperature": 0.0, "avg_logprob": -0.14690968455100545, "compression_ratio": 1.6798245614035088, "no_speech_prob": 0.004959534388035536}, {"id": 152, "seek": 107044, "start": 1088.44, "end": 1097.0, "text": " using Wayland protocol, that would be nice to have. Then last, the hardest part, also the coolest part,", "tokens": [51264, 1228, 9558, 1661, 10336, 11, 300, 576, 312, 1481, 281, 362, 13, 1396, 1036, 11, 264, 13158, 644, 11, 611, 264, 22013, 644, 11, 51692], "temperature": 0.0, "avg_logprob": -0.14690968455100545, "compression_ratio": 1.6798245614035088, "no_speech_prob": 0.004959534388035536}, {"id": 153, "seek": 109700, "start": 1097.0, "end": 1104.92, "text": " is the whole EM scripting posix issue. It would be nice if you would simply got rid of EM scripting", "tokens": [50364, 307, 264, 1379, 16237, 5755, 278, 1366, 970, 2734, 13, 467, 576, 312, 1481, 498, 291, 576, 2935, 658, 3973, 295, 16237, 5755, 278, 50760], "temperature": 0.0, "avg_logprob": -0.19894176980723505, "compression_ratio": 1.4540816326530612, "no_speech_prob": 0.009628445841372013}, {"id": 154, "seek": 109700, "start": 1104.92, "end": 1111.72, "text": " and just could compile applications directly to WebAssembly and actually have a Linux micro", "tokens": [50760, 293, 445, 727, 31413, 5821, 3838, 281, 9573, 10884, 19160, 293, 767, 362, 257, 18734, 4532, 51100], "temperature": 0.0, "avg_logprob": -0.19894176980723505, "compression_ratio": 1.4540816326530612, "no_speech_prob": 0.009628445841372013}, {"id": 155, "seek": 109700, "start": 1111.72, "end": 1121.24, "text": " kernel running in your browser. Somebody else who is also crazy ported Linux kernel to ASMGS.", "tokens": [51100, 28256, 2614, 294, 428, 11185, 13, 13463, 1646, 567, 307, 611, 3219, 2436, 292, 18734, 28256, 281, 7469, 44, 24446, 13, 51576], "temperature": 0.0, "avg_logprob": -0.19894176980723505, "compression_ratio": 1.4540816326530612, "no_speech_prob": 0.009628445841372013}, {"id": 156, "seek": 112124, "start": 1122.2, "end": 1131.0, "text": " ASMGS is the predecessor of WebAssembly and that crazy person got the Linux kernel to boot,", "tokens": [50412, 7469, 44, 24446, 307, 264, 34991, 295, 9573, 10884, 19160, 293, 300, 3219, 954, 658, 264, 18734, 28256, 281, 11450, 11, 50852], "temperature": 0.0, "avg_logprob": -0.21756956312391493, "compression_ratio": 1.5573770491803278, "no_speech_prob": 0.027821257710456848}, {"id": 157, "seek": 112124, "start": 1131.0, "end": 1138.92, "text": " up until pit one at least. I tried it to do that myself using WebAssembly, turns out it's actually", "tokens": [50852, 493, 1826, 10147, 472, 412, 1935, 13, 286, 3031, 309, 281, 360, 300, 2059, 1228, 9573, 10884, 19160, 11, 4523, 484, 309, 311, 767, 51248], "temperature": 0.0, "avg_logprob": -0.21756956312391493, "compression_ratio": 1.5573770491803278, "no_speech_prob": 0.027821257710456848}, {"id": 158, "seek": 112124, "start": 1138.92, "end": 1146.2, "text": " really hard to port the Linux kernel to other architecture, no shit, especially if WebAssembly", "tokens": [51248, 534, 1152, 281, 2436, 264, 18734, 28256, 281, 661, 9482, 11, 572, 4611, 11, 2318, 498, 9573, 10884, 19160, 51612], "temperature": 0.0, "avg_logprob": -0.21756956312391493, "compression_ratio": 1.5573770491803278, "no_speech_prob": 0.027821257710456848}, {"id": 159, "seek": 114620, "start": 1146.76, "end": 1154.52, "text": " is not an elf binary. The Linux kernel expects the elf binary to be used, the format to be used", "tokens": [50392, 307, 406, 364, 35565, 17434, 13, 440, 18734, 28256, 33280, 264, 35565, 17434, 281, 312, 1143, 11, 264, 7877, 281, 312, 1143, 50780], "temperature": 0.0, "avg_logprob": -0.12594482173090396, "compression_ratio": 1.7882882882882882, "no_speech_prob": 0.015833750367164612}, {"id": 160, "seek": 114620, "start": 1154.52, "end": 1160.1200000000001, "text": " when it's compiled in all kinds of different places and that assumption goes through the window when", "tokens": [50780, 562, 309, 311, 36548, 294, 439, 3685, 295, 819, 3190, 293, 300, 15302, 1709, 807, 264, 4910, 562, 51060], "temperature": 0.0, "avg_logprob": -0.12594482173090396, "compression_ratio": 1.7882882882882882, "no_speech_prob": 0.015833750367164612}, {"id": 161, "seek": 114620, "start": 1160.1200000000001, "end": 1167.56, "text": " you try to compile to WebAssembly. There's also a bit of documentation importing the Linux kernel", "tokens": [51060, 291, 853, 281, 31413, 281, 9573, 10884, 19160, 13, 821, 311, 611, 257, 857, 295, 14333, 43866, 264, 18734, 28256, 51432], "temperature": 0.0, "avg_logprob": -0.12594482173090396, "compression_ratio": 1.7882882882882882, "no_speech_prob": 0.015833750367164612}, {"id": 162, "seek": 114620, "start": 1167.56, "end": 1172.52, "text": " to other architectures. There's a ton of documentation about the Linux kernel, but most of it is about", "tokens": [51432, 281, 661, 6331, 1303, 13, 821, 311, 257, 2952, 295, 14333, 466, 264, 18734, 28256, 11, 457, 881, 295, 309, 307, 466, 51680], "temperature": 0.0, "avg_logprob": -0.12594482173090396, "compression_ratio": 1.7882882882882882, "no_speech_prob": 0.015833750367164612}, {"id": 163, "seek": 117252, "start": 1173.16, "end": 1179.72, "text": " developing drivers. But yeah, I'm not a kernel developer as well, so that might also have to do", "tokens": [50396, 6416, 11590, 13, 583, 1338, 11, 286, 478, 406, 257, 28256, 10754, 382, 731, 11, 370, 300, 1062, 611, 362, 281, 360, 50724], "temperature": 0.0, "avg_logprob": -0.14622834595766934, "compression_ratio": 1.5767634854771784, "no_speech_prob": 0.004121465142816305}, {"id": 164, "seek": 117252, "start": 1179.72, "end": 1185.8, "text": " something with it. But I'd say think about possibilities you could compile an application", "tokens": [50724, 746, 365, 309, 13, 583, 286, 1116, 584, 519, 466, 12178, 291, 727, 31413, 364, 3861, 51028], "temperature": 0.0, "avg_logprob": -0.14622834595766934, "compression_ratio": 1.5767634854771784, "no_speech_prob": 0.004121465142816305}, {"id": 165, "seek": 117252, "start": 1185.8, "end": 1191.48, "text": " or Linux application to WebAssembly, boot it up in your browser by simply accessing a URL and have", "tokens": [51028, 420, 18734, 3861, 281, 9573, 10884, 19160, 11, 11450, 309, 493, 294, 428, 11185, 538, 2935, 26440, 257, 12905, 293, 362, 51312], "temperature": 0.0, "avg_logprob": -0.14622834595766934, "compression_ratio": 1.5767634854771784, "no_speech_prob": 0.004121465142816305}, {"id": 166, "seek": 117252, "start": 1191.48, "end": 1198.36, "text": " it completely sandboxed, super secure, running inside a desktop that's running in your browser.", "tokens": [51312, 309, 2584, 42115, 292, 11, 1687, 7144, 11, 2614, 1854, 257, 14502, 300, 311, 2614, 294, 428, 11185, 13, 51656], "temperature": 0.0, "avg_logprob": -0.14622834595766934, "compression_ratio": 1.5767634854771784, "no_speech_prob": 0.004121465142816305}, {"id": 167, "seek": 119836, "start": 1198.36, "end": 1205.9599999999998, "text": " That would be really cool I think. So how would say a Linux port look like in WebAssembly?", "tokens": [50364, 663, 576, 312, 534, 1627, 286, 519, 13, 407, 577, 576, 584, 257, 18734, 2436, 574, 411, 294, 9573, 10884, 19160, 30, 50744], "temperature": 0.0, "avg_logprob": -0.17799375345418741, "compression_ratio": 1.6396396396396395, "no_speech_prob": 0.0010145246051251888}, {"id": 168, "seek": 119836, "start": 1206.52, "end": 1212.84, "text": " We have a nice yellow diagram this time. It would simply load access a URL,", "tokens": [50772, 492, 362, 257, 1481, 5566, 10686, 341, 565, 13, 467, 576, 2935, 3677, 2105, 257, 12905, 11, 51088], "temperature": 0.0, "avg_logprob": -0.17799375345418741, "compression_ratio": 1.6396396396396395, "no_speech_prob": 0.0010145246051251888}, {"id": 169, "seek": 119836, "start": 1213.9599999999998, "end": 1219.0, "text": " it would load the WebAssembly application, the WebAssembly application would then link against your", "tokens": [51144, 309, 576, 3677, 264, 9573, 10884, 19160, 3861, 11, 264, 9573, 10884, 19160, 3861, 576, 550, 2113, 1970, 428, 51396], "temperature": 0.0, "avg_logprob": -0.17799375345418741, "compression_ratio": 1.6396396396396395, "no_speech_prob": 0.0010145246051251888}, {"id": 170, "seek": 119836, "start": 1219.9599999999998, "end": 1227.6399999999999, "text": " kernel, which is also a WebAssembly module, bit out of scope for the graphics room, but there are", "tokens": [51444, 28256, 11, 597, 307, 611, 257, 9573, 10884, 19160, 10088, 11, 857, 484, 295, 11923, 337, 264, 11837, 1808, 11, 457, 456, 366, 51828], "temperature": 0.0, "avg_logprob": -0.17799375345418741, "compression_ratio": 1.6396396396396395, "no_speech_prob": 0.0010145246051251888}, {"id": 171, "seek": 122764, "start": 1227.72, "end": 1233.96, "text": " certain WebAssembly standards that allow you to isolate certain region memories to the application", "tokens": [50368, 1629, 9573, 10884, 19160, 7787, 300, 2089, 291, 281, 25660, 1629, 4458, 8495, 281, 264, 3861, 50680], "temperature": 0.0, "avg_logprob": -0.1229516253059293, "compression_ratio": 1.6894977168949772, "no_speech_prob": 0.0013440552866086364}, {"id": 172, "seek": 122764, "start": 1233.96, "end": 1239.8000000000002, "text": " and to the kernel module and have some regions shared with them. And then we could probably", "tokens": [50680, 293, 281, 264, 28256, 10088, 293, 362, 512, 10682, 5507, 365, 552, 13, 400, 550, 321, 727, 1391, 50972], "temperature": 0.0, "avg_logprob": -0.1229516253059293, "compression_ratio": 1.6894977168949772, "no_speech_prob": 0.0013440552866086364}, {"id": 173, "seek": 122764, "start": 1239.8000000000002, "end": 1247.96, "text": " leverage the Vue.tio stack and have it interact with basically the browser APIs and have your", "tokens": [50972, 13982, 264, 691, 622, 13, 83, 1004, 8630, 293, 362, 309, 4648, 365, 1936, 264, 11185, 21445, 293, 362, 428, 51380], "temperature": 0.0, "avg_logprob": -0.1229516253059293, "compression_ratio": 1.6894977168949772, "no_speech_prob": 0.0013440552866086364}, {"id": 174, "seek": 122764, "start": 1247.96, "end": 1253.3200000000002, "text": " browser basically be your virtual machine. So that's probably how it would look like.", "tokens": [51380, 11185, 1936, 312, 428, 6374, 3479, 13, 407, 300, 311, 1391, 577, 309, 576, 574, 411, 13, 51648], "temperature": 0.0, "avg_logprob": -0.1229516253059293, "compression_ratio": 1.6894977168949772, "no_speech_prob": 0.0013440552866086364}, {"id": 175, "seek": 125332, "start": 1253.56, "end": 1262.12, "text": " For the file system some attempts have been made and for now Jusifes seems to be the most", "tokens": [50376, 1171, 264, 3991, 1185, 512, 15257, 362, 668, 1027, 293, 337, 586, 508, 301, 351, 279, 2544, 281, 312, 264, 881, 50804], "temperature": 0.0, "avg_logprob": -0.21627474522245102, "compression_ratio": 1.6011560693641618, "no_speech_prob": 0.001808706670999527}, {"id": 176, "seek": 125332, "start": 1262.12, "end": 1271.72, "text": " valid candidate. Interesting note here is that Jusifes uses two kinds of databases, one to", "tokens": [50804, 7363, 11532, 13, 14711, 3637, 510, 307, 300, 508, 301, 351, 279, 4960, 732, 3685, 295, 22380, 11, 472, 281, 51284], "temperature": 0.0, "avg_logprob": -0.21627474522245102, "compression_ratio": 1.6011560693641618, "no_speech_prob": 0.001808706670999527}, {"id": 177, "seek": 125332, "start": 1271.72, "end": 1277.48, "text": " store your data itself, one to store the metadata of your file system and the experiment. It was", "tokens": [51284, 3531, 428, 1412, 2564, 11, 472, 281, 3531, 264, 26603, 295, 428, 3991, 1185, 293, 264, 5120, 13, 467, 390, 51572], "temperature": 0.0, "avg_logprob": -0.21627474522245102, "compression_ratio": 1.6011560693641618, "no_speech_prob": 0.001808706670999527}, {"id": 178, "seek": 127748, "start": 1278.28, "end": 1287.56, "text": " shown that the metadata database needs to be really fast, so we probably need a locally cached", "tokens": [50404, 4898, 300, 264, 26603, 8149, 2203, 281, 312, 534, 2370, 11, 370, 321, 1391, 643, 257, 16143, 269, 15095, 50868], "temperature": 0.0, "avg_logprob": -0.14341634511947632, "compression_ratio": 1.511111111111111, "no_speech_prob": 0.0013239344116300344}, {"id": 179, "seek": 127748, "start": 1287.56, "end": 1293.72, "text": " metadata database which then uses CRTT basically to synchronize between the instances", "tokens": [50868, 26603, 8149, 597, 550, 4960, 14123, 28178, 1936, 281, 19331, 1125, 1296, 264, 14519, 51176], "temperature": 0.0, "avg_logprob": -0.14341634511947632, "compression_ratio": 1.511111111111111, "no_speech_prob": 0.0013239344116300344}, {"id": 180, "seek": 127748, "start": 1295.56, "end": 1305.48, "text": " to make it fast enough. So let's see if we can show some demos. That would be cool I guess.", "tokens": [51268, 281, 652, 309, 2370, 1547, 13, 407, 718, 311, 536, 498, 321, 393, 855, 512, 33788, 13, 663, 576, 312, 1627, 286, 2041, 13, 51764], "temperature": 0.0, "avg_logprob": -0.14341634511947632, "compression_ratio": 1.511111111111111, "no_speech_prob": 0.0013239344116300344}, {"id": 181, "seek": 130748, "start": 1308.04, "end": 1317.56, "text": " So in here we have a state-of-the-art green field running, super fancy as you can see.", "tokens": [50392, 407, 294, 510, 321, 362, 257, 1785, 12, 2670, 12, 3322, 12, 446, 3092, 2519, 2614, 11, 1687, 10247, 382, 291, 393, 536, 13, 50868], "temperature": 0.0, "avg_logprob": -0.22754258694856064, "compression_ratio": 1.2357723577235773, "no_speech_prob": 0.0016175832133740187}, {"id": 182, "seek": 130748, "start": 1323.16, "end": 1328.1200000000001, "text": " And I'm going to try a remote application, I hope the wifi holds.", "tokens": [51148, 400, 286, 478, 516, 281, 853, 257, 8607, 3861, 11, 286, 1454, 264, 35246, 9190, 13, 51396], "temperature": 0.0, "avg_logprob": -0.22754258694856064, "compression_ratio": 1.2357723577235773, "no_speech_prob": 0.0016175832133740187}, {"id": 183, "seek": 132812, "start": 1328.12, "end": 1344.04, "text": " So this one is actually streaming remotely, Doom 3. I noticed it sometimes tends to freeze,", "tokens": [50364, 407, 341, 472, 307, 767, 11791, 20824, 11, 30168, 805, 13, 286, 5694, 309, 2171, 12258, 281, 15959, 11, 51160], "temperature": 0.0, "avg_logprob": -0.20196175208458533, "compression_ratio": 1.3858695652173914, "no_speech_prob": 0.00192055176012218}, {"id": 184, "seek": 132812, "start": 1344.04, "end": 1348.04, "text": " I don't know if it's because it's an old application running on the Nvidia", "tokens": [51160, 286, 500, 380, 458, 498, 309, 311, 570, 309, 311, 364, 1331, 3861, 2614, 322, 264, 46284, 51360], "temperature": 0.0, "avg_logprob": -0.20196175208458533, "compression_ratio": 1.3858695652173914, "no_speech_prob": 0.00192055176012218}, {"id": 185, "seek": 132812, "start": 1348.6, "end": 1353.7199999999998, "text": " Wayland drivers. As you can see there is no pointer locking here, so that's still one of", "tokens": [51388, 9558, 1661, 11590, 13, 1018, 291, 393, 536, 456, 307, 572, 23918, 23954, 510, 11, 370, 300, 311, 920, 472, 295, 51644], "temperature": 0.0, "avg_logprob": -0.20196175208458533, "compression_ratio": 1.3858695652173914, "no_speech_prob": 0.00192055176012218}, {"id": 186, "seek": 135372, "start": 1353.72, "end": 1358.68, "text": " the protocols that needs to be implemented, but we can simply start a new application here.", "tokens": [50364, 264, 20618, 300, 2203, 281, 312, 12270, 11, 457, 321, 393, 2935, 722, 257, 777, 3861, 510, 13, 50612], "temperature": 0.0, "avg_logprob": -0.14056599934895833, "compression_ratio": 1.4876847290640394, "no_speech_prob": 0.0043779052793979645}, {"id": 187, "seek": 135372, "start": 1359.24, "end": 1366.3600000000001, "text": " We have a nice 60 frames per second streaming to your browser. All works fast and fine,", "tokens": [50640, 492, 362, 257, 1481, 4060, 12083, 680, 1150, 11791, 281, 428, 11185, 13, 1057, 1985, 2370, 293, 2489, 11, 50996], "temperature": 0.0, "avg_logprob": -0.14056599934895833, "compression_ratio": 1.4876847290640394, "no_speech_prob": 0.0043779052793979645}, {"id": 188, "seek": 135372, "start": 1367.4, "end": 1370.92, "text": " so I wasn't lying when I said it's fast enough for gaming.", "tokens": [51048, 370, 286, 2067, 380, 8493, 562, 286, 848, 309, 311, 2370, 1547, 337, 9703, 13, 51224], "temperature": 0.0, "avg_logprob": -0.14056599934895833, "compression_ratio": 1.4876847290640394, "no_speech_prob": 0.0043779052793979645}, {"id": 189, "seek": 135372, "start": 1375.96, "end": 1379.8, "text": " You can see it, you can simply walk around here and everything.", "tokens": [51476, 509, 393, 536, 309, 11, 291, 393, 2935, 1792, 926, 510, 293, 1203, 13, 51668], "temperature": 0.0, "avg_logprob": -0.14056599934895833, "compression_ratio": 1.4876847290640394, "no_speech_prob": 0.0043779052793979645}, {"id": 190, "seek": 138372, "start": 1383.8, "end": 1397.48, "text": " There's also, here we have a Western demo applications compiled to a web assembly,", "tokens": [50368, 821, 311, 611, 11, 510, 321, 362, 257, 8724, 10723, 5821, 36548, 281, 257, 3670, 12103, 11, 51052], "temperature": 0.0, "avg_logprob": -0.2554600492436835, "compression_ratio": 1.3235294117647058, "no_speech_prob": 0.002461130963638425}, {"id": 191, "seek": 138372, "start": 1398.6000000000001, "end": 1407.64, "text": " there we go. So this is, I believe it's written using Cairo, I think my pointer is being captured", "tokens": [51108, 456, 321, 352, 13, 407, 341, 307, 11, 286, 1697, 309, 311, 3720, 1228, 30983, 340, 11, 286, 519, 452, 23918, 307, 885, 11828, 51560], "temperature": 0.0, "avg_logprob": -0.2554600492436835, "compression_ratio": 1.3235294117647058, "no_speech_prob": 0.002461130963638425}, {"id": 192, "seek": 140764, "start": 1407.64, "end": 1416.8400000000001, "text": " by the game. So it's using Cairo to draw all everything and G-Lip as well. So this runs inside", "tokens": [50364, 538, 264, 1216, 13, 407, 309, 311, 1228, 30983, 340, 281, 2642, 439, 1203, 293, 460, 12, 43, 647, 382, 731, 13, 407, 341, 6676, 1854, 50824], "temperature": 0.0, "avg_logprob": -0.20490785078568893, "compression_ratio": 1.5026737967914439, "no_speech_prob": 0.005543529987335205}, {"id": 193, "seek": 140764, "start": 1416.8400000000001, "end": 1424.3600000000001, "text": " an iframe, if you were to inspect the source code here, we have the iframe here that runs the web", "tokens": [50824, 364, 498, 81, 529, 11, 498, 291, 645, 281, 15018, 264, 4009, 3089, 510, 11, 321, 362, 264, 498, 81, 529, 510, 300, 6676, 264, 3670, 51200], "temperature": 0.0, "avg_logprob": -0.20490785078568893, "compression_ratio": 1.5026737967914439, "no_speech_prob": 0.005543529987335205}, {"id": 194, "seek": 140764, "start": 1424.3600000000001, "end": 1431.88, "text": " assembly application and yeah, talks Wayland protocol, it runs entirely in your browser,", "tokens": [51200, 12103, 3861, 293, 1338, 11, 6686, 9558, 1661, 10336, 11, 309, 6676, 7696, 294, 428, 11185, 11, 51576], "temperature": 0.0, "avg_logprob": -0.20490785078568893, "compression_ratio": 1.5026737967914439, "no_speech_prob": 0.005543529987335205}, {"id": 195, "seek": 143188, "start": 1431.88, "end": 1442.8400000000001, "text": " nicely isolated as well. It's all transparently done. Then we have, let's see if we can get this", "tokens": [50364, 9594, 14621, 382, 731, 13, 467, 311, 439, 7132, 6420, 1096, 13, 1396, 321, 362, 11, 718, 311, 536, 498, 321, 393, 483, 341, 50912], "temperature": 0.0, "avg_logprob": -0.22994261774523506, "compression_ratio": 1.4304635761589404, "no_speech_prob": 0.0036449830513447523}, {"id": 196, "seek": 143188, "start": 1447.5600000000002, "end": 1448.5200000000002, "text": " No, it doesn't want to go.", "tokens": [51148, 883, 11, 309, 1177, 380, 528, 281, 352, 13, 51196], "temperature": 0.0, "avg_logprob": -0.22994261774523506, "compression_ratio": 1.4304635761589404, "no_speech_prob": 0.0036449830513447523}, {"id": 197, "seek": 143188, "start": 1454.3600000000001, "end": 1461.3200000000002, "text": " So this is your web assembly application and of course we can also run desktop applications,", "tokens": [51488, 407, 341, 307, 428, 3670, 12103, 3861, 293, 295, 1164, 321, 393, 611, 1190, 14502, 5821, 11, 51836], "temperature": 0.0, "avg_logprob": -0.22994261774523506, "compression_ratio": 1.4304635761589404, "no_speech_prob": 0.0036449830513447523}, {"id": 198, "seek": 146132, "start": 1461.32, "end": 1473.6399999999999, "text": " so I have one running locally here. I think this is a cute app, there we go. So this one is running", "tokens": [50364, 370, 286, 362, 472, 2614, 16143, 510, 13, 286, 519, 341, 307, 257, 4052, 724, 11, 456, 321, 352, 13, 407, 341, 472, 307, 2614, 50980], "temperature": 0.0, "avg_logprob": -0.23355498137297453, "compression_ratio": 1.5977653631284916, "no_speech_prob": 0.0016419566236436367}, {"id": 199, "seek": 146132, "start": 1473.6399999999999, "end": 1482.52, "text": " on my desktop locally and see I can open, so this popup chooser is running in my browser,", "tokens": [50980, 322, 452, 14502, 16143, 293, 536, 286, 393, 1269, 11, 370, 341, 1665, 1010, 1586, 22150, 307, 2614, 294, 452, 11185, 11, 51424], "temperature": 0.0, "avg_logprob": -0.23355498137297453, "compression_ratio": 1.5977653631284916, "no_speech_prob": 0.0016419566236436367}, {"id": 200, "seek": 146132, "start": 1482.52, "end": 1488.4399999999998, "text": " it's all Wayland, see I can't move it and you arrive some packet. See it's the fast system of my", "tokens": [51424, 309, 311, 439, 9558, 1661, 11, 536, 286, 393, 380, 1286, 309, 293, 291, 8881, 512, 20300, 13, 3008, 309, 311, 264, 2370, 1185, 295, 452, 51720], "temperature": 0.0, "avg_logprob": -0.23355498137297453, "compression_ratio": 1.5977653631284916, "no_speech_prob": 0.0016419566236436367}, {"id": 201, "seek": 148844, "start": 1489.0800000000002, "end": 1498.04, "text": " my laptop as I said before and you can run it here. So that's that.", "tokens": [50396, 452, 10732, 382, 286, 848, 949, 293, 291, 393, 1190, 309, 510, 13, 407, 300, 311, 300, 13, 50844], "temperature": 0.0, "avg_logprob": -0.20533771019477348, "compression_ratio": 1.5120481927710843, "no_speech_prob": 0.004726095590740442}, {"id": 202, "seek": 148844, "start": 1502.04, "end": 1509.8, "text": " So far the demo, let's see if I can move it, yes, can go. So that was it, I hope you enjoyed. If you", "tokens": [51044, 407, 1400, 264, 10723, 11, 718, 311, 536, 498, 286, 393, 1286, 309, 11, 2086, 11, 393, 352, 13, 407, 300, 390, 309, 11, 286, 1454, 291, 4626, 13, 759, 291, 51432], "temperature": 0.0, "avg_logprob": -0.20533771019477348, "compression_ratio": 1.5120481927710843, "no_speech_prob": 0.004726095590740442}, {"id": 203, "seek": 148844, "start": 1509.8, "end": 1514.3600000000001, "text": " have any questions, I guess I have maybe some answers. I'll go from left to right.", "tokens": [51432, 362, 604, 1651, 11, 286, 2041, 286, 362, 1310, 512, 6338, 13, 286, 603, 352, 490, 1411, 281, 558, 13, 51660], "temperature": 0.0, "avg_logprob": -0.20533771019477348, "compression_ratio": 1.5120481927710843, "no_speech_prob": 0.004726095590740442}, {"id": 204, "seek": 151436, "start": 1515.08, "end": 1523.0, "text": " How does it work for input events? Yeah, so the question was how does it work for input events?", "tokens": [50400, 1012, 775, 309, 589, 337, 4846, 3931, 30, 865, 11, 370, 264, 1168, 390, 577, 775, 309, 589, 337, 4846, 3931, 30, 50796], "temperature": 0.0, "avg_logprob": -0.21311839639324032, "compression_ratio": 1.65, "no_speech_prob": 0.005975756328552961}, {"id": 205, "seek": 151436, "start": 1524.1999999999998, "end": 1532.4399999999998, "text": " It uses the browser's input framework. In case of pointer events, it uses the raw pointer event", "tokens": [50856, 467, 4960, 264, 11185, 311, 4846, 8388, 13, 682, 1389, 295, 23918, 3931, 11, 309, 4960, 264, 8936, 23918, 2280, 51268], "temperature": 0.0, "avg_logprob": -0.21311839639324032, "compression_ratio": 1.65, "no_speech_prob": 0.005975756328552961}, {"id": 206, "seek": 151436, "start": 1532.4399999999998, "end": 1539.3999999999999, "text": " API if it's available. It's still quite experimental but it removes some lag. So when it does it captures", "tokens": [51268, 9362, 498, 309, 311, 2435, 13, 467, 311, 920, 1596, 17069, 457, 309, 30445, 512, 8953, 13, 407, 562, 309, 775, 309, 27986, 51616], "temperature": 0.0, "avg_logprob": -0.21311839639324032, "compression_ratio": 1.65, "no_speech_prob": 0.005975756328552961}, {"id": 207, "seek": 153940, "start": 1539.4, "end": 1545.72, "text": " the browser pointer events and then basically translates this to input events like they were", "tokens": [50364, 264, 11185, 23918, 3931, 293, 550, 1936, 28468, 341, 281, 4846, 3931, 411, 436, 645, 50680], "temperature": 0.0, "avg_logprob": -0.14513731002807617, "compression_ratio": 1.550561797752809, "no_speech_prob": 0.025802677497267723}, {"id": 208, "seek": 153940, "start": 1545.72, "end": 1551.5600000000002, "text": " coming say from from lip inputs and it's then sent using Wayland protocol to the application.", "tokens": [50680, 1348, 584, 490, 490, 8280, 15743, 293, 309, 311, 550, 2279, 1228, 9558, 1661, 10336, 281, 264, 3861, 13, 50972], "temperature": 0.0, "avg_logprob": -0.14513731002807617, "compression_ratio": 1.550561797752809, "no_speech_prob": 0.025802677497267723}, {"id": 209, "seek": 153940, "start": 1551.5600000000002, "end": 1559.0, "text": " So it's fast but you still have inevitably the network latency that's unavoidable, sadly.", "tokens": [50972, 407, 309, 311, 2370, 457, 291, 920, 362, 28171, 264, 3209, 27043, 300, 311, 36541, 17079, 712, 11, 22023, 13, 51344], "temperature": 0.0, "avg_logprob": -0.14513731002807617, "compression_ratio": 1.550561797752809, "no_speech_prob": 0.025802677497267723}, {"id": 210, "seek": 155900, "start": 1559.64, "end": 1565.88, "text": " Yes, I have two questions. The first one is does it support KDE's background blur protocol?", "tokens": [50396, 1079, 11, 286, 362, 732, 1651, 13, 440, 700, 472, 307, 775, 309, 1406, 591, 22296, 311, 3678, 14257, 10336, 30, 50708], "temperature": 0.0, "avg_logprob": -0.2360425047822051, "compression_ratio": 1.7175925925925926, "no_speech_prob": 0.07865634560585022}, {"id": 211, "seek": 155900, "start": 1567.16, "end": 1571.64, "text": " The question was does it support KDE background blur? No, it does not. Currently the only", "tokens": [50772, 440, 1168, 390, 775, 309, 1406, 591, 22296, 3678, 14257, 30, 883, 11, 309, 775, 406, 13, 19964, 264, 787, 50996], "temperature": 0.0, "avg_logprob": -0.2360425047822051, "compression_ratio": 1.7175925925925926, "no_speech_prob": 0.07865634560585022}, {"id": 212, "seek": 155900, "start": 1571.64, "end": 1576.92, "text": " protocols implemented are the core Wayland protocol and basically the XDG desktop protocol.", "tokens": [50996, 20618, 12270, 366, 264, 4965, 9558, 1661, 10336, 293, 1936, 264, 32336, 38, 14502, 10336, 13, 51260], "temperature": 0.0, "avg_logprob": -0.2360425047822051, "compression_ratio": 1.7175925925925926, "no_speech_prob": 0.07865634560585022}, {"id": 213, "seek": 155900, "start": 1577.48, "end": 1586.04, "text": " The second question is vertical synchronization v-sync. Yes, so the vertical v-sync is supported.", "tokens": [51288, 440, 1150, 1168, 307, 9429, 19331, 2144, 371, 12, 82, 34015, 13, 1079, 11, 370, 264, 9429, 371, 12, 82, 34015, 307, 8104, 13, 51716], "temperature": 0.0, "avg_logprob": -0.2360425047822051, "compression_ratio": 1.7175925925925926, "no_speech_prob": 0.07865634560585022}, {"id": 214, "seek": 158604, "start": 1586.04, "end": 1593.8, "text": " So it uses the browser request frame callback API which is basically the v-sync callback that", "tokens": [50364, 407, 309, 4960, 264, 11185, 5308, 3920, 818, 3207, 9362, 597, 307, 1936, 264, 371, 12, 82, 34015, 818, 3207, 300, 50752], "temperature": 0.0, "avg_logprob": -0.17368549619402204, "compression_ratio": 1.2592592592592593, "no_speech_prob": 0.020996108651161194}, {"id": 215, "seek": 158604, "start": 1593.8, "end": 1597.96, "text": " the browser offers to draw. Next question.", "tokens": [50752, 264, 11185, 7736, 281, 2642, 13, 3087, 1168, 13, 50960], "temperature": 0.0, "avg_logprob": -0.17368549619402204, "compression_ratio": 1.2592592592592593, "no_speech_prob": 0.020996108651161194}, {"id": 216, "seek": 161604, "start": 1616.76, "end": 1626.44, "text": " Yeah, so the question was does it use h.265 and is it secure I guess in a legal standpoint?", "tokens": [50400, 865, 11, 370, 264, 1168, 390, 775, 309, 764, 276, 13, 10880, 20, 293, 307, 309, 7144, 286, 2041, 294, 257, 5089, 15827, 30, 50884], "temperature": 0.0, "avg_logprob": -0.13877649796314728, "compression_ratio": 1.4972067039106145, "no_speech_prob": 0.014151109382510185}, {"id": 217, "seek": 161604, "start": 1626.44, "end": 1633.8799999999999, "text": " It uses h.264 in this case. The reason being that the web codec API is from the browsers.", "tokens": [50884, 467, 4960, 276, 13, 10880, 19, 294, 341, 1389, 13, 440, 1778, 885, 300, 264, 3670, 3089, 66, 9362, 307, 490, 264, 36069, 13, 51256], "temperature": 0.0, "avg_logprob": -0.13877649796314728, "compression_ratio": 1.4972067039106145, "no_speech_prob": 0.014151109382510185}, {"id": 218, "seek": 161604, "start": 1634.44, "end": 1639.3999999999999, "text": " Most of the browsers do not support h.265, at least not at the point I implemented it.", "tokens": [51284, 4534, 295, 264, 36069, 360, 406, 1406, 276, 13, 10880, 20, 11, 412, 1935, 406, 412, 264, 935, 286, 12270, 309, 13, 51532], "temperature": 0.0, "avg_logprob": -0.13877649796314728, "compression_ratio": 1.4972067039106145, "no_speech_prob": 0.014151109382510185}, {"id": 219, "seek": 163940, "start": 1639.4, "end": 1646.8400000000001, "text": " So currently it uses h.264. I currently do not use it for commercial purposes.", "tokens": [50364, 407, 4362, 309, 4960, 276, 13, 10880, 19, 13, 286, 4362, 360, 406, 764, 309, 337, 6841, 9932, 13, 50736], "temperature": 0.0, "avg_logprob": -0.26342193029260125, "compression_ratio": 1.4955752212389382, "no_speech_prob": 0.0029256721027195454}, {"id": 220, "seek": 163940, "start": 1648.1200000000001, "end": 1654.1200000000001, "text": " So yeah, I hope I'm safe. I'm going to have one more question and then I'm going to stop.", "tokens": [50800, 407, 1338, 11, 286, 1454, 286, 478, 3273, 13, 286, 478, 516, 281, 362, 472, 544, 1168, 293, 550, 286, 478, 516, 281, 1590, 13, 51100], "temperature": 0.0, "avg_logprob": -0.26342193029260125, "compression_ratio": 1.4955752212389382, "no_speech_prob": 0.0029256721027195454}, {"id": 221, "seek": 163940, "start": 1655.64, "end": 1660.8400000000001, "text": " Yes. So obviously the way the application expects Unix socket at the wet level,", "tokens": [51176, 1079, 13, 407, 2745, 264, 636, 264, 3861, 33280, 1156, 970, 19741, 412, 264, 6630, 1496, 11, 51436], "temperature": 0.0, "avg_logprob": -0.26342193029260125, "compression_ratio": 1.4955752212389382, "no_speech_prob": 0.0029256721027195454}, {"id": 222, "seek": 163940, "start": 1660.8400000000001, "end": 1664.52, "text": " do you fix this if they're compiling for WebAssembly? Did you just implement the Wayland?", "tokens": [51436, 360, 291, 3191, 341, 498, 436, 434, 715, 4883, 337, 9573, 10884, 19160, 30, 2589, 291, 445, 4445, 264, 9558, 1661, 30, 51620], "temperature": 0.0, "avg_logprob": -0.26342193029260125, "compression_ratio": 1.4955752212389382, "no_speech_prob": 0.0029256721027195454}, {"id": 223, "seek": 166452, "start": 1665.4, "end": 1671.32, "text": " Yeah, so the question was if you're compiling for WebAssembly and the application is expecting a", "tokens": [50408, 865, 11, 370, 264, 1168, 390, 498, 291, 434, 715, 4883, 337, 9573, 10884, 19160, 293, 264, 3861, 307, 9650, 257, 50704], "temperature": 0.0, "avg_logprob": -0.16460219065348308, "compression_ratio": 1.455958549222798, "no_speech_prob": 0.005266635678708553}, {"id": 224, "seek": 166452, "start": 1671.32, "end": 1681.8799999999999, "text": " Unix socket, how do you implement it? I extended the EM script in SDK so that it basically has", "tokens": [50704, 1156, 970, 19741, 11, 577, 360, 291, 4445, 309, 30, 286, 10913, 264, 16237, 5755, 294, 37135, 370, 300, 309, 1936, 575, 51232], "temperature": 0.0, "avg_logprob": -0.16460219065348308, "compression_ratio": 1.455958549222798, "no_speech_prob": 0.005266635678708553}, {"id": 225, "seek": 166452, "start": 1681.8799999999999, "end": 1689.32, "text": " support for Unix sockets on the user level and then also added e-polling to that as well.", "tokens": [51232, 1406, 337, 1156, 970, 370, 11984, 322, 264, 4195, 1496, 293, 550, 611, 3869, 308, 12, 79, 1833, 278, 281, 300, 382, 731, 13, 51604], "temperature": 0.0, "avg_logprob": -0.16460219065348308, "compression_ratio": 1.455958549222798, "no_speech_prob": 0.005266635678708553}, {"id": 226, "seek": 168932, "start": 1689.3999999999999, "end": 1696.36, "text": " So for the application it's purely Unix sockets. It's not entirely so there's only client side", "tokens": [50368, 407, 337, 264, 3861, 309, 311, 17491, 1156, 970, 370, 11984, 13, 467, 311, 406, 7696, 370, 456, 311, 787, 6423, 1252, 50716], "temperature": 0.0, "avg_logprob": -0.17056777954101562, "compression_ratio": 1.5052631578947369, "no_speech_prob": 0.004862460307776928}, {"id": 227, "seek": 168932, "start": 1696.36, "end": 1700.84, "text": " support for connecting to a Unix socket, not for creating a Unix socket because that is done", "tokens": [50716, 1406, 337, 11015, 281, 257, 1156, 970, 19741, 11, 406, 337, 4084, 257, 1156, 970, 19741, 570, 300, 307, 1096, 50940], "temperature": 0.0, "avg_logprob": -0.17056777954101562, "compression_ratio": 1.5052631578947369, "no_speech_prob": 0.004862460307776928}, {"id": 228, "seek": 168932, "start": 1701.96, "end": 1710.36, "text": " by the SDK itself. If you have more questions, I'm available. So after the talk, come and find me.", "tokens": [50996, 538, 264, 37135, 2564, 13, 759, 291, 362, 544, 1651, 11, 286, 478, 2435, 13, 407, 934, 264, 751, 11, 808, 293, 915, 385, 13, 51416], "temperature": 0.0, "avg_logprob": -0.17056777954101562, "compression_ratio": 1.5052631578947369, "no_speech_prob": 0.004862460307776928}, {"id": 229, "seek": 171036, "start": 1710.36, "end": 1721.8, "text": " Happy to answer them. Thank you.", "tokens": [50368, 8277, 281, 1867, 552, 13, 1044, 291, 13, 50936], "temperature": 0.0, "avg_logprob": -0.4620010636069558, "compression_ratio": 0.8, "no_speech_prob": 0.03523598238825798}], "language": "en"}