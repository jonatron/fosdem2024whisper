{"text": " All right, everyone. So I guess this is the last session for today. And what I'm going to present now is about our project, Test Enough for Automated Appendice Updates. And before I delve into my presentation, does anyone actually have an answer to this? Who wants to attempt to answer the question here? It depends. Yeah, that's a great answer. And I think that's also in a way in the right direction. So a little bit about myself. So my name is Joseph Hyder. I'm a member of technical staff at Endolabs. It's a startup on more now a scale up based in Palo Alto in California. And before that, I mean, I'm still actually a PhD candidate at the Duff University of Technology in the Netherlands. So quite close by to Brussels here. And for the last, let's say like six, seven, eight years of my life, I've been quite involved in working on this, writing, security, but also developing techniques that are focused on trying to like apply program analysis to, for example, package repositories or trying to better understand what's going on within dependencies and dependency trees. And just like a little bit talk about what I mean with automated appendice updates. I guess most of you already know what it is. So essentially whenever there is a new release from Maven, Ruby Jam, Socargo or MPM, you would have a tool. I just did a couple of them, which is the Panda Bot or renovate or that few. So when there's a new release in your repository, usually a prerequisite is created. And then the, let's say like it creates a branch out of your repository, tries to build it. If that goes fine, so it goes usually to the next stage. If you have it configured to basically run the tests. And then if everything is fine, in this case, it's showed on X mark, but imagine if everything is fine, you will merge it. In some cases, if you know it's not a problem, you would merge it in any case. And I think for many of us, we have seen like, usually show something like this. It would update version 2.2 to 2.4. So that's like the essential thing that I'm focusing around. Like what I mean with automated dependence updates. And an interesting thing around automated dependence updates is that there's usually this promise that if you just run your tests, you are essentially able to catch any type of regression errors, any problems that might exist in your code. And me as a researcher that maybe sort of a bit questioning pattern, as I felt like, hmm, the test that we are usually having are projects, they're more focused on the your project test suite. And maybe not so much on the third party dependencies or third party libraries that you use in your code. So that may be sort of race three questions. The first question that I asked was, do we even write tests against dependencies in the first place? And then the second question is, do project tests with even cover usages of dependencies in the source code? And the last one is like, are even test sufficient alone just using tests to detect any bad updates that you might find in using these tools or doing automated dependency updates? And to study this, I looked into open source projects at the first, oh yeah, another question is, of course, should we even write test for dependencies? Because if we like to reuse components from open source package repositories, why should we even write tests for that? Because it kind of gives us the ergonomics that we can just use anything like it in our code and that's it. And this sort of like started like as an empirical study, that's sort of what this talk is primarily centered around. So the first thing that I looked at in 20 study was to see what is the statement coverage of function calls to dependencies. And this is similar to considering for example, like covered like life support, for example, like J. Coco as a tool. And then the other thing that we also focus in the study is how effective are tests using detecting updates with regression errors. So what we're doing here is that we are basically trying to find, I mean, either find or actually put regression errors in existing libraries, and then directly validate whether the project test suite can directly detect that or not. And that's also something called mutation testing analysis. And I think there was one talk about this earlier. And then the last thing around the studies that currently the sort of state of thought is to focus on just using test suites, but could we use another way to find any problems or early detect issues that might exist in updating our dependency. So yeah, the first question is like, how can we do some type of statement coverage or get an idea about what exactly are we using in third party libraries? So we did this in two ways. The first thing was to essentially, so this was of course in Java, we extracted all call sites that we will find in projects. And if those call sites points to third party libraries in bytecode, we consider that as a usage. And that's for trustive dependencies because now you're not, let's say like longer on your source code where you have the call set direct dependencies, you would also need to go to the trusty ones and here to sort of approximate that is not an exact measurement. We essentially build static whole graphs to kind of get an idea of what would be used in the chemistry of our project. And then last we did some instrumentation. So we essentially run the tests of a project and execute what functions were invoked in the dependencies. And this will give, let's say like some idea of what exactly is being used or not used at all. So essentially first we statically derive like, what are all the usages? And then by running the tests we know which of those functions were covered or not. So kind of similar to code coverage. And we did this for around 521 Gita projects. And what we found very interesting was that when we look at the direct dependencies of a project, so this is all the direct dependencies that were found, about 60% like when running the tests are, let's say like covered by it. But then when we go to trustive dependencies, we found that the median was only 20%. So which means that a lot of the transitive functions that may be used may not even be reachable by test. So they sort of like ring some alarm bells, right? Because that means essentially like if you have a dependency update and you don't have any test that is covering that area, that will basically give you a green tick and you might merge it. And I don't think many would do that. But that's, let's say like the implementation area that also kind of raises some questions around how effective using tests for automated updates. And yeah, the other question does this matter at all. And I think a very interesting one here is the log for shell case because I don't think many of us would have tests that is particularly targeting log libraries. But here is an instance where something we don't normally would test and would have tests in any case. If you would do an update, then yeah, there might be some breaking changes then yeah, there will be a problem here. Then going to the second part of the study, which was on test effectiveness. And I was measuring that we're doing mutation testing. So the underlying framework we used here was a pie test, but we modified pie test to do things a little bit differently. And yeah, to sort of like give a quick sort of idea of what mutation testing is, is that you essentially have a function, for example, return x plus y. And then you apply some type of mutation operator where you swap, let's say like the class. And then you would expect that your test suite will be able to cover this because here the behavior is completely changed, right? It's no longer an addition operator. So normally with mutation testing, you would give it your whole project source code. It will start trying to modify in the source code and then see whether the test suite is able to capture that or not. So what we did differently is that we essentially mutated functions in the dependency code and not the project code at all. And we only mutated those that were reachable by test. So I was saying earlier that we were running a test to know which functions were executed. So we used those functions to essentially apply those mutation operators. And then from there we can see if the test is able to capture that or not. And yeah, before I go into this also another alternative way that we investigated is called a change impact analysis. So here we sort of leverage static analysis and specifically using call graphs. So how it essentially works is that we have a version 1.02 and 1.03. We compute a diff and for the diff we will find out which functions changed. And for example here we know that in bar and bus function we can see that there is an arithmetic change like instead of y minus minus it's y plus plus. And then in the other, like in the bus function we see that there is a new method called. And then what do we do later? We practically build a call graph of the application and its dependencies. And then using reachability analysis, so what we do here is that we know that the bar and bus was changed. And here we have let's say like a reachable path from bar up to let's say like stats on the score JSON I mean. And also we have like bus here where we have a new function called to QX STR. And by using this we can directly figure out if there is a coaching and dependency whether you are reachable or not in the first place. And why this is like a very nice complement to dynamic test is that we are essentially leveraging by looking at the source code what are we actually using. And then as a complement to where tests might not be covering we can sort of find directly if there is any change that might affect like your project. That of course comes the more tricky part which is semantic changes. So I mean one thing it's nice that you can detect that the method change but sometimes you might just do a simple refactoring that you know just refactors are a huge method into a method with like a couple of smaller methods is that. So the truth is that it's extremely difficult to know what exactly is a semantic change because there's a lot of factors around it. So the only thing that we did was that we kind of took what was like behavioral changes. So we looked at only like data flow or control flow changes. So for example if you add a new method call we consider that as like a special change or if you did some major change on your if statements that may introduce a new logic of how the control flow works then we consider that as an interesting change to follow. And what it is like I implemented a tool called Uptatera which means update in Swedish. And so I applied this on. So it essentially shows like which function had a change. So for example Rx, Java, not facing subscriber on error and we can see that it's reachable from the project and then it shows exactly how it was reachable. Yeah through like the code. And then in the second section I would have like what is basically the major changes in that function. So this could sort of give you some context of what essentially changed. Other than just telling that either the test parsed or failed. And when using this mutation PyPlanet that was explaining we essentially generated 1 million artificial updates by introducing those regressions and we did this on 262 GitHub projects. And what we found was that when doing the sort of changes on project tests we found that on average projects are able to detect 37% of those which means that a lot of like changes may not may get unnoticed like in general. But if you use static analysis now that you sort of have the whole context we able to detect 72% of all those changes. But what we find more interesting is that we can see that interestingly here like from the context of the studies that there's basically no guarantees that tests can prevent bad updates and using either of those techniques is not good enough to ensure that updates are safe. Then of course the other thing is that static analysis is not perfect. There are also problems with it as well. So the problem is over approximation. So we have over approximation at two locations. One is the call graphs themselves because when it comes to dynamic dispatch if there are maybe 200 implementations that might stand from an interface call we have to link to all of them and that might generate false positives. And then the other case is also with the semantic changes that we are detecting because we also don't know exactly what type of semantic changes it is. But to sort of see how this worked in practice we also analyzed and applied this on 22 dependable PRs. And from the results what we found in general was that by using static analysis we were able to detect three unused dependencies. So here let's say like the test would just pass it whatever but in fact we found that the dependencies were not used at all. And we were able to prevent three breaking updates and one which actually was confirmed by our developer where the test were not able to detect. And then of course we found that there are let's say like false positives and as I mentioned there were many cases with refractorings and then of course this over approximated call paths. So if you use like a tool like Google here or static analysis it can help to prevent updates but then you also get a lot of noise as well as a result. So sort of coming to the end of more of the studies what are let's say like the recommendations that I have after looking into like on Github projects how tests are being made etc. So one thing I found missing when it comes to updating with test widths is that we don't have any form of confidence score. And what I mean with confidence score is that for example if we can stop measuring test coverage we can see for example if there is a change function in a third party library do we even have test that reaches that or not and that could directly give an indication whether like my test width is able to capture that or not. And another very interesting thing could be for example if you find that one of your libraries are very tightly integrated with your project it can also sort of give an indication whether you have let's say like enough test to cover that usage or not at all. And then by having sort of this score you can maybe get an indication where does let's say like how well am I just able to capture things in third party libraries or not. This is something that I would like to see in tooling in general. And then when it comes to the gaps in test coverage so this is related to the results I was saying like the statement coverage and effectiveness. So I believe more of having a hybrid solution so we're using tests or dynamic analysis is able to capture. I think we should use that because that is more precise. But then in areas of the code where we don't have any coverage so for example consider back to the look for J library where usually I wouldn't expect just to be much test coverage. Here it could be nice to complement the static analysis. So you sort of get a little bit better for both words here. And then another advantage that I might see having static analysis rather running tests is that we can maybe much more earlier to take potential like problems in compatibilities by having that rather than trying to run it through the build system consuming extra resources or tests etc. So those are less likely to main things that I find important to address. And then for users like myself of using this automated dependence updating tools. So although like reusing is free in the sense that we can easily just use a library but we often forget the operational and maintenance costs and those are not free. So trying to basically automate away everything by using tooling etc. is not always the solution. I think it's important to also consider that once we start adopting a library we also need to think about how we can maintain it but also understanding what potential risk might come from it. Could be for example that maintainer have a very different sort of handling when it comes to security vulnerabilities. It could also be with the release protocol like there could be disagreements on what is breaking change or not for clients. So I think having that aspect is one important thing. And the other thing is like of course not blindly trusting automated dependency updates and I guess no one really does this. And then that's another thing which could be debatable is to have essentially critical I mean having writing tests for critical dependencies and this could be a library that's very critical to your project. I think here maybe having tests could help let's say like capture early issues that might arise in dependencies and not come as an unwanted breaking change later on once you merge the automated PR. So if you want to let's say like know more about this work I have a paper so I also uploaded slides on the Fosnum website so you can click the link and the paper is open access and yeah this is concludes my talk more or less so happy to take any questions. So do you know if any of these bots like the pen about renovate are working on such a score so let's say the merge request to get like a warning. Hey your tests are not covering only 10 percent of the dependencies. Do you know if there is any work. So what I'm aware of is that there is a compatibility score that looks at for example for a particular dependency version updates if out of less than like 200 PRs if 100 of those were successful for other projects then it will give us a score that there's a 50 percent chance that you will succeed here. The only thing I find problematic is that every project has their own specific use case or context of how they use it so it could be misleading but I haven't heard anything that looks specifically into your test suite to see how I mean how it's able to do that. Thank you. You mentioned the number of 60 percent for the amount of tests for direct dependencies and I believe it was a lot less for transitive dependencies. Do you have any numbers on the amount of transitive dependencies in search change the chains actually. So I can can imagine that the 60 percent is cumulative in these. Do you mean for the statement coverage thing or the statement. Yeah the first one. So the first one the 60 percent was on like direct dependencies and then this 20 percent was on the transitive ones. Do you have any numbers of the amount of transitive dependencies so you can relate it to that 60 percent. Okay so I did this on 500 time projects but I might have the more specific numbers in the paper. Okay. You have been looking at detecting errors. Have you looked in the other side because you can use it in a hybrid mode that your tool maybe can tell me you can make this update for sure because all the code is changed. You don't care about it. For example if you look at low level right libraries like Apache Commons you only use a part of it but you want to keep up to date and some updates are more or less completely safe because you don't touch any code that has changed because only new features have been added or so and that would also help if I just know yes that's safe. Yeah that's a great question. So this is a little bit idea we had with introducing call graphs because the call graphs you can start learning what exactly is used. So even if you use like a major library and you just use maybe two utility classes and even if you go to like a major version of it you might not be affected by it and this is something that should be covered by the call graph so we will see for example that the utility classes there are no changes there but then in the rest of the package there's a lot of changes that you're unaffected by. Thank you. Did you check how the call graphs work with dynamic dependency injection? Yeah so we essentially if I understood the question right I mean so we did generate the dynamic call graphs like running the test and this is something that we essentially used to guide or rotation like testing framework to only do changes in those functions and not for example functions that the test didn't touch because otherwise we wouldn't know whether I mean the test we were able to detect changes or not.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 7.0, "text": " All right, everyone. So I guess this is the last session for today. And what I'm going", "tokens": [50364, 1057, 558, 11, 1518, 13, 407, 286, 2041, 341, 307, 264, 1036, 5481, 337, 965, 13, 400, 437, 286, 478, 516, 50714], "temperature": 0.0, "avg_logprob": -0.3075821770562066, "compression_ratio": 1.497854077253219, "no_speech_prob": 0.4780263900756836}, {"id": 1, "seek": 0, "start": 10.92, "end": 17.04, "text": " to present now is about our project, Test Enough for Automated Appendice Updates. And", "tokens": [50910, 281, 1974, 586, 307, 466, 527, 1716, 11, 9279, 19401, 337, 24619, 770, 3132, 521, 573, 5858, 67, 1024, 13, 400, 51216], "temperature": 0.0, "avg_logprob": -0.3075821770562066, "compression_ratio": 1.497854077253219, "no_speech_prob": 0.4780263900756836}, {"id": 2, "seek": 0, "start": 17.04, "end": 21.04, "text": " before I delve into my presentation, does anyone actually have an answer to this? Who", "tokens": [51216, 949, 286, 43098, 666, 452, 5860, 11, 775, 2878, 767, 362, 364, 1867, 281, 341, 30, 2102, 51416], "temperature": 0.0, "avg_logprob": -0.3075821770562066, "compression_ratio": 1.497854077253219, "no_speech_prob": 0.4780263900756836}, {"id": 3, "seek": 0, "start": 21.04, "end": 28.04, "text": " wants to attempt to answer the question here? It depends. Yeah, that's a great answer. And", "tokens": [51416, 2738, 281, 5217, 281, 1867, 264, 1168, 510, 30, 467, 5946, 13, 865, 11, 300, 311, 257, 869, 1867, 13, 400, 51766], "temperature": 0.0, "avg_logprob": -0.3075821770562066, "compression_ratio": 1.497854077253219, "no_speech_prob": 0.4780263900756836}, {"id": 4, "seek": 2804, "start": 28.08, "end": 33.92, "text": " I think that's also in a way in the right direction. So a little bit about myself. So", "tokens": [50366, 286, 519, 300, 311, 611, 294, 257, 636, 294, 264, 558, 3513, 13, 407, 257, 707, 857, 466, 2059, 13, 407, 50658], "temperature": 0.0, "avg_logprob": -0.3193798475368049, "compression_ratio": 1.4638297872340424, "no_speech_prob": 0.039514634758234024}, {"id": 5, "seek": 2804, "start": 33.92, "end": 40.92, "text": " my name is Joseph Hyder. I'm a member of technical staff at Endolabs. It's a startup", "tokens": [50658, 452, 1315, 307, 11170, 5701, 1068, 13, 286, 478, 257, 4006, 295, 6191, 3525, 412, 6967, 401, 17243, 13, 467, 311, 257, 18578, 51008], "temperature": 0.0, "avg_logprob": -0.3193798475368049, "compression_ratio": 1.4638297872340424, "no_speech_prob": 0.039514634758234024}, {"id": 6, "seek": 2804, "start": 41.04, "end": 48.04, "text": " on more now a scale up based in Palo Alto in California. And before that, I mean, I'm", "tokens": [51014, 322, 544, 586, 257, 4373, 493, 2361, 294, 6116, 78, 50066, 294, 5384, 13, 400, 949, 300, 11, 286, 914, 11, 286, 478, 51364], "temperature": 0.0, "avg_logprob": -0.3193798475368049, "compression_ratio": 1.4638297872340424, "no_speech_prob": 0.039514634758234024}, {"id": 7, "seek": 2804, "start": 49.120000000000005, "end": 53.6, "text": " still actually a PhD candidate at the Duff University of Technology in the Netherlands.", "tokens": [51418, 920, 767, 257, 14476, 11532, 412, 264, 413, 1245, 3535, 295, 15037, 294, 264, 20873, 13, 51642], "temperature": 0.0, "avg_logprob": -0.3193798475368049, "compression_ratio": 1.4638297872340424, "no_speech_prob": 0.039514634758234024}, {"id": 8, "seek": 5360, "start": 53.64, "end": 60.64, "text": " So quite close by to Brussels here. And for the last, let's say like six, seven, eight", "tokens": [50366, 407, 1596, 1998, 538, 281, 38717, 510, 13, 400, 337, 264, 1036, 11, 718, 311, 584, 411, 2309, 11, 3407, 11, 3180, 50716], "temperature": 0.0, "avg_logprob": -0.32525455520813723, "compression_ratio": 1.5108225108225108, "no_speech_prob": 0.08870451152324677}, {"id": 9, "seek": 5360, "start": 60.64, "end": 66.64, "text": " years of my life, I've been quite involved in working on this, writing, security, but", "tokens": [50716, 924, 295, 452, 993, 11, 286, 600, 668, 1596, 3288, 294, 1364, 322, 341, 11, 3579, 11, 3825, 11, 457, 51016], "temperature": 0.0, "avg_logprob": -0.32525455520813723, "compression_ratio": 1.5108225108225108, "no_speech_prob": 0.08870451152324677}, {"id": 10, "seek": 5360, "start": 66.64, "end": 73.64, "text": " also developing techniques that are focused on trying to like apply program analysis to,", "tokens": [51016, 611, 6416, 7512, 300, 366, 5178, 322, 1382, 281, 411, 3079, 1461, 5215, 281, 11, 51366], "temperature": 0.0, "avg_logprob": -0.32525455520813723, "compression_ratio": 1.5108225108225108, "no_speech_prob": 0.08870451152324677}, {"id": 11, "seek": 5360, "start": 74.44, "end": 79.0, "text": " for example, package repositories or trying to better understand what's going on within", "tokens": [51406, 337, 1365, 11, 7372, 22283, 2083, 420, 1382, 281, 1101, 1223, 437, 311, 516, 322, 1951, 51634], "temperature": 0.0, "avg_logprob": -0.32525455520813723, "compression_ratio": 1.5108225108225108, "no_speech_prob": 0.08870451152324677}, {"id": 12, "seek": 7900, "start": 79.04, "end": 86.04, "text": " dependencies and dependency trees. And just like a little bit talk about what I mean with", "tokens": [50366, 36606, 293, 33621, 5852, 13, 400, 445, 411, 257, 707, 857, 751, 466, 437, 286, 914, 365, 50716], "temperature": 0.0, "avg_logprob": -0.3039577732915464, "compression_ratio": 1.5, "no_speech_prob": 0.01804560050368309}, {"id": 13, "seek": 7900, "start": 86.6, "end": 92.84, "text": " automated appendice updates. I guess most of you already know what it is. So essentially", "tokens": [50744, 18473, 34116, 573, 9205, 13, 286, 2041, 881, 295, 291, 1217, 458, 437, 309, 307, 13, 407, 4476, 51056], "temperature": 0.0, "avg_logprob": -0.3039577732915464, "compression_ratio": 1.5, "no_speech_prob": 0.01804560050368309}, {"id": 14, "seek": 7900, "start": 92.84, "end": 99.84, "text": " whenever there is a new release from Maven, Ruby Jam, Socargo or MPM, you would have a", "tokens": [51056, 5699, 456, 307, 257, 777, 4374, 490, 4042, 553, 11, 19907, 10372, 11, 407, 6166, 1571, 420, 14146, 44, 11, 291, 576, 362, 257, 51406], "temperature": 0.0, "avg_logprob": -0.3039577732915464, "compression_ratio": 1.5, "no_speech_prob": 0.01804560050368309}, {"id": 15, "seek": 7900, "start": 100.52, "end": 107.12, "text": " tool. I just did a couple of them, which is the Panda Bot or renovate or that few. So", "tokens": [51440, 2290, 13, 286, 445, 630, 257, 1916, 295, 552, 11, 597, 307, 264, 44207, 25486, 420, 18845, 473, 420, 300, 1326, 13, 407, 51770], "temperature": 0.0, "avg_logprob": -0.3039577732915464, "compression_ratio": 1.5, "no_speech_prob": 0.01804560050368309}, {"id": 16, "seek": 10712, "start": 107.16000000000001, "end": 113.16000000000001, "text": " when there's a new release in your repository, usually a prerequisite is created. And then", "tokens": [50366, 562, 456, 311, 257, 777, 4374, 294, 428, 25841, 11, 2673, 257, 38333, 34152, 307, 2942, 13, 400, 550, 50666], "temperature": 0.0, "avg_logprob": -0.25877843351445645, "compression_ratio": 1.78714859437751, "no_speech_prob": 0.01736833155155182}, {"id": 17, "seek": 10712, "start": 113.16000000000001, "end": 120.16000000000001, "text": " the, let's say like it creates a branch out of your repository, tries to build it. If", "tokens": [50666, 264, 11, 718, 311, 584, 411, 309, 7829, 257, 9819, 484, 295, 428, 25841, 11, 9898, 281, 1322, 309, 13, 759, 51016], "temperature": 0.0, "avg_logprob": -0.25877843351445645, "compression_ratio": 1.78714859437751, "no_speech_prob": 0.01736833155155182}, {"id": 18, "seek": 10712, "start": 120.16000000000001, "end": 124.56, "text": " that goes fine, so it goes usually to the next stage. If you have it configured to basically", "tokens": [51016, 300, 1709, 2489, 11, 370, 309, 1709, 2673, 281, 264, 958, 3233, 13, 759, 291, 362, 309, 30538, 281, 1936, 51236], "temperature": 0.0, "avg_logprob": -0.25877843351445645, "compression_ratio": 1.78714859437751, "no_speech_prob": 0.01736833155155182}, {"id": 19, "seek": 10712, "start": 124.56, "end": 131.56, "text": " run the tests. And then if everything is fine, in this case, it's showed on X mark, but", "tokens": [51236, 1190, 264, 6921, 13, 400, 550, 498, 1203, 307, 2489, 11, 294, 341, 1389, 11, 309, 311, 4712, 322, 1783, 1491, 11, 457, 51586], "temperature": 0.0, "avg_logprob": -0.25877843351445645, "compression_ratio": 1.78714859437751, "no_speech_prob": 0.01736833155155182}, {"id": 20, "seek": 10712, "start": 131.72, "end": 135.08, "text": " imagine if everything is fine, you will merge it. In some cases, if you know it's not a", "tokens": [51594, 3811, 498, 1203, 307, 2489, 11, 291, 486, 22183, 309, 13, 682, 512, 3331, 11, 498, 291, 458, 309, 311, 406, 257, 51762], "temperature": 0.0, "avg_logprob": -0.25877843351445645, "compression_ratio": 1.78714859437751, "no_speech_prob": 0.01736833155155182}, {"id": 21, "seek": 13508, "start": 135.12, "end": 142.12, "text": " problem, you would merge it in any case. And I think for many of us, we have seen like,", "tokens": [50366, 1154, 11, 291, 576, 22183, 309, 294, 604, 1389, 13, 400, 286, 519, 337, 867, 295, 505, 11, 321, 362, 1612, 411, 11, 50716], "temperature": 0.0, "avg_logprob": -0.2668926771297011, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.01706487499177456}, {"id": 22, "seek": 13508, "start": 142.16000000000003, "end": 148.16000000000003, "text": " usually show something like this. It would update version 2.2 to 2.4. So that's like", "tokens": [50718, 2673, 855, 746, 411, 341, 13, 467, 576, 5623, 3037, 568, 13, 17, 281, 568, 13, 19, 13, 407, 300, 311, 411, 51018], "temperature": 0.0, "avg_logprob": -0.2668926771297011, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.01706487499177456}, {"id": 23, "seek": 13508, "start": 148.28, "end": 154.28, "text": " the essential thing that I'm focusing around. Like what I mean with automated dependence", "tokens": [51024, 264, 7115, 551, 300, 286, 478, 8416, 926, 13, 1743, 437, 286, 914, 365, 18473, 31704, 51324], "temperature": 0.0, "avg_logprob": -0.2668926771297011, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.01706487499177456}, {"id": 24, "seek": 13508, "start": 154.28, "end": 161.28, "text": " updates. And an interesting thing around automated dependence updates is that there's usually", "tokens": [51324, 9205, 13, 400, 364, 1880, 551, 926, 18473, 31704, 9205, 307, 300, 456, 311, 2673, 51674], "temperature": 0.0, "avg_logprob": -0.2668926771297011, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.01706487499177456}, {"id": 25, "seek": 16128, "start": 161.36, "end": 168.36, "text": " this promise that if you just run your tests, you are essentially able to catch any type", "tokens": [50368, 341, 6228, 300, 498, 291, 445, 1190, 428, 6921, 11, 291, 366, 4476, 1075, 281, 3745, 604, 2010, 50718], "temperature": 0.0, "avg_logprob": -0.2941236939541129, "compression_ratio": 1.6409090909090909, "no_speech_prob": 0.0353473536670208}, {"id": 26, "seek": 16128, "start": 168.56, "end": 175.56, "text": " of regression errors, any problems that might exist in your code. And me as a researcher", "tokens": [50728, 295, 24590, 13603, 11, 604, 2740, 300, 1062, 2514, 294, 428, 3089, 13, 400, 385, 382, 257, 21751, 51078], "temperature": 0.0, "avg_logprob": -0.2941236939541129, "compression_ratio": 1.6409090909090909, "no_speech_prob": 0.0353473536670208}, {"id": 27, "seek": 16128, "start": 176.52, "end": 183.52, "text": " that maybe sort of a bit questioning pattern, as I felt like, hmm, the test that we are usually", "tokens": [51126, 300, 1310, 1333, 295, 257, 857, 21257, 5102, 11, 382, 286, 2762, 411, 11, 16478, 11, 264, 1500, 300, 321, 366, 2673, 51476], "temperature": 0.0, "avg_logprob": -0.2941236939541129, "compression_ratio": 1.6409090909090909, "no_speech_prob": 0.0353473536670208}, {"id": 28, "seek": 16128, "start": 183.64, "end": 188.16, "text": " having are projects, they're more focused on the your project test suite. And maybe not", "tokens": [51482, 1419, 366, 4455, 11, 436, 434, 544, 5178, 322, 264, 428, 1716, 1500, 14205, 13, 400, 1310, 406, 51708], "temperature": 0.0, "avg_logprob": -0.2941236939541129, "compression_ratio": 1.6409090909090909, "no_speech_prob": 0.0353473536670208}, {"id": 29, "seek": 18816, "start": 188.2, "end": 192.32, "text": " so much on the third party dependencies or third party libraries that you use in your", "tokens": [50366, 370, 709, 322, 264, 2636, 3595, 36606, 420, 2636, 3595, 15148, 300, 291, 764, 294, 428, 50572], "temperature": 0.0, "avg_logprob": -0.23002270954411205, "compression_ratio": 1.77, "no_speech_prob": 0.027039499953389168}, {"id": 30, "seek": 18816, "start": 192.32, "end": 199.32, "text": " code. So that may be sort of race three questions. The first question that I asked was, do we", "tokens": [50572, 3089, 13, 407, 300, 815, 312, 1333, 295, 4569, 1045, 1651, 13, 440, 700, 1168, 300, 286, 2351, 390, 11, 360, 321, 50922], "temperature": 0.0, "avg_logprob": -0.23002270954411205, "compression_ratio": 1.77, "no_speech_prob": 0.027039499953389168}, {"id": 31, "seek": 18816, "start": 202.88, "end": 208.44, "text": " even write tests against dependencies in the first place? And then the second question", "tokens": [51100, 754, 2464, 6921, 1970, 36606, 294, 264, 700, 1081, 30, 400, 550, 264, 1150, 1168, 51378], "temperature": 0.0, "avg_logprob": -0.23002270954411205, "compression_ratio": 1.77, "no_speech_prob": 0.027039499953389168}, {"id": 32, "seek": 18816, "start": 208.44, "end": 215.44, "text": " is, do project tests with even cover usages of dependencies in the source code? And the", "tokens": [51378, 307, 11, 360, 1716, 6921, 365, 754, 2060, 505, 1660, 295, 36606, 294, 264, 4009, 3089, 30, 400, 264, 51728], "temperature": 0.0, "avg_logprob": -0.23002270954411205, "compression_ratio": 1.77, "no_speech_prob": 0.027039499953389168}, {"id": 33, "seek": 21544, "start": 215.64, "end": 221.28, "text": " last one is like, are even test sufficient alone just using tests to detect any bad updates", "tokens": [50374, 1036, 472, 307, 411, 11, 366, 754, 1500, 11563, 3312, 445, 1228, 6921, 281, 5531, 604, 1578, 9205, 50656], "temperature": 0.0, "avg_logprob": -0.2572407550122364, "compression_ratio": 1.6283185840707965, "no_speech_prob": 0.008470938540995121}, {"id": 34, "seek": 21544, "start": 221.28, "end": 228.28, "text": " that you might find in using these tools or doing automated dependency updates? And to", "tokens": [50656, 300, 291, 1062, 915, 294, 1228, 613, 3873, 420, 884, 18473, 33621, 9205, 30, 400, 281, 51006], "temperature": 0.0, "avg_logprob": -0.2572407550122364, "compression_ratio": 1.6283185840707965, "no_speech_prob": 0.008470938540995121}, {"id": 35, "seek": 21544, "start": 228.64, "end": 235.64, "text": " study this, I looked into open source projects at the first, oh yeah, another question is,", "tokens": [51024, 2979, 341, 11, 286, 2956, 666, 1269, 4009, 4455, 412, 264, 700, 11, 1954, 1338, 11, 1071, 1168, 307, 11, 51374], "temperature": 0.0, "avg_logprob": -0.2572407550122364, "compression_ratio": 1.6283185840707965, "no_speech_prob": 0.008470938540995121}, {"id": 36, "seek": 21544, "start": 237.56, "end": 244.56, "text": " of course, should we even write test for dependencies? Because if we like to reuse components from", "tokens": [51470, 295, 1164, 11, 820, 321, 754, 2464, 1500, 337, 36606, 30, 1436, 498, 321, 411, 281, 26225, 6677, 490, 51820], "temperature": 0.0, "avg_logprob": -0.2572407550122364, "compression_ratio": 1.6283185840707965, "no_speech_prob": 0.008470938540995121}, {"id": 37, "seek": 24456, "start": 245.0, "end": 250.04, "text": " open source package repositories, why should we even write tests for that? Because it kind", "tokens": [50386, 1269, 4009, 7372, 22283, 2083, 11, 983, 820, 321, 754, 2464, 6921, 337, 300, 30, 1436, 309, 733, 50638], "temperature": 0.0, "avg_logprob": -0.2214080547464305, "compression_ratio": 1.5848214285714286, "no_speech_prob": 0.005721775349229574}, {"id": 38, "seek": 24456, "start": 250.04, "end": 255.52, "text": " of gives us the ergonomics that we can just use anything like it in our code and that's", "tokens": [50638, 295, 2709, 505, 264, 42735, 29884, 300, 321, 393, 445, 764, 1340, 411, 309, 294, 527, 3089, 293, 300, 311, 50912], "temperature": 0.0, "avg_logprob": -0.2214080547464305, "compression_ratio": 1.5848214285714286, "no_speech_prob": 0.005721775349229574}, {"id": 39, "seek": 24456, "start": 255.52, "end": 262.52, "text": " it. And this sort of like started like as an empirical study, that's sort of what this", "tokens": [50912, 309, 13, 400, 341, 1333, 295, 411, 1409, 411, 382, 364, 31886, 2979, 11, 300, 311, 1333, 295, 437, 341, 51262], "temperature": 0.0, "avg_logprob": -0.2214080547464305, "compression_ratio": 1.5848214285714286, "no_speech_prob": 0.005721775349229574}, {"id": 40, "seek": 24456, "start": 264.84000000000003, "end": 271.52, "text": " talk is primarily centered around. So the first thing that I looked at in 20 study was to", "tokens": [51378, 751, 307, 10029, 18988, 926, 13, 407, 264, 700, 551, 300, 286, 2956, 412, 294, 945, 2979, 390, 281, 51712], "temperature": 0.0, "avg_logprob": -0.2214080547464305, "compression_ratio": 1.5848214285714286, "no_speech_prob": 0.005721775349229574}, {"id": 41, "seek": 27152, "start": 271.56, "end": 277.52, "text": " see what is the statement coverage of function calls to dependencies. And this is similar", "tokens": [50366, 536, 437, 307, 264, 5629, 9645, 295, 2445, 5498, 281, 36606, 13, 400, 341, 307, 2531, 50664], "temperature": 0.0, "avg_logprob": -0.28426802301981363, "compression_ratio": 1.6355555555555557, "no_speech_prob": 0.02588569186627865}, {"id": 42, "seek": 27152, "start": 277.52, "end": 284.28, "text": " to considering for example, like covered like life support, for example, like J. Coco as", "tokens": [50664, 281, 8079, 337, 1365, 11, 411, 5343, 411, 993, 1406, 11, 337, 1365, 11, 411, 508, 13, 29787, 382, 51002], "temperature": 0.0, "avg_logprob": -0.28426802301981363, "compression_ratio": 1.6355555555555557, "no_speech_prob": 0.02588569186627865}, {"id": 43, "seek": 27152, "start": 284.28, "end": 290.79999999999995, "text": " a tool. And then the other thing that we also focus in the study is how effective are tests", "tokens": [51002, 257, 2290, 13, 400, 550, 264, 661, 551, 300, 321, 611, 1879, 294, 264, 2979, 307, 577, 4942, 366, 6921, 51328], "temperature": 0.0, "avg_logprob": -0.28426802301981363, "compression_ratio": 1.6355555555555557, "no_speech_prob": 0.02588569186627865}, {"id": 44, "seek": 27152, "start": 290.79999999999995, "end": 296.59999999999997, "text": " using detecting updates with regression errors. So what we're doing here is that we are basically", "tokens": [51328, 1228, 40237, 9205, 365, 24590, 13603, 13, 407, 437, 321, 434, 884, 510, 307, 300, 321, 366, 1936, 51618], "temperature": 0.0, "avg_logprob": -0.28426802301981363, "compression_ratio": 1.6355555555555557, "no_speech_prob": 0.02588569186627865}, {"id": 45, "seek": 29660, "start": 296.64000000000004, "end": 303.0, "text": " trying to find, I mean, either find or actually put regression errors in existing libraries,", "tokens": [50366, 1382, 281, 915, 11, 286, 914, 11, 2139, 915, 420, 767, 829, 24590, 13603, 294, 6741, 15148, 11, 50684], "temperature": 0.0, "avg_logprob": -0.27173933229948344, "compression_ratio": 1.655813953488372, "no_speech_prob": 0.03370713070034981}, {"id": 46, "seek": 29660, "start": 303.0, "end": 309.0, "text": " and then directly validate whether the project test suite can directly detect that or not.", "tokens": [50684, 293, 550, 3838, 29562, 1968, 264, 1716, 1500, 14205, 393, 3838, 5531, 300, 420, 406, 13, 50984], "temperature": 0.0, "avg_logprob": -0.27173933229948344, "compression_ratio": 1.655813953488372, "no_speech_prob": 0.03370713070034981}, {"id": 47, "seek": 29660, "start": 309.0, "end": 313.88, "text": " And that's also something called mutation testing analysis. And I think there was one", "tokens": [50984, 400, 300, 311, 611, 746, 1219, 27960, 4997, 5215, 13, 400, 286, 519, 456, 390, 472, 51228], "temperature": 0.0, "avg_logprob": -0.27173933229948344, "compression_ratio": 1.655813953488372, "no_speech_prob": 0.03370713070034981}, {"id": 48, "seek": 29660, "start": 313.88, "end": 320.88, "text": " talk about this earlier. And then the last thing around the studies that currently the", "tokens": [51228, 751, 466, 341, 3071, 13, 400, 550, 264, 1036, 551, 926, 264, 5313, 300, 4362, 264, 51578], "temperature": 0.0, "avg_logprob": -0.27173933229948344, "compression_ratio": 1.655813953488372, "no_speech_prob": 0.03370713070034981}, {"id": 49, "seek": 32088, "start": 321.64, "end": 327.6, "text": " sort of state of thought is to focus on just using test suites, but could we use another", "tokens": [50402, 1333, 295, 1785, 295, 1194, 307, 281, 1879, 322, 445, 1228, 1500, 459, 3324, 11, 457, 727, 321, 764, 1071, 50700], "temperature": 0.0, "avg_logprob": -0.19839677249684054, "compression_ratio": 1.5707964601769913, "no_speech_prob": 0.008502141572535038}, {"id": 50, "seek": 32088, "start": 327.6, "end": 334.6, "text": " way to find any problems or early detect issues that might exist in updating our dependency.", "tokens": [50700, 636, 281, 915, 604, 2740, 420, 2440, 5531, 2663, 300, 1062, 2514, 294, 25113, 527, 33621, 13, 51050], "temperature": 0.0, "avg_logprob": -0.19839677249684054, "compression_ratio": 1.5707964601769913, "no_speech_prob": 0.008502141572535038}, {"id": 51, "seek": 32088, "start": 339.15999999999997, "end": 342.96, "text": " So yeah, the first question is like, how can we do some type of statement coverage or", "tokens": [51278, 407, 1338, 11, 264, 700, 1168, 307, 411, 11, 577, 393, 321, 360, 512, 2010, 295, 5629, 9645, 420, 51468], "temperature": 0.0, "avg_logprob": -0.19839677249684054, "compression_ratio": 1.5707964601769913, "no_speech_prob": 0.008502141572535038}, {"id": 52, "seek": 32088, "start": 342.96, "end": 349.96, "text": " get an idea about what exactly are we using in third party libraries? So we did this in", "tokens": [51468, 483, 364, 1558, 466, 437, 2293, 366, 321, 1228, 294, 2636, 3595, 15148, 30, 407, 321, 630, 341, 294, 51818], "temperature": 0.0, "avg_logprob": -0.19839677249684054, "compression_ratio": 1.5707964601769913, "no_speech_prob": 0.008502141572535038}, {"id": 53, "seek": 34996, "start": 350.4, "end": 357.4, "text": " two ways. The first thing was to essentially, so this was of course in Java, we extracted", "tokens": [50386, 732, 2098, 13, 440, 700, 551, 390, 281, 4476, 11, 370, 341, 390, 295, 1164, 294, 10745, 11, 321, 34086, 50736], "temperature": 0.0, "avg_logprob": -0.29229234117980396, "compression_ratio": 1.6931818181818181, "no_speech_prob": 0.021532591432332993}, {"id": 54, "seek": 34996, "start": 357.88, "end": 363.32, "text": " all call sites that we will find in projects. And if those call sites points to third party", "tokens": [50760, 439, 818, 7533, 300, 321, 486, 915, 294, 4455, 13, 400, 498, 729, 818, 7533, 2793, 281, 2636, 3595, 51032], "temperature": 0.0, "avg_logprob": -0.29229234117980396, "compression_ratio": 1.6931818181818181, "no_speech_prob": 0.021532591432332993}, {"id": 55, "seek": 34996, "start": 363.32, "end": 369.03999999999996, "text": " libraries in bytecode, we consider that as a usage. And that's for trustive dependencies", "tokens": [51032, 15148, 294, 40846, 22332, 11, 321, 1949, 300, 382, 257, 14924, 13, 400, 300, 311, 337, 3361, 488, 36606, 51318], "temperature": 0.0, "avg_logprob": -0.29229234117980396, "compression_ratio": 1.6931818181818181, "no_speech_prob": 0.021532591432332993}, {"id": 56, "seek": 34996, "start": 369.03999999999996, "end": 373.4, "text": " because now you're not, let's say like longer on your source code where you have the call", "tokens": [51318, 570, 586, 291, 434, 406, 11, 718, 311, 584, 411, 2854, 322, 428, 4009, 3089, 689, 291, 362, 264, 818, 51536], "temperature": 0.0, "avg_logprob": -0.29229234117980396, "compression_ratio": 1.6931818181818181, "no_speech_prob": 0.021532591432332993}, {"id": 57, "seek": 34996, "start": 373.4, "end": 378.24, "text": " set direct dependencies, you would also need to go to the trusty ones and here to sort", "tokens": [51536, 992, 2047, 36606, 11, 291, 576, 611, 643, 281, 352, 281, 264, 3361, 88, 2306, 293, 510, 281, 1333, 51778], "temperature": 0.0, "avg_logprob": -0.29229234117980396, "compression_ratio": 1.6931818181818181, "no_speech_prob": 0.021532591432332993}, {"id": 58, "seek": 37824, "start": 378.28000000000003, "end": 383.52, "text": " of approximate that is not an exact measurement. We essentially build static whole graphs to", "tokens": [50366, 295, 30874, 300, 307, 406, 364, 1900, 13160, 13, 492, 4476, 1322, 13437, 1379, 24877, 281, 50628], "temperature": 0.0, "avg_logprob": -0.24851088926016565, "compression_ratio": 1.6116071428571428, "no_speech_prob": 0.014045212417840958}, {"id": 59, "seek": 37824, "start": 383.52, "end": 390.52, "text": " kind of get an idea of what would be used in the chemistry of our project. And then", "tokens": [50628, 733, 295, 483, 364, 1558, 295, 437, 576, 312, 1143, 294, 264, 12558, 295, 527, 1716, 13, 400, 550, 50978], "temperature": 0.0, "avg_logprob": -0.24851088926016565, "compression_ratio": 1.6116071428571428, "no_speech_prob": 0.014045212417840958}, {"id": 60, "seek": 37824, "start": 391.48, "end": 398.48, "text": " last we did some instrumentation. So we essentially run the tests of a project and execute what", "tokens": [51026, 1036, 321, 630, 512, 7198, 399, 13, 407, 321, 4476, 1190, 264, 6921, 295, 257, 1716, 293, 14483, 437, 51376], "temperature": 0.0, "avg_logprob": -0.24851088926016565, "compression_ratio": 1.6116071428571428, "no_speech_prob": 0.014045212417840958}, {"id": 61, "seek": 37824, "start": 400.96000000000004, "end": 405.24, "text": " functions were invoked in the dependencies. And this will give, let's say like some idea", "tokens": [51500, 6828, 645, 1048, 9511, 294, 264, 36606, 13, 400, 341, 486, 976, 11, 718, 311, 584, 411, 512, 1558, 51714], "temperature": 0.0, "avg_logprob": -0.24851088926016565, "compression_ratio": 1.6116071428571428, "no_speech_prob": 0.014045212417840958}, {"id": 62, "seek": 40524, "start": 405.24, "end": 411.64, "text": " of what exactly is being used or not used at all. So essentially first we statically", "tokens": [50364, 295, 437, 2293, 307, 885, 1143, 420, 406, 1143, 412, 439, 13, 407, 4476, 700, 321, 2219, 984, 50684], "temperature": 0.0, "avg_logprob": -0.20759604698003725, "compression_ratio": 1.5799086757990868, "no_speech_prob": 0.008431999012827873}, {"id": 63, "seek": 40524, "start": 411.64, "end": 417.12, "text": " derive like, what are all the usages? And then by running the tests we know which of", "tokens": [50684, 28446, 411, 11, 437, 366, 439, 264, 505, 1660, 30, 400, 550, 538, 2614, 264, 6921, 321, 458, 597, 295, 50958], "temperature": 0.0, "avg_logprob": -0.20759604698003725, "compression_ratio": 1.5799086757990868, "no_speech_prob": 0.008431999012827873}, {"id": 64, "seek": 40524, "start": 417.12, "end": 424.12, "text": " those functions were covered or not. So kind of similar to code coverage. And we did this", "tokens": [50958, 729, 6828, 645, 5343, 420, 406, 13, 407, 733, 295, 2531, 281, 3089, 9645, 13, 400, 321, 630, 341, 51308], "temperature": 0.0, "avg_logprob": -0.20759604698003725, "compression_ratio": 1.5799086757990868, "no_speech_prob": 0.008431999012827873}, {"id": 65, "seek": 40524, "start": 424.12, "end": 431.12, "text": " for around 521 Gita projects. And what we found very interesting was that when we look", "tokens": [51308, 337, 926, 1025, 4436, 460, 2786, 4455, 13, 400, 437, 321, 1352, 588, 1880, 390, 300, 562, 321, 574, 51658], "temperature": 0.0, "avg_logprob": -0.20759604698003725, "compression_ratio": 1.5799086757990868, "no_speech_prob": 0.008431999012827873}, {"id": 66, "seek": 43112, "start": 432.12, "end": 437.12, "text": " at the direct dependencies of a project, so this is all the direct dependencies that", "tokens": [50414, 412, 264, 2047, 36606, 295, 257, 1716, 11, 370, 341, 307, 439, 264, 2047, 36606, 300, 50664], "temperature": 0.0, "avg_logprob": -0.2094714285313398, "compression_ratio": 1.6401869158878504, "no_speech_prob": 0.005811817944049835}, {"id": 67, "seek": 43112, "start": 437.12, "end": 444.12, "text": " were found, about 60% like when running the tests are, let's say like covered by it.", "tokens": [50664, 645, 1352, 11, 466, 4060, 4, 411, 562, 2614, 264, 6921, 366, 11, 718, 311, 584, 411, 5343, 538, 309, 13, 51014], "temperature": 0.0, "avg_logprob": -0.2094714285313398, "compression_ratio": 1.6401869158878504, "no_speech_prob": 0.005811817944049835}, {"id": 68, "seek": 43112, "start": 445.48, "end": 451.48, "text": " But then when we go to trustive dependencies, we found that the median was only 20%. So", "tokens": [51082, 583, 550, 562, 321, 352, 281, 3361, 488, 36606, 11, 321, 1352, 300, 264, 26779, 390, 787, 945, 6856, 407, 51382], "temperature": 0.0, "avg_logprob": -0.2094714285313398, "compression_ratio": 1.6401869158878504, "no_speech_prob": 0.005811817944049835}, {"id": 69, "seek": 43112, "start": 451.48, "end": 458.48, "text": " which means that a lot of the transitive functions that may be used may not even be reachable", "tokens": [51382, 597, 1355, 300, 257, 688, 295, 264, 1145, 2187, 6828, 300, 815, 312, 1143, 815, 406, 754, 312, 2524, 712, 51732], "temperature": 0.0, "avg_logprob": -0.2094714285313398, "compression_ratio": 1.6401869158878504, "no_speech_prob": 0.005811817944049835}, {"id": 70, "seek": 45848, "start": 458.48, "end": 465.48, "text": " by test. So they sort of like ring some alarm bells, right? Because that means essentially", "tokens": [50364, 538, 1500, 13, 407, 436, 1333, 295, 411, 4875, 512, 14183, 25474, 11, 558, 30, 1436, 300, 1355, 4476, 50714], "temperature": 0.0, "avg_logprob": -0.30452925583411905, "compression_ratio": 1.6118721461187215, "no_speech_prob": 0.019079411402344704}, {"id": 71, "seek": 45848, "start": 465.64000000000004, "end": 471.20000000000005, "text": " like if you have a dependency update and you don't have any test that is covering that", "tokens": [50722, 411, 498, 291, 362, 257, 33621, 5623, 293, 291, 500, 380, 362, 604, 1500, 300, 307, 10322, 300, 51000], "temperature": 0.0, "avg_logprob": -0.30452925583411905, "compression_ratio": 1.6118721461187215, "no_speech_prob": 0.019079411402344704}, {"id": 72, "seek": 45848, "start": 471.20000000000005, "end": 476.6, "text": " area, that will basically give you a green tick and you might merge it. And I don't think", "tokens": [51000, 1859, 11, 300, 486, 1936, 976, 291, 257, 3092, 5204, 293, 291, 1062, 22183, 309, 13, 400, 286, 500, 380, 519, 51270], "temperature": 0.0, "avg_logprob": -0.30452925583411905, "compression_ratio": 1.6118721461187215, "no_speech_prob": 0.019079411402344704}, {"id": 73, "seek": 45848, "start": 476.6, "end": 481.08000000000004, "text": " many would do that. But that's, let's say like the implementation area that also kind", "tokens": [51270, 867, 576, 360, 300, 13, 583, 300, 311, 11, 718, 311, 584, 411, 264, 11420, 1859, 300, 611, 733, 51494], "temperature": 0.0, "avg_logprob": -0.30452925583411905, "compression_ratio": 1.6118721461187215, "no_speech_prob": 0.019079411402344704}, {"id": 74, "seek": 48108, "start": 481.08, "end": 488.08, "text": " of raises some questions around how effective using tests for automated updates. And yeah,", "tokens": [50364, 295, 19658, 512, 1651, 926, 577, 4942, 1228, 6921, 337, 18473, 9205, 13, 400, 1338, 11, 50714], "temperature": 0.0, "avg_logprob": -0.23538453578948976, "compression_ratio": 1.6367713004484306, "no_speech_prob": 0.018917931243777275}, {"id": 75, "seek": 48108, "start": 491.2, "end": 495.03999999999996, "text": " the other question does this matter at all. And I think a very interesting one here is", "tokens": [50870, 264, 661, 1168, 775, 341, 1871, 412, 439, 13, 400, 286, 519, 257, 588, 1880, 472, 510, 307, 51062], "temperature": 0.0, "avg_logprob": -0.23538453578948976, "compression_ratio": 1.6367713004484306, "no_speech_prob": 0.018917931243777275}, {"id": 76, "seek": 48108, "start": 495.03999999999996, "end": 502.03999999999996, "text": " the log for shell case because I don't think many of us would have tests that is particularly", "tokens": [51062, 264, 3565, 337, 8720, 1389, 570, 286, 500, 380, 519, 867, 295, 505, 576, 362, 6921, 300, 307, 4098, 51412], "temperature": 0.0, "avg_logprob": -0.23538453578948976, "compression_ratio": 1.6367713004484306, "no_speech_prob": 0.018917931243777275}, {"id": 77, "seek": 48108, "start": 502.03999999999996, "end": 507.2, "text": " targeting log libraries. But here is an instance where something we don't normally would test", "tokens": [51412, 17918, 3565, 15148, 13, 583, 510, 307, 364, 5197, 689, 746, 321, 500, 380, 5646, 576, 1500, 51670], "temperature": 0.0, "avg_logprob": -0.23538453578948976, "compression_ratio": 1.6367713004484306, "no_speech_prob": 0.018917931243777275}, {"id": 78, "seek": 50720, "start": 507.24, "end": 512.2, "text": " and would have tests in any case. If you would do an update, then yeah, there might be some", "tokens": [50366, 293, 576, 362, 6921, 294, 604, 1389, 13, 759, 291, 576, 360, 364, 5623, 11, 550, 1338, 11, 456, 1062, 312, 512, 50614], "temperature": 0.0, "avg_logprob": -0.2484467246315696, "compression_ratio": 1.6425339366515836, "no_speech_prob": 0.014584212563931942}, {"id": 79, "seek": 50720, "start": 512.2, "end": 519.04, "text": " breaking changes then yeah, there will be a problem here. Then going to the second part", "tokens": [50614, 7697, 2962, 550, 1338, 11, 456, 486, 312, 257, 1154, 510, 13, 1396, 516, 281, 264, 1150, 644, 50956], "temperature": 0.0, "avg_logprob": -0.2484467246315696, "compression_ratio": 1.6425339366515836, "no_speech_prob": 0.014584212563931942}, {"id": 80, "seek": 50720, "start": 519.04, "end": 524.2, "text": " of the study, which was on test effectiveness. And I was measuring that we're doing mutation", "tokens": [50956, 295, 264, 2979, 11, 597, 390, 322, 1500, 21208, 13, 400, 286, 390, 13389, 300, 321, 434, 884, 27960, 51214], "temperature": 0.0, "avg_logprob": -0.2484467246315696, "compression_ratio": 1.6425339366515836, "no_speech_prob": 0.014584212563931942}, {"id": 81, "seek": 50720, "start": 524.2, "end": 531.4399999999999, "text": " testing. So the underlying framework we used here was a pie test, but we modified pie test", "tokens": [51214, 4997, 13, 407, 264, 14217, 8388, 321, 1143, 510, 390, 257, 1730, 1500, 11, 457, 321, 15873, 1730, 1500, 51576], "temperature": 0.0, "avg_logprob": -0.2484467246315696, "compression_ratio": 1.6425339366515836, "no_speech_prob": 0.014584212563931942}, {"id": 82, "seek": 53144, "start": 531.5200000000001, "end": 538.5200000000001, "text": " to do things a little bit differently. And yeah, to sort of like give a quick sort of", "tokens": [50368, 281, 360, 721, 257, 707, 857, 7614, 13, 400, 1338, 11, 281, 1333, 295, 411, 976, 257, 1702, 1333, 295, 50718], "temperature": 0.0, "avg_logprob": -0.21722219182156968, "compression_ratio": 1.625, "no_speech_prob": 0.02498788759112358}, {"id": 83, "seek": 53144, "start": 538.5600000000001, "end": 545.0600000000001, "text": " idea of what mutation testing is, is that you essentially have a function, for example,", "tokens": [50720, 1558, 295, 437, 27960, 4997, 307, 11, 307, 300, 291, 4476, 362, 257, 2445, 11, 337, 1365, 11, 51045], "temperature": 0.0, "avg_logprob": -0.21722219182156968, "compression_ratio": 1.625, "no_speech_prob": 0.02498788759112358}, {"id": 84, "seek": 53144, "start": 545.0600000000001, "end": 552.0600000000001, "text": " return x plus y. And then you apply some type of mutation operator where you swap, let's", "tokens": [51045, 2736, 2031, 1804, 288, 13, 400, 550, 291, 3079, 512, 2010, 295, 27960, 12973, 689, 291, 18135, 11, 718, 311, 51395], "temperature": 0.0, "avg_logprob": -0.21722219182156968, "compression_ratio": 1.625, "no_speech_prob": 0.02498788759112358}, {"id": 85, "seek": 53144, "start": 553.36, "end": 559.5200000000001, "text": " say like the class. And then you would expect that your test suite will be able to cover", "tokens": [51460, 584, 411, 264, 1508, 13, 400, 550, 291, 576, 2066, 300, 428, 1500, 14205, 486, 312, 1075, 281, 2060, 51768], "temperature": 0.0, "avg_logprob": -0.21722219182156968, "compression_ratio": 1.625, "no_speech_prob": 0.02498788759112358}, {"id": 86, "seek": 55952, "start": 559.52, "end": 565.24, "text": " this because here the behavior is completely changed, right? It's no longer an addition", "tokens": [50364, 341, 570, 510, 264, 5223, 307, 2584, 3105, 11, 558, 30, 467, 311, 572, 2854, 364, 4500, 50650], "temperature": 0.0, "avg_logprob": -0.1723183546916093, "compression_ratio": 1.7011494252873562, "no_speech_prob": 0.014347322285175323}, {"id": 87, "seek": 55952, "start": 565.24, "end": 570.24, "text": " operator. So normally with mutation testing, you would give it your whole project source", "tokens": [50650, 12973, 13, 407, 5646, 365, 27960, 4997, 11, 291, 576, 976, 309, 428, 1379, 1716, 4009, 50900], "temperature": 0.0, "avg_logprob": -0.1723183546916093, "compression_ratio": 1.7011494252873562, "no_speech_prob": 0.014347322285175323}, {"id": 88, "seek": 55952, "start": 570.24, "end": 575.12, "text": " code. It will start trying to modify in the source code and then see whether the test", "tokens": [50900, 3089, 13, 467, 486, 722, 1382, 281, 16927, 294, 264, 4009, 3089, 293, 550, 536, 1968, 264, 1500, 51144], "temperature": 0.0, "avg_logprob": -0.1723183546916093, "compression_ratio": 1.7011494252873562, "no_speech_prob": 0.014347322285175323}, {"id": 89, "seek": 55952, "start": 575.12, "end": 581.04, "text": " suite is able to capture that or not. So what we did differently is that we essentially", "tokens": [51144, 14205, 307, 1075, 281, 7983, 300, 420, 406, 13, 407, 437, 321, 630, 7614, 307, 300, 321, 4476, 51440], "temperature": 0.0, "avg_logprob": -0.1723183546916093, "compression_ratio": 1.7011494252873562, "no_speech_prob": 0.014347322285175323}, {"id": 90, "seek": 55952, "start": 581.04, "end": 588.04, "text": " mutated functions in the dependency code and not the project code at all. And we only mutated", "tokens": [51440, 5839, 770, 6828, 294, 264, 33621, 3089, 293, 406, 264, 1716, 3089, 412, 439, 13, 400, 321, 787, 5839, 770, 51790], "temperature": 0.0, "avg_logprob": -0.1723183546916093, "compression_ratio": 1.7011494252873562, "no_speech_prob": 0.014347322285175323}, {"id": 91, "seek": 58804, "start": 588.4399999999999, "end": 593.4399999999999, "text": " those that were reachable by test. So I was saying earlier that we were running a test", "tokens": [50384, 729, 300, 645, 2524, 712, 538, 1500, 13, 407, 286, 390, 1566, 3071, 300, 321, 645, 2614, 257, 1500, 50634], "temperature": 0.0, "avg_logprob": -0.1528861787584093, "compression_ratio": 1.6713615023474178, "no_speech_prob": 0.005491281859576702}, {"id": 92, "seek": 58804, "start": 593.4399999999999, "end": 597.92, "text": " to know which functions were executed. So we used those functions to essentially apply", "tokens": [50634, 281, 458, 597, 6828, 645, 17577, 13, 407, 321, 1143, 729, 6828, 281, 4476, 3079, 50858], "temperature": 0.0, "avg_logprob": -0.1528861787584093, "compression_ratio": 1.6713615023474178, "no_speech_prob": 0.005491281859576702}, {"id": 93, "seek": 58804, "start": 597.92, "end": 602.8399999999999, "text": " those mutation operators. And then from there we can see if the test is able to capture", "tokens": [50858, 729, 27960, 19077, 13, 400, 550, 490, 456, 321, 393, 536, 498, 264, 1500, 307, 1075, 281, 7983, 51104], "temperature": 0.0, "avg_logprob": -0.1528861787584093, "compression_ratio": 1.6713615023474178, "no_speech_prob": 0.005491281859576702}, {"id": 94, "seek": 58804, "start": 602.8399999999999, "end": 609.8399999999999, "text": " that or not. And yeah, before I go into this also another alternative way that we investigated", "tokens": [51104, 300, 420, 406, 13, 400, 1338, 11, 949, 286, 352, 666, 341, 611, 1071, 8535, 636, 300, 321, 30070, 51454], "temperature": 0.0, "avg_logprob": -0.1528861787584093, "compression_ratio": 1.6713615023474178, "no_speech_prob": 0.005491281859576702}, {"id": 95, "seek": 60984, "start": 610.1600000000001, "end": 617.1600000000001, "text": " is called a change impact analysis. So here we sort of leverage static analysis and specifically", "tokens": [50380, 307, 1219, 257, 1319, 2712, 5215, 13, 407, 510, 321, 1333, 295, 13982, 13437, 5215, 293, 4682, 50730], "temperature": 0.0, "avg_logprob": -0.21018807093302408, "compression_ratio": 1.5197740112994351, "no_speech_prob": 0.022937307134270668}, {"id": 96, "seek": 60984, "start": 621.2, "end": 628.2, "text": " using call graphs. So how it essentially works is that we have a version 1.02 and 1.03.", "tokens": [50932, 1228, 818, 24877, 13, 407, 577, 309, 4476, 1985, 307, 300, 321, 362, 257, 3037, 502, 13, 12756, 293, 502, 13, 11592, 13, 51282], "temperature": 0.0, "avg_logprob": -0.21018807093302408, "compression_ratio": 1.5197740112994351, "no_speech_prob": 0.022937307134270668}, {"id": 97, "seek": 60984, "start": 630.1600000000001, "end": 636.8000000000001, "text": " We compute a diff and for the diff we will find out which functions changed. And for", "tokens": [51380, 492, 14722, 257, 7593, 293, 337, 264, 7593, 321, 486, 915, 484, 597, 6828, 3105, 13, 400, 337, 51712], "temperature": 0.0, "avg_logprob": -0.21018807093302408, "compression_ratio": 1.5197740112994351, "no_speech_prob": 0.022937307134270668}, {"id": 98, "seek": 63680, "start": 636.8399999999999, "end": 643.8399999999999, "text": " example here we know that in bar and bus function we can see that there is an arithmetic change", "tokens": [50366, 1365, 510, 321, 458, 300, 294, 2159, 293, 1255, 2445, 321, 393, 536, 300, 456, 307, 364, 42973, 1319, 50716], "temperature": 0.0, "avg_logprob": -0.17589664459228516, "compression_ratio": 1.7428571428571429, "no_speech_prob": 0.01799425296485424}, {"id": 99, "seek": 63680, "start": 644.0799999999999, "end": 650.28, "text": " like instead of y minus minus it's y plus plus. And then in the other, like in the bus", "tokens": [50728, 411, 2602, 295, 288, 3175, 3175, 309, 311, 288, 1804, 1804, 13, 400, 550, 294, 264, 661, 11, 411, 294, 264, 1255, 51038], "temperature": 0.0, "avg_logprob": -0.17589664459228516, "compression_ratio": 1.7428571428571429, "no_speech_prob": 0.01799425296485424}, {"id": 100, "seek": 63680, "start": 650.28, "end": 657.28, "text": " function we see that there is a new method called. And then what do we do later? We practically", "tokens": [51038, 2445, 321, 536, 300, 456, 307, 257, 777, 3170, 1219, 13, 400, 550, 437, 360, 321, 360, 1780, 30, 492, 15667, 51388], "temperature": 0.0, "avg_logprob": -0.17589664459228516, "compression_ratio": 1.7428571428571429, "no_speech_prob": 0.01799425296485424}, {"id": 101, "seek": 63680, "start": 658.68, "end": 665.1999999999999, "text": " build a call graph of the application and its dependencies. And then using reachability", "tokens": [51458, 1322, 257, 818, 4295, 295, 264, 3861, 293, 1080, 36606, 13, 400, 550, 1228, 2524, 2310, 51784], "temperature": 0.0, "avg_logprob": -0.17589664459228516, "compression_ratio": 1.7428571428571429, "no_speech_prob": 0.01799425296485424}, {"id": 102, "seek": 66520, "start": 665.2800000000001, "end": 671.24, "text": " analysis, so what we do here is that we know that the bar and bus was changed. And here", "tokens": [50368, 5215, 11, 370, 437, 321, 360, 510, 307, 300, 321, 458, 300, 264, 2159, 293, 1255, 390, 3105, 13, 400, 510, 50666], "temperature": 0.0, "avg_logprob": -0.262469830720321, "compression_ratio": 1.6203703703703705, "no_speech_prob": 0.017976844683289528}, {"id": 103, "seek": 66520, "start": 671.24, "end": 678.24, "text": " we have let's say like a reachable path from bar up to let's say like stats on the score", "tokens": [50666, 321, 362, 718, 311, 584, 411, 257, 2524, 712, 3100, 490, 2159, 493, 281, 718, 311, 584, 411, 18152, 322, 264, 6175, 51016], "temperature": 0.0, "avg_logprob": -0.262469830720321, "compression_ratio": 1.6203703703703705, "no_speech_prob": 0.017976844683289528}, {"id": 104, "seek": 66520, "start": 679.0, "end": 684.5600000000001, "text": " JSON I mean. And also we have like bus here where we have a new function called to QX", "tokens": [51054, 31828, 286, 914, 13, 400, 611, 321, 362, 411, 1255, 510, 689, 321, 362, 257, 777, 2445, 1219, 281, 1249, 55, 51332], "temperature": 0.0, "avg_logprob": -0.262469830720321, "compression_ratio": 1.6203703703703705, "no_speech_prob": 0.017976844683289528}, {"id": 105, "seek": 66520, "start": 684.5600000000001, "end": 691.5600000000001, "text": " STR. And by using this we can directly figure out if there is a coaching and dependency", "tokens": [51332, 43013, 13, 400, 538, 1228, 341, 321, 393, 3838, 2573, 484, 498, 456, 307, 257, 15818, 293, 33621, 51682], "temperature": 0.0, "avg_logprob": -0.262469830720321, "compression_ratio": 1.6203703703703705, "no_speech_prob": 0.017976844683289528}, {"id": 106, "seek": 69156, "start": 691.76, "end": 698.04, "text": " whether you are reachable or not in the first place. And why this is like a very nice complement", "tokens": [50374, 1968, 291, 366, 2524, 712, 420, 406, 294, 264, 700, 1081, 13, 400, 983, 341, 307, 411, 257, 588, 1481, 17103, 50688], "temperature": 0.0, "avg_logprob": -0.21062754435711598, "compression_ratio": 1.6470588235294117, "no_speech_prob": 0.04110703989863396}, {"id": 107, "seek": 69156, "start": 698.04, "end": 704.64, "text": " to dynamic test is that we are essentially leveraging by looking at the source code what", "tokens": [50688, 281, 8546, 1500, 307, 300, 321, 366, 4476, 32666, 538, 1237, 412, 264, 4009, 3089, 437, 51018], "temperature": 0.0, "avg_logprob": -0.21062754435711598, "compression_ratio": 1.6470588235294117, "no_speech_prob": 0.04110703989863396}, {"id": 108, "seek": 69156, "start": 704.64, "end": 709.76, "text": " are we actually using. And then as a complement to where tests might not be covering we can", "tokens": [51018, 366, 321, 767, 1228, 13, 400, 550, 382, 257, 17103, 281, 689, 6921, 1062, 406, 312, 10322, 321, 393, 51274], "temperature": 0.0, "avg_logprob": -0.21062754435711598, "compression_ratio": 1.6470588235294117, "no_speech_prob": 0.04110703989863396}, {"id": 109, "seek": 69156, "start": 709.76, "end": 716.76, "text": " sort of find directly if there is any change that might affect like your project. That", "tokens": [51274, 1333, 295, 915, 3838, 498, 456, 307, 604, 1319, 300, 1062, 3345, 411, 428, 1716, 13, 663, 51624], "temperature": 0.0, "avg_logprob": -0.21062754435711598, "compression_ratio": 1.6470588235294117, "no_speech_prob": 0.04110703989863396}, {"id": 110, "seek": 71676, "start": 717.04, "end": 723.24, "text": " of course comes the more tricky part which is semantic changes. So I mean one thing it's", "tokens": [50378, 295, 1164, 1487, 264, 544, 12414, 644, 597, 307, 47982, 2962, 13, 407, 286, 914, 472, 551, 309, 311, 50688], "temperature": 0.0, "avg_logprob": -0.3174380134133732, "compression_ratio": 1.7115384615384615, "no_speech_prob": 0.014245038852095604}, {"id": 111, "seek": 71676, "start": 723.24, "end": 728.4399999999999, "text": " nice that you can detect that the method change but sometimes you might just do a simple", "tokens": [50688, 1481, 300, 291, 393, 5531, 300, 264, 3170, 1319, 457, 2171, 291, 1062, 445, 360, 257, 2199, 50948], "temperature": 0.0, "avg_logprob": -0.3174380134133732, "compression_ratio": 1.7115384615384615, "no_speech_prob": 0.014245038852095604}, {"id": 112, "seek": 71676, "start": 728.4399999999999, "end": 735.4399999999999, "text": " refactoring that you know just refactors are a huge method into a method with like a couple", "tokens": [50948, 1895, 578, 3662, 300, 291, 458, 445, 1895, 578, 830, 366, 257, 2603, 3170, 666, 257, 3170, 365, 411, 257, 1916, 51298], "temperature": 0.0, "avg_logprob": -0.3174380134133732, "compression_ratio": 1.7115384615384615, "no_speech_prob": 0.014245038852095604}, {"id": 113, "seek": 71676, "start": 735.4399999999999, "end": 742.04, "text": " of smaller methods is that. So the truth is that it's extremely difficult to know what", "tokens": [51298, 295, 4356, 7150, 307, 300, 13, 407, 264, 3494, 307, 300, 309, 311, 4664, 2252, 281, 458, 437, 51628], "temperature": 0.0, "avg_logprob": -0.3174380134133732, "compression_ratio": 1.7115384615384615, "no_speech_prob": 0.014245038852095604}, {"id": 114, "seek": 74204, "start": 742.0799999999999, "end": 746.8, "text": " exactly is a semantic change because there's a lot of factors around it. So the only thing", "tokens": [50366, 2293, 307, 257, 47982, 1319, 570, 456, 311, 257, 688, 295, 6771, 926, 309, 13, 407, 264, 787, 551, 50602], "temperature": 0.0, "avg_logprob": -0.2027458009265718, "compression_ratio": 1.8666666666666667, "no_speech_prob": 0.03342108428478241}, {"id": 115, "seek": 74204, "start": 746.8, "end": 751.7199999999999, "text": " that we did was that we kind of took what was like behavioral changes. So we looked at", "tokens": [50602, 300, 321, 630, 390, 300, 321, 733, 295, 1890, 437, 390, 411, 19124, 2962, 13, 407, 321, 2956, 412, 50848], "temperature": 0.0, "avg_logprob": -0.2027458009265718, "compression_ratio": 1.8666666666666667, "no_speech_prob": 0.03342108428478241}, {"id": 116, "seek": 74204, "start": 751.7199999999999, "end": 757.4399999999999, "text": " only like data flow or control flow changes. So for example if you add a new method call", "tokens": [50848, 787, 411, 1412, 3095, 420, 1969, 3095, 2962, 13, 407, 337, 1365, 498, 291, 909, 257, 777, 3170, 818, 51134], "temperature": 0.0, "avg_logprob": -0.2027458009265718, "compression_ratio": 1.8666666666666667, "no_speech_prob": 0.03342108428478241}, {"id": 117, "seek": 74204, "start": 757.4399999999999, "end": 763.8, "text": " we consider that as like a special change or if you did some major change on your if statements", "tokens": [51134, 321, 1949, 300, 382, 411, 257, 2121, 1319, 420, 498, 291, 630, 512, 2563, 1319, 322, 428, 498, 12363, 51452], "temperature": 0.0, "avg_logprob": -0.2027458009265718, "compression_ratio": 1.8666666666666667, "no_speech_prob": 0.03342108428478241}, {"id": 118, "seek": 74204, "start": 763.8, "end": 769.4, "text": " that may introduce a new logic of how the control flow works then we consider that as", "tokens": [51452, 300, 815, 5366, 257, 777, 9952, 295, 577, 264, 1969, 3095, 1985, 550, 321, 1949, 300, 382, 51732], "temperature": 0.0, "avg_logprob": -0.2027458009265718, "compression_ratio": 1.8666666666666667, "no_speech_prob": 0.03342108428478241}, {"id": 119, "seek": 76940, "start": 769.48, "end": 776.48, "text": " an interesting change to follow. And what it is like I implemented a tool called Uptatera", "tokens": [50368, 364, 1880, 1319, 281, 1524, 13, 400, 437, 309, 307, 411, 286, 12270, 257, 2290, 1219, 624, 662, 771, 64, 50718], "temperature": 0.0, "avg_logprob": -0.4405806181860752, "compression_ratio": 1.4294478527607362, "no_speech_prob": 0.035620421171188354}, {"id": 120, "seek": 76940, "start": 778.88, "end": 785.88, "text": " which means update in Swedish. And so I applied this on.", "tokens": [50838, 597, 1355, 5623, 294, 23523, 13, 400, 370, 286, 6456, 341, 322, 13, 51188], "temperature": 0.0, "avg_logprob": -0.4405806181860752, "compression_ratio": 1.4294478527607362, "no_speech_prob": 0.035620421171188354}, {"id": 121, "seek": 76940, "start": 790.8, "end": 797.8, "text": " So it essentially shows like which function had a change. So for example Rx, Java, not", "tokens": [51434, 407, 309, 4476, 3110, 411, 597, 2445, 632, 257, 1319, 13, 407, 337, 1365, 497, 87, 11, 10745, 11, 406, 51784], "temperature": 0.0, "avg_logprob": -0.4405806181860752, "compression_ratio": 1.4294478527607362, "no_speech_prob": 0.035620421171188354}, {"id": 122, "seek": 79780, "start": 798.4399999999999, "end": 803.64, "text": " facing subscriber on error and we can see that it's reachable from the project and then", "tokens": [50396, 7170, 26122, 322, 6713, 293, 321, 393, 536, 300, 309, 311, 2524, 712, 490, 264, 1716, 293, 550, 50656], "temperature": 0.0, "avg_logprob": -0.20162497626410592, "compression_ratio": 1.6164383561643836, "no_speech_prob": 0.023538805544376373}, {"id": 123, "seek": 79780, "start": 803.64, "end": 810.14, "text": " it shows exactly how it was reachable. Yeah through like the code. And then in the second", "tokens": [50656, 309, 3110, 2293, 577, 309, 390, 2524, 712, 13, 865, 807, 411, 264, 3089, 13, 400, 550, 294, 264, 1150, 50981], "temperature": 0.0, "avg_logprob": -0.20162497626410592, "compression_ratio": 1.6164383561643836, "no_speech_prob": 0.023538805544376373}, {"id": 124, "seek": 79780, "start": 810.14, "end": 816.52, "text": " section I would have like what is basically the major changes in that function. So this", "tokens": [50981, 3541, 286, 576, 362, 411, 437, 307, 1936, 264, 2563, 2962, 294, 300, 2445, 13, 407, 341, 51300], "temperature": 0.0, "avg_logprob": -0.20162497626410592, "compression_ratio": 1.6164383561643836, "no_speech_prob": 0.023538805544376373}, {"id": 125, "seek": 79780, "start": 816.52, "end": 821.04, "text": " could sort of give you some context of what essentially changed. Other than just telling", "tokens": [51300, 727, 1333, 295, 976, 291, 512, 4319, 295, 437, 4476, 3105, 13, 5358, 813, 445, 3585, 51526], "temperature": 0.0, "avg_logprob": -0.20162497626410592, "compression_ratio": 1.6164383561643836, "no_speech_prob": 0.023538805544376373}, {"id": 126, "seek": 82104, "start": 821.04, "end": 828.04, "text": " that either the test parsed or failed. And when using this mutation PyPlanet that was", "tokens": [50364, 300, 2139, 264, 1500, 21156, 292, 420, 7612, 13, 400, 562, 1228, 341, 27960, 9953, 47, 8658, 302, 300, 390, 50714], "temperature": 0.0, "avg_logprob": -0.27835815183578, "compression_ratio": 1.4754098360655739, "no_speech_prob": 0.035477545112371445}, {"id": 127, "seek": 82104, "start": 832.8399999999999, "end": 839.8399999999999, "text": " explaining we essentially generated 1 million artificial updates by introducing those regressions", "tokens": [50954, 13468, 321, 4476, 10833, 502, 2459, 11677, 9205, 538, 15424, 729, 1121, 735, 626, 51304], "temperature": 0.0, "avg_logprob": -0.27835815183578, "compression_ratio": 1.4754098360655739, "no_speech_prob": 0.035477545112371445}, {"id": 128, "seek": 82104, "start": 840.16, "end": 847.16, "text": " and we did this on 262 GitHub projects. And what we found was that when doing the sort", "tokens": [51320, 293, 321, 630, 341, 322, 7551, 17, 23331, 4455, 13, 400, 437, 321, 1352, 390, 300, 562, 884, 264, 1333, 51670], "temperature": 0.0, "avg_logprob": -0.27835815183578, "compression_ratio": 1.4754098360655739, "no_speech_prob": 0.035477545112371445}, {"id": 129, "seek": 84716, "start": 848.0, "end": 855.0, "text": " of changes on project tests we found that on average projects are able to detect 37%", "tokens": [50406, 295, 2962, 322, 1716, 6921, 321, 1352, 300, 322, 4274, 4455, 366, 1075, 281, 5531, 13435, 4, 50756], "temperature": 0.0, "avg_logprob": -0.26653984614780973, "compression_ratio": 1.6844660194174756, "no_speech_prob": 0.015406251884996891}, {"id": 130, "seek": 84716, "start": 855.4, "end": 862.4, "text": " of those which means that a lot of like changes may not may get unnoticed like in general.", "tokens": [50776, 295, 729, 597, 1355, 300, 257, 688, 295, 411, 2962, 815, 406, 815, 483, 517, 2247, 4233, 411, 294, 2674, 13, 51126], "temperature": 0.0, "avg_logprob": -0.26653984614780973, "compression_ratio": 1.6844660194174756, "no_speech_prob": 0.015406251884996891}, {"id": 131, "seek": 84716, "start": 864.12, "end": 869.9599999999999, "text": " But if you use static analysis now that you sort of have the whole context we able to", "tokens": [51212, 583, 498, 291, 764, 13437, 5215, 586, 300, 291, 1333, 295, 362, 264, 1379, 4319, 321, 1075, 281, 51504], "temperature": 0.0, "avg_logprob": -0.26653984614780973, "compression_ratio": 1.6844660194174756, "no_speech_prob": 0.015406251884996891}, {"id": 132, "seek": 84716, "start": 869.9599999999999, "end": 876.9599999999999, "text": " detect 72% of all those changes. But what we find more interesting is that we can see", "tokens": [51504, 5531, 18731, 4, 295, 439, 729, 2962, 13, 583, 437, 321, 915, 544, 1880, 307, 300, 321, 393, 536, 51854], "temperature": 0.0, "avg_logprob": -0.26653984614780973, "compression_ratio": 1.6844660194174756, "no_speech_prob": 0.015406251884996891}, {"id": 133, "seek": 87716, "start": 877.16, "end": 881.76, "text": " that interestingly here like from the context of the studies that there's basically no guarantees", "tokens": [50364, 300, 25873, 510, 411, 490, 264, 4319, 295, 264, 5313, 300, 456, 311, 1936, 572, 32567, 50594], "temperature": 0.0, "avg_logprob": -0.2286180906657931, "compression_ratio": 1.701834862385321, "no_speech_prob": 0.014940222725272179}, {"id": 134, "seek": 87716, "start": 881.76, "end": 888.52, "text": " that tests can prevent bad updates and using either of those techniques is not good enough", "tokens": [50594, 300, 6921, 393, 4871, 1578, 9205, 293, 1228, 2139, 295, 729, 7512, 307, 406, 665, 1547, 50932], "temperature": 0.0, "avg_logprob": -0.2286180906657931, "compression_ratio": 1.701834862385321, "no_speech_prob": 0.014940222725272179}, {"id": 135, "seek": 87716, "start": 888.52, "end": 895.52, "text": " to ensure that updates are safe. Then of course the other thing is that static analysis is", "tokens": [50932, 281, 5586, 300, 9205, 366, 3273, 13, 1396, 295, 1164, 264, 661, 551, 307, 300, 13437, 5215, 307, 51282], "temperature": 0.0, "avg_logprob": -0.2286180906657931, "compression_ratio": 1.701834862385321, "no_speech_prob": 0.014940222725272179}, {"id": 136, "seek": 87716, "start": 896.0, "end": 901.12, "text": " not perfect. There are also problems with it as well. So the problem is over approximation.", "tokens": [51306, 406, 2176, 13, 821, 366, 611, 2740, 365, 309, 382, 731, 13, 407, 264, 1154, 307, 670, 28023, 13, 51562], "temperature": 0.0, "avg_logprob": -0.2286180906657931, "compression_ratio": 1.701834862385321, "no_speech_prob": 0.014940222725272179}, {"id": 137, "seek": 90112, "start": 901.12, "end": 907.76, "text": " So we have over approximation at two locations. One is the call graphs themselves because", "tokens": [50364, 407, 321, 362, 670, 28023, 412, 732, 9253, 13, 1485, 307, 264, 818, 24877, 2969, 570, 50696], "temperature": 0.0, "avg_logprob": -0.20860249483132665, "compression_ratio": 1.6371681415929205, "no_speech_prob": 0.04304169490933418}, {"id": 138, "seek": 90112, "start": 907.76, "end": 913.6, "text": " when it comes to dynamic dispatch if there are maybe 200 implementations that might stand", "tokens": [50696, 562, 309, 1487, 281, 8546, 36729, 498, 456, 366, 1310, 2331, 4445, 763, 300, 1062, 1463, 50988], "temperature": 0.0, "avg_logprob": -0.20860249483132665, "compression_ratio": 1.6371681415929205, "no_speech_prob": 0.04304169490933418}, {"id": 139, "seek": 90112, "start": 913.6, "end": 919.2, "text": " from an interface call we have to link to all of them and that might generate false positives.", "tokens": [50988, 490, 364, 9226, 818, 321, 362, 281, 2113, 281, 439, 295, 552, 293, 300, 1062, 8460, 7908, 35127, 13, 51268], "temperature": 0.0, "avg_logprob": -0.20860249483132665, "compression_ratio": 1.6371681415929205, "no_speech_prob": 0.04304169490933418}, {"id": 140, "seek": 90112, "start": 919.2, "end": 925.6800000000001, "text": " And then the other case is also with the semantic changes that we are detecting because we also", "tokens": [51268, 400, 550, 264, 661, 1389, 307, 611, 365, 264, 47982, 2962, 300, 321, 366, 40237, 570, 321, 611, 51592], "temperature": 0.0, "avg_logprob": -0.20860249483132665, "compression_ratio": 1.6371681415929205, "no_speech_prob": 0.04304169490933418}, {"id": 141, "seek": 92568, "start": 926.04, "end": 930.92, "text": " don't know exactly what type of semantic changes it is. But to sort of see how this worked", "tokens": [50382, 500, 380, 458, 2293, 437, 2010, 295, 47982, 2962, 309, 307, 13, 583, 281, 1333, 295, 536, 577, 341, 2732, 50626], "temperature": 0.0, "avg_logprob": -0.1787486189887637, "compression_ratio": 1.5236051502145922, "no_speech_prob": 0.022739915177226067}, {"id": 142, "seek": 92568, "start": 930.92, "end": 937.92, "text": " in practice we also analyzed and applied this on 22 dependable PRs. And from the results", "tokens": [50626, 294, 3124, 321, 611, 28181, 293, 6456, 341, 322, 5853, 5672, 712, 11568, 82, 13, 400, 490, 264, 3542, 50976], "temperature": 0.0, "avg_logprob": -0.1787486189887637, "compression_ratio": 1.5236051502145922, "no_speech_prob": 0.022739915177226067}, {"id": 143, "seek": 92568, "start": 939.8, "end": 946.4, "text": " what we found in general was that by using static analysis we were able to detect three", "tokens": [51070, 437, 321, 1352, 294, 2674, 390, 300, 538, 1228, 13437, 5215, 321, 645, 1075, 281, 5531, 1045, 51400], "temperature": 0.0, "avg_logprob": -0.1787486189887637, "compression_ratio": 1.5236051502145922, "no_speech_prob": 0.022739915177226067}, {"id": 144, "seek": 92568, "start": 946.4, "end": 950.8, "text": " unused dependencies. So here let's say like the test would just pass it whatever but in", "tokens": [51400, 44383, 36606, 13, 407, 510, 718, 311, 584, 411, 264, 1500, 576, 445, 1320, 309, 2035, 457, 294, 51620], "temperature": 0.0, "avg_logprob": -0.1787486189887637, "compression_ratio": 1.5236051502145922, "no_speech_prob": 0.022739915177226067}, {"id": 145, "seek": 95080, "start": 950.8399999999999, "end": 957.68, "text": " fact we found that the dependencies were not used at all. And we were able to prevent three", "tokens": [50366, 1186, 321, 1352, 300, 264, 36606, 645, 406, 1143, 412, 439, 13, 400, 321, 645, 1075, 281, 4871, 1045, 50708], "temperature": 0.0, "avg_logprob": -0.178036630153656, "compression_ratio": 1.7067307692307692, "no_speech_prob": 0.02280934900045395}, {"id": 146, "seek": 95080, "start": 957.68, "end": 964.68, "text": " breaking updates and one which actually was confirmed by our developer where the test", "tokens": [50708, 7697, 9205, 293, 472, 597, 767, 390, 11341, 538, 527, 10754, 689, 264, 1500, 51058], "temperature": 0.0, "avg_logprob": -0.178036630153656, "compression_ratio": 1.7067307692307692, "no_speech_prob": 0.02280934900045395}, {"id": 147, "seek": 95080, "start": 964.68, "end": 969.7199999999999, "text": " were not able to detect. And then of course we found that there are let's say like false", "tokens": [51058, 645, 406, 1075, 281, 5531, 13, 400, 550, 295, 1164, 321, 1352, 300, 456, 366, 718, 311, 584, 411, 7908, 51310], "temperature": 0.0, "avg_logprob": -0.178036630153656, "compression_ratio": 1.7067307692307692, "no_speech_prob": 0.02280934900045395}, {"id": 148, "seek": 95080, "start": 969.7199999999999, "end": 976.0, "text": " positives and as I mentioned there were many cases with refractorings and then of course", "tokens": [51310, 35127, 293, 382, 286, 2835, 456, 645, 867, 3331, 365, 45353, 284, 1109, 293, 550, 295, 1164, 51624], "temperature": 0.0, "avg_logprob": -0.178036630153656, "compression_ratio": 1.7067307692307692, "no_speech_prob": 0.02280934900045395}, {"id": 149, "seek": 97600, "start": 976.04, "end": 982.08, "text": " this over approximated call paths. So if you use like a tool like Google here or static", "tokens": [50366, 341, 670, 8542, 770, 818, 14518, 13, 407, 498, 291, 764, 411, 257, 2290, 411, 3329, 510, 420, 13437, 50668], "temperature": 0.0, "avg_logprob": -0.2645636713782022, "compression_ratio": 1.5695067264573992, "no_speech_prob": 0.0146299684420228}, {"id": 150, "seek": 97600, "start": 982.08, "end": 987.08, "text": " analysis it can help to prevent updates but then you also get a lot of noise as well as", "tokens": [50668, 5215, 309, 393, 854, 281, 4871, 9205, 457, 550, 291, 611, 483, 257, 688, 295, 5658, 382, 731, 382, 50918], "temperature": 0.0, "avg_logprob": -0.2645636713782022, "compression_ratio": 1.5695067264573992, "no_speech_prob": 0.0146299684420228}, {"id": 151, "seek": 97600, "start": 987.08, "end": 994.08, "text": " a result. So sort of coming to the end of more of the studies what are let's say like the", "tokens": [50918, 257, 1874, 13, 407, 1333, 295, 1348, 281, 264, 917, 295, 544, 295, 264, 5313, 437, 366, 718, 311, 584, 411, 264, 51268], "temperature": 0.0, "avg_logprob": -0.2645636713782022, "compression_ratio": 1.5695067264573992, "no_speech_prob": 0.0146299684420228}, {"id": 152, "seek": 97600, "start": 997.08, "end": 1004.08, "text": " recommendations that I have after looking into like on Github projects how tests are", "tokens": [51418, 10434, 300, 286, 362, 934, 1237, 666, 411, 322, 460, 355, 836, 4455, 577, 6921, 366, 51768], "temperature": 0.0, "avg_logprob": -0.2645636713782022, "compression_ratio": 1.5695067264573992, "no_speech_prob": 0.0146299684420228}, {"id": 153, "seek": 100408, "start": 1004.1600000000001, "end": 1009.96, "text": " being made etc. So one thing I found missing when it comes to updating with test widths", "tokens": [50368, 885, 1027, 5183, 13, 407, 472, 551, 286, 1352, 5361, 562, 309, 1487, 281, 25113, 365, 1500, 11402, 82, 50658], "temperature": 0.0, "avg_logprob": -0.19134918848673502, "compression_ratio": 1.7115384615384615, "no_speech_prob": 0.03507870063185692}, {"id": 154, "seek": 100408, "start": 1009.96, "end": 1015.76, "text": " is that we don't have any form of confidence score. And what I mean with confidence score", "tokens": [50658, 307, 300, 321, 500, 380, 362, 604, 1254, 295, 6687, 6175, 13, 400, 437, 286, 914, 365, 6687, 6175, 50948], "temperature": 0.0, "avg_logprob": -0.19134918848673502, "compression_ratio": 1.7115384615384615, "no_speech_prob": 0.03507870063185692}, {"id": 155, "seek": 100408, "start": 1015.76, "end": 1022.76, "text": " is that for example if we can stop measuring test coverage we can see for example if there", "tokens": [50948, 307, 300, 337, 1365, 498, 321, 393, 1590, 13389, 1500, 9645, 321, 393, 536, 337, 1365, 498, 456, 51298], "temperature": 0.0, "avg_logprob": -0.19134918848673502, "compression_ratio": 1.7115384615384615, "no_speech_prob": 0.03507870063185692}, {"id": 156, "seek": 100408, "start": 1023.6800000000001, "end": 1029.16, "text": " is a change function in a third party library do we even have test that reaches that or", "tokens": [51344, 307, 257, 1319, 2445, 294, 257, 2636, 3595, 6405, 360, 321, 754, 362, 1500, 300, 14235, 300, 420, 51618], "temperature": 0.0, "avg_logprob": -0.19134918848673502, "compression_ratio": 1.7115384615384615, "no_speech_prob": 0.03507870063185692}, {"id": 157, "seek": 102916, "start": 1029.16, "end": 1034.8400000000001, "text": " not and that could directly give an indication whether like my test width is able to capture", "tokens": [50364, 406, 293, 300, 727, 3838, 976, 364, 18877, 1968, 411, 452, 1500, 11402, 307, 1075, 281, 7983, 50648], "temperature": 0.0, "avg_logprob": -0.16241955521083115, "compression_ratio": 1.825910931174089, "no_speech_prob": 0.049399759620428085}, {"id": 158, "seek": 102916, "start": 1034.8400000000001, "end": 1040.8400000000001, "text": " that or not. And another very interesting thing could be for example if you find that", "tokens": [50648, 300, 420, 406, 13, 400, 1071, 588, 1880, 551, 727, 312, 337, 1365, 498, 291, 915, 300, 50948], "temperature": 0.0, "avg_logprob": -0.16241955521083115, "compression_ratio": 1.825910931174089, "no_speech_prob": 0.049399759620428085}, {"id": 159, "seek": 102916, "start": 1040.8400000000001, "end": 1046.2, "text": " one of your libraries are very tightly integrated with your project it can also sort of give", "tokens": [50948, 472, 295, 428, 15148, 366, 588, 21952, 10919, 365, 428, 1716, 309, 393, 611, 1333, 295, 976, 51216], "temperature": 0.0, "avg_logprob": -0.16241955521083115, "compression_ratio": 1.825910931174089, "no_speech_prob": 0.049399759620428085}, {"id": 160, "seek": 102916, "start": 1046.2, "end": 1053.2, "text": " an indication whether you have let's say like enough test to cover that usage or not at all.", "tokens": [51216, 364, 18877, 1968, 291, 362, 718, 311, 584, 411, 1547, 1500, 281, 2060, 300, 14924, 420, 406, 412, 439, 13, 51566], "temperature": 0.0, "avg_logprob": -0.16241955521083115, "compression_ratio": 1.825910931174089, "no_speech_prob": 0.049399759620428085}, {"id": 161, "seek": 102916, "start": 1054.0400000000002, "end": 1058.3600000000001, "text": " And then by having sort of this score you can maybe get an indication where does let's", "tokens": [51608, 400, 550, 538, 1419, 1333, 295, 341, 6175, 291, 393, 1310, 483, 364, 18877, 689, 775, 718, 311, 51824], "temperature": 0.0, "avg_logprob": -0.16241955521083115, "compression_ratio": 1.825910931174089, "no_speech_prob": 0.049399759620428085}, {"id": 162, "seek": 105836, "start": 1058.4399999999998, "end": 1064.4399999999998, "text": " say like how well am I just able to capture things in third party libraries or not. This", "tokens": [50368, 584, 411, 577, 731, 669, 286, 445, 1075, 281, 7983, 721, 294, 2636, 3595, 15148, 420, 406, 13, 639, 50668], "temperature": 0.0, "avg_logprob": -0.17011912818093902, "compression_ratio": 1.718146718146718, "no_speech_prob": 0.013456815853714943}, {"id": 163, "seek": 105836, "start": 1064.4399999999998, "end": 1069.32, "text": " is something that I would like to see in tooling in general. And then when it comes to the", "tokens": [50668, 307, 746, 300, 286, 576, 411, 281, 536, 294, 46593, 294, 2674, 13, 400, 550, 562, 309, 1487, 281, 264, 50912], "temperature": 0.0, "avg_logprob": -0.17011912818093902, "compression_ratio": 1.718146718146718, "no_speech_prob": 0.013456815853714943}, {"id": 164, "seek": 105836, "start": 1069.32, "end": 1073.4399999999998, "text": " gaps in test coverage so this is related to the results I was saying like the statement", "tokens": [50912, 15031, 294, 1500, 9645, 370, 341, 307, 4077, 281, 264, 3542, 286, 390, 1566, 411, 264, 5629, 51118], "temperature": 0.0, "avg_logprob": -0.17011912818093902, "compression_ratio": 1.718146718146718, "no_speech_prob": 0.013456815853714943}, {"id": 165, "seek": 105836, "start": 1073.4399999999998, "end": 1080.4399999999998, "text": " coverage and effectiveness. So I believe more of having a hybrid solution so we're using", "tokens": [51118, 9645, 293, 21208, 13, 407, 286, 1697, 544, 295, 1419, 257, 13051, 3827, 370, 321, 434, 1228, 51468], "temperature": 0.0, "avg_logprob": -0.17011912818093902, "compression_ratio": 1.718146718146718, "no_speech_prob": 0.013456815853714943}, {"id": 166, "seek": 105836, "start": 1082.6, "end": 1087.6, "text": " tests or dynamic analysis is able to capture. I think we should use that because that is", "tokens": [51576, 6921, 420, 8546, 5215, 307, 1075, 281, 7983, 13, 286, 519, 321, 820, 764, 300, 570, 300, 307, 51826], "temperature": 0.0, "avg_logprob": -0.17011912818093902, "compression_ratio": 1.718146718146718, "no_speech_prob": 0.013456815853714943}, {"id": 167, "seek": 108760, "start": 1087.6399999999999, "end": 1093.6399999999999, "text": " more precise. But then in areas of the code where we don't have any coverage so for example", "tokens": [50366, 544, 13600, 13, 583, 550, 294, 3179, 295, 264, 3089, 689, 321, 500, 380, 362, 604, 9645, 370, 337, 1365, 50666], "temperature": 0.0, "avg_logprob": -0.258061689489028, "compression_ratio": 1.567099567099567, "no_speech_prob": 0.014752994291484356}, {"id": 168, "seek": 108760, "start": 1093.6399999999999, "end": 1099.28, "text": " consider back to the look for J library where usually I wouldn't expect just to be much", "tokens": [50666, 1949, 646, 281, 264, 574, 337, 508, 6405, 689, 2673, 286, 2759, 380, 2066, 445, 281, 312, 709, 50948], "temperature": 0.0, "avg_logprob": -0.258061689489028, "compression_ratio": 1.567099567099567, "no_speech_prob": 0.014752994291484356}, {"id": 169, "seek": 108760, "start": 1099.28, "end": 1104.8, "text": " test coverage. Here it could be nice to complement the static analysis. So you sort of get a", "tokens": [50948, 1500, 9645, 13, 1692, 309, 727, 312, 1481, 281, 17103, 264, 13437, 5215, 13, 407, 291, 1333, 295, 483, 257, 51224], "temperature": 0.0, "avg_logprob": -0.258061689489028, "compression_ratio": 1.567099567099567, "no_speech_prob": 0.014752994291484356}, {"id": 170, "seek": 108760, "start": 1104.8, "end": 1111.8, "text": " little bit better for both words here. And then another advantage that I might see having", "tokens": [51224, 707, 857, 1101, 337, 1293, 2283, 510, 13, 400, 550, 1071, 5002, 300, 286, 1062, 536, 1419, 51574], "temperature": 0.0, "avg_logprob": -0.258061689489028, "compression_ratio": 1.567099567099567, "no_speech_prob": 0.014752994291484356}, {"id": 171, "seek": 111180, "start": 1112.04, "end": 1119.04, "text": " static analysis rather running tests is that we can maybe much more earlier to take potential", "tokens": [50376, 13437, 5215, 2831, 2614, 6921, 307, 300, 321, 393, 1310, 709, 544, 3071, 281, 747, 3995, 50726], "temperature": 0.0, "avg_logprob": -0.32391578674316407, "compression_ratio": 1.6090909090909091, "no_speech_prob": 0.023401636630296707}, {"id": 172, "seek": 111180, "start": 1119.48, "end": 1124.84, "text": " like problems in compatibilities by having that rather than trying to run it through", "tokens": [50748, 411, 2740, 294, 13147, 8261, 538, 1419, 300, 2831, 813, 1382, 281, 1190, 309, 807, 51016], "temperature": 0.0, "avg_logprob": -0.32391578674316407, "compression_ratio": 1.6090909090909091, "no_speech_prob": 0.023401636630296707}, {"id": 173, "seek": 111180, "start": 1124.84, "end": 1131.84, "text": " the build system consuming extra resources or tests etc. So those are less likely to main", "tokens": [51016, 264, 1322, 1185, 19867, 2857, 3593, 420, 6921, 5183, 13, 407, 729, 366, 1570, 3700, 281, 2135, 51366], "temperature": 0.0, "avg_logprob": -0.32391578674316407, "compression_ratio": 1.6090909090909091, "no_speech_prob": 0.023401636630296707}, {"id": 174, "seek": 111180, "start": 1131.8799999999999, "end": 1138.8799999999999, "text": " things that I find important to address. And then for users like myself of using this", "tokens": [51368, 721, 300, 286, 915, 1021, 281, 2985, 13, 400, 550, 337, 5022, 411, 2059, 295, 1228, 341, 51718], "temperature": 0.0, "avg_logprob": -0.32391578674316407, "compression_ratio": 1.6090909090909091, "no_speech_prob": 0.023401636630296707}, {"id": 175, "seek": 113888, "start": 1139.8400000000001, "end": 1145.72, "text": " automated dependence updating tools. So although like reusing is free in the sense that we", "tokens": [50412, 18473, 31704, 25113, 3873, 13, 407, 4878, 411, 319, 7981, 307, 1737, 294, 264, 2020, 300, 321, 50706], "temperature": 0.0, "avg_logprob": -0.2554844342745267, "compression_ratio": 1.6318181818181818, "no_speech_prob": 0.038547415286302567}, {"id": 176, "seek": 113888, "start": 1145.72, "end": 1151.64, "text": " can easily just use a library but we often forget the operational and maintenance costs", "tokens": [50706, 393, 3612, 445, 764, 257, 6405, 457, 321, 2049, 2870, 264, 16607, 293, 11258, 5497, 51002], "temperature": 0.0, "avg_logprob": -0.2554844342745267, "compression_ratio": 1.6318181818181818, "no_speech_prob": 0.038547415286302567}, {"id": 177, "seek": 113888, "start": 1151.64, "end": 1158.64, "text": " and those are not free. So trying to basically automate away everything by using tooling", "tokens": [51002, 293, 729, 366, 406, 1737, 13, 407, 1382, 281, 1936, 31605, 1314, 1203, 538, 1228, 46593, 51352], "temperature": 0.0, "avg_logprob": -0.2554844342745267, "compression_ratio": 1.6318181818181818, "no_speech_prob": 0.038547415286302567}, {"id": 178, "seek": 113888, "start": 1158.7600000000002, "end": 1164.72, "text": " etc. is not always the solution. I think it's important to also consider that once we start", "tokens": [51358, 5183, 13, 307, 406, 1009, 264, 3827, 13, 286, 519, 309, 311, 1021, 281, 611, 1949, 300, 1564, 321, 722, 51656], "temperature": 0.0, "avg_logprob": -0.2554844342745267, "compression_ratio": 1.6318181818181818, "no_speech_prob": 0.038547415286302567}, {"id": 179, "seek": 116472, "start": 1164.72, "end": 1170.08, "text": " adopting a library we also need to think about how we can maintain it but also understanding", "tokens": [50364, 32328, 257, 6405, 321, 611, 643, 281, 519, 466, 577, 321, 393, 6909, 309, 457, 611, 3701, 50632], "temperature": 0.0, "avg_logprob": -0.18002297480901083, "compression_ratio": 1.6529850746268657, "no_speech_prob": 0.07714944332838058}, {"id": 180, "seek": 116472, "start": 1170.08, "end": 1175.84, "text": " what potential risk might come from it. Could be for example that maintainer have a very", "tokens": [50632, 437, 3995, 3148, 1062, 808, 490, 309, 13, 7497, 312, 337, 1365, 300, 6909, 260, 362, 257, 588, 50920], "temperature": 0.0, "avg_logprob": -0.18002297480901083, "compression_ratio": 1.6529850746268657, "no_speech_prob": 0.07714944332838058}, {"id": 181, "seek": 116472, "start": 1175.84, "end": 1180.6000000000001, "text": " different sort of handling when it comes to security vulnerabilities. It could also be", "tokens": [50920, 819, 1333, 295, 13175, 562, 309, 1487, 281, 3825, 37633, 13, 467, 727, 611, 312, 51158], "temperature": 0.0, "avg_logprob": -0.18002297480901083, "compression_ratio": 1.6529850746268657, "no_speech_prob": 0.07714944332838058}, {"id": 182, "seek": 116472, "start": 1180.6000000000001, "end": 1184.88, "text": " with the release protocol like there could be disagreements on what is breaking change", "tokens": [51158, 365, 264, 4374, 10336, 411, 456, 727, 312, 23926, 6400, 322, 437, 307, 7697, 1319, 51372], "temperature": 0.0, "avg_logprob": -0.18002297480901083, "compression_ratio": 1.6529850746268657, "no_speech_prob": 0.07714944332838058}, {"id": 183, "seek": 116472, "start": 1184.88, "end": 1191.88, "text": " or not for clients. So I think having that aspect is one important thing. And the other", "tokens": [51372, 420, 406, 337, 6982, 13, 407, 286, 519, 1419, 300, 4171, 307, 472, 1021, 551, 13, 400, 264, 661, 51722], "temperature": 0.0, "avg_logprob": -0.18002297480901083, "compression_ratio": 1.6529850746268657, "no_speech_prob": 0.07714944332838058}, {"id": 184, "seek": 119188, "start": 1192.8000000000002, "end": 1198.7600000000002, "text": " thing is like of course not blindly trusting automated dependency updates and I guess no", "tokens": [50410, 551, 307, 411, 295, 1164, 406, 47744, 28235, 18473, 33621, 9205, 293, 286, 2041, 572, 50708], "temperature": 0.0, "avg_logprob": -0.19217838287353517, "compression_ratio": 1.6904761904761905, "no_speech_prob": 0.0282350555062294}, {"id": 185, "seek": 119188, "start": 1198.7600000000002, "end": 1204.64, "text": " one really does this. And then that's another thing which could be debatable is to have", "tokens": [50708, 472, 534, 775, 341, 13, 400, 550, 300, 311, 1071, 551, 597, 727, 312, 3001, 31415, 307, 281, 362, 51002], "temperature": 0.0, "avg_logprob": -0.19217838287353517, "compression_ratio": 1.6904761904761905, "no_speech_prob": 0.0282350555062294}, {"id": 186, "seek": 119188, "start": 1204.64, "end": 1209.24, "text": " essentially critical I mean having writing tests for critical dependencies and this could", "tokens": [51002, 4476, 4924, 286, 914, 1419, 3579, 6921, 337, 4924, 36606, 293, 341, 727, 51232], "temperature": 0.0, "avg_logprob": -0.19217838287353517, "compression_ratio": 1.6904761904761905, "no_speech_prob": 0.0282350555062294}, {"id": 187, "seek": 119188, "start": 1209.24, "end": 1216.48, "text": " be a library that's very critical to your project. I think here maybe having tests could", "tokens": [51232, 312, 257, 6405, 300, 311, 588, 4924, 281, 428, 1716, 13, 286, 519, 510, 1310, 1419, 6921, 727, 51594], "temperature": 0.0, "avg_logprob": -0.19217838287353517, "compression_ratio": 1.6904761904761905, "no_speech_prob": 0.0282350555062294}, {"id": 188, "seek": 121648, "start": 1216.52, "end": 1222.44, "text": " help let's say like capture early issues that might arise in dependencies and not come", "tokens": [50366, 854, 718, 311, 584, 411, 7983, 2440, 2663, 300, 1062, 20288, 294, 36606, 293, 406, 808, 50662], "temperature": 0.0, "avg_logprob": -0.3017926797634218, "compression_ratio": 1.5555555555555556, "no_speech_prob": 0.05726027861237526}, {"id": 189, "seek": 121648, "start": 1222.44, "end": 1229.44, "text": " as an unwanted breaking change later on once you merge the automated PR.", "tokens": [50662, 382, 364, 33745, 7697, 1319, 1780, 322, 1564, 291, 22183, 264, 18473, 11568, 13, 51012], "temperature": 0.0, "avg_logprob": -0.3017926797634218, "compression_ratio": 1.5555555555555556, "no_speech_prob": 0.05726027861237526}, {"id": 190, "seek": 121648, "start": 1232.2, "end": 1237.76, "text": " So if you want to let's say like know more about this work I have a paper so I also", "tokens": [51150, 407, 498, 291, 528, 281, 718, 311, 584, 411, 458, 544, 466, 341, 589, 286, 362, 257, 3035, 370, 286, 611, 51428], "temperature": 0.0, "avg_logprob": -0.3017926797634218, "compression_ratio": 1.5555555555555556, "no_speech_prob": 0.05726027861237526}, {"id": 191, "seek": 121648, "start": 1237.76, "end": 1244.76, "text": " uploaded slides on the Fosnum website so you can click the link and the paper is open access", "tokens": [51428, 17135, 9788, 322, 264, 479, 329, 77, 449, 3144, 370, 291, 393, 2052, 264, 2113, 293, 264, 3035, 307, 1269, 2105, 51778], "temperature": 0.0, "avg_logprob": -0.3017926797634218, "compression_ratio": 1.5555555555555556, "no_speech_prob": 0.05726027861237526}, {"id": 192, "seek": 124476, "start": 1244.76, "end": 1252.76, "text": " and yeah this is concludes my talk more or less so happy to take any questions.", "tokens": [50414, 293, 1338, 341, 307, 24643, 452, 751, 544, 420, 1570, 370, 2055, 281, 747, 604, 1651, 13, 50764], "temperature": 0.0, "avg_logprob": -0.2869038343429565, "compression_ratio": 1.0972222222222223, "no_speech_prob": 0.027365056797862053}, {"id": 193, "seek": 127476, "start": 1275.76, "end": 1282.76, "text": " So do you know if any of these bots like the pen about renovate are working on such a score", "tokens": [50414, 407, 360, 291, 458, 498, 604, 295, 613, 35410, 411, 264, 3435, 466, 18845, 473, 366, 1364, 322, 1270, 257, 6175, 50764], "temperature": 0.0, "avg_logprob": -0.4001946284853179, "compression_ratio": 1.610091743119266, "no_speech_prob": 0.01880047097802162}, {"id": 194, "seek": 127476, "start": 1282.76, "end": 1288.76, "text": " so let's say the merge request to get like a warning. Hey your tests are not covering", "tokens": [50764, 370, 718, 311, 584, 264, 22183, 5308, 281, 483, 411, 257, 9164, 13, 1911, 428, 6921, 366, 406, 10322, 51064], "temperature": 0.0, "avg_logprob": -0.4001946284853179, "compression_ratio": 1.610091743119266, "no_speech_prob": 0.01880047097802162}, {"id": 195, "seek": 127476, "start": 1288.76, "end": 1293.76, "text": " only 10 percent of the dependencies. Do you know if there is any work.", "tokens": [51064, 787, 1266, 3043, 295, 264, 36606, 13, 1144, 291, 458, 498, 456, 307, 604, 589, 13, 51314], "temperature": 0.0, "avg_logprob": -0.4001946284853179, "compression_ratio": 1.610091743119266, "no_speech_prob": 0.01880047097802162}, {"id": 196, "seek": 127476, "start": 1293.76, "end": 1300.76, "text": " So what I'm aware of is that there is a compatibility score that looks at for example for a particular", "tokens": [51314, 407, 437, 286, 478, 3650, 295, 307, 300, 456, 307, 257, 34237, 6175, 300, 1542, 412, 337, 1365, 337, 257, 1729, 51664], "temperature": 0.0, "avg_logprob": -0.4001946284853179, "compression_ratio": 1.610091743119266, "no_speech_prob": 0.01880047097802162}, {"id": 197, "seek": 130076, "start": 1301.76, "end": 1308.76, "text": " dependency version updates if out of less than like 200 PRs if 100 of those were successful", "tokens": [50414, 33621, 3037, 9205, 498, 484, 295, 1570, 813, 411, 2331, 11568, 82, 498, 2319, 295, 729, 645, 4406, 50764], "temperature": 0.0, "avg_logprob": -0.21222655352424172, "compression_ratio": 1.5541666666666667, "no_speech_prob": 0.01364762894809246}, {"id": 198, "seek": 130076, "start": 1309.76, "end": 1315.76, "text": " for other projects then it will give us a score that there's a 50 percent chance that you will", "tokens": [50814, 337, 661, 4455, 550, 309, 486, 976, 505, 257, 6175, 300, 456, 311, 257, 2625, 3043, 2931, 300, 291, 486, 51114], "temperature": 0.0, "avg_logprob": -0.21222655352424172, "compression_ratio": 1.5541666666666667, "no_speech_prob": 0.01364762894809246}, {"id": 199, "seek": 130076, "start": 1315.76, "end": 1320.76, "text": " succeed here. The only thing I find problematic is that every project has their own specific", "tokens": [51114, 7754, 510, 13, 440, 787, 551, 286, 915, 19011, 307, 300, 633, 1716, 575, 641, 1065, 2685, 51364], "temperature": 0.0, "avg_logprob": -0.21222655352424172, "compression_ratio": 1.5541666666666667, "no_speech_prob": 0.01364762894809246}, {"id": 200, "seek": 130076, "start": 1320.76, "end": 1326.76, "text": " use case or context of how they use it so it could be misleading but I haven't heard anything", "tokens": [51364, 764, 1389, 420, 4319, 295, 577, 436, 764, 309, 370, 309, 727, 312, 36429, 457, 286, 2378, 380, 2198, 1340, 51664], "temperature": 0.0, "avg_logprob": -0.21222655352424172, "compression_ratio": 1.5541666666666667, "no_speech_prob": 0.01364762894809246}, {"id": 201, "seek": 132676, "start": 1326.76, "end": 1333.76, "text": " that looks specifically into your test suite to see how I mean how it's able to do that.", "tokens": [50364, 300, 1542, 4682, 666, 428, 1500, 14205, 281, 536, 577, 286, 914, 577, 309, 311, 1075, 281, 360, 300, 13, 50714], "temperature": 0.0, "avg_logprob": -0.2055831172249534, "compression_ratio": 1.3576642335766422, "no_speech_prob": 0.02908920682966709}, {"id": 202, "seek": 132676, "start": 1344.76, "end": 1351.76, "text": " Thank you. You mentioned the number of 60 percent for the amount of tests for direct dependencies", "tokens": [51264, 1044, 291, 13, 509, 2835, 264, 1230, 295, 4060, 3043, 337, 264, 2372, 295, 6921, 337, 2047, 36606, 51614], "temperature": 0.0, "avg_logprob": -0.2055831172249534, "compression_ratio": 1.3576642335766422, "no_speech_prob": 0.02908920682966709}, {"id": 203, "seek": 135176, "start": 1352.76, "end": 1361.76, "text": " and I believe it was a lot less for transitive dependencies. Do you have any numbers on the amount of transitive dependencies", "tokens": [50414, 293, 286, 1697, 309, 390, 257, 688, 1570, 337, 1145, 2187, 36606, 13, 1144, 291, 362, 604, 3547, 322, 264, 2372, 295, 1145, 2187, 36606, 50864], "temperature": 0.0, "avg_logprob": -0.31984732184611575, "compression_ratio": 1.6542553191489362, "no_speech_prob": 0.12387963384389877}, {"id": 204, "seek": 135176, "start": 1362.76, "end": 1371.76, "text": " in search change the chains actually. So I can can imagine that the 60 percent is cumulative in these.", "tokens": [50914, 294, 3164, 1319, 264, 12626, 767, 13, 407, 286, 393, 393, 3811, 300, 264, 4060, 3043, 307, 38379, 294, 613, 13, 51364], "temperature": 0.0, "avg_logprob": -0.31984732184611575, "compression_ratio": 1.6542553191489362, "no_speech_prob": 0.12387963384389877}, {"id": 205, "seek": 135176, "start": 1372.76, "end": 1377.76, "text": " Do you mean for the statement coverage thing or the statement. Yeah the first one.", "tokens": [51414, 1144, 291, 914, 337, 264, 5629, 9645, 551, 420, 264, 5629, 13, 865, 264, 700, 472, 13, 51664], "temperature": 0.0, "avg_logprob": -0.31984732184611575, "compression_ratio": 1.6542553191489362, "no_speech_prob": 0.12387963384389877}, {"id": 206, "seek": 137776, "start": 1378.76, "end": 1386.76, "text": " So the first one the 60 percent was on like direct dependencies and then this 20 percent was on the transitive ones.", "tokens": [50414, 407, 264, 700, 472, 264, 4060, 3043, 390, 322, 411, 2047, 36606, 293, 550, 341, 945, 3043, 390, 322, 264, 1145, 2187, 2306, 13, 50814], "temperature": 0.0, "avg_logprob": -0.20339310963948568, "compression_ratio": 1.6443298969072164, "no_speech_prob": 0.025231841951608658}, {"id": 207, "seek": 137776, "start": 1387.76, "end": 1393.76, "text": " Do you have any numbers of the amount of transitive dependencies so you can relate it to that 60 percent.", "tokens": [50864, 1144, 291, 362, 604, 3547, 295, 264, 2372, 295, 1145, 2187, 36606, 370, 291, 393, 10961, 309, 281, 300, 4060, 3043, 13, 51164], "temperature": 0.0, "avg_logprob": -0.20339310963948568, "compression_ratio": 1.6443298969072164, "no_speech_prob": 0.025231841951608658}, {"id": 208, "seek": 137776, "start": 1394.76, "end": 1399.76, "text": " Okay so I did this on 500 time projects but I might have the more specific numbers in the paper.", "tokens": [51214, 1033, 370, 286, 630, 341, 322, 5923, 565, 4455, 457, 286, 1062, 362, 264, 544, 2685, 3547, 294, 264, 3035, 13, 51464], "temperature": 0.0, "avg_logprob": -0.20339310963948568, "compression_ratio": 1.6443298969072164, "no_speech_prob": 0.025231841951608658}, {"id": 209, "seek": 139976, "start": 1399.76, "end": 1412.76, "text": " Okay. You have been looking at detecting errors. Have you looked in the other side because you can use it in a hybrid mode", "tokens": [50364, 1033, 13, 509, 362, 668, 1237, 412, 40237, 13603, 13, 3560, 291, 2956, 294, 264, 661, 1252, 570, 291, 393, 764, 309, 294, 257, 13051, 4391, 51014], "temperature": 0.0, "avg_logprob": -0.18435987612096275, "compression_ratio": 1.5944700460829493, "no_speech_prob": 0.019751396030187607}, {"id": 210, "seek": 139976, "start": 1412.76, "end": 1419.76, "text": " that your tool maybe can tell me you can make this update for sure because all the code is changed.", "tokens": [51014, 300, 428, 2290, 1310, 393, 980, 385, 291, 393, 652, 341, 5623, 337, 988, 570, 439, 264, 3089, 307, 3105, 13, 51364], "temperature": 0.0, "avg_logprob": -0.18435987612096275, "compression_ratio": 1.5944700460829493, "no_speech_prob": 0.019751396030187607}, {"id": 211, "seek": 139976, "start": 1420.76, "end": 1427.76, "text": " You don't care about it. For example if you look at low level right libraries like Apache Commons you only use a part of it", "tokens": [51414, 509, 500, 380, 1127, 466, 309, 13, 1171, 1365, 498, 291, 574, 412, 2295, 1496, 558, 15148, 411, 46597, 34894, 291, 787, 764, 257, 644, 295, 309, 51764], "temperature": 0.0, "avg_logprob": -0.18435987612096275, "compression_ratio": 1.5944700460829493, "no_speech_prob": 0.019751396030187607}, {"id": 212, "seek": 142776, "start": 1427.76, "end": 1436.76, "text": " but you want to keep up to date and some updates are more or less completely safe because you don't touch any code that has changed", "tokens": [50364, 457, 291, 528, 281, 1066, 493, 281, 4002, 293, 512, 9205, 366, 544, 420, 1570, 2584, 3273, 570, 291, 500, 380, 2557, 604, 3089, 300, 575, 3105, 50814], "temperature": 0.0, "avg_logprob": -0.16450074823891245, "compression_ratio": 1.6210045662100456, "no_speech_prob": 0.010645161382853985}, {"id": 213, "seek": 142776, "start": 1436.76, "end": 1443.76, "text": " because only new features have been added or so and that would also help if I just know yes that's safe.", "tokens": [50814, 570, 787, 777, 4122, 362, 668, 3869, 420, 370, 293, 300, 576, 611, 854, 498, 286, 445, 458, 2086, 300, 311, 3273, 13, 51164], "temperature": 0.0, "avg_logprob": -0.16450074823891245, "compression_ratio": 1.6210045662100456, "no_speech_prob": 0.010645161382853985}, {"id": 214, "seek": 142776, "start": 1444.76, "end": 1451.76, "text": " Yeah that's a great question. So this is a little bit idea we had with introducing call graphs because the call graphs", "tokens": [51214, 865, 300, 311, 257, 869, 1168, 13, 407, 341, 307, 257, 707, 857, 1558, 321, 632, 365, 15424, 818, 24877, 570, 264, 818, 24877, 51564], "temperature": 0.0, "avg_logprob": -0.16450074823891245, "compression_ratio": 1.6210045662100456, "no_speech_prob": 0.010645161382853985}, {"id": 215, "seek": 145176, "start": 1451.76, "end": 1459.76, "text": " you can start learning what exactly is used. So even if you use like a major library and you just use maybe two utility classes", "tokens": [50364, 291, 393, 722, 2539, 437, 2293, 307, 1143, 13, 407, 754, 498, 291, 764, 411, 257, 2563, 6405, 293, 291, 445, 764, 1310, 732, 14877, 5359, 50764], "temperature": 0.0, "avg_logprob": -0.11922198002881343, "compression_ratio": 1.8099173553719008, "no_speech_prob": 0.02049287222325802}, {"id": 216, "seek": 145176, "start": 1460.76, "end": 1466.76, "text": " and even if you go to like a major version of it you might not be affected by it and this is something that should be covered by the call graph", "tokens": [50814, 293, 754, 498, 291, 352, 281, 411, 257, 2563, 3037, 295, 309, 291, 1062, 406, 312, 8028, 538, 309, 293, 341, 307, 746, 300, 820, 312, 5343, 538, 264, 818, 4295, 51114], "temperature": 0.0, "avg_logprob": -0.11922198002881343, "compression_ratio": 1.8099173553719008, "no_speech_prob": 0.02049287222325802}, {"id": 217, "seek": 145176, "start": 1466.76, "end": 1475.76, "text": " so we will see for example that the utility classes there are no changes there but then in the rest of the package there's a lot of changes that you're unaffected by.", "tokens": [51114, 370, 321, 486, 536, 337, 1365, 300, 264, 14877, 5359, 456, 366, 572, 2962, 456, 457, 550, 294, 264, 1472, 295, 264, 7372, 456, 311, 257, 688, 295, 2962, 300, 291, 434, 2002, 11259, 292, 538, 13, 51564], "temperature": 0.0, "avg_logprob": -0.11922198002881343, "compression_ratio": 1.8099173553719008, "no_speech_prob": 0.02049287222325802}, {"id": 218, "seek": 148176, "start": 1481.76, "end": 1483.76, "text": " Thank you.", "tokens": [50364, 1044, 291, 13, 50464], "temperature": 0.0, "avg_logprob": -0.4072078358043324, "compression_ratio": 1.037037037037037, "no_speech_prob": 0.06806501001119614}, {"id": 219, "seek": 148176, "start": 1499.76, "end": 1504.76, "text": " Did you check how the call graphs work with dynamic dependency injection?", "tokens": [51264, 2589, 291, 1520, 577, 264, 818, 24877, 589, 365, 8546, 33621, 22873, 30, 51514], "temperature": 0.0, "avg_logprob": -0.4072078358043324, "compression_ratio": 1.037037037037037, "no_speech_prob": 0.06806501001119614}, {"id": 220, "seek": 150476, "start": 1505.76, "end": 1514.76, "text": " Yeah so we essentially if I understood the question right I mean so we did generate the dynamic call graphs like running the test", "tokens": [50414, 865, 370, 321, 4476, 498, 286, 7320, 264, 1168, 558, 286, 914, 370, 321, 630, 8460, 264, 8546, 818, 24877, 411, 2614, 264, 1500, 50864], "temperature": 0.0, "avg_logprob": -0.17958372831344604, "compression_ratio": 1.7567567567567568, "no_speech_prob": 0.012599905952811241}, {"id": 221, "seek": 150476, "start": 1514.76, "end": 1524.76, "text": " and this is something that we essentially used to guide or rotation like testing framework to only do changes in those functions", "tokens": [50864, 293, 341, 307, 746, 300, 321, 4476, 1143, 281, 5934, 420, 12447, 411, 4997, 8388, 281, 787, 360, 2962, 294, 729, 6828, 51364], "temperature": 0.0, "avg_logprob": -0.17958372831344604, "compression_ratio": 1.7567567567567568, "no_speech_prob": 0.012599905952811241}, {"id": 222, "seek": 150476, "start": 1524.76, "end": 1533.76, "text": " and not for example functions that the test didn't touch because otherwise we wouldn't know whether I mean the test we were able to", "tokens": [51364, 293, 406, 337, 1365, 6828, 300, 264, 1500, 994, 380, 2557, 570, 5911, 321, 2759, 380, 458, 1968, 286, 914, 264, 1500, 321, 645, 1075, 281, 51814], "temperature": 0.0, "avg_logprob": -0.17958372831344604, "compression_ratio": 1.7567567567567568, "no_speech_prob": 0.012599905952811241}, {"id": 223, "seek": 153376, "start": 1533.76, "end": 1535.76, "text": " detect changes or not.", "tokens": [50364, 5531, 2962, 420, 406, 13, 50464], "temperature": 0.0, "avg_logprob": -0.19779977202415466, "compression_ratio": 0.7333333333333333, "no_speech_prob": 0.08391830325126648}], "language": "en"}