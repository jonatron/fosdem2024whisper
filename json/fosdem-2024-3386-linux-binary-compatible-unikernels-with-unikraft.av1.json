{"text": " Perfect. So, welcome everybody. My name is Simon K\u00fcnzer. I'm the project founder actually of Unicraft and lead maintainer there. I'm also CTO and co-founder of Unicraft TMBH, which is a commercial open source company using the Unicraft project for building a new cloud. You saw some aspects actually from Rasmus talk. This was like three talks earlier than mine. Here I'll go really now into much more technical details, how it looks like on the kernel side. So, this is much more OS class here, what I'm doing. So, first of all, briefly, wave your hands up if you know what a Unicron is. Good. Okay. So, then I do it here really quick. In the end, what we are doing is turning an application into a kernel by using something that we call operating system libraries that are directly baked to an application and we run that as a virtual machine. So, then we're all on the same page. Especially the Unicraft project, what's for us important is the aspect of single purpose. So, we do specialization and saying the OS layers are built just for that particular application that we're interested in and that allows you a lot of optimizations that you can do. For instance, we do single address space because we run one application in one kernel. We have a really small TCP and a small memory footprint. Behind the scenes, we have something that we call the micro library pool. So, you have decomposed OS functionality as library available. So, this is for instance scheduling file systems, then libraries that do Linux or POSIX APIs so that ease programming with that environment. So, it's kind of an SDK. The current project focus is on Linux compatibility because our vision is actually we want seamless application support for existing Linux applications. And since most software is written for Linux, especially for the cloud, we want to remove as many obstacles that we can do for running them on top of Unicraft. And one aspect as Vassim was showing is the tooling side. We have actually two approaches from the kernel side. We can do application compatibility natively, meaning you take the sources of your application and compile it together with the libraries of your kernel. But we can also do binary compatibility and this is what I'm going to speak about here, where we provide the Linux ABI to the application. So, we do system calls, VGSOs, etc., etc., to support a pre-compiled application. And now I'm going over these individual steps. So, first of all, when you build a kernel and want to make that supporting running a Linux application, what you need to understand or the kernel needs to understand is the ELF format. Running that application ELF is actually a pretty straightforward process. So, you need to first be able to pass the ELF, load it in your memory space, then you need to prepare an entrance stack. This is all specifications that you need to look up and fill out the specific vectors and values in there, and then jump to the entrance. And then that application is working. The only interaction that you will then, from that time on, have with the application are actually system calls. There's two interesting things here regarding loading ELF applications. So, you have something called non-PIE applications and something called PIE applications, meaning non-position independent... Sorry, non-position independent, position independent. The non-position dependent, they dictate you the address layout in your unicolonel. And since we want to run everything with a single address space, it means we can support only one non-PIE application. The beauty of PIE is we can relocate the application in the address space. So, we can still work with a single address space, but can run multiple applications if you want. And, sorry, if we're going a bit more further with the original reason why PIE is now pretty common in operating systems, we could even apply with that single address space full stack ASLR, where we mix kernel libraries and application libraries completely spread in the address space. I give you some more readings when you download the slides, but basically in the project we are focusing on PIE applications, since most of them, at least the last five years, is the standard when you get a pre-compiled binary from the distro. System calls. So, we are in a single address space, we have a pre-compiled binary from Linux and we want to run it, so we have to do system calls. This is actually a long pipeline that we need to run. It starts with a Cisco instruction, so note here this is now x86 specific, but that instruction usually takes care of a protection domain switch from ring 3 to ring 0, but we run in a single protection domain, actually we don't need that, so we go from ring 0 to ring 0, but yeah, we need to execute that instruction. Then Linux requires us to have an own kernel side stack, especially language environments like Go. They don't give you a big enough stack that you can just continue executing on the kernel side, so you need to switch. In reality, of course, if you have an application that has a big enough stack, you could also configure Unicraft to get rid of this step. Then at the moment we are using full CPU features also on the Unicraft side, it's mainly coming from for supporting native applications where basically addressing the kernel is just a function call, so why would you restrict your CPU features? If you don't compile it with that, then you can also remove that step, but if you do that in a default option, we need to save and restore that state 2 of your CPU. Then we have a TLS switch, which we really require because we use the TLS for our OSD composites, you know, libraryization, sorry, because we didn't want to have a central big TCP control structure where we need to maintain every particular field. We want to have everything clearly decomposed, so the TLS was the way to go for that. Yeah, and then actually we're able to call the system call handler. That brings you to the question, does it have to be that complicated? We need to do really so many steps, isn't there something we can do a bit better with a single address space? And actually there is, and there is this mechanism called VDSO and also kernel VSS call, this is an old thing, so the VDSO basically for us is just a catalog to look up kernel symbols, so this is a way for us to provide the function addresses to the application that the application can directly call because again, single address space, single protection domain, we don't need to do a switch. The second thing is the kernel VSS call symbol, which was a standardized symbol in the past, mostly for x86 when CPUs were introduced to do sysenter and syscall instead of interrupt driven system calls, that was a way for the S, from the US to tell the application to enter the kernel more efficiently. For us, we can use it as a function call to directly jump in the system call handler, so it's no trap, no interrupt, no privileged domain switch, no need to save and restore of extended registers because even that is covered by the system V calling convention. And the idea here is we just need to patch the libc shared library of that application and then most system calls anyways go through the libc because they provide wrappers there and then we have that covered. So in comparison, no expensive syscall instruction anymore, it's just a function call, the stack maybe we needed depends still, no floating point registers, whatever I mean, you don't need to save anymore and the TNS register we need to switch still. Okay, now we get into this fork dilemma, how I call it, this is like always the bad word for unicolonial people. So this is a bit of OS class here, so you probably remember fork means duplicating the address space of your application so that everything is at the same address. Problem with this is it's a second address space, I don't want a second address space, I want everything flat in a single address space to save time in context switches or TLB flashes, right? So, doesn't work. What we actually would need in a unicolon environment is a fork version that forks the application to a different address. Unfortunately, without compiler support, that's not that easy. You could of course copy the memory region but you need to then start patching your application because you have absolute addresses in there like return addresses on stacks, pointer addresses, etc. So don't work that great but what we can do, sorry, for instance, let's say, what the question is is when you look at the applications, they're compilers position independent. In principle, the result is that I can run multiple applications in a single address space. It's just that this model with fork and exit doesn't fit, you would say, because we have this fork intermediate step. And luckily, there was also this was coming from, let's say, older generations of Linux when they were trying to run Linux on targets without MMU. There's a system called V fork that allows you that. It's a bit of a funky fork call because it doesn't fork actually. It just pauses your parent and allows you to execute within the memory space of the parent, the child, for a short period of time, actually until the child calls either exit or one of the execution functions to load a new application binary. And that is basically our solution for running multiple applications or like a shell or something where the shell forks, you load a position independent binary anyway in the next step, then you have it in a different address area and you execute. What we want to try out here is if that mechanism works great for, you know, if you could just replace the fork system call number internally with a V fork and see for how many applications that works great because they were doing fork exit before and for how many that does work. But obviously, won't work is for applications that just use fork to open up worker processes. But just for this fork exit model that works. Okay, and then the last point is a bit, I really rushed through. I was when I was preparing, I was checking, okay, I can't say this, there's no time, no time. So here I wanted to give you a bit of an overview of what we did the last year when we looked at different applications and we're always in front of that question. We need to have Linux compatibility, but at the same time, we don't want to re-implement Linux. And there's some aspects where it's really tricky. For instance, the first one is a really interesting example. It's about querying from the kernel side network interfaces or setting up routing tables, etc. So get if address and call, which normally needs a complete subsystem of sockets to be implemented. And then on top of a known protocol called netlink, just to do this user space kernel interaction for gathering that information. An alternative here could be, of course, we implemented that, but an alternative here could be also to make use of the VDSO again, patch the libc and do more direct calls for just querying the IP address from the kernel that's currently set. Another interesting point is applications that are so mean that implicitly rely on a specific behavior on Linux. And really, a funny example is primitive scheduling that you come across from time to time. So far we have cooperative scheduling in Unicraft because that's a really efficient for us scheduling way to do things. But then you, I mean, you put something like Frank in PHP or MySQL and they use busy waiting loops to wait for other threads to wake up. With a cooperative scheduler, you can imagine what happens. Basically nothing because you're constantly busy waiting but never give another threat to chance to pop up. Then there is this whole topic about which system calls you need to support, which ones you can stop, which one need to be completely implemented. It's actually true that you can stop a lot, you don't need all of them. I would here refer you to a nice paper from Esplos. Actually last year for STEM, the authors were giving a presentation here too about how to figure out which system calls you need to implement. Of course, there's also sometimes the application dependent, but there is a, you don't need to implement all of the Linux system calls to have Linux compatibility. There are really a lot of system calls that are really specific to some cases or setting up seed groups or whatever, which normal applications don't use. And then of course the whole topic about file system hierarchy standard, where of course application expect you have something under PROC or under ETC or somewhere. So far, we were able to go around that by providing a meaningful filled text file for the application, especially the PROC file system without implementing that yet. And that worked for NGINX, Node.js, Redis, HA Proxy and a lot of other number of applications. Okay, so now we're so fast through this, I'm sorry. So we have time for some questions. I guess there's some stuff for more clarity. We are an open source project. These are the resources where you can find us. And you can also, I mean, see that I put here KraftCloud, that logo. This is what we currently try to build with our company, which is a cloud that uses the beauty of unicronals for really fast bootups, high resource efficiency for serverless architectures, microservices, functional services, etc. Unfortunately, just two minutes for the questions, but still, are there any questions? So when you run everything in a single address base, do you actually need to enable paging at all? So yeah, with the CPU, actually we need to enable paging, but it allows you to build a page table at compile time. And then it's just switching that page table on during boot. What additionally happens with Linux applications that are sometimes doing MAP calls and mapping here, something or file there, of course, if you enable that support, then you need some kind of dynamic page table handling. But if you don't need that, you have the opportunity to have a compile time page table. So we don't have the time to discuss it, but I was wondering if you have paging, wouldn't you be able to use copy and write to the popular one? Maybe something to think about. Of course, we do also copy and write where you need it. The thing is, what we still want is a single address space. So that page table is, basically, there's just one page table, another page table per application. We don't have this page table switches, no TLB flushes. So this is where we gain actually a lot of performance also from. And since we say we are a single application, we run only one thing, why do I need to handle? Everything that runs in the unique kernel is defined to be trusted, and you have then the hard isolation boundaries outside from the hard-provise environment to protect anything that is going bad or an overtaken unique conference. If you write, protect the data pages of a process that does fork, you can actually detect processes that don't use default exec that do actual fork to share memory, and you would be able to detect that. I would just add to that because you would have multiple other spaces just for a short while, so it's not really a performance issue, right? Yeah, it's like two kinds, implementation effort and... But yeah, I see your point. Also for non-position independent applications, I mean, if you have a choice not supporting multiple of them and having multiple address spaces, I mean, why not go for multiple address spaces, it does not invalidate the unique kernel idea. No, no, no, it doesn't. It doesn't. It just comes with some cost, right? Right. Okay, thank you very much. We have to switch to another talk. Thanks again.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 11.16, "text": " Perfect. So, welcome everybody. My name is Simon K\u00fcnzer. I'm the project founder actually", "tokens": [50364, 10246, 13, 407, 11, 2928, 2201, 13, 1222, 1315, 307, 13193, 591, 3412, 4527, 13, 286, 478, 264, 1716, 14917, 767, 50922], "temperature": 0.0, "avg_logprob": -0.2666468090481228, "compression_ratio": 1.4076086956521738, "no_speech_prob": 0.18083366751670837}, {"id": 1, "seek": 0, "start": 11.16, "end": 16.56, "text": " of Unicraft and lead maintainer there. I'm also CTO and co-founder of Unicraft TMBH,", "tokens": [50922, 295, 1156, 299, 4469, 293, 1477, 6909, 260, 456, 13, 286, 478, 611, 383, 15427, 293, 598, 12, 33348, 295, 1156, 299, 4469, 33550, 33, 39, 11, 51192], "temperature": 0.0, "avg_logprob": -0.2666468090481228, "compression_ratio": 1.4076086956521738, "no_speech_prob": 0.18083366751670837}, {"id": 2, "seek": 0, "start": 16.56, "end": 24.72, "text": " which is a commercial open source company using the Unicraft project for building a", "tokens": [51192, 597, 307, 257, 6841, 1269, 4009, 2237, 1228, 264, 1156, 299, 4469, 1716, 337, 2390, 257, 51600], "temperature": 0.0, "avg_logprob": -0.2666468090481228, "compression_ratio": 1.4076086956521738, "no_speech_prob": 0.18083366751670837}, {"id": 3, "seek": 2472, "start": 24.72, "end": 31.68, "text": " new cloud. You saw some aspects actually from Rasmus talk. This was like three talks earlier", "tokens": [50364, 777, 4588, 13, 509, 1866, 512, 7270, 767, 490, 497, 14774, 301, 751, 13, 639, 390, 411, 1045, 6686, 3071, 50712], "temperature": 0.0, "avg_logprob": -0.2377729034423828, "compression_ratio": 1.4455958549222798, "no_speech_prob": 0.03599335253238678}, {"id": 4, "seek": 2472, "start": 31.68, "end": 38.76, "text": " than mine. Here I'll go really now into much more technical details, how it looks like on the", "tokens": [50712, 813, 3892, 13, 1692, 286, 603, 352, 534, 586, 666, 709, 544, 6191, 4365, 11, 577, 309, 1542, 411, 322, 264, 51066], "temperature": 0.0, "avg_logprob": -0.2377729034423828, "compression_ratio": 1.4455958549222798, "no_speech_prob": 0.03599335253238678}, {"id": 5, "seek": 2472, "start": 38.76, "end": 47.08, "text": " kernel side. So, this is much more OS class here, what I'm doing. So, first of all, briefly,", "tokens": [51066, 28256, 1252, 13, 407, 11, 341, 307, 709, 544, 12731, 1508, 510, 11, 437, 286, 478, 884, 13, 407, 11, 700, 295, 439, 11, 10515, 11, 51482], "temperature": 0.0, "avg_logprob": -0.2377729034423828, "compression_ratio": 1.4455958549222798, "no_speech_prob": 0.03599335253238678}, {"id": 6, "seek": 4708, "start": 47.08, "end": 58.0, "text": " wave your hands up if you know what a Unicron is. Good. Okay. So, then I do it here really", "tokens": [50364, 5772, 428, 2377, 493, 498, 291, 458, 437, 257, 1156, 299, 2044, 307, 13, 2205, 13, 1033, 13, 407, 11, 550, 286, 360, 309, 510, 534, 50910], "temperature": 0.0, "avg_logprob": -0.19610864094325475, "compression_ratio": 1.516304347826087, "no_speech_prob": 0.02356536127626896}, {"id": 7, "seek": 4708, "start": 58.0, "end": 66.32, "text": " quick. In the end, what we are doing is turning an application into a kernel by using something", "tokens": [50910, 1702, 13, 682, 264, 917, 11, 437, 321, 366, 884, 307, 6246, 364, 3861, 666, 257, 28256, 538, 1228, 746, 51326], "temperature": 0.0, "avg_logprob": -0.19610864094325475, "compression_ratio": 1.516304347826087, "no_speech_prob": 0.02356536127626896}, {"id": 8, "seek": 4708, "start": 66.32, "end": 72.03999999999999, "text": " that we call operating system libraries that are directly baked to an application and we run", "tokens": [51326, 300, 321, 818, 7447, 1185, 15148, 300, 366, 3838, 19453, 281, 364, 3861, 293, 321, 1190, 51612], "temperature": 0.0, "avg_logprob": -0.19610864094325475, "compression_ratio": 1.516304347826087, "no_speech_prob": 0.02356536127626896}, {"id": 9, "seek": 7204, "start": 72.04, "end": 77.64, "text": " that as a virtual machine. So, then we're all on the same page. Especially the Unicraft project,", "tokens": [50364, 300, 382, 257, 6374, 3479, 13, 407, 11, 550, 321, 434, 439, 322, 264, 912, 3028, 13, 8545, 264, 1156, 299, 4469, 1716, 11, 50644], "temperature": 0.0, "avg_logprob": -0.1934909613236137, "compression_ratio": 1.6271186440677967, "no_speech_prob": 0.006266588345170021}, {"id": 10, "seek": 7204, "start": 77.64, "end": 86.24000000000001, "text": " what's for us important is the aspect of single purpose. So, we do specialization and saying the", "tokens": [50644, 437, 311, 337, 505, 1021, 307, 264, 4171, 295, 2167, 4334, 13, 407, 11, 321, 360, 2121, 2144, 293, 1566, 264, 51074], "temperature": 0.0, "avg_logprob": -0.1934909613236137, "compression_ratio": 1.6271186440677967, "no_speech_prob": 0.006266588345170021}, {"id": 11, "seek": 7204, "start": 86.24000000000001, "end": 91.0, "text": " OS layers are built just for that particular application that we're interested in and that", "tokens": [51074, 12731, 7914, 366, 3094, 445, 337, 300, 1729, 3861, 300, 321, 434, 3102, 294, 293, 300, 51312], "temperature": 0.0, "avg_logprob": -0.1934909613236137, "compression_ratio": 1.6271186440677967, "no_speech_prob": 0.006266588345170021}, {"id": 12, "seek": 7204, "start": 91.0, "end": 95.64000000000001, "text": " allows you a lot of optimizations that you can do. For instance, we do single address space because", "tokens": [51312, 4045, 291, 257, 688, 295, 5028, 14455, 300, 291, 393, 360, 13, 1171, 5197, 11, 321, 360, 2167, 2985, 1901, 570, 51544], "temperature": 0.0, "avg_logprob": -0.1934909613236137, "compression_ratio": 1.6271186440677967, "no_speech_prob": 0.006266588345170021}, {"id": 13, "seek": 9564, "start": 95.68, "end": 102.4, "text": " we run one application in one kernel. We have a really small TCP and a small memory footprint.", "tokens": [50366, 321, 1190, 472, 3861, 294, 472, 28256, 13, 492, 362, 257, 534, 1359, 48965, 293, 257, 1359, 4675, 24222, 13, 50702], "temperature": 0.0, "avg_logprob": -0.21667643326979416, "compression_ratio": 1.4867724867724867, "no_speech_prob": 0.005001502111554146}, {"id": 14, "seek": 9564, "start": 102.4, "end": 109.92, "text": " Behind the scenes, we have something that we call the micro library pool. So, you have decomposed", "tokens": [50702, 20475, 264, 8026, 11, 321, 362, 746, 300, 321, 818, 264, 4532, 6405, 7005, 13, 407, 11, 291, 362, 22867, 1744, 51078], "temperature": 0.0, "avg_logprob": -0.21667643326979416, "compression_ratio": 1.4867724867724867, "no_speech_prob": 0.005001502111554146}, {"id": 15, "seek": 9564, "start": 109.92, "end": 118.72, "text": " OS functionality as library available. So, this is for instance scheduling file systems,", "tokens": [51078, 12731, 14980, 382, 6405, 2435, 13, 407, 11, 341, 307, 337, 5197, 29055, 3991, 3652, 11, 51518], "temperature": 0.0, "avg_logprob": -0.21667643326979416, "compression_ratio": 1.4867724867724867, "no_speech_prob": 0.005001502111554146}, {"id": 16, "seek": 11872, "start": 119.67999999999999, "end": 130.52, "text": " then libraries that do Linux or POSIX APIs so that ease programming with that environment. So,", "tokens": [50412, 550, 15148, 300, 360, 18734, 420, 430, 4367, 21124, 21445, 370, 300, 12708, 9410, 365, 300, 2823, 13, 407, 11, 50954], "temperature": 0.0, "avg_logprob": -0.19871325571028914, "compression_ratio": 1.4292929292929293, "no_speech_prob": 0.003214304568246007}, {"id": 17, "seek": 11872, "start": 130.52, "end": 137.76, "text": " it's kind of an SDK. The current project focus is on Linux compatibility because our vision is", "tokens": [50954, 309, 311, 733, 295, 364, 37135, 13, 440, 2190, 1716, 1879, 307, 322, 18734, 34237, 570, 527, 5201, 307, 51316], "temperature": 0.0, "avg_logprob": -0.19871325571028914, "compression_ratio": 1.4292929292929293, "no_speech_prob": 0.003214304568246007}, {"id": 18, "seek": 11872, "start": 137.76, "end": 144.4, "text": " actually we want seamless application support for existing Linux applications. And since most", "tokens": [51316, 767, 321, 528, 28677, 3861, 1406, 337, 6741, 18734, 5821, 13, 400, 1670, 881, 51648], "temperature": 0.0, "avg_logprob": -0.19871325571028914, "compression_ratio": 1.4292929292929293, "no_speech_prob": 0.003214304568246007}, {"id": 19, "seek": 14440, "start": 144.84, "end": 150.84, "text": " software is written for Linux, especially for the cloud, we want to remove as many obstacles that", "tokens": [50386, 4722, 307, 3720, 337, 18734, 11, 2318, 337, 264, 4588, 11, 321, 528, 281, 4159, 382, 867, 17735, 300, 50686], "temperature": 0.0, "avg_logprob": -0.22343440388524255, "compression_ratio": 1.6163793103448276, "no_speech_prob": 0.0016861569602042437}, {"id": 20, "seek": 14440, "start": 150.84, "end": 157.4, "text": " we can do for running them on top of Unicraft. And one aspect as Vassim was showing is the", "tokens": [50686, 321, 393, 360, 337, 2614, 552, 322, 1192, 295, 1156, 299, 4469, 13, 400, 472, 4171, 382, 691, 640, 332, 390, 4099, 307, 264, 51014], "temperature": 0.0, "avg_logprob": -0.22343440388524255, "compression_ratio": 1.6163793103448276, "no_speech_prob": 0.0016861569602042437}, {"id": 21, "seek": 14440, "start": 157.4, "end": 165.24, "text": " tooling side. We have actually two approaches from the kernel side. We can do application", "tokens": [51014, 46593, 1252, 13, 492, 362, 767, 732, 11587, 490, 264, 28256, 1252, 13, 492, 393, 360, 3861, 51406], "temperature": 0.0, "avg_logprob": -0.22343440388524255, "compression_ratio": 1.6163793103448276, "no_speech_prob": 0.0016861569602042437}, {"id": 22, "seek": 14440, "start": 165.24, "end": 171.16, "text": " compatibility natively, meaning you take the sources of your application and compile it together", "tokens": [51406, 34237, 8470, 356, 11, 3620, 291, 747, 264, 7139, 295, 428, 3861, 293, 31413, 309, 1214, 51702], "temperature": 0.0, "avg_logprob": -0.22343440388524255, "compression_ratio": 1.6163793103448276, "no_speech_prob": 0.0016861569602042437}, {"id": 23, "seek": 17116, "start": 171.2, "end": 176.88, "text": " with the libraries of your kernel. But we can also do binary compatibility and this is what I'm", "tokens": [50366, 365, 264, 15148, 295, 428, 28256, 13, 583, 321, 393, 611, 360, 17434, 34237, 293, 341, 307, 437, 286, 478, 50650], "temperature": 0.0, "avg_logprob": -0.2043015203977886, "compression_ratio": 1.4564102564102563, "no_speech_prob": 0.0022824532352387905}, {"id": 24, "seek": 17116, "start": 176.88, "end": 184.12, "text": " going to speak about here, where we provide the Linux ABI to the application. So, we do system", "tokens": [50650, 516, 281, 1710, 466, 510, 11, 689, 321, 2893, 264, 18734, 316, 11291, 281, 264, 3861, 13, 407, 11, 321, 360, 1185, 51012], "temperature": 0.0, "avg_logprob": -0.2043015203977886, "compression_ratio": 1.4564102564102563, "no_speech_prob": 0.0022824532352387905}, {"id": 25, "seek": 17116, "start": 184.12, "end": 195.35999999999999, "text": " calls, VGSOs, etc., etc., to support a pre-compiled application. And now I'm going over these", "tokens": [51012, 5498, 11, 691, 24446, 31376, 11, 5183, 7933, 5183, 7933, 281, 1406, 257, 659, 12, 21541, 7292, 3861, 13, 400, 586, 286, 478, 516, 670, 613, 51574], "temperature": 0.0, "avg_logprob": -0.2043015203977886, "compression_ratio": 1.4564102564102563, "no_speech_prob": 0.0022824532352387905}, {"id": 26, "seek": 19536, "start": 195.4, "end": 201.4, "text": " individual steps. So, first of all, when you build a kernel and want to make that supporting", "tokens": [50366, 2609, 4439, 13, 407, 11, 700, 295, 439, 11, 562, 291, 1322, 257, 28256, 293, 528, 281, 652, 300, 7231, 50666], "temperature": 0.0, "avg_logprob": -0.19018677605523004, "compression_ratio": 1.7149321266968325, "no_speech_prob": 0.0021472349762916565}, {"id": 27, "seek": 19536, "start": 201.4, "end": 205.52, "text": " running a Linux application, what you need to understand or the kernel needs to understand is", "tokens": [50666, 2614, 257, 18734, 3861, 11, 437, 291, 643, 281, 1223, 420, 264, 28256, 2203, 281, 1223, 307, 50872], "temperature": 0.0, "avg_logprob": -0.19018677605523004, "compression_ratio": 1.7149321266968325, "no_speech_prob": 0.0021472349762916565}, {"id": 28, "seek": 19536, "start": 205.52, "end": 214.56, "text": " the ELF format. Running that application ELF is actually a pretty straightforward process. So,", "tokens": [50872, 264, 14426, 37, 7877, 13, 28136, 300, 3861, 14426, 37, 307, 767, 257, 1238, 15325, 1399, 13, 407, 11, 51324], "temperature": 0.0, "avg_logprob": -0.19018677605523004, "compression_ratio": 1.7149321266968325, "no_speech_prob": 0.0021472349762916565}, {"id": 29, "seek": 19536, "start": 214.56, "end": 220.60000000000002, "text": " you need to first be able to pass the ELF, load it in your memory space, then you need to prepare", "tokens": [51324, 291, 643, 281, 700, 312, 1075, 281, 1320, 264, 14426, 37, 11, 3677, 309, 294, 428, 4675, 1901, 11, 550, 291, 643, 281, 5940, 51626], "temperature": 0.0, "avg_logprob": -0.19018677605523004, "compression_ratio": 1.7149321266968325, "no_speech_prob": 0.0021472349762916565}, {"id": 30, "seek": 22060, "start": 220.64, "end": 226.32, "text": " an entrance stack. This is all specifications that you need to look up and fill out the specific", "tokens": [50366, 364, 12014, 8630, 13, 639, 307, 439, 29448, 300, 291, 643, 281, 574, 493, 293, 2836, 484, 264, 2685, 50650], "temperature": 0.0, "avg_logprob": -0.15607891312564712, "compression_ratio": 1.7149321266968325, "no_speech_prob": 0.0020362313371151686}, {"id": 31, "seek": 22060, "start": 226.32, "end": 231.28, "text": " vectors and values in there, and then jump to the entrance. And then that application is working.", "tokens": [50650, 18875, 293, 4190, 294, 456, 11, 293, 550, 3012, 281, 264, 12014, 13, 400, 550, 300, 3861, 307, 1364, 13, 50898], "temperature": 0.0, "avg_logprob": -0.15607891312564712, "compression_ratio": 1.7149321266968325, "no_speech_prob": 0.0020362313371151686}, {"id": 32, "seek": 22060, "start": 231.28, "end": 236.4, "text": " The only interaction that you will then, from that time on, have with the application are", "tokens": [50898, 440, 787, 9285, 300, 291, 486, 550, 11, 490, 300, 565, 322, 11, 362, 365, 264, 3861, 366, 51154], "temperature": 0.0, "avg_logprob": -0.15607891312564712, "compression_ratio": 1.7149321266968325, "no_speech_prob": 0.0020362313371151686}, {"id": 33, "seek": 22060, "start": 236.4, "end": 247.35999999999999, "text": " actually system calls. There's two interesting things here regarding loading ELF applications.", "tokens": [51154, 767, 1185, 5498, 13, 821, 311, 732, 1880, 721, 510, 8595, 15114, 14426, 37, 5821, 13, 51702], "temperature": 0.0, "avg_logprob": -0.15607891312564712, "compression_ratio": 1.7149321266968325, "no_speech_prob": 0.0020362313371151686}, {"id": 34, "seek": 24736, "start": 247.56, "end": 254.12, "text": " So, you have something called non-PIE applications and something called PIE applications, meaning", "tokens": [50374, 407, 11, 291, 362, 746, 1219, 2107, 12, 47, 6550, 5821, 293, 746, 1219, 430, 6550, 5821, 11, 3620, 50702], "temperature": 0.0, "avg_logprob": -0.2950079414281952, "compression_ratio": 1.9540816326530612, "no_speech_prob": 0.00836685486137867}, {"id": 35, "seek": 24736, "start": 254.12, "end": 260.32, "text": " non-position independent... Sorry, non-position independent, position independent. The non-position", "tokens": [50702, 2107, 12, 38078, 6695, 485, 4919, 11, 2107, 12, 38078, 6695, 11, 2535, 6695, 13, 440, 2107, 12, 38078, 51012], "temperature": 0.0, "avg_logprob": -0.2950079414281952, "compression_ratio": 1.9540816326530612, "no_speech_prob": 0.00836685486137867}, {"id": 36, "seek": 24736, "start": 260.32, "end": 267.16, "text": " dependent, they dictate you the address layout in your unicolonel. And since we want to run", "tokens": [51012, 12334, 11, 436, 36071, 291, 264, 2985, 13333, 294, 428, 517, 299, 38780, 338, 13, 400, 1670, 321, 528, 281, 1190, 51354], "temperature": 0.0, "avg_logprob": -0.2950079414281952, "compression_ratio": 1.9540816326530612, "no_speech_prob": 0.00836685486137867}, {"id": 37, "seek": 24736, "start": 267.16, "end": 272.08000000000004, "text": " everything with a single address space, it means we can support only one non-PIE application.", "tokens": [51354, 1203, 365, 257, 2167, 2985, 1901, 11, 309, 1355, 321, 393, 1406, 787, 472, 2107, 12, 47, 6550, 3861, 13, 51600], "temperature": 0.0, "avg_logprob": -0.2950079414281952, "compression_ratio": 1.9540816326530612, "no_speech_prob": 0.00836685486137867}, {"id": 38, "seek": 27208, "start": 272.8, "end": 278.68, "text": " The beauty of PIE is we can relocate the application in the address space. So, we can still work", "tokens": [50400, 440, 6643, 295, 430, 6550, 307, 321, 393, 26981, 473, 264, 3861, 294, 264, 2985, 1901, 13, 407, 11, 321, 393, 920, 589, 50694], "temperature": 0.0, "avg_logprob": -0.2508518218994141, "compression_ratio": 1.6610169491525424, "no_speech_prob": 0.004420342855155468}, {"id": 39, "seek": 27208, "start": 278.68, "end": 286.4, "text": " with a single address space, but can run multiple applications if you want. And, sorry, if we're", "tokens": [50694, 365, 257, 2167, 2985, 1901, 11, 457, 393, 1190, 3866, 5821, 498, 291, 528, 13, 400, 11, 2597, 11, 498, 321, 434, 51080], "temperature": 0.0, "avg_logprob": -0.2508518218994141, "compression_ratio": 1.6610169491525424, "no_speech_prob": 0.004420342855155468}, {"id": 40, "seek": 27208, "start": 286.4, "end": 292.76, "text": " going a bit more further with the original reason why PIE is now pretty common in operating systems,", "tokens": [51080, 516, 257, 857, 544, 3052, 365, 264, 3380, 1778, 983, 430, 6550, 307, 586, 1238, 2689, 294, 7447, 3652, 11, 51398], "temperature": 0.0, "avg_logprob": -0.2508518218994141, "compression_ratio": 1.6610169491525424, "no_speech_prob": 0.004420342855155468}, {"id": 41, "seek": 27208, "start": 292.76, "end": 301.32, "text": " we could even apply with that single address space full stack ASLR, where we mix kernel libraries", "tokens": [51398, 321, 727, 754, 3079, 365, 300, 2167, 2985, 1901, 1577, 8630, 7469, 43, 49, 11, 689, 321, 2890, 28256, 15148, 51826], "temperature": 0.0, "avg_logprob": -0.2508518218994141, "compression_ratio": 1.6610169491525424, "no_speech_prob": 0.004420342855155468}, {"id": 42, "seek": 30132, "start": 301.56, "end": 307.15999999999997, "text": " and application libraries completely spread in the address space. I give you some more readings", "tokens": [50376, 293, 3861, 15148, 2584, 3974, 294, 264, 2985, 1901, 13, 286, 976, 291, 512, 544, 27319, 50656], "temperature": 0.0, "avg_logprob": -0.21120032397183505, "compression_ratio": 1.5405405405405406, "no_speech_prob": 0.0022146760020405054}, {"id": 43, "seek": 30132, "start": 307.15999999999997, "end": 315.36, "text": " when you download the slides, but basically in the project we are focusing on PIE applications,", "tokens": [50656, 562, 291, 5484, 264, 9788, 11, 457, 1936, 294, 264, 1716, 321, 366, 8416, 322, 430, 6550, 5821, 11, 51066], "temperature": 0.0, "avg_logprob": -0.21120032397183505, "compression_ratio": 1.5405405405405406, "no_speech_prob": 0.0022146760020405054}, {"id": 44, "seek": 30132, "start": 315.36, "end": 322.68, "text": " since most of them, at least the last five years, is the standard when you get a pre-compiled", "tokens": [51066, 1670, 881, 295, 552, 11, 412, 1935, 264, 1036, 1732, 924, 11, 307, 264, 3832, 562, 291, 483, 257, 659, 12, 21541, 7292, 51432], "temperature": 0.0, "avg_logprob": -0.21120032397183505, "compression_ratio": 1.5405405405405406, "no_speech_prob": 0.0022146760020405054}, {"id": 45, "seek": 32268, "start": 323.04, "end": 334.36, "text": " binary from the distro. System calls. So, we are in a single address space, we have a pre-compiled", "tokens": [50382, 17434, 490, 264, 1483, 340, 13, 8910, 5498, 13, 407, 11, 321, 366, 294, 257, 2167, 2985, 1901, 11, 321, 362, 257, 659, 12, 21541, 7292, 50948], "temperature": 0.0, "avg_logprob": -0.2235454607613479, "compression_ratio": 1.5210526315789474, "no_speech_prob": 0.009439393877983093}, {"id": 46, "seek": 32268, "start": 334.36, "end": 339.96000000000004, "text": " binary from Linux and we want to run it, so we have to do system calls. This is actually a long", "tokens": [50948, 17434, 490, 18734, 293, 321, 528, 281, 1190, 309, 11, 370, 321, 362, 281, 360, 1185, 5498, 13, 639, 307, 767, 257, 938, 51228], "temperature": 0.0, "avg_logprob": -0.2235454607613479, "compression_ratio": 1.5210526315789474, "no_speech_prob": 0.009439393877983093}, {"id": 47, "seek": 32268, "start": 339.96000000000004, "end": 347.16, "text": " pipeline that we need to run. It starts with a Cisco instruction, so note here this is now x86", "tokens": [51228, 15517, 300, 321, 643, 281, 1190, 13, 467, 3719, 365, 257, 38528, 10951, 11, 370, 3637, 510, 341, 307, 586, 2031, 22193, 51588], "temperature": 0.0, "avg_logprob": -0.2235454607613479, "compression_ratio": 1.5210526315789474, "no_speech_prob": 0.009439393877983093}, {"id": 48, "seek": 34716, "start": 347.16, "end": 353.24, "text": " specific, but that instruction usually takes care of a protection domain switch from ring 3 to", "tokens": [50364, 2685, 11, 457, 300, 10951, 2673, 2516, 1127, 295, 257, 6334, 9274, 3679, 490, 4875, 805, 281, 50668], "temperature": 0.0, "avg_logprob": -0.19286231156233902, "compression_ratio": 1.721461187214612, "no_speech_prob": 0.003952724859118462}, {"id": 49, "seek": 34716, "start": 353.24, "end": 358.36, "text": " ring 0, but we run in a single protection domain, actually we don't need that, so we go from ring 0", "tokens": [50668, 4875, 1958, 11, 457, 321, 1190, 294, 257, 2167, 6334, 9274, 11, 767, 321, 500, 380, 643, 300, 11, 370, 321, 352, 490, 4875, 1958, 50924], "temperature": 0.0, "avg_logprob": -0.19286231156233902, "compression_ratio": 1.721461187214612, "no_speech_prob": 0.003952724859118462}, {"id": 50, "seek": 34716, "start": 358.36, "end": 367.64000000000004, "text": " to ring 0, but yeah, we need to execute that instruction. Then Linux requires us to have an", "tokens": [50924, 281, 4875, 1958, 11, 457, 1338, 11, 321, 643, 281, 14483, 300, 10951, 13, 1396, 18734, 7029, 505, 281, 362, 364, 51388], "temperature": 0.0, "avg_logprob": -0.19286231156233902, "compression_ratio": 1.721461187214612, "no_speech_prob": 0.003952724859118462}, {"id": 51, "seek": 34716, "start": 367.64000000000004, "end": 375.12, "text": " own kernel side stack, especially language environments like Go. They don't give you a big", "tokens": [51388, 1065, 28256, 1252, 8630, 11, 2318, 2856, 12388, 411, 1037, 13, 814, 500, 380, 976, 291, 257, 955, 51762], "temperature": 0.0, "avg_logprob": -0.19286231156233902, "compression_ratio": 1.721461187214612, "no_speech_prob": 0.003952724859118462}, {"id": 52, "seek": 37512, "start": 375.16, "end": 380.56, "text": " enough stack that you can just continue executing on the kernel side, so you need to switch. In", "tokens": [50366, 1547, 8630, 300, 291, 393, 445, 2354, 32368, 322, 264, 28256, 1252, 11, 370, 291, 643, 281, 3679, 13, 682, 50636], "temperature": 0.0, "avg_logprob": -0.15616683745652102, "compression_ratio": 1.6103896103896105, "no_speech_prob": 0.003844944993034005}, {"id": 53, "seek": 37512, "start": 380.56, "end": 388.64, "text": " reality, of course, if you have an application that has a big enough stack, you could also", "tokens": [50636, 4103, 11, 295, 1164, 11, 498, 291, 362, 364, 3861, 300, 575, 257, 955, 1547, 8630, 11, 291, 727, 611, 51040], "temperature": 0.0, "avg_logprob": -0.15616683745652102, "compression_ratio": 1.6103896103896105, "no_speech_prob": 0.003844944993034005}, {"id": 54, "seek": 37512, "start": 388.64, "end": 396.64, "text": " configure Unicraft to get rid of this step. Then at the moment we are using full CPU features", "tokens": [51040, 22162, 1156, 299, 4469, 281, 483, 3973, 295, 341, 1823, 13, 1396, 412, 264, 1623, 321, 366, 1228, 1577, 13199, 4122, 51440], "temperature": 0.0, "avg_logprob": -0.15616683745652102, "compression_ratio": 1.6103896103896105, "no_speech_prob": 0.003844944993034005}, {"id": 55, "seek": 37512, "start": 396.64, "end": 402.44, "text": " also on the Unicraft side, it's mainly coming from for supporting native applications where", "tokens": [51440, 611, 322, 264, 1156, 299, 4469, 1252, 11, 309, 311, 8704, 1348, 490, 337, 7231, 8470, 5821, 689, 51730], "temperature": 0.0, "avg_logprob": -0.15616683745652102, "compression_ratio": 1.6103896103896105, "no_speech_prob": 0.003844944993034005}, {"id": 56, "seek": 40244, "start": 402.8, "end": 408.44, "text": " basically addressing the kernel is just a function call, so why would you restrict your CPU", "tokens": [50382, 1936, 14329, 264, 28256, 307, 445, 257, 2445, 818, 11, 370, 983, 576, 291, 7694, 428, 13199, 50664], "temperature": 0.0, "avg_logprob": -0.16844237009684246, "compression_ratio": 1.5025641025641026, "no_speech_prob": 0.000741244584787637}, {"id": 57, "seek": 40244, "start": 408.44, "end": 415.0, "text": " features? If you don't compile it with that, then you can also remove that step, but if you do that", "tokens": [50664, 4122, 30, 759, 291, 500, 380, 31413, 309, 365, 300, 11, 550, 291, 393, 611, 4159, 300, 1823, 11, 457, 498, 291, 360, 300, 50992], "temperature": 0.0, "avg_logprob": -0.16844237009684246, "compression_ratio": 1.5025641025641026, "no_speech_prob": 0.000741244584787637}, {"id": 58, "seek": 40244, "start": 415.0, "end": 423.08, "text": " in a default option, we need to save and restore that state 2 of your CPU. Then we have a TLS switch,", "tokens": [50992, 294, 257, 7576, 3614, 11, 321, 643, 281, 3155, 293, 15227, 300, 1785, 568, 295, 428, 13199, 13, 1396, 321, 362, 257, 314, 19198, 3679, 11, 51396], "temperature": 0.0, "avg_logprob": -0.16844237009684246, "compression_ratio": 1.5025641025641026, "no_speech_prob": 0.000741244584787637}, {"id": 59, "seek": 42308, "start": 423.84, "end": 430.88, "text": " which we really require because we use the TLS for our OSD composites, you know,", "tokens": [50402, 597, 321, 534, 3651, 570, 321, 764, 264, 314, 19198, 337, 527, 12731, 35, 10199, 3324, 11, 291, 458, 11, 50754], "temperature": 0.0, "avg_logprob": -0.25934677124023436, "compression_ratio": 1.5517241379310345, "no_speech_prob": 0.008096194826066494}, {"id": 60, "seek": 42308, "start": 430.88, "end": 439.79999999999995, "text": " libraryization, sorry, because we didn't want to have a central big TCP control structure where", "tokens": [50754, 6405, 2144, 11, 2597, 11, 570, 321, 994, 380, 528, 281, 362, 257, 5777, 955, 48965, 1969, 3877, 689, 51200], "temperature": 0.0, "avg_logprob": -0.25934677124023436, "compression_ratio": 1.5517241379310345, "no_speech_prob": 0.008096194826066494}, {"id": 61, "seek": 42308, "start": 439.79999999999995, "end": 444.24, "text": " we need to maintain every particular field. We want to have everything clearly decomposed,", "tokens": [51200, 321, 643, 281, 6909, 633, 1729, 2519, 13, 492, 528, 281, 362, 1203, 4448, 22867, 1744, 11, 51422], "temperature": 0.0, "avg_logprob": -0.25934677124023436, "compression_ratio": 1.5517241379310345, "no_speech_prob": 0.008096194826066494}, {"id": 62, "seek": 42308, "start": 444.24, "end": 452.32, "text": " so the TLS was the way to go for that. Yeah, and then actually we're able to call the system", "tokens": [51422, 370, 264, 314, 19198, 390, 264, 636, 281, 352, 337, 300, 13, 865, 11, 293, 550, 767, 321, 434, 1075, 281, 818, 264, 1185, 51826], "temperature": 0.0, "avg_logprob": -0.25934677124023436, "compression_ratio": 1.5517241379310345, "no_speech_prob": 0.008096194826066494}, {"id": 63, "seek": 45232, "start": 452.36, "end": 457.84, "text": " call handler. That brings you to the question, does it have to be that complicated? We need to", "tokens": [50366, 818, 41967, 13, 663, 5607, 291, 281, 264, 1168, 11, 775, 309, 362, 281, 312, 300, 6179, 30, 492, 643, 281, 50640], "temperature": 0.0, "avg_logprob": -0.21661044140251315, "compression_ratio": 1.5555555555555556, "no_speech_prob": 0.0020755247678607702}, {"id": 64, "seek": 45232, "start": 457.84, "end": 462.96, "text": " do really so many steps, isn't there something we can do a bit better with a single address space?", "tokens": [50640, 360, 534, 370, 867, 4439, 11, 1943, 380, 456, 746, 321, 393, 360, 257, 857, 1101, 365, 257, 2167, 2985, 1901, 30, 50896], "temperature": 0.0, "avg_logprob": -0.21661044140251315, "compression_ratio": 1.5555555555555556, "no_speech_prob": 0.0020755247678607702}, {"id": 65, "seek": 45232, "start": 462.96, "end": 471.8, "text": " And actually there is, and there is this mechanism called VDSO and also kernel VSS call,", "tokens": [50896, 400, 767, 456, 307, 11, 293, 456, 307, 341, 7513, 1219, 691, 11844, 46, 293, 611, 28256, 691, 21929, 818, 11, 51338], "temperature": 0.0, "avg_logprob": -0.21661044140251315, "compression_ratio": 1.5555555555555556, "no_speech_prob": 0.0020755247678607702}, {"id": 66, "seek": 45232, "start": 471.8, "end": 480.2, "text": " this is an old thing, so the VDSO basically for us is just a catalog to look up kernel symbols,", "tokens": [51338, 341, 307, 364, 1331, 551, 11, 370, 264, 691, 11844, 46, 1936, 337, 505, 307, 445, 257, 19746, 281, 574, 493, 28256, 16944, 11, 51758], "temperature": 0.0, "avg_logprob": -0.21661044140251315, "compression_ratio": 1.5555555555555556, "no_speech_prob": 0.0020755247678607702}, {"id": 67, "seek": 48020, "start": 480.4, "end": 486.12, "text": " so this is a way for us to provide the function addresses to the application that the application", "tokens": [50374, 370, 341, 307, 257, 636, 337, 505, 281, 2893, 264, 2445, 16862, 281, 264, 3861, 300, 264, 3861, 50660], "temperature": 0.0, "avg_logprob": -0.16207094890315357, "compression_ratio": 1.5818181818181818, "no_speech_prob": 0.0017497390508651733}, {"id": 68, "seek": 48020, "start": 486.12, "end": 490.52, "text": " can directly call because again, single address space, single protection domain,", "tokens": [50660, 393, 3838, 818, 570, 797, 11, 2167, 2985, 1901, 11, 2167, 6334, 9274, 11, 50880], "temperature": 0.0, "avg_logprob": -0.16207094890315357, "compression_ratio": 1.5818181818181818, "no_speech_prob": 0.0017497390508651733}, {"id": 69, "seek": 48020, "start": 490.52, "end": 496.56, "text": " we don't need to do a switch. The second thing is the kernel VSS call symbol,", "tokens": [50880, 321, 500, 380, 643, 281, 360, 257, 3679, 13, 440, 1150, 551, 307, 264, 28256, 691, 21929, 818, 5986, 11, 51182], "temperature": 0.0, "avg_logprob": -0.16207094890315357, "compression_ratio": 1.5818181818181818, "no_speech_prob": 0.0017497390508651733}, {"id": 70, "seek": 48020, "start": 496.56, "end": 503.28, "text": " which was a standardized symbol in the past, mostly for x86 when CPUs were introduced to do", "tokens": [51182, 597, 390, 257, 31677, 5986, 294, 264, 1791, 11, 5240, 337, 2031, 22193, 562, 13199, 82, 645, 7268, 281, 360, 51518], "temperature": 0.0, "avg_logprob": -0.16207094890315357, "compression_ratio": 1.5818181818181818, "no_speech_prob": 0.0017497390508651733}, {"id": 71, "seek": 50328, "start": 503.47999999999996, "end": 509.76, "text": " sysenter and syscall instead of interrupt driven system calls, that was a way for the S,", "tokens": [50374, 262, 749, 14278, 293, 262, 749, 45459, 2602, 295, 12729, 9555, 1185, 5498, 11, 300, 390, 257, 636, 337, 264, 318, 11, 50688], "temperature": 0.0, "avg_logprob": -0.291114507096537, "compression_ratio": 1.6199095022624435, "no_speech_prob": 0.002676585456356406}, {"id": 72, "seek": 50328, "start": 509.76, "end": 515.4399999999999, "text": " from the US to tell the application to enter the kernel more efficiently. For us,", "tokens": [50688, 490, 264, 2546, 281, 980, 264, 3861, 281, 3242, 264, 28256, 544, 19621, 13, 1171, 505, 11, 50972], "temperature": 0.0, "avg_logprob": -0.291114507096537, "compression_ratio": 1.6199095022624435, "no_speech_prob": 0.002676585456356406}, {"id": 73, "seek": 50328, "start": 515.4399999999999, "end": 521.1999999999999, "text": " we can use it as a function call to directly jump in the system call handler, so it's no trap,", "tokens": [50972, 321, 393, 764, 309, 382, 257, 2445, 818, 281, 3838, 3012, 294, 264, 1185, 818, 41967, 11, 370, 309, 311, 572, 11487, 11, 51260], "temperature": 0.0, "avg_logprob": -0.291114507096537, "compression_ratio": 1.6199095022624435, "no_speech_prob": 0.002676585456356406}, {"id": 74, "seek": 50328, "start": 521.1999999999999, "end": 528.24, "text": " no interrupt, no privileged domain switch, no need to save and restore of extended registers", "tokens": [51260, 572, 12729, 11, 572, 25293, 9274, 3679, 11, 572, 643, 281, 3155, 293, 15227, 295, 10913, 38351, 51612], "temperature": 0.0, "avg_logprob": -0.291114507096537, "compression_ratio": 1.6199095022624435, "no_speech_prob": 0.002676585456356406}, {"id": 75, "seek": 52824, "start": 528.5600000000001, "end": 535.6800000000001, "text": " because even that is covered by the system V calling convention. And the idea here is we just", "tokens": [50380, 570, 754, 300, 307, 5343, 538, 264, 1185, 691, 5141, 10286, 13, 400, 264, 1558, 510, 307, 321, 445, 50736], "temperature": 0.0, "avg_logprob": -0.19339586740516754, "compression_ratio": 1.6589861751152073, "no_speech_prob": 0.001824969076551497}, {"id": 76, "seek": 52824, "start": 535.6800000000001, "end": 543.36, "text": " need to patch the libc shared library of that application and then most system calls anyways", "tokens": [50736, 643, 281, 9972, 264, 22854, 66, 5507, 6405, 295, 300, 3861, 293, 550, 881, 1185, 5498, 13448, 51120], "temperature": 0.0, "avg_logprob": -0.19339586740516754, "compression_ratio": 1.6589861751152073, "no_speech_prob": 0.001824969076551497}, {"id": 77, "seek": 52824, "start": 543.36, "end": 547.44, "text": " go through the libc because they provide wrappers there and then we have that covered.", "tokens": [51120, 352, 807, 264, 22854, 66, 570, 436, 2893, 7843, 15226, 456, 293, 550, 321, 362, 300, 5343, 13, 51324], "temperature": 0.0, "avg_logprob": -0.19339586740516754, "compression_ratio": 1.6589861751152073, "no_speech_prob": 0.001824969076551497}, {"id": 78, "seek": 52824, "start": 549.84, "end": 554.32, "text": " So in comparison, no expensive syscall instruction anymore, it's just a function call,", "tokens": [51444, 407, 294, 9660, 11, 572, 5124, 262, 749, 45459, 10951, 3602, 11, 309, 311, 445, 257, 2445, 818, 11, 51668], "temperature": 0.0, "avg_logprob": -0.19339586740516754, "compression_ratio": 1.6589861751152073, "no_speech_prob": 0.001824969076551497}, {"id": 79, "seek": 55432, "start": 554.8000000000001, "end": 561.0400000000001, "text": " the stack maybe we needed depends still, no floating point registers, whatever I mean,", "tokens": [50388, 264, 8630, 1310, 321, 2978, 5946, 920, 11, 572, 12607, 935, 38351, 11, 2035, 286, 914, 11, 50700], "temperature": 0.0, "avg_logprob": -0.26487986246744794, "compression_ratio": 1.471264367816092, "no_speech_prob": 0.0009631329448893666}, {"id": 80, "seek": 55432, "start": 561.0400000000001, "end": 566.4000000000001, "text": " you don't need to save anymore and the TNS register we need to switch still.", "tokens": [50700, 291, 500, 380, 643, 281, 3155, 3602, 293, 264, 314, 42003, 7280, 321, 643, 281, 3679, 920, 13, 50968], "temperature": 0.0, "avg_logprob": -0.26487986246744794, "compression_ratio": 1.471264367816092, "no_speech_prob": 0.0009631329448893666}, {"id": 81, "seek": 55432, "start": 567.84, "end": 576.08, "text": " Okay, now we get into this fork dilemma, how I call it, this is like always the bad word for", "tokens": [51040, 1033, 11, 586, 321, 483, 666, 341, 17716, 34312, 11, 577, 286, 818, 309, 11, 341, 307, 411, 1009, 264, 1578, 1349, 337, 51452], "temperature": 0.0, "avg_logprob": -0.26487986246744794, "compression_ratio": 1.471264367816092, "no_speech_prob": 0.0009631329448893666}, {"id": 82, "seek": 57608, "start": 576.08, "end": 584.0, "text": " unicolonial people. So this is a bit of OS class here, so you probably remember fork means", "tokens": [50364, 517, 299, 38780, 831, 561, 13, 407, 341, 307, 257, 857, 295, 12731, 1508, 510, 11, 370, 291, 1391, 1604, 17716, 1355, 50760], "temperature": 0.0, "avg_logprob": -0.1264395767383361, "compression_ratio": 1.7116279069767442, "no_speech_prob": 0.004043829161673784}, {"id": 83, "seek": 57608, "start": 584.0, "end": 590.48, "text": " duplicating the address space of your application so that everything is at the same address.", "tokens": [50760, 17154, 990, 264, 2985, 1901, 295, 428, 3861, 370, 300, 1203, 307, 412, 264, 912, 2985, 13, 51084], "temperature": 0.0, "avg_logprob": -0.1264395767383361, "compression_ratio": 1.7116279069767442, "no_speech_prob": 0.004043829161673784}, {"id": 84, "seek": 57608, "start": 591.2, "end": 595.0400000000001, "text": " Problem with this is it's a second address space, I don't want a second address space,", "tokens": [51120, 11676, 365, 341, 307, 309, 311, 257, 1150, 2985, 1901, 11, 286, 500, 380, 528, 257, 1150, 2985, 1901, 11, 51312], "temperature": 0.0, "avg_logprob": -0.1264395767383361, "compression_ratio": 1.7116279069767442, "no_speech_prob": 0.004043829161673784}, {"id": 85, "seek": 57608, "start": 595.0400000000001, "end": 601.76, "text": " I want everything flat in a single address space to save time in context switches or TLB flashes,", "tokens": [51312, 286, 528, 1203, 4962, 294, 257, 2167, 2985, 1901, 281, 3155, 565, 294, 4319, 19458, 420, 40277, 33, 39665, 11, 51648], "temperature": 0.0, "avg_logprob": -0.1264395767383361, "compression_ratio": 1.7116279069767442, "no_speech_prob": 0.004043829161673784}, {"id": 86, "seek": 60176, "start": 601.76, "end": 611.52, "text": " right? So, doesn't work. What we actually would need in a unicolon environment is a fork version", "tokens": [50364, 558, 30, 407, 11, 1177, 380, 589, 13, 708, 321, 767, 576, 643, 294, 257, 517, 299, 38780, 2823, 307, 257, 17716, 3037, 50852], "temperature": 0.0, "avg_logprob": -0.13124142570057135, "compression_ratio": 1.6131687242798354, "no_speech_prob": 0.0009136702865362167}, {"id": 87, "seek": 60176, "start": 611.52, "end": 620.08, "text": " that forks the application to a different address. Unfortunately, without compiler support, that's", "tokens": [50852, 300, 337, 1694, 264, 3861, 281, 257, 819, 2985, 13, 8590, 11, 1553, 31958, 1406, 11, 300, 311, 51280], "temperature": 0.0, "avg_logprob": -0.13124142570057135, "compression_ratio": 1.6131687242798354, "no_speech_prob": 0.0009136702865362167}, {"id": 88, "seek": 60176, "start": 620.08, "end": 625.6, "text": " not that easy. You could of course copy the memory region but you need to then start patching your", "tokens": [51280, 406, 300, 1858, 13, 509, 727, 295, 1164, 5055, 264, 4675, 4458, 457, 291, 643, 281, 550, 722, 9972, 278, 428, 51556], "temperature": 0.0, "avg_logprob": -0.13124142570057135, "compression_ratio": 1.6131687242798354, "no_speech_prob": 0.0009136702865362167}, {"id": 89, "seek": 60176, "start": 625.6, "end": 631.28, "text": " application because you have absolute addresses in there like return addresses on stacks, pointer", "tokens": [51556, 3861, 570, 291, 362, 8236, 16862, 294, 456, 411, 2736, 16862, 322, 30792, 11, 23918, 51840], "temperature": 0.0, "avg_logprob": -0.13124142570057135, "compression_ratio": 1.6131687242798354, "no_speech_prob": 0.0009136702865362167}, {"id": 90, "seek": 63128, "start": 631.28, "end": 645.8399999999999, "text": " addresses, etc. So don't work that great but what we can do, sorry, for instance, let's say,", "tokens": [50364, 16862, 11, 5183, 13, 407, 500, 380, 589, 300, 869, 457, 437, 321, 393, 360, 11, 2597, 11, 337, 5197, 11, 718, 311, 584, 11, 51092], "temperature": 0.0, "avg_logprob": -0.19567857661717375, "compression_ratio": 1.546448087431694, "no_speech_prob": 0.0003863279416691512}, {"id": 91, "seek": 63128, "start": 645.8399999999999, "end": 651.52, "text": " what the question is is when you look at the applications, they're compilers position independent.", "tokens": [51092, 437, 264, 1168, 307, 307, 562, 291, 574, 412, 264, 5821, 11, 436, 434, 715, 388, 433, 2535, 6695, 13, 51376], "temperature": 0.0, "avg_logprob": -0.19567857661717375, "compression_ratio": 1.546448087431694, "no_speech_prob": 0.0003863279416691512}, {"id": 92, "seek": 63128, "start": 651.52, "end": 657.12, "text": " In principle, the result is that I can run multiple applications in a single address space.", "tokens": [51376, 682, 8665, 11, 264, 1874, 307, 300, 286, 393, 1190, 3866, 5821, 294, 257, 2167, 2985, 1901, 13, 51656], "temperature": 0.0, "avg_logprob": -0.19567857661717375, "compression_ratio": 1.546448087431694, "no_speech_prob": 0.0003863279416691512}, {"id": 93, "seek": 65712, "start": 657.12, "end": 665.52, "text": " It's just that this model with fork and exit doesn't fit, you would say, because we have this fork", "tokens": [50364, 467, 311, 445, 300, 341, 2316, 365, 17716, 293, 11043, 1177, 380, 3318, 11, 291, 576, 584, 11, 570, 321, 362, 341, 17716, 50784], "temperature": 0.0, "avg_logprob": -0.19630872386775605, "compression_ratio": 1.4603960396039604, "no_speech_prob": 0.002590558025985956}, {"id": 94, "seek": 65712, "start": 665.52, "end": 675.28, "text": " intermediate step. And luckily, there was also this was coming from, let's say, older generations", "tokens": [50784, 19376, 1823, 13, 400, 22880, 11, 456, 390, 611, 341, 390, 1348, 490, 11, 718, 311, 584, 11, 4906, 10593, 51272], "temperature": 0.0, "avg_logprob": -0.19630872386775605, "compression_ratio": 1.4603960396039604, "no_speech_prob": 0.002590558025985956}, {"id": 95, "seek": 65712, "start": 675.84, "end": 681.92, "text": " of Linux when they were trying to run Linux on targets without MMU. There's a system called V fork", "tokens": [51300, 295, 18734, 562, 436, 645, 1382, 281, 1190, 18734, 322, 12911, 1553, 34191, 52, 13, 821, 311, 257, 1185, 1219, 691, 17716, 51604], "temperature": 0.0, "avg_logprob": -0.19630872386775605, "compression_ratio": 1.4603960396039604, "no_speech_prob": 0.002590558025985956}, {"id": 96, "seek": 68192, "start": 682.4799999999999, "end": 691.5999999999999, "text": " that allows you that. It's a bit of a funky fork call because it doesn't fork actually. It just pauses", "tokens": [50392, 300, 4045, 291, 300, 13, 467, 311, 257, 857, 295, 257, 33499, 17716, 818, 570, 309, 1177, 380, 17716, 767, 13, 467, 445, 2502, 8355, 50848], "temperature": 0.0, "avg_logprob": -0.14867409070332846, "compression_ratio": 1.6741573033707866, "no_speech_prob": 0.00209450745023787}, {"id": 97, "seek": 68192, "start": 691.5999999999999, "end": 699.5999999999999, "text": " your parent and allows you to execute within the memory space of the parent, the child, for a short", "tokens": [50848, 428, 2596, 293, 4045, 291, 281, 14483, 1951, 264, 4675, 1901, 295, 264, 2596, 11, 264, 1440, 11, 337, 257, 2099, 51248], "temperature": 0.0, "avg_logprob": -0.14867409070332846, "compression_ratio": 1.6741573033707866, "no_speech_prob": 0.00209450745023787}, {"id": 98, "seek": 68192, "start": 699.5999999999999, "end": 708.24, "text": " period of time, actually until the child calls either exit or one of the execution functions to", "tokens": [51248, 2896, 295, 565, 11, 767, 1826, 264, 1440, 5498, 2139, 11043, 420, 472, 295, 264, 15058, 6828, 281, 51680], "temperature": 0.0, "avg_logprob": -0.14867409070332846, "compression_ratio": 1.6741573033707866, "no_speech_prob": 0.00209450745023787}, {"id": 99, "seek": 70824, "start": 708.24, "end": 719.44, "text": " load a new application binary. And that is basically our solution for running multiple", "tokens": [50364, 3677, 257, 777, 3861, 17434, 13, 400, 300, 307, 1936, 527, 3827, 337, 2614, 3866, 50924], "temperature": 0.0, "avg_logprob": -0.16164234036304911, "compression_ratio": 1.5738636363636365, "no_speech_prob": 0.001071370206773281}, {"id": 100, "seek": 70824, "start": 719.44, "end": 725.6, "text": " applications or like a shell or something where the shell forks, you load a position independent", "tokens": [50924, 5821, 420, 411, 257, 8720, 420, 746, 689, 264, 8720, 337, 1694, 11, 291, 3677, 257, 2535, 6695, 51232], "temperature": 0.0, "avg_logprob": -0.16164234036304911, "compression_ratio": 1.5738636363636365, "no_speech_prob": 0.001071370206773281}, {"id": 101, "seek": 70824, "start": 725.6, "end": 731.28, "text": " binary anyway in the next step, then you have it in a different address area and you execute.", "tokens": [51232, 17434, 4033, 294, 264, 958, 1823, 11, 550, 291, 362, 309, 294, 257, 819, 2985, 1859, 293, 291, 14483, 13, 51516], "temperature": 0.0, "avg_logprob": -0.16164234036304911, "compression_ratio": 1.5738636363636365, "no_speech_prob": 0.001071370206773281}, {"id": 102, "seek": 73128, "start": 732.24, "end": 739.1999999999999, "text": " What we want to try out here is if that mechanism works great for, you know, if you could just", "tokens": [50412, 708, 321, 528, 281, 853, 484, 510, 307, 498, 300, 7513, 1985, 869, 337, 11, 291, 458, 11, 498, 291, 727, 445, 50760], "temperature": 0.0, "avg_logprob": -0.19733495490495548, "compression_ratio": 1.7077625570776256, "no_speech_prob": 0.0022025369107723236}, {"id": 103, "seek": 73128, "start": 739.8399999999999, "end": 745.52, "text": " replace the fork system call number internally with a V fork and see for how many applications", "tokens": [50792, 7406, 264, 17716, 1185, 818, 1230, 19501, 365, 257, 691, 17716, 293, 536, 337, 577, 867, 5821, 51076], "temperature": 0.0, "avg_logprob": -0.19733495490495548, "compression_ratio": 1.7077625570776256, "no_speech_prob": 0.0022025369107723236}, {"id": 104, "seek": 73128, "start": 745.52, "end": 751.6, "text": " that works great because they were doing fork exit before and for how many that does work.", "tokens": [51076, 300, 1985, 869, 570, 436, 645, 884, 17716, 11043, 949, 293, 337, 577, 867, 300, 775, 589, 13, 51380], "temperature": 0.0, "avg_logprob": -0.19733495490495548, "compression_ratio": 1.7077625570776256, "no_speech_prob": 0.0022025369107723236}, {"id": 105, "seek": 73128, "start": 751.6, "end": 760.16, "text": " But obviously, won't work is for applications that just use fork to open up worker processes.", "tokens": [51380, 583, 2745, 11, 1582, 380, 589, 307, 337, 5821, 300, 445, 764, 17716, 281, 1269, 493, 11346, 7555, 13, 51808], "temperature": 0.0, "avg_logprob": -0.19733495490495548, "compression_ratio": 1.7077625570776256, "no_speech_prob": 0.0022025369107723236}, {"id": 106, "seek": 76016, "start": 761.12, "end": 764.48, "text": " But just for this fork exit model that works.", "tokens": [50412, 583, 445, 337, 341, 17716, 11043, 2316, 300, 1985, 13, 50580], "temperature": 0.0, "avg_logprob": -0.23334920129110648, "compression_ratio": 1.5677083333333333, "no_speech_prob": 0.006929963827133179}, {"id": 107, "seek": 76016, "start": 767.36, "end": 775.1999999999999, "text": " Okay, and then the last point is a bit, I really rushed through.", "tokens": [50724, 1033, 11, 293, 550, 264, 1036, 935, 307, 257, 857, 11, 286, 534, 24421, 807, 13, 51116], "temperature": 0.0, "avg_logprob": -0.23334920129110648, "compression_ratio": 1.5677083333333333, "no_speech_prob": 0.006929963827133179}, {"id": 108, "seek": 76016, "start": 776.88, "end": 781.12, "text": " I was when I was preparing, I was checking, okay, I can't say this, there's no time, no time.", "tokens": [51200, 286, 390, 562, 286, 390, 10075, 11, 286, 390, 8568, 11, 1392, 11, 286, 393, 380, 584, 341, 11, 456, 311, 572, 565, 11, 572, 565, 13, 51412], "temperature": 0.0, "avg_logprob": -0.23334920129110648, "compression_ratio": 1.5677083333333333, "no_speech_prob": 0.006929963827133179}, {"id": 109, "seek": 76016, "start": 783.6, "end": 788.88, "text": " So here I wanted to give you a bit of an overview of what we did the last year when we looked at", "tokens": [51536, 407, 510, 286, 1415, 281, 976, 291, 257, 857, 295, 364, 12492, 295, 437, 321, 630, 264, 1036, 1064, 562, 321, 2956, 412, 51800], "temperature": 0.0, "avg_logprob": -0.23334920129110648, "compression_ratio": 1.5677083333333333, "no_speech_prob": 0.006929963827133179}, {"id": 110, "seek": 78888, "start": 788.88, "end": 795.52, "text": " different applications and we're always in front of that question. We need to have Linux", "tokens": [50364, 819, 5821, 293, 321, 434, 1009, 294, 1868, 295, 300, 1168, 13, 492, 643, 281, 362, 18734, 50696], "temperature": 0.0, "avg_logprob": -0.14339087226174094, "compression_ratio": 1.5375, "no_speech_prob": 0.0020662068855017424}, {"id": 111, "seek": 78888, "start": 795.52, "end": 801.28, "text": " compatibility, but at the same time, we don't want to re-implement Linux. And there's some", "tokens": [50696, 34237, 11, 457, 412, 264, 912, 565, 11, 321, 500, 380, 528, 281, 319, 12, 332, 43704, 18734, 13, 400, 456, 311, 512, 50984], "temperature": 0.0, "avg_logprob": -0.14339087226174094, "compression_ratio": 1.5375, "no_speech_prob": 0.0020662068855017424}, {"id": 112, "seek": 78888, "start": 801.28, "end": 809.04, "text": " aspects where it's really tricky. For instance, the first one is a really interesting example. It's", "tokens": [50984, 7270, 689, 309, 311, 534, 12414, 13, 1171, 5197, 11, 264, 700, 472, 307, 257, 534, 1880, 1365, 13, 467, 311, 51372], "temperature": 0.0, "avg_logprob": -0.14339087226174094, "compression_ratio": 1.5375, "no_speech_prob": 0.0020662068855017424}, {"id": 113, "seek": 78888, "start": 809.04, "end": 815.76, "text": " about querying from the kernel side network interfaces or setting up routing tables, etc.", "tokens": [51372, 466, 7083, 1840, 490, 264, 28256, 1252, 3209, 28416, 420, 3287, 493, 32722, 8020, 11, 5183, 13, 51708], "temperature": 0.0, "avg_logprob": -0.14339087226174094, "compression_ratio": 1.5375, "no_speech_prob": 0.0020662068855017424}, {"id": 114, "seek": 81576, "start": 815.76, "end": 823.68, "text": " So get if address and call, which normally needs a complete subsystem of sockets to be", "tokens": [50364, 407, 483, 498, 2985, 293, 818, 11, 597, 5646, 2203, 257, 3566, 2090, 9321, 295, 370, 11984, 281, 312, 50760], "temperature": 0.0, "avg_logprob": -0.20342239803738063, "compression_ratio": 1.6375545851528384, "no_speech_prob": 0.0006823609001003206}, {"id": 115, "seek": 81576, "start": 823.68, "end": 829.52, "text": " implemented. And then on top of a known protocol called netlink, just to do this user space kernel", "tokens": [50760, 12270, 13, 400, 550, 322, 1192, 295, 257, 2570, 10336, 1219, 2533, 22473, 11, 445, 281, 360, 341, 4195, 1901, 28256, 51052], "temperature": 0.0, "avg_logprob": -0.20342239803738063, "compression_ratio": 1.6375545851528384, "no_speech_prob": 0.0006823609001003206}, {"id": 116, "seek": 81576, "start": 829.52, "end": 835.92, "text": " interaction for gathering that information. An alternative here could be, of course, we implemented", "tokens": [51052, 9285, 337, 13519, 300, 1589, 13, 1107, 8535, 510, 727, 312, 11, 295, 1164, 11, 321, 12270, 51372], "temperature": 0.0, "avg_logprob": -0.20342239803738063, "compression_ratio": 1.6375545851528384, "no_speech_prob": 0.0006823609001003206}, {"id": 117, "seek": 81576, "start": 835.92, "end": 841.68, "text": " that, but an alternative here could be also to make use of the VDSO again, patch the libc", "tokens": [51372, 300, 11, 457, 364, 8535, 510, 727, 312, 611, 281, 652, 764, 295, 264, 691, 11844, 46, 797, 11, 9972, 264, 22854, 66, 51660], "temperature": 0.0, "avg_logprob": -0.20342239803738063, "compression_ratio": 1.6375545851528384, "no_speech_prob": 0.0006823609001003206}, {"id": 118, "seek": 84168, "start": 841.68, "end": 846.56, "text": " and do more direct calls for just querying the IP address from the kernel that's currently set.", "tokens": [50364, 293, 360, 544, 2047, 5498, 337, 445, 7083, 1840, 264, 8671, 2985, 490, 264, 28256, 300, 311, 4362, 992, 13, 50608], "temperature": 0.0, "avg_logprob": -0.11960266297122082, "compression_ratio": 1.6051502145922747, "no_speech_prob": 0.00047153577907010913}, {"id": 119, "seek": 84168, "start": 849.52, "end": 857.8399999999999, "text": " Another interesting point is applications that are so mean that implicitly rely on a specific", "tokens": [50756, 3996, 1880, 935, 307, 5821, 300, 366, 370, 914, 300, 26947, 356, 10687, 322, 257, 2685, 51172], "temperature": 0.0, "avg_logprob": -0.11960266297122082, "compression_ratio": 1.6051502145922747, "no_speech_prob": 0.00047153577907010913}, {"id": 120, "seek": 84168, "start": 857.8399999999999, "end": 864.7199999999999, "text": " behavior on Linux. And really, a funny example is primitive scheduling that you come across", "tokens": [51172, 5223, 322, 18734, 13, 400, 534, 11, 257, 4074, 1365, 307, 28540, 29055, 300, 291, 808, 2108, 51516], "temperature": 0.0, "avg_logprob": -0.11960266297122082, "compression_ratio": 1.6051502145922747, "no_speech_prob": 0.00047153577907010913}, {"id": 121, "seek": 84168, "start": 865.5999999999999, "end": 870.56, "text": " from time to time. So far we have cooperative scheduling in Unicraft because that's a really", "tokens": [51560, 490, 565, 281, 565, 13, 407, 1400, 321, 362, 31772, 29055, 294, 1156, 299, 4469, 570, 300, 311, 257, 534, 51808], "temperature": 0.0, "avg_logprob": -0.11960266297122082, "compression_ratio": 1.6051502145922747, "no_speech_prob": 0.00047153577907010913}, {"id": 122, "seek": 87056, "start": 870.56, "end": 880.64, "text": " efficient for us scheduling way to do things. But then you, I mean, you put something like", "tokens": [50364, 7148, 337, 505, 29055, 636, 281, 360, 721, 13, 583, 550, 291, 11, 286, 914, 11, 291, 829, 746, 411, 50868], "temperature": 0.0, "avg_logprob": -0.18869704911203095, "compression_ratio": 1.4473684210526316, "no_speech_prob": 0.0010671182535588741}, {"id": 123, "seek": 87056, "start": 880.64, "end": 889.5999999999999, "text": " Frank in PHP or MySQL and they use busy waiting loops to wait for other threads to wake up.", "tokens": [50868, 6823, 294, 47298, 420, 1222, 39934, 293, 436, 764, 5856, 3806, 16121, 281, 1699, 337, 661, 19314, 281, 6634, 493, 13, 51316], "temperature": 0.0, "avg_logprob": -0.18869704911203095, "compression_ratio": 1.4473684210526316, "no_speech_prob": 0.0010671182535588741}, {"id": 124, "seek": 87056, "start": 890.3199999999999, "end": 895.28, "text": " With a cooperative scheduler, you can imagine what happens. Basically nothing because you're", "tokens": [51352, 2022, 257, 31772, 12000, 260, 11, 291, 393, 3811, 437, 2314, 13, 8537, 1825, 570, 291, 434, 51600], "temperature": 0.0, "avg_logprob": -0.18869704911203095, "compression_ratio": 1.4473684210526316, "no_speech_prob": 0.0010671182535588741}, {"id": 125, "seek": 89528, "start": 895.28, "end": 899.8399999999999, "text": " constantly busy waiting but never give another threat to chance to pop up.", "tokens": [50364, 6460, 5856, 3806, 457, 1128, 976, 1071, 4734, 281, 2931, 281, 1665, 493, 13, 50592], "temperature": 0.0, "avg_logprob": -0.18969550946863686, "compression_ratio": 1.6280193236714975, "no_speech_prob": 0.002260737819597125}, {"id": 126, "seek": 89528, "start": 902.0799999999999, "end": 908.0, "text": " Then there is this whole topic about which system calls you need to support, which ones you can", "tokens": [50704, 1396, 456, 307, 341, 1379, 4829, 466, 597, 1185, 5498, 291, 643, 281, 1406, 11, 597, 2306, 291, 393, 51000], "temperature": 0.0, "avg_logprob": -0.18969550946863686, "compression_ratio": 1.6280193236714975, "no_speech_prob": 0.002260737819597125}, {"id": 127, "seek": 89528, "start": 908.0, "end": 914.24, "text": " stop, which one need to be completely implemented. It's actually true that you can stop a lot,", "tokens": [51000, 1590, 11, 597, 472, 643, 281, 312, 2584, 12270, 13, 467, 311, 767, 2074, 300, 291, 393, 1590, 257, 688, 11, 51312], "temperature": 0.0, "avg_logprob": -0.18969550946863686, "compression_ratio": 1.6280193236714975, "no_speech_prob": 0.002260737819597125}, {"id": 128, "seek": 89528, "start": 914.24, "end": 922.16, "text": " you don't need all of them. I would here refer you to a nice paper from", "tokens": [51312, 291, 500, 380, 643, 439, 295, 552, 13, 286, 576, 510, 2864, 291, 281, 257, 1481, 3035, 490, 51708], "temperature": 0.0, "avg_logprob": -0.18969550946863686, "compression_ratio": 1.6280193236714975, "no_speech_prob": 0.002260737819597125}, {"id": 129, "seek": 92216, "start": 922.3199999999999, "end": 931.6, "text": " Esplos. Actually last year for STEM, the authors were giving a presentation here too about how to", "tokens": [50372, 2313, 564, 329, 13, 5135, 1036, 1064, 337, 25043, 11, 264, 16552, 645, 2902, 257, 5860, 510, 886, 466, 577, 281, 50836], "temperature": 0.0, "avg_logprob": -0.18697825840541293, "compression_ratio": 1.7397769516728625, "no_speech_prob": 0.0009889999637380242}, {"id": 130, "seek": 92216, "start": 931.6, "end": 935.68, "text": " figure out which system calls you need to implement. Of course, there's also sometimes the application", "tokens": [50836, 2573, 484, 597, 1185, 5498, 291, 643, 281, 4445, 13, 2720, 1164, 11, 456, 311, 611, 2171, 264, 3861, 51040], "temperature": 0.0, "avg_logprob": -0.18697825840541293, "compression_ratio": 1.7397769516728625, "no_speech_prob": 0.0009889999637380242}, {"id": 131, "seek": 92216, "start": 935.68, "end": 941.12, "text": " dependent, but there is a, you don't need to implement all of the Linux system calls to have", "tokens": [51040, 12334, 11, 457, 456, 307, 257, 11, 291, 500, 380, 643, 281, 4445, 439, 295, 264, 18734, 1185, 5498, 281, 362, 51312], "temperature": 0.0, "avg_logprob": -0.18697825840541293, "compression_ratio": 1.7397769516728625, "no_speech_prob": 0.0009889999637380242}, {"id": 132, "seek": 92216, "start": 941.12, "end": 946.64, "text": " Linux compatibility. There are really a lot of system calls that are really specific to some", "tokens": [51312, 18734, 34237, 13, 821, 366, 534, 257, 688, 295, 1185, 5498, 300, 366, 534, 2685, 281, 512, 51588], "temperature": 0.0, "avg_logprob": -0.18697825840541293, "compression_ratio": 1.7397769516728625, "no_speech_prob": 0.0009889999637380242}, {"id": 133, "seek": 92216, "start": 946.64, "end": 950.3199999999999, "text": " cases or setting up seed groups or whatever, which normal applications don't use.", "tokens": [51588, 3331, 420, 3287, 493, 8871, 3935, 420, 2035, 11, 597, 2710, 5821, 500, 380, 764, 13, 51772], "temperature": 0.0, "avg_logprob": -0.18697825840541293, "compression_ratio": 1.7397769516728625, "no_speech_prob": 0.0009889999637380242}, {"id": 134, "seek": 95216, "start": 952.64, "end": 956.7199999999999, "text": " And then of course the whole topic about file system hierarchy standard,", "tokens": [50388, 400, 550, 295, 1164, 264, 1379, 4829, 466, 3991, 1185, 22333, 3832, 11, 50592], "temperature": 0.0, "avg_logprob": -0.18824524538857595, "compression_ratio": 1.4642857142857142, "no_speech_prob": 0.00026521357358433306}, {"id": 135, "seek": 95216, "start": 958.9599999999999, "end": 966.16, "text": " where of course application expect you have something under PROC or under ETC or somewhere.", "tokens": [50704, 689, 295, 1164, 3861, 2066, 291, 362, 746, 833, 15008, 34, 420, 833, 462, 18238, 420, 4079, 13, 51064], "temperature": 0.0, "avg_logprob": -0.18824524538857595, "compression_ratio": 1.4642857142857142, "no_speech_prob": 0.00026521357358433306}, {"id": 136, "seek": 95216, "start": 968.0, "end": 977.8399999999999, "text": " So far, we were able to go around that by providing a meaningful filled text file", "tokens": [51156, 407, 1400, 11, 321, 645, 1075, 281, 352, 926, 300, 538, 6530, 257, 10995, 6412, 2487, 3991, 51648], "temperature": 0.0, "avg_logprob": -0.18824524538857595, "compression_ratio": 1.4642857142857142, "no_speech_prob": 0.00026521357358433306}, {"id": 137, "seek": 97784, "start": 978.8000000000001, "end": 982.72, "text": " for the application, especially the PROC file system without implementing that yet.", "tokens": [50412, 337, 264, 3861, 11, 2318, 264, 15008, 34, 3991, 1185, 1553, 18114, 300, 1939, 13, 50608], "temperature": 0.0, "avg_logprob": -0.2725345711959036, "compression_ratio": 1.3979591836734695, "no_speech_prob": 0.0012981441104784608}, {"id": 138, "seek": 97784, "start": 983.52, "end": 992.72, "text": " And that worked for NGINX, Node.js, Redis, HA Proxy and a lot of other number of applications.", "tokens": [50648, 400, 300, 2732, 337, 426, 38, 1464, 55, 11, 38640, 13, 25530, 11, 4477, 271, 11, 11979, 1705, 12876, 293, 257, 688, 295, 661, 1230, 295, 5821, 13, 51108], "temperature": 0.0, "avg_logprob": -0.2725345711959036, "compression_ratio": 1.3979591836734695, "no_speech_prob": 0.0012981441104784608}, {"id": 139, "seek": 97784, "start": 995.6, "end": 1002.64, "text": " Okay, so now we're so fast through this, I'm sorry. So we have time for some questions. I guess", "tokens": [51252, 1033, 11, 370, 586, 321, 434, 370, 2370, 807, 341, 11, 286, 478, 2597, 13, 407, 321, 362, 565, 337, 512, 1651, 13, 286, 2041, 51604], "temperature": 0.0, "avg_logprob": -0.2725345711959036, "compression_ratio": 1.3979591836734695, "no_speech_prob": 0.0012981441104784608}, {"id": 140, "seek": 100264, "start": 1002.88, "end": 1010.16, "text": " there's some stuff for more clarity. We are an open source project. These are the resources where", "tokens": [50376, 456, 311, 512, 1507, 337, 544, 16992, 13, 492, 366, 364, 1269, 4009, 1716, 13, 1981, 366, 264, 3593, 689, 50740], "temperature": 0.0, "avg_logprob": -0.16539698761778993, "compression_ratio": 1.489795918367347, "no_speech_prob": 0.0017103847349062562}, {"id": 141, "seek": 100264, "start": 1010.16, "end": 1020.08, "text": " you can find us. And you can also, I mean, see that I put here KraftCloud, that logo. This is", "tokens": [50740, 291, 393, 915, 505, 13, 400, 291, 393, 611, 11, 286, 914, 11, 536, 300, 286, 829, 510, 31313, 32787, 11, 300, 9699, 13, 639, 307, 51236], "temperature": 0.0, "avg_logprob": -0.16539698761778993, "compression_ratio": 1.489795918367347, "no_speech_prob": 0.0017103847349062562}, {"id": 142, "seek": 100264, "start": 1020.08, "end": 1030.0, "text": " what we currently try to build with our company, which is a cloud that uses the beauty of unicronals", "tokens": [51236, 437, 321, 4362, 853, 281, 1322, 365, 527, 2237, 11, 597, 307, 257, 4588, 300, 4960, 264, 6643, 295, 517, 299, 2044, 1124, 51732], "temperature": 0.0, "avg_logprob": -0.16539698761778993, "compression_ratio": 1.489795918367347, "no_speech_prob": 0.0017103847349062562}, {"id": 143, "seek": 103000, "start": 1030.0, "end": 1037.52, "text": " for really fast bootups, high resource efficiency for serverless architectures,", "tokens": [50364, 337, 534, 2370, 11450, 7528, 11, 1090, 7684, 10493, 337, 7154, 1832, 6331, 1303, 11, 50740], "temperature": 0.0, "avg_logprob": -0.16999253055505587, "compression_ratio": 1.5029585798816567, "no_speech_prob": 0.003757677972316742}, {"id": 144, "seek": 103000, "start": 1037.52, "end": 1051.6, "text": " microservices, functional services, etc. Unfortunately, just two minutes for the", "tokens": [50740, 15547, 47480, 11, 11745, 3328, 11, 5183, 13, 8590, 11, 445, 732, 2077, 337, 264, 51444], "temperature": 0.0, "avg_logprob": -0.16999253055505587, "compression_ratio": 1.5029585798816567, "no_speech_prob": 0.003757677972316742}, {"id": 145, "seek": 103000, "start": 1051.6, "end": 1058.32, "text": " questions, but still, are there any questions? So when you run everything in a single address", "tokens": [51444, 1651, 11, 457, 920, 11, 366, 456, 604, 1651, 30, 407, 562, 291, 1190, 1203, 294, 257, 2167, 2985, 51780], "temperature": 0.0, "avg_logprob": -0.16999253055505587, "compression_ratio": 1.5029585798816567, "no_speech_prob": 0.003757677972316742}, {"id": 146, "seek": 105832, "start": 1058.32, "end": 1063.76, "text": " base, do you actually need to enable paging at all? So yeah, with the CPU, actually we need to", "tokens": [50364, 3096, 11, 360, 291, 767, 643, 281, 9528, 280, 3568, 412, 439, 30, 407, 1338, 11, 365, 264, 13199, 11, 767, 321, 643, 281, 50636], "temperature": 0.0, "avg_logprob": -0.14881835067481325, "compression_ratio": 1.7677902621722847, "no_speech_prob": 0.007768689189106226}, {"id": 147, "seek": 105832, "start": 1063.76, "end": 1069.52, "text": " enable paging, but it allows you to build a page table at compile time. And then it's just", "tokens": [50636, 9528, 280, 3568, 11, 457, 309, 4045, 291, 281, 1322, 257, 3028, 3199, 412, 31413, 565, 13, 400, 550, 309, 311, 445, 50924], "temperature": 0.0, "avg_logprob": -0.14881835067481325, "compression_ratio": 1.7677902621722847, "no_speech_prob": 0.007768689189106226}, {"id": 148, "seek": 105832, "start": 1069.52, "end": 1074.3999999999999, "text": " switching that page table on during boot. What additionally happens with Linux applications", "tokens": [50924, 16493, 300, 3028, 3199, 322, 1830, 11450, 13, 708, 43181, 2314, 365, 18734, 5821, 51168], "temperature": 0.0, "avg_logprob": -0.14881835067481325, "compression_ratio": 1.7677902621722847, "no_speech_prob": 0.007768689189106226}, {"id": 149, "seek": 105832, "start": 1074.3999999999999, "end": 1079.84, "text": " that are sometimes doing MAP calls and mapping here, something or file there, of course, if you", "tokens": [51168, 300, 366, 2171, 884, 376, 4715, 5498, 293, 18350, 510, 11, 746, 420, 3991, 456, 11, 295, 1164, 11, 498, 291, 51440], "temperature": 0.0, "avg_logprob": -0.14881835067481325, "compression_ratio": 1.7677902621722847, "no_speech_prob": 0.007768689189106226}, {"id": 150, "seek": 105832, "start": 1079.84, "end": 1084.24, "text": " enable that support, then you need some kind of dynamic page table handling. But if you don't need", "tokens": [51440, 9528, 300, 1406, 11, 550, 291, 643, 512, 733, 295, 8546, 3028, 3199, 13175, 13, 583, 498, 291, 500, 380, 643, 51660], "temperature": 0.0, "avg_logprob": -0.14881835067481325, "compression_ratio": 1.7677902621722847, "no_speech_prob": 0.007768689189106226}, {"id": 151, "seek": 108424, "start": 1084.24, "end": 1089.2, "text": " that, you have the opportunity to have a compile time page table. So we don't have the time to", "tokens": [50364, 300, 11, 291, 362, 264, 2650, 281, 362, 257, 31413, 565, 3028, 3199, 13, 407, 321, 500, 380, 362, 264, 565, 281, 50612], "temperature": 0.0, "avg_logprob": -0.18857776141557536, "compression_ratio": 1.7857142857142858, "no_speech_prob": 0.03154945746064186}, {"id": 152, "seek": 108424, "start": 1089.2, "end": 1094.24, "text": " discuss it, but I was wondering if you have paging, wouldn't you be able to use copy and write to", "tokens": [50612, 2248, 309, 11, 457, 286, 390, 6359, 498, 291, 362, 280, 3568, 11, 2759, 380, 291, 312, 1075, 281, 764, 5055, 293, 2464, 281, 50864], "temperature": 0.0, "avg_logprob": -0.18857776141557536, "compression_ratio": 1.7857142857142858, "no_speech_prob": 0.03154945746064186}, {"id": 153, "seek": 108424, "start": 1094.8, "end": 1100.16, "text": " the popular one? Maybe something to think about. Of course, we do also copy and write where you", "tokens": [50892, 264, 3743, 472, 30, 2704, 746, 281, 519, 466, 13, 2720, 1164, 11, 321, 360, 611, 5055, 293, 2464, 689, 291, 51160], "temperature": 0.0, "avg_logprob": -0.18857776141557536, "compression_ratio": 1.7857142857142858, "no_speech_prob": 0.03154945746064186}, {"id": 154, "seek": 108424, "start": 1100.16, "end": 1104.72, "text": " need it. The thing is, what we still want is a single address space. So that page table is,", "tokens": [51160, 643, 309, 13, 440, 551, 307, 11, 437, 321, 920, 528, 307, 257, 2167, 2985, 1901, 13, 407, 300, 3028, 3199, 307, 11, 51388], "temperature": 0.0, "avg_logprob": -0.18857776141557536, "compression_ratio": 1.7857142857142858, "no_speech_prob": 0.03154945746064186}, {"id": 155, "seek": 108424, "start": 1105.76, "end": 1109.76, "text": " basically, there's just one page table, another page table per application. We don't have this", "tokens": [51440, 1936, 11, 456, 311, 445, 472, 3028, 3199, 11, 1071, 3028, 3199, 680, 3861, 13, 492, 500, 380, 362, 341, 51640], "temperature": 0.0, "avg_logprob": -0.18857776141557536, "compression_ratio": 1.7857142857142858, "no_speech_prob": 0.03154945746064186}, {"id": 156, "seek": 110976, "start": 1109.76, "end": 1116.64, "text": " page table switches, no TLB flushes. So this is where we gain actually a lot of performance", "tokens": [50364, 3028, 3199, 19458, 11, 572, 40277, 33, 19568, 279, 13, 407, 341, 307, 689, 321, 6052, 767, 257, 688, 295, 3389, 50708], "temperature": 0.0, "avg_logprob": -0.20020346805967135, "compression_ratio": 1.5321888412017168, "no_speech_prob": 0.0047883144579827785}, {"id": 157, "seek": 110976, "start": 1116.64, "end": 1123.44, "text": " also from. And since we say we are a single application, we run only one thing, why do I need", "tokens": [50708, 611, 490, 13, 400, 1670, 321, 584, 321, 366, 257, 2167, 3861, 11, 321, 1190, 787, 472, 551, 11, 983, 360, 286, 643, 51048], "temperature": 0.0, "avg_logprob": -0.20020346805967135, "compression_ratio": 1.5321888412017168, "no_speech_prob": 0.0047883144579827785}, {"id": 158, "seek": 110976, "start": 1124.08, "end": 1130.0, "text": " to handle? Everything that runs in the unique kernel is defined to be trusted,", "tokens": [51080, 281, 4813, 30, 5471, 300, 6676, 294, 264, 3845, 28256, 307, 7642, 281, 312, 16034, 11, 51376], "temperature": 0.0, "avg_logprob": -0.20020346805967135, "compression_ratio": 1.5321888412017168, "no_speech_prob": 0.0047883144579827785}, {"id": 159, "seek": 110976, "start": 1130.8, "end": 1136.72, "text": " and you have then the hard isolation boundaries outside from the hard-provise environment to", "tokens": [51416, 293, 291, 362, 550, 264, 1152, 16001, 13180, 2380, 490, 264, 1152, 12, 49911, 908, 2823, 281, 51712], "temperature": 0.0, "avg_logprob": -0.20020346805967135, "compression_ratio": 1.5321888412017168, "no_speech_prob": 0.0047883144579827785}, {"id": 160, "seek": 113672, "start": 1136.8, "end": 1141.28, "text": " protect anything that is going bad or an overtaken unique conference.", "tokens": [50368, 2371, 1340, 300, 307, 516, 1578, 420, 364, 17038, 9846, 3845, 7586, 13, 50592], "temperature": 0.0, "avg_logprob": -0.2468499808475889, "compression_ratio": 1.7102803738317758, "no_speech_prob": 0.03513393551111221}, {"id": 161, "seek": 113672, "start": 1145.76, "end": 1149.76, "text": " If you write, protect the data pages of a process that does fork, you can actually", "tokens": [50816, 759, 291, 2464, 11, 2371, 264, 1412, 7183, 295, 257, 1399, 300, 775, 17716, 11, 291, 393, 767, 51016], "temperature": 0.0, "avg_logprob": -0.2468499808475889, "compression_ratio": 1.7102803738317758, "no_speech_prob": 0.03513393551111221}, {"id": 162, "seek": 113672, "start": 1149.76, "end": 1154.8, "text": " detect processes that don't use default exec that do actual fork to share memory,", "tokens": [51016, 5531, 7555, 300, 500, 380, 764, 7576, 4454, 300, 360, 3539, 17716, 281, 2073, 4675, 11, 51268], "temperature": 0.0, "avg_logprob": -0.2468499808475889, "compression_ratio": 1.7102803738317758, "no_speech_prob": 0.03513393551111221}, {"id": 163, "seek": 113672, "start": 1154.8, "end": 1156.08, "text": " and you would be able to detect that.", "tokens": [51268, 293, 291, 576, 312, 1075, 281, 5531, 300, 13, 51332], "temperature": 0.0, "avg_logprob": -0.2468499808475889, "compression_ratio": 1.7102803738317758, "no_speech_prob": 0.03513393551111221}, {"id": 164, "seek": 113672, "start": 1159.6000000000001, "end": 1164.0, "text": " I would just add to that because you would have multiple other spaces just for a short while,", "tokens": [51508, 286, 576, 445, 909, 281, 300, 570, 291, 576, 362, 3866, 661, 7673, 445, 337, 257, 2099, 1339, 11, 51728], "temperature": 0.0, "avg_logprob": -0.2468499808475889, "compression_ratio": 1.7102803738317758, "no_speech_prob": 0.03513393551111221}, {"id": 165, "seek": 116400, "start": 1164.24, "end": 1165.92, "text": " so it's not really a performance issue, right?", "tokens": [50376, 370, 309, 311, 406, 534, 257, 3389, 2734, 11, 558, 30, 50460], "temperature": 0.0, "avg_logprob": -0.27749706904093424, "compression_ratio": 1.717557251908397, "no_speech_prob": 0.013519239611923695}, {"id": 166, "seek": 116400, "start": 1166.4, "end": 1172.96, "text": " Yeah, it's like two kinds, implementation effort and... But yeah, I see your point.", "tokens": [50484, 865, 11, 309, 311, 411, 732, 3685, 11, 11420, 4630, 293, 485, 583, 1338, 11, 286, 536, 428, 935, 13, 50812], "temperature": 0.0, "avg_logprob": -0.27749706904093424, "compression_ratio": 1.717557251908397, "no_speech_prob": 0.013519239611923695}, {"id": 167, "seek": 116400, "start": 1172.96, "end": 1178.64, "text": " Also for non-position independent applications, I mean, if you have a choice not supporting", "tokens": [50812, 2743, 337, 2107, 12, 38078, 6695, 5821, 11, 286, 914, 11, 498, 291, 362, 257, 3922, 406, 7231, 51096], "temperature": 0.0, "avg_logprob": -0.27749706904093424, "compression_ratio": 1.717557251908397, "no_speech_prob": 0.013519239611923695}, {"id": 168, "seek": 116400, "start": 1178.64, "end": 1183.2, "text": " multiple of them and having multiple address spaces, I mean, why not go for multiple address", "tokens": [51096, 3866, 295, 552, 293, 1419, 3866, 2985, 7673, 11, 286, 914, 11, 983, 406, 352, 337, 3866, 2985, 51324], "temperature": 0.0, "avg_logprob": -0.27749706904093424, "compression_ratio": 1.717557251908397, "no_speech_prob": 0.013519239611923695}, {"id": 169, "seek": 116400, "start": 1183.2, "end": 1186.56, "text": " spaces, it does not invalidate the unique kernel idea.", "tokens": [51324, 7673, 11, 309, 775, 406, 34702, 473, 264, 3845, 28256, 1558, 13, 51492], "temperature": 0.0, "avg_logprob": -0.27749706904093424, "compression_ratio": 1.717557251908397, "no_speech_prob": 0.013519239611923695}, {"id": 170, "seek": 116400, "start": 1186.56, "end": 1191.36, "text": " No, no, no, it doesn't. It doesn't. It just comes with some cost, right?", "tokens": [51492, 883, 11, 572, 11, 572, 11, 309, 1177, 380, 13, 467, 1177, 380, 13, 467, 445, 1487, 365, 512, 2063, 11, 558, 30, 51732], "temperature": 0.0, "avg_logprob": -0.27749706904093424, "compression_ratio": 1.717557251908397, "no_speech_prob": 0.013519239611923695}, {"id": 171, "seek": 116400, "start": 1191.36, "end": 1192.0, "text": " Right.", "tokens": [51732, 1779, 13, 51764], "temperature": 0.0, "avg_logprob": -0.27749706904093424, "compression_ratio": 1.717557251908397, "no_speech_prob": 0.013519239611923695}, {"id": 172, "seek": 119200, "start": 1192.0, "end": 1196.0, "text": " Okay, thank you very much. We have to switch to another talk. Thanks again.", "tokens": [50384, 1033, 11, 1309, 291, 588, 709, 13, 492, 362, 281, 3679, 281, 1071, 751, 13, 2561, 797, 13, 50564], "temperature": 0.0, "avg_logprob": -0.3349244026910691, "compression_ratio": 0.9868421052631579, "no_speech_prob": 0.01743052899837494}], "language": "en"}