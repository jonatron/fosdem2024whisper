{"text": " Good morning everyone. Thank you for joining this talk. My name is Niels de Vos. I am presenting instead of Ria. Ria was supposed to travel here but got cancelled. So she gave me her slides. I am one of the organizers of the deaf room together with Jan instead of having an empty shot. I am presenting her talk. Hopefully I know enough about the topic to present it well enough. If you have questions don't hesitate to interrupt. I don't mind answering questions immediately. So Ria and I are actually colleagues. We both work on mostly CFCSI but anything that touches it as well. So that includes RUG. It includes other deaf components where we need it. And we make sure that Kubernetes or OpenShift works well with deaf. It is performant enough and in this case also your data integrity is guaranteed as best as we can. Today we focus on CFFS. CFFS is a scale out storage system based on top of CEPF. And I hope most of you are familiar with CEPF. It is quite a nice network file system. We use it for lots of different deployments and our customers use it for whatever applications they have. For example the Kubernetes image registry if you want to put it locally on your Kubernetes cluster is a very common use case for CFFS but it is not limited to container images. You can use basically any workload on top of it. Software engineers we always face a lot of challenges. For challenges we hopefully find nice approaches to solve these challenges. And one of these challenges is that in a Kubernetes cluster a node can go down. Either a virtual machine where you host your Kubernetes worker node or a Bimetal machine that runs all the Kubernetes services. It can go down. That just happens. That just affects. You can't prevent it. What you can do is you can accommodate your environment or your infrastructure as best as possible to work around these kind of hiccups. When a node goes down it isn't guaranteed that your whole node goes down. There are like partial failures. One of the easiest failures to imagine is if you have a worker node that runs Qplit as part of Kubernetes the Qplit daemon is responsible for mounting volumes, mounting file systems, starting containers and whatnot. If this Qplit daemon has a bug of some kind and it fails to respond to any requests from your Qplit management plane. This node is perceived down in the sense of Kubernetes infrastructure. However it doesn't mean that the node actually is down. It's only the Qplit service that is down. If this is the case then all your containers might still be running. If you have like a database running in your container this database might be happily running, reading and writing and accepting connections and whatnot. It might still function. It might write your data to a file system, CFFS in this case. But if Kubernetes thinks the node is down, Kubernetes will schedule this workload, your database on a different worker node. When it does so with CFFS it is possible to mount your file system on multiple nodes at the same time. It's a network file system so it's prepared to do that. For your database that runs on a second node this is very nice because Kubernetes thinks the service is up and running, everything is fine. But now you certainly have two databases running on the same file system with the same directories, with the same files that it uses. One on the old node that is perceived as down or broken because Qplit isn't running there and the other one where Qplit is running happily your container has been started new and it's running there as well. Now this can cause a lot of issues if your application in case of a database you can almost assume that the database uses a file looking correctly and really doesn't want to corrupt your data if another database instance is running on the same file system. In this case you are relatively safe however the database starting on the second node that just got started that will not get your file system logs. So the database will not start to write but Kubernetes might announce that this database is the master database and actually should be able to write but it doesn't because the old one is still running. So in that case you have like a partial outage that's the good case. The bad case is that your application doesn't use logs and the bad case is that the old instance is still writing data. The second newly started instance is writing data as well and they start to overwrite each other's data and that would be horrible because the application doesn't immediately notice and your data is now destroyed. It's corrupted because it's not in sync anymore. You don't know the state of your data and this is a really bad situation. This is not an inherent problem to Cephaphase. It's just network file systems in general and applications that don't use logs that can corrupt data in this way. It's not even restricted to file systems. If you use block storage like an Iskazi disk attached to multiple servers at the same time and you run a virtual machine on top of it, you actually have the same kind of issues. So that's the challenge. The resolution or one of the resolutions that we have with Cephaphase as a network file system, we can fence off broken nodes, network fencing. On storage layers, you have storage fencing. So if you have your SAN, you can actually fence servers on the HPA level and your storage fabric. With network file systems, you can do network fencing. You can see it as setting up a firewall between the broken server and the actual Ceph cluster. For Kubernetes, we wrote a network fence. It's part of an operator. Network fencing is a CRD. So it's an object, a Kubernetes object, that describes what you want to fence. The IP addresses, in this case, the ciders, so the network that you want to fence. You can have a list of networks in case you have multiple nodes or multiple networks on the node and whatnot. These can be fenced by creating this custom resource. Once you create the custom resource, our operator will see that it exists. It will see the states that you requested and will start do the fencing. That's the eventual thing that we want to do. This is one of the CRs, just an example. CSI Adons is a project that we use for enhancing the CSI specification. CSI is the container storage interface specification. That's the specification that is used by storage drivers and let Kubernetes mount a particular volume or create new volumes and so on. With this storage interface, it's rather limited, unfortunately, and it's not trivial to extend it. We have an Adon project, basically, that adds more storage operations that are not necessarily basic storage operations, but more advanced or more management operations, like fencing nodes from the network. What you do is you create the network fence CR. It needs to have a name. That's just the standard thing. You specify which driver you want to fence or which driver is used for the volumes. In this case, it's CephFS. We use RookCef in many deployments because it's just extremely easy to deploy your Ceph cluster with Rook. You can list which IP addresses you want. This is just a single IP address and this is the whole network that you want to fence. Possibly, you can even use it with multi-cluster environments. If you have a single Ceph cluster and you have one data center and another data center and you want to fence off one whole data center, you can also use it this way. You could fence your whole Kubernetes cluster in data center one and then make sure that data center number two is the only one accessing your storage. Yes, so that's it. You pass it to CephFS because if you want to talk to Ceph, you need your credentials. That's it, mostly. Now, the previous one is the manual example. It works nicely, but you still have to do it as an administrator. As an administrator, you need to know that a pod or that a system started to fail. Then you have to figure out all these kinds of details, which is rather annoying. It's already broken. Sorry? It's already broken before you can actually fence it. If you can just reschedule it in a couple of seconds. Yes, exactly. The remark is that it's already broken if you have to fence it. Yes, so often, you might have a little bit of time, depending on your application and so on, but yes, you are in a stressful situation because something broke in your environment and you don't want to hastily put some yaml together and make sure that you have the right IP addresses. If you do wrong IP addresses, you might break your cluster even more. This is something you can do manually, but it's tricky. Definitely, if you're in a stressful situation with an outage or partial outage, then you really don't want to bother with this. So the enhancement for the network fencing that we have is we include support in RUG. RUG already supports a form of network fencing for CepRBD, which uses the same kind of yaml. For CepFS, it's new and it requires a little bit of a twist, a little bit different commands, for example, with RBD. RBD is the image storage, so the block device is similar to Iscasi. And RBD only mainly talks to the OSDs. There's no metadata server, so the OSDs are what you want to communicate with, so you have only a single service type that you need to book access to. With CepFS, you have also the MDS metadata server, and this is the server that keeps, for example, file system logs. So in the first example, where you have two databases running and the database is smart enough to use a file system log, even if you would network fence the broken node, the broken node had the file system log. The second node doesn't immediately get the file system log if the first node completely gets down. There will be a timeout and it might take, depending on the kind of issue that you had, it might take a while. So for CepFS, we actually evict CepFS clients, which is a little bit different than block listing a client from the OSDs. That's for the background information, but for RUK, it is relatively simple to detect if a node is out. RUK doesn't have its own logic to verify if a node is working correctly. There are dedicated projects for that. I think a project like MediCADES is specialized in detecting the health of a node, and if something goes wrong, MediCADES can set a taint on a node. You can also set as an administrator a taint manually, and in this case, you put the out of service taint, and when RUK notices that a node is tainted with out of service, it will start the network fencing for the drivers of the volumes that are used on that particular node. So if your node is not using a CepFS volume, it's not going to network fence this particular node, because that node might still be used, or ideally, that will have the second database instance that should work correctly. This is then what you would see. So if you edit the taint, or if you manually created this YAML, this is what is shown. If you check the state of the network fence objects, and this is the host name, and whatnot, this is the IP resisted defense, in this case, it's just a single one, and it was fenced 20 seconds ago. In this case, and blocklisted from the OSDs, and the client was evicted from the MDSs. So another client can resume operation with the MDS, it can obtain file logs, and it can talk to the OSDs as usual. If you recover this node, you can edit the network fence CR and mark it as unfenced. Yes, sure. The network fence is always a blacklist. The question is if the network fence is always a blacklist, and that is right. So usually everything is allowed, so the whole cluster is basically allowed to communicate with the CEP cluster, the whole Kubernetes cluster in this case. And we call it blocklist now, but yes, it's a blocklist. You can have an allow list, but that's less practical. If you want to secure an environment, then that's probably something you want to do, but for network fencing, we only do the blocklisting. Yes. Basically two operations at the same time is evicting the client and also doing the network fence. So yes, so the question is if this happens with CEPFS, if network fencing is done, there are two operations and that's true. So there are two operations. The first operation is to evict the client. If you evict on the CEP level, it actually already does the blocklisting, but we only evict the client if the client is actually connected. If you want to network fence a client that does not have a CEPFS fast and connected at that time, we still blocklisted additionally just to make sure that nothing happens in the future. Yes, yes. So we try to be as safe as possible and make sure that it's consistent. What the output here is, if it's fenced, then it really should not be not fenced. So even if you did not have CEPFS mounted, it will still fence your node or your whole subnet or whatnot. Yes, oh yes. So the fencing is done on the CEPF cluster and that means that any client on the particular node won't be able to access the cluster anymore. So that's the whole goal. It doesn't matter what kind of client it is. It can be a kernel mount file system. It can be the fuse mount or it can be LibcFFS, which is also used in fuse. So none of these clients will be able to use the file system anymore and that's just the security measure to prevent any data inconsistencies. This is in fact what we do. So we evict the client. We figure out the client on the worker node or from the worker node that is connected has a particular client ID. We figure out this client ID for this particular IP address. It might be more than one and the network fencing will evict all of these clients and then eventually it will also block list the clients and you can check with this OSD block list command if everything was fenced correctly or not. And yes, so this is the summary how RUG protects you or can protect you more from data inconsistencies if you have multiple or potentially multiple workloads running on the same CEPFS file system. It's a very important feature not only for CEPFS but also for other storage environments because silently corrupting your data is not what you really want. This can further be automated with additional operators like medecates and that do the health checking of nodes and if they figure out that the node is not working they can taint the node. RUG then figures out the taint and RUG then starts the network fence CR. The network fence CR is then executed by the CSI add-ons operator talking to the CEPF cluster and the CEPF cluster will not be able to communicate with the worker out anymore. There's a question. So it sounds like it has to be the case that CEPF is in the final position to control whether the next pod is going to be able to use the same CEPFS file system otherwise there's no way to guarantee that the proper ordering occurs. Is that correct? So the question is that is CEPF is the final source or the decision maker in fencing? It is but you also want to fence, you ideally want to fence on different levels but in order to have your data consistent not necessarily only your workloads but if you want to have your data consistent then that needs to be done on the storage level as low as possible. So CEPF is the one that decides who is allowed to use your data and if there is a broken worker node a broken worker node should not be allowed to use it the best way to prevent the broken worker node from using or modifying the data is by blocking it on the storage level on CEPF. Right but my question was neither should be the next pod was able to schedule because even step one that you missed it could cause a new pod to come. So that would be allowed to happen because what? So the first step is that I'll rephrase it. The first step is that step zero is the broken out breaks. Step one is Kubernetes detects some breakage and starts the pod on another node. Right and that's where you are going to. Right in that case you're already late because the next pod might start to disrupt your data and write in the same things and that is correct. Yes, yes so there's still in this case there's still a window where things might not go right and that is in this case a Kubernetes issue and hopefully by automating more things like enabling like medicaid to detect a broken pod or broken worker node immediately tainted and then make sure that it fails over. Kubernetes also has a timeout in detecting if for example, Kuplet doesn't respond or so it doesn't immediately reschedule so you still have time to actually do some operations but you should not reschedule. Yes, it depends on the failure behavior that you see but you still need to be very fast on automating it so if you have automation around it then that's the best but you should try to have a large enough timeout for the rescheduling after a failure. Exactly so the comment is that you should check your timeouts and the ordering should be sufficient so if you have long enough timeouts then you can be very safe and if you have very short timeouts then the challenge on problems is just bigger. It's not always good to have your application up like five nines and sometimes a little bit lower but more safety is encouraged. This was it for my talk. I'm not sure if we still have we have two minutes for questions if there's anything and otherwise I thank you all for listening.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 17.12, "text": " Good morning everyone. Thank you for joining this talk. My name is Niels de Vos. I am", "tokens": [50364, 2205, 2446, 1518, 13, 1044, 291, 337, 5549, 341, 751, 13, 1222, 1315, 307, 426, 44189, 368, 691, 329, 13, 286, 669, 51220], "temperature": 0.0, "avg_logprob": -0.3223118980725606, "compression_ratio": 1.286764705882353, "no_speech_prob": 0.42203086614608765}, {"id": 1, "seek": 0, "start": 17.12, "end": 27.12, "text": " presenting instead of Ria. Ria was supposed to travel here but got cancelled. So she gave", "tokens": [51220, 15578, 2602, 295, 497, 654, 13, 497, 654, 390, 3442, 281, 3147, 510, 457, 658, 25103, 13, 407, 750, 2729, 51720], "temperature": 0.0, "avg_logprob": -0.3223118980725606, "compression_ratio": 1.286764705882353, "no_speech_prob": 0.42203086614608765}, {"id": 2, "seek": 2712, "start": 27.12, "end": 32.64, "text": " me her slides. I am one of the organizers of the deaf room together with Jan instead of having an", "tokens": [50364, 385, 720, 9788, 13, 286, 669, 472, 295, 264, 35071, 295, 264, 15559, 1808, 1214, 365, 4956, 2602, 295, 1419, 364, 50640], "temperature": 0.0, "avg_logprob": -0.17346785285256125, "compression_ratio": 1.564102564102564, "no_speech_prob": 0.34954577684402466}, {"id": 3, "seek": 2712, "start": 32.64, "end": 38.24, "text": " empty shot. I am presenting her talk. Hopefully I know enough about the topic to present it", "tokens": [50640, 6707, 3347, 13, 286, 669, 15578, 720, 751, 13, 10429, 286, 458, 1547, 466, 264, 4829, 281, 1974, 309, 50920], "temperature": 0.0, "avg_logprob": -0.17346785285256125, "compression_ratio": 1.564102564102564, "no_speech_prob": 0.34954577684402466}, {"id": 4, "seek": 2712, "start": 39.2, "end": 45.44, "text": " well enough. If you have questions don't hesitate to interrupt. I don't mind answering questions", "tokens": [50968, 731, 1547, 13, 759, 291, 362, 1651, 500, 380, 20842, 281, 12729, 13, 286, 500, 380, 1575, 13430, 1651, 51280], "temperature": 0.0, "avg_logprob": -0.17346785285256125, "compression_ratio": 1.564102564102564, "no_speech_prob": 0.34954577684402466}, {"id": 5, "seek": 2712, "start": 45.44, "end": 56.56, "text": " immediately. So Ria and I are actually colleagues. We both work on mostly CFCSI", "tokens": [51280, 4258, 13, 407, 497, 654, 293, 286, 366, 767, 7734, 13, 492, 1293, 589, 322, 5240, 383, 18671, 20262, 51836], "temperature": 0.0, "avg_logprob": -0.17346785285256125, "compression_ratio": 1.564102564102564, "no_speech_prob": 0.34954577684402466}, {"id": 6, "seek": 5656, "start": 56.64, "end": 63.36, "text": " but anything that touches it as well. So that includes RUG. It includes other deaf components", "tokens": [50368, 457, 1340, 300, 17431, 309, 382, 731, 13, 407, 300, 5974, 497, 52, 38, 13, 467, 5974, 661, 15559, 6677, 50704], "temperature": 0.0, "avg_logprob": -0.24045496401579483, "compression_ratio": 1.4866310160427807, "no_speech_prob": 0.048755943775177}, {"id": 7, "seek": 5656, "start": 63.36, "end": 70.16, "text": " where we need it. And we make sure that Kubernetes or OpenShift works well with", "tokens": [50704, 689, 321, 643, 309, 13, 400, 321, 652, 988, 300, 23145, 420, 7238, 7774, 2008, 1985, 731, 365, 51044], "temperature": 0.0, "avg_logprob": -0.24045496401579483, "compression_ratio": 1.4866310160427807, "no_speech_prob": 0.048755943775177}, {"id": 8, "seek": 5656, "start": 70.16, "end": 78.0, "text": " deaf. It is performant enough and in this case also your data integrity is guaranteed as best as we can.", "tokens": [51044, 15559, 13, 467, 307, 2042, 394, 1547, 293, 294, 341, 1389, 611, 428, 1412, 16000, 307, 18031, 382, 1151, 382, 321, 393, 13, 51436], "temperature": 0.0, "avg_logprob": -0.24045496401579483, "compression_ratio": 1.4866310160427807, "no_speech_prob": 0.048755943775177}, {"id": 9, "seek": 7800, "start": 78.0, "end": 88.0, "text": " Today we focus on CFFS. CFFS is a scale out storage system based on top of CEPF.", "tokens": [50364, 2692, 321, 1879, 322, 383, 6345, 50, 13, 383, 6345, 50, 307, 257, 4373, 484, 6725, 1185, 2361, 322, 1192, 295, 383, 8929, 37, 13, 50864], "temperature": 0.0, "avg_logprob": -0.2144624392191569, "compression_ratio": 1.4316939890710383, "no_speech_prob": 0.030625347048044205}, {"id": 10, "seek": 7800, "start": 88.72, "end": 95.28, "text": " And I hope most of you are familiar with CEPF. It is quite a nice network file system.", "tokens": [50900, 400, 286, 1454, 881, 295, 291, 366, 4963, 365, 383, 8929, 37, 13, 467, 307, 1596, 257, 1481, 3209, 3991, 1185, 13, 51228], "temperature": 0.0, "avg_logprob": -0.2144624392191569, "compression_ratio": 1.4316939890710383, "no_speech_prob": 0.030625347048044205}, {"id": 11, "seek": 7800, "start": 97.76, "end": 102.88, "text": " We use it for lots of different deployments and our customers use it for whatever applications", "tokens": [51352, 492, 764, 309, 337, 3195, 295, 819, 7274, 1117, 293, 527, 4581, 764, 309, 337, 2035, 5821, 51608], "temperature": 0.0, "avg_logprob": -0.2144624392191569, "compression_ratio": 1.4316939890710383, "no_speech_prob": 0.030625347048044205}, {"id": 12, "seek": 10288, "start": 102.88, "end": 107.44, "text": " they have. For example the Kubernetes image registry if you want to put it locally on your", "tokens": [50364, 436, 362, 13, 1171, 1365, 264, 23145, 3256, 36468, 498, 291, 528, 281, 829, 309, 16143, 322, 428, 50592], "temperature": 0.0, "avg_logprob": -0.13676629384358724, "compression_ratio": 1.5576923076923077, "no_speech_prob": 0.03047817386686802}, {"id": 13, "seek": 10288, "start": 107.44, "end": 114.56, "text": " Kubernetes cluster is a very common use case for CFFS but it is not limited to", "tokens": [50592, 23145, 13630, 307, 257, 588, 2689, 764, 1389, 337, 383, 6345, 50, 457, 309, 307, 406, 5567, 281, 50948], "temperature": 0.0, "avg_logprob": -0.13676629384358724, "compression_ratio": 1.5576923076923077, "no_speech_prob": 0.03047817386686802}, {"id": 14, "seek": 10288, "start": 115.6, "end": 120.0, "text": " container images. You can use basically any workload on top of it.", "tokens": [51000, 10129, 5267, 13, 509, 393, 764, 1936, 604, 20139, 322, 1192, 295, 309, 13, 51220], "temperature": 0.0, "avg_logprob": -0.13676629384358724, "compression_ratio": 1.5576923076923077, "no_speech_prob": 0.03047817386686802}, {"id": 15, "seek": 10288, "start": 125.28, "end": 131.04, "text": " Software engineers we always face a lot of challenges. For challenges we hopefully find", "tokens": [51484, 27428, 11955, 321, 1009, 1851, 257, 688, 295, 4759, 13, 1171, 4759, 321, 4696, 915, 51772], "temperature": 0.0, "avg_logprob": -0.13676629384358724, "compression_ratio": 1.5576923076923077, "no_speech_prob": 0.03047817386686802}, {"id": 16, "seek": 13104, "start": 131.04, "end": 140.07999999999998, "text": " nice approaches to solve these challenges. And one of these challenges is that in a Kubernetes", "tokens": [50364, 1481, 11587, 281, 5039, 613, 4759, 13, 400, 472, 295, 613, 4759, 307, 300, 294, 257, 23145, 50816], "temperature": 0.0, "avg_logprob": -0.2159155038686899, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.017909184098243713}, {"id": 17, "seek": 13104, "start": 140.07999999999998, "end": 146.88, "text": " cluster a node can go down. Either a virtual machine where you host your Kubernetes worker node", "tokens": [50816, 13630, 257, 9984, 393, 352, 760, 13, 13746, 257, 6374, 3479, 689, 291, 3975, 428, 23145, 11346, 9984, 51156], "temperature": 0.0, "avg_logprob": -0.2159155038686899, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.017909184098243713}, {"id": 18, "seek": 13104, "start": 146.88, "end": 152.88, "text": " or a Bimetal machine that runs all the Kubernetes services. It can go down. That just happens.", "tokens": [51156, 420, 257, 363, 26123, 304, 3479, 300, 6676, 439, 264, 23145, 3328, 13, 467, 393, 352, 760, 13, 663, 445, 2314, 13, 51456], "temperature": 0.0, "avg_logprob": -0.2159155038686899, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.017909184098243713}, {"id": 19, "seek": 15288, "start": 152.96, "end": 161.04, "text": " That just affects. You can't prevent it. What you can do is you can accommodate your environment or", "tokens": [50368, 663, 445, 11807, 13, 509, 393, 380, 4871, 309, 13, 708, 291, 393, 360, 307, 291, 393, 21410, 428, 2823, 420, 50772], "temperature": 0.0, "avg_logprob": -0.1547161586700924, "compression_ratio": 1.535294117647059, "no_speech_prob": 0.060145288705825806}, {"id": 20, "seek": 15288, "start": 161.04, "end": 166.16, "text": " your infrastructure as best as possible to work around these kind of hiccups.", "tokens": [50772, 428, 6896, 382, 1151, 382, 1944, 281, 589, 926, 613, 733, 295, 23697, 66, 7528, 13, 51028], "temperature": 0.0, "avg_logprob": -0.1547161586700924, "compression_ratio": 1.535294117647059, "no_speech_prob": 0.060145288705825806}, {"id": 21, "seek": 15288, "start": 168.0, "end": 175.44, "text": " When a node goes down it isn't guaranteed that your whole node goes down. There are", "tokens": [51120, 1133, 257, 9984, 1709, 760, 309, 1943, 380, 18031, 300, 428, 1379, 9984, 1709, 760, 13, 821, 366, 51492], "temperature": 0.0, "avg_logprob": -0.1547161586700924, "compression_ratio": 1.535294117647059, "no_speech_prob": 0.060145288705825806}, {"id": 22, "seek": 17544, "start": 175.44, "end": 183.35999999999999, "text": " like partial failures. One of the easiest failures to imagine is if you have a worker", "tokens": [50364, 411, 14641, 20774, 13, 1485, 295, 264, 12889, 20774, 281, 3811, 307, 498, 291, 362, 257, 11346, 50760], "temperature": 0.0, "avg_logprob": -0.15798639895311042, "compression_ratio": 1.536723163841808, "no_speech_prob": 0.022560158744454384}, {"id": 23, "seek": 17544, "start": 183.35999999999999, "end": 190.24, "text": " node that runs Qplit as part of Kubernetes the Qplit daemon is responsible for mounting", "tokens": [50760, 9984, 300, 6676, 1249, 564, 270, 382, 644, 295, 23145, 264, 1249, 564, 270, 1120, 36228, 307, 6250, 337, 22986, 51104], "temperature": 0.0, "avg_logprob": -0.15798639895311042, "compression_ratio": 1.536723163841808, "no_speech_prob": 0.022560158744454384}, {"id": 24, "seek": 17544, "start": 191.52, "end": 197.68, "text": " volumes, mounting file systems, starting containers and whatnot. If this Qplit daemon has a bug of", "tokens": [51168, 22219, 11, 22986, 3991, 3652, 11, 2891, 17089, 293, 25882, 13, 759, 341, 1249, 564, 270, 1120, 36228, 575, 257, 7426, 295, 51476], "temperature": 0.0, "avg_logprob": -0.15798639895311042, "compression_ratio": 1.536723163841808, "no_speech_prob": 0.022560158744454384}, {"id": 25, "seek": 19768, "start": 197.68, "end": 205.44, "text": " some kind and it fails to respond to any requests from your Qplit management plane.", "tokens": [50364, 512, 733, 293, 309, 18199, 281, 4196, 281, 604, 12475, 490, 428, 1249, 564, 270, 4592, 5720, 13, 50752], "temperature": 0.0, "avg_logprob": -0.09472237933765758, "compression_ratio": 1.6304347826086956, "no_speech_prob": 0.016013968735933304}, {"id": 26, "seek": 19768, "start": 206.48000000000002, "end": 213.68, "text": " This node is perceived down in the sense of Kubernetes infrastructure. However it doesn't", "tokens": [50804, 639, 9984, 307, 19049, 760, 294, 264, 2020, 295, 23145, 6896, 13, 2908, 309, 1177, 380, 51164], "temperature": 0.0, "avg_logprob": -0.09472237933765758, "compression_ratio": 1.6304347826086956, "no_speech_prob": 0.016013968735933304}, {"id": 27, "seek": 19768, "start": 213.68, "end": 221.60000000000002, "text": " mean that the node actually is down. It's only the Qplit service that is down. If this is the case", "tokens": [51164, 914, 300, 264, 9984, 767, 307, 760, 13, 467, 311, 787, 264, 1249, 564, 270, 2643, 300, 307, 760, 13, 759, 341, 307, 264, 1389, 51560], "temperature": 0.0, "avg_logprob": -0.09472237933765758, "compression_ratio": 1.6304347826086956, "no_speech_prob": 0.016013968735933304}, {"id": 28, "seek": 19768, "start": 221.60000000000002, "end": 226.8, "text": " then all your containers might still be running. If you have like a database running in your container", "tokens": [51560, 550, 439, 428, 17089, 1062, 920, 312, 2614, 13, 759, 291, 362, 411, 257, 8149, 2614, 294, 428, 10129, 51820], "temperature": 0.0, "avg_logprob": -0.09472237933765758, "compression_ratio": 1.6304347826086956, "no_speech_prob": 0.016013968735933304}, {"id": 29, "seek": 22680, "start": 226.8, "end": 231.44, "text": " this database might be happily running, reading and writing and accepting connections and whatnot.", "tokens": [50364, 341, 8149, 1062, 312, 19909, 2614, 11, 3760, 293, 3579, 293, 17391, 9271, 293, 25882, 13, 50596], "temperature": 0.0, "avg_logprob": -0.14233215944266614, "compression_ratio": 1.6442307692307692, "no_speech_prob": 0.0026672754902392626}, {"id": 30, "seek": 22680, "start": 231.44, "end": 235.52, "text": " It might still function. It might write your data to a file system,", "tokens": [50596, 467, 1062, 920, 2445, 13, 467, 1062, 2464, 428, 1412, 281, 257, 3991, 1185, 11, 50800], "temperature": 0.0, "avg_logprob": -0.14233215944266614, "compression_ratio": 1.6442307692307692, "no_speech_prob": 0.0026672754902392626}, {"id": 31, "seek": 22680, "start": 236.32000000000002, "end": 244.0, "text": " CFFS in this case. But if Kubernetes thinks the node is down, Kubernetes will schedule", "tokens": [50840, 383, 6345, 50, 294, 341, 1389, 13, 583, 498, 23145, 7309, 264, 9984, 307, 760, 11, 23145, 486, 7567, 51224], "temperature": 0.0, "avg_logprob": -0.14233215944266614, "compression_ratio": 1.6442307692307692, "no_speech_prob": 0.0026672754902392626}, {"id": 32, "seek": 22680, "start": 245.04000000000002, "end": 252.0, "text": " this workload, your database on a different worker node. When it does so with CFFS it is", "tokens": [51276, 341, 20139, 11, 428, 8149, 322, 257, 819, 11346, 9984, 13, 1133, 309, 775, 370, 365, 383, 6345, 50, 309, 307, 51624], "temperature": 0.0, "avg_logprob": -0.14233215944266614, "compression_ratio": 1.6442307692307692, "no_speech_prob": 0.0026672754902392626}, {"id": 33, "seek": 25200, "start": 252.0, "end": 257.6, "text": " possible to mount your file system on multiple nodes at the same time. It's a network file system", "tokens": [50364, 1944, 281, 3746, 428, 3991, 1185, 322, 3866, 13891, 412, 264, 912, 565, 13, 467, 311, 257, 3209, 3991, 1185, 50644], "temperature": 0.0, "avg_logprob": -0.07474498534470461, "compression_ratio": 1.7455357142857142, "no_speech_prob": 0.003759874729439616}, {"id": 34, "seek": 25200, "start": 257.6, "end": 268.4, "text": " so it's prepared to do that. For your database that runs on a second node this is very nice because", "tokens": [50644, 370, 309, 311, 4927, 281, 360, 300, 13, 1171, 428, 8149, 300, 6676, 322, 257, 1150, 9984, 341, 307, 588, 1481, 570, 51184], "temperature": 0.0, "avg_logprob": -0.07474498534470461, "compression_ratio": 1.7455357142857142, "no_speech_prob": 0.003759874729439616}, {"id": 35, "seek": 25200, "start": 268.4, "end": 273.04, "text": " Kubernetes thinks the service is up and running, everything is fine. But now you certainly have", "tokens": [51184, 23145, 7309, 264, 2643, 307, 493, 293, 2614, 11, 1203, 307, 2489, 13, 583, 586, 291, 3297, 362, 51416], "temperature": 0.0, "avg_logprob": -0.07474498534470461, "compression_ratio": 1.7455357142857142, "no_speech_prob": 0.003759874729439616}, {"id": 36, "seek": 25200, "start": 273.04, "end": 277.36, "text": " two databases running on the same file system with the same directories, with the same files that", "tokens": [51416, 732, 22380, 2614, 322, 264, 912, 3991, 1185, 365, 264, 912, 5391, 530, 11, 365, 264, 912, 7098, 300, 51632], "temperature": 0.0, "avg_logprob": -0.07474498534470461, "compression_ratio": 1.7455357142857142, "no_speech_prob": 0.003759874729439616}, {"id": 37, "seek": 27736, "start": 277.44, "end": 285.04, "text": " it uses. One on the old node that is perceived as down or broken because Qplit isn't running there", "tokens": [50368, 309, 4960, 13, 1485, 322, 264, 1331, 9984, 300, 307, 19049, 382, 760, 420, 5463, 570, 1249, 564, 270, 1943, 380, 2614, 456, 50748], "temperature": 0.0, "avg_logprob": -0.10278666814168294, "compression_ratio": 1.7085201793721974, "no_speech_prob": 0.004812179133296013}, {"id": 38, "seek": 27736, "start": 285.04, "end": 289.6, "text": " and the other one where Qplit is running happily your container has been started new", "tokens": [50748, 293, 264, 661, 472, 689, 1249, 564, 270, 307, 2614, 19909, 428, 10129, 575, 668, 1409, 777, 50976], "temperature": 0.0, "avg_logprob": -0.10278666814168294, "compression_ratio": 1.7085201793721974, "no_speech_prob": 0.004812179133296013}, {"id": 39, "seek": 27736, "start": 290.32, "end": 296.24, "text": " and it's running there as well. Now this can cause a lot of issues if your application in case of", "tokens": [51012, 293, 309, 311, 2614, 456, 382, 731, 13, 823, 341, 393, 3082, 257, 688, 295, 2663, 498, 428, 3861, 294, 1389, 295, 51308], "temperature": 0.0, "avg_logprob": -0.10278666814168294, "compression_ratio": 1.7085201793721974, "no_speech_prob": 0.004812179133296013}, {"id": 40, "seek": 27736, "start": 296.24, "end": 302.8, "text": " a database you can almost assume that the database uses a file looking correctly and really doesn't", "tokens": [51308, 257, 8149, 291, 393, 1920, 6552, 300, 264, 8149, 4960, 257, 3991, 1237, 8944, 293, 534, 1177, 380, 51636], "temperature": 0.0, "avg_logprob": -0.10278666814168294, "compression_ratio": 1.7085201793721974, "no_speech_prob": 0.004812179133296013}, {"id": 41, "seek": 30280, "start": 302.8, "end": 307.36, "text": " want to corrupt your data if another database instance is running on the same file system.", "tokens": [50364, 528, 281, 17366, 428, 1412, 498, 1071, 8149, 5197, 307, 2614, 322, 264, 912, 3991, 1185, 13, 50592], "temperature": 0.0, "avg_logprob": -0.09254538258419762, "compression_ratio": 1.7962085308056872, "no_speech_prob": 0.020874323323369026}, {"id": 42, "seek": 30280, "start": 307.36, "end": 312.8, "text": " In this case you are relatively safe however the database starting on the second node that just", "tokens": [50592, 682, 341, 1389, 291, 366, 7226, 3273, 4461, 264, 8149, 2891, 322, 264, 1150, 9984, 300, 445, 50864], "temperature": 0.0, "avg_logprob": -0.09254538258419762, "compression_ratio": 1.7962085308056872, "no_speech_prob": 0.020874323323369026}, {"id": 43, "seek": 30280, "start": 312.8, "end": 322.56, "text": " got started that will not get your file system logs. So the database will not start to write", "tokens": [50864, 658, 1409, 300, 486, 406, 483, 428, 3991, 1185, 20820, 13, 407, 264, 8149, 486, 406, 722, 281, 2464, 51352], "temperature": 0.0, "avg_logprob": -0.09254538258419762, "compression_ratio": 1.7962085308056872, "no_speech_prob": 0.020874323323369026}, {"id": 44, "seek": 30280, "start": 323.44, "end": 328.88, "text": " but Kubernetes might announce that this database is the master database and actually should be able", "tokens": [51396, 457, 23145, 1062, 7478, 300, 341, 8149, 307, 264, 4505, 8149, 293, 767, 820, 312, 1075, 51668], "temperature": 0.0, "avg_logprob": -0.09254538258419762, "compression_ratio": 1.7962085308056872, "no_speech_prob": 0.020874323323369026}, {"id": 45, "seek": 32888, "start": 328.88, "end": 333.2, "text": " to write but it doesn't because the old one is still running. So in that case you have like a", "tokens": [50364, 281, 2464, 457, 309, 1177, 380, 570, 264, 1331, 472, 307, 920, 2614, 13, 407, 294, 300, 1389, 291, 362, 411, 257, 50580], "temperature": 0.0, "avg_logprob": -0.07928188641866048, "compression_ratio": 1.878787878787879, "no_speech_prob": 0.019319510087370872}, {"id": 46, "seek": 32888, "start": 333.2, "end": 339.2, "text": " partial outage that's the good case. The bad case is that your application doesn't use logs", "tokens": [50580, 14641, 484, 609, 300, 311, 264, 665, 1389, 13, 440, 1578, 1389, 307, 300, 428, 3861, 1177, 380, 764, 20820, 50880], "temperature": 0.0, "avg_logprob": -0.07928188641866048, "compression_ratio": 1.878787878787879, "no_speech_prob": 0.019319510087370872}, {"id": 47, "seek": 32888, "start": 339.84, "end": 346.56, "text": " and the bad case is that the old instance is still writing data. The second newly started", "tokens": [50912, 293, 264, 1578, 1389, 307, 300, 264, 1331, 5197, 307, 920, 3579, 1412, 13, 440, 1150, 15109, 1409, 51248], "temperature": 0.0, "avg_logprob": -0.07928188641866048, "compression_ratio": 1.878787878787879, "no_speech_prob": 0.019319510087370872}, {"id": 48, "seek": 32888, "start": 346.56, "end": 354.15999999999997, "text": " instance is writing data as well and they start to overwrite each other's data and that would be", "tokens": [51248, 5197, 307, 3579, 1412, 382, 731, 293, 436, 722, 281, 670, 21561, 1184, 661, 311, 1412, 293, 300, 576, 312, 51628], "temperature": 0.0, "avg_logprob": -0.07928188641866048, "compression_ratio": 1.878787878787879, "no_speech_prob": 0.019319510087370872}, {"id": 49, "seek": 35416, "start": 354.16, "end": 360.64000000000004, "text": " horrible because the application doesn't immediately notice and your data is now destroyed. It's", "tokens": [50364, 9263, 570, 264, 3861, 1177, 380, 4258, 3449, 293, 428, 1412, 307, 586, 8937, 13, 467, 311, 50688], "temperature": 0.0, "avg_logprob": -0.12972495261203038, "compression_ratio": 1.6816143497757847, "no_speech_prob": 0.012992608360946178}, {"id": 50, "seek": 35416, "start": 360.64000000000004, "end": 366.40000000000003, "text": " corrupted because it's not in sync anymore. You don't know the state of your data and this is a", "tokens": [50688, 39480, 570, 309, 311, 406, 294, 20271, 3602, 13, 509, 500, 380, 458, 264, 1785, 295, 428, 1412, 293, 341, 307, 257, 50976], "temperature": 0.0, "avg_logprob": -0.12972495261203038, "compression_ratio": 1.6816143497757847, "no_speech_prob": 0.012992608360946178}, {"id": 51, "seek": 35416, "start": 366.40000000000003, "end": 373.6, "text": " really bad situation. This is not an inherent problem to Cephaphase. It's just network file", "tokens": [50976, 534, 1578, 2590, 13, 639, 307, 406, 364, 26387, 1154, 281, 383, 595, 71, 13957, 651, 13, 467, 311, 445, 3209, 3991, 51336], "temperature": 0.0, "avg_logprob": -0.12972495261203038, "compression_ratio": 1.6816143497757847, "no_speech_prob": 0.012992608360946178}, {"id": 52, "seek": 35416, "start": 373.6, "end": 379.12, "text": " systems in general and applications that don't use logs that can corrupt data in this way.", "tokens": [51336, 3652, 294, 2674, 293, 5821, 300, 500, 380, 764, 20820, 300, 393, 17366, 1412, 294, 341, 636, 13, 51612], "temperature": 0.0, "avg_logprob": -0.12972495261203038, "compression_ratio": 1.6816143497757847, "no_speech_prob": 0.012992608360946178}, {"id": 53, "seek": 37912, "start": 379.36, "end": 385.76, "text": " It's not even restricted to file systems. If you use block storage like an Iskazi", "tokens": [50376, 467, 311, 406, 754, 20608, 281, 3991, 3652, 13, 759, 291, 764, 3461, 6725, 411, 364, 1119, 74, 26637, 50696], "temperature": 0.0, "avg_logprob": -0.1983029047648112, "compression_ratio": 1.5699481865284974, "no_speech_prob": 0.009636365808546543}, {"id": 54, "seek": 37912, "start": 386.32, "end": 390.56, "text": " disk attached to multiple servers at the same time and you run a virtual machine on top of it,", "tokens": [50724, 12355, 8570, 281, 3866, 15909, 412, 264, 912, 565, 293, 291, 1190, 257, 6374, 3479, 322, 1192, 295, 309, 11, 50936], "temperature": 0.0, "avg_logprob": -0.1983029047648112, "compression_ratio": 1.5699481865284974, "no_speech_prob": 0.009636365808546543}, {"id": 55, "seek": 37912, "start": 390.56, "end": 393.04, "text": " you actually have the same kind of issues.", "tokens": [50936, 291, 767, 362, 264, 912, 733, 295, 2663, 13, 51060], "temperature": 0.0, "avg_logprob": -0.1983029047648112, "compression_ratio": 1.5699481865284974, "no_speech_prob": 0.009636365808546543}, {"id": 56, "seek": 37912, "start": 397.84000000000003, "end": 404.48, "text": " So that's the challenge. The resolution or one of the resolutions that we have with", "tokens": [51300, 407, 300, 311, 264, 3430, 13, 440, 8669, 420, 472, 295, 264, 32179, 300, 321, 362, 365, 51632], "temperature": 0.0, "avg_logprob": -0.1983029047648112, "compression_ratio": 1.5699481865284974, "no_speech_prob": 0.009636365808546543}, {"id": 57, "seek": 40448, "start": 405.36, "end": 412.88, "text": " Cephaphase as a network file system, we can fence off broken nodes, network fencing.", "tokens": [50408, 383, 595, 71, 13957, 651, 382, 257, 3209, 3991, 1185, 11, 321, 393, 15422, 766, 5463, 13891, 11, 3209, 283, 13644, 13, 50784], "temperature": 0.0, "avg_logprob": -0.1743195804197397, "compression_ratio": 1.5974842767295598, "no_speech_prob": 0.004990618675947189}, {"id": 58, "seek": 40448, "start": 414.48, "end": 419.92, "text": " On storage layers, you have storage fencing. So if you have your SAN, you can actually", "tokens": [50864, 1282, 6725, 7914, 11, 291, 362, 6725, 283, 13644, 13, 407, 498, 291, 362, 428, 49557, 11, 291, 393, 767, 51136], "temperature": 0.0, "avg_logprob": -0.1743195804197397, "compression_ratio": 1.5974842767295598, "no_speech_prob": 0.004990618675947189}, {"id": 59, "seek": 40448, "start": 421.52000000000004, "end": 428.48, "text": " fence servers on the HPA level and your storage fabric. With network file systems,", "tokens": [51216, 15422, 15909, 322, 264, 389, 10297, 1496, 293, 428, 6725, 7253, 13, 2022, 3209, 3991, 3652, 11, 51564], "temperature": 0.0, "avg_logprob": -0.1743195804197397, "compression_ratio": 1.5974842767295598, "no_speech_prob": 0.004990618675947189}, {"id": 60, "seek": 42848, "start": 429.36, "end": 436.56, "text": " you can do network fencing. You can see it as setting up a firewall between the broken server", "tokens": [50408, 291, 393, 360, 3209, 283, 13644, 13, 509, 393, 536, 309, 382, 3287, 493, 257, 36109, 1296, 264, 5463, 7154, 50768], "temperature": 0.0, "avg_logprob": -0.11605017525809151, "compression_ratio": 1.532934131736527, "no_speech_prob": 0.003093877574428916}, {"id": 61, "seek": 42848, "start": 436.56, "end": 444.16, "text": " and the actual Ceph cluster. For Kubernetes, we wrote a network fence.", "tokens": [50768, 293, 264, 3539, 383, 595, 71, 13630, 13, 1171, 23145, 11, 321, 4114, 257, 3209, 15422, 13, 51148], "temperature": 0.0, "avg_logprob": -0.11605017525809151, "compression_ratio": 1.532934131736527, "no_speech_prob": 0.003093877574428916}, {"id": 62, "seek": 42848, "start": 447.28000000000003, "end": 454.56, "text": " It's part of an operator. Network fencing is a CRD. So it's an object, a Kubernetes object,", "tokens": [51304, 467, 311, 644, 295, 364, 12973, 13, 12640, 283, 13644, 307, 257, 14123, 35, 13, 407, 309, 311, 364, 2657, 11, 257, 23145, 2657, 11, 51668], "temperature": 0.0, "avg_logprob": -0.11605017525809151, "compression_ratio": 1.532934131736527, "no_speech_prob": 0.003093877574428916}, {"id": 63, "seek": 45456, "start": 455.12, "end": 459.52, "text": " that describes what you want to fence. The IP addresses, in this case, the", "tokens": [50392, 300, 15626, 437, 291, 528, 281, 15422, 13, 440, 8671, 16862, 11, 294, 341, 1389, 11, 264, 50612], "temperature": 0.0, "avg_logprob": -0.18772063604215297, "compression_ratio": 1.7708333333333333, "no_speech_prob": 0.01578802801668644}, {"id": 64, "seek": 45456, "start": 460.24, "end": 464.56, "text": " ciders, so the network that you want to fence. You can have a list of networks in case you have", "tokens": [50648, 269, 6936, 11, 370, 264, 3209, 300, 291, 528, 281, 15422, 13, 509, 393, 362, 257, 1329, 295, 9590, 294, 1389, 291, 362, 50864], "temperature": 0.0, "avg_logprob": -0.18772063604215297, "compression_ratio": 1.7708333333333333, "no_speech_prob": 0.01578802801668644}, {"id": 65, "seek": 45456, "start": 464.56, "end": 473.84000000000003, "text": " multiple nodes or multiple networks on the node and whatnot. These can be fenced by creating this", "tokens": [50864, 3866, 13891, 420, 3866, 9590, 322, 264, 9984, 293, 25882, 13, 1981, 393, 312, 283, 14672, 538, 4084, 341, 51328], "temperature": 0.0, "avg_logprob": -0.18772063604215297, "compression_ratio": 1.7708333333333333, "no_speech_prob": 0.01578802801668644}, {"id": 66, "seek": 45456, "start": 474.56, "end": 480.64, "text": " custom resource. Once you create the custom resource, our operator will", "tokens": [51364, 2375, 7684, 13, 3443, 291, 1884, 264, 2375, 7684, 11, 527, 12973, 486, 51668], "temperature": 0.0, "avg_logprob": -0.18772063604215297, "compression_ratio": 1.7708333333333333, "no_speech_prob": 0.01578802801668644}, {"id": 67, "seek": 48064, "start": 481.12, "end": 488.15999999999997, "text": " see that it exists. It will see the states that you requested and will start do the fencing.", "tokens": [50388, 536, 300, 309, 8198, 13, 467, 486, 536, 264, 4368, 300, 291, 16436, 293, 486, 722, 360, 264, 283, 13644, 13, 50740], "temperature": 0.0, "avg_logprob": -0.2729233932495117, "compression_ratio": 1.3875968992248062, "no_speech_prob": 0.010241218842566013}, {"id": 68, "seek": 48064, "start": 488.15999999999997, "end": 501.03999999999996, "text": " That's the eventual thing that we want to do. This is one of the CRs, just an example.", "tokens": [50740, 663, 311, 264, 33160, 551, 300, 321, 528, 281, 360, 13, 639, 307, 472, 295, 264, 14123, 82, 11, 445, 364, 1365, 13, 51384], "temperature": 0.0, "avg_logprob": -0.2729233932495117, "compression_ratio": 1.3875968992248062, "no_speech_prob": 0.010241218842566013}, {"id": 69, "seek": 50104, "start": 502.0, "end": 513.6800000000001, "text": " CSI Adons is a project that we use for enhancing the CSI specification. CSI is the container", "tokens": [50412, 9460, 40, 1999, 892, 307, 257, 1716, 300, 321, 764, 337, 36579, 264, 9460, 40, 31256, 13, 9460, 40, 307, 264, 10129, 50996], "temperature": 0.0, "avg_logprob": -0.15288328720351396, "compression_ratio": 1.5757575757575757, "no_speech_prob": 0.014156417921185493}, {"id": 70, "seek": 50104, "start": 513.6800000000001, "end": 519.28, "text": " storage interface specification. That's the specification that is used by storage drivers", "tokens": [50996, 6725, 9226, 31256, 13, 663, 311, 264, 31256, 300, 307, 1143, 538, 6725, 11590, 51276], "temperature": 0.0, "avg_logprob": -0.15288328720351396, "compression_ratio": 1.5757575757575757, "no_speech_prob": 0.014156417921185493}, {"id": 71, "seek": 50104, "start": 520.08, "end": 525.28, "text": " and let Kubernetes mount a particular volume or create new volumes and so on.", "tokens": [51316, 293, 718, 23145, 3746, 257, 1729, 5523, 420, 1884, 777, 22219, 293, 370, 322, 13, 51576], "temperature": 0.0, "avg_logprob": -0.15288328720351396, "compression_ratio": 1.5757575757575757, "no_speech_prob": 0.014156417921185493}, {"id": 72, "seek": 52528, "start": 525.8399999999999, "end": 534.72, "text": " With this storage interface, it's rather limited, unfortunately, and it's not trivial to extend it.", "tokens": [50392, 2022, 341, 6725, 9226, 11, 309, 311, 2831, 5567, 11, 7015, 11, 293, 309, 311, 406, 26703, 281, 10101, 309, 13, 50836], "temperature": 0.0, "avg_logprob": -0.23256055770381803, "compression_ratio": 1.630057803468208, "no_speech_prob": 0.003456509206444025}, {"id": 73, "seek": 52528, "start": 536.24, "end": 543.04, "text": " We have an Adon project, basically, that adds more storage operations that are not necessarily", "tokens": [50912, 492, 362, 364, 1999, 266, 1716, 11, 1936, 11, 300, 10860, 544, 6725, 7705, 300, 366, 406, 4725, 51252], "temperature": 0.0, "avg_logprob": -0.23256055770381803, "compression_ratio": 1.630057803468208, "no_speech_prob": 0.003456509206444025}, {"id": 74, "seek": 52528, "start": 543.68, "end": 548.16, "text": " basic storage operations, but more advanced or more management operations, like fencing", "tokens": [51284, 3875, 6725, 7705, 11, 457, 544, 7339, 420, 544, 4592, 7705, 11, 411, 283, 13644, 51508], "temperature": 0.0, "avg_logprob": -0.23256055770381803, "compression_ratio": 1.630057803468208, "no_speech_prob": 0.003456509206444025}, {"id": 75, "seek": 54816, "start": 548.8, "end": 559.1999999999999, "text": " nodes from the network. What you do is you create the network fence CR. It needs to have a name.", "tokens": [50396, 13891, 490, 264, 3209, 13, 708, 291, 360, 307, 291, 1884, 264, 3209, 15422, 14123, 13, 467, 2203, 281, 362, 257, 1315, 13, 50916], "temperature": 0.0, "avg_logprob": -0.23317289352416992, "compression_ratio": 1.5051546391752577, "no_speech_prob": 0.025539837777614594}, {"id": 76, "seek": 54816, "start": 559.1999999999999, "end": 568.24, "text": " That's just the standard thing. You specify which driver you want to fence or which driver is used", "tokens": [50916, 663, 311, 445, 264, 3832, 551, 13, 509, 16500, 597, 6787, 291, 528, 281, 15422, 420, 597, 6787, 307, 1143, 51368], "temperature": 0.0, "avg_logprob": -0.23317289352416992, "compression_ratio": 1.5051546391752577, "no_speech_prob": 0.025539837777614594}, {"id": 77, "seek": 54816, "start": 568.24, "end": 575.28, "text": " for the volumes. In this case, it's CephFS. We use RookCef in many deployments because it's just", "tokens": [51368, 337, 264, 22219, 13, 682, 341, 1389, 11, 309, 311, 383, 595, 71, 29318, 13, 492, 764, 497, 1212, 34, 5666, 294, 867, 7274, 1117, 570, 309, 311, 445, 51720], "temperature": 0.0, "avg_logprob": -0.23317289352416992, "compression_ratio": 1.5051546391752577, "no_speech_prob": 0.025539837777614594}, {"id": 78, "seek": 57528, "start": 575.28, "end": 580.88, "text": " extremely easy to deploy your Ceph cluster with Rook. You can list which IP addresses you want.", "tokens": [50364, 4664, 1858, 281, 7274, 428, 383, 595, 71, 13630, 365, 497, 1212, 13, 509, 393, 1329, 597, 8671, 16862, 291, 528, 13, 50644], "temperature": 0.0, "avg_logprob": -0.11918697965906021, "compression_ratio": 1.776190476190476, "no_speech_prob": 0.006524527911096811}, {"id": 79, "seek": 57528, "start": 581.76, "end": 586.64, "text": " This is just a single IP address and this is the whole network that you want to fence. Possibly,", "tokens": [50688, 639, 307, 445, 257, 2167, 8671, 2985, 293, 341, 307, 264, 1379, 3209, 300, 291, 528, 281, 15422, 13, 33112, 3545, 11, 50932], "temperature": 0.0, "avg_logprob": -0.11918697965906021, "compression_ratio": 1.776190476190476, "no_speech_prob": 0.006524527911096811}, {"id": 80, "seek": 57528, "start": 586.64, "end": 593.12, "text": " you can even use it with multi-cluster environments. If you have a single Ceph cluster", "tokens": [50932, 291, 393, 754, 764, 309, 365, 4825, 12, 3474, 8393, 12388, 13, 759, 291, 362, 257, 2167, 383, 595, 71, 13630, 51256], "temperature": 0.0, "avg_logprob": -0.11918697965906021, "compression_ratio": 1.776190476190476, "no_speech_prob": 0.006524527911096811}, {"id": 81, "seek": 57528, "start": 593.68, "end": 598.8, "text": " and you have one data center and another data center and you want to fence off one whole data", "tokens": [51284, 293, 291, 362, 472, 1412, 3056, 293, 1071, 1412, 3056, 293, 291, 528, 281, 15422, 766, 472, 1379, 1412, 51540], "temperature": 0.0, "avg_logprob": -0.11918697965906021, "compression_ratio": 1.776190476190476, "no_speech_prob": 0.006524527911096811}, {"id": 82, "seek": 59880, "start": 598.8, "end": 605.3599999999999, "text": " center, you can also use it this way. You could fence your whole Kubernetes cluster in data center", "tokens": [50364, 3056, 11, 291, 393, 611, 764, 309, 341, 636, 13, 509, 727, 15422, 428, 1379, 23145, 13630, 294, 1412, 3056, 50692], "temperature": 0.0, "avg_logprob": -0.19399524015538833, "compression_ratio": 1.5808080808080809, "no_speech_prob": 0.015066064894199371}, {"id": 83, "seek": 59880, "start": 605.3599999999999, "end": 610.3199999999999, "text": " one and then make sure that data center number two is the only one accessing your storage.", "tokens": [50692, 472, 293, 550, 652, 988, 300, 1412, 3056, 1230, 732, 307, 264, 787, 472, 26440, 428, 6725, 13, 50940], "temperature": 0.0, "avg_logprob": -0.19399524015538833, "compression_ratio": 1.5808080808080809, "no_speech_prob": 0.015066064894199371}, {"id": 84, "seek": 59880, "start": 612.24, "end": 617.5999999999999, "text": " Yes, so that's it. You pass it to CephFS because if you want to talk to Ceph, you need your credentials.", "tokens": [51036, 1079, 11, 370, 300, 311, 309, 13, 509, 1320, 309, 281, 383, 595, 71, 29318, 570, 498, 291, 528, 281, 751, 281, 383, 595, 71, 11, 291, 643, 428, 27404, 13, 51304], "temperature": 0.0, "avg_logprob": -0.19399524015538833, "compression_ratio": 1.5808080808080809, "no_speech_prob": 0.015066064894199371}, {"id": 85, "seek": 59880, "start": 621.04, "end": 622.24, "text": " That's it, mostly.", "tokens": [51476, 663, 311, 309, 11, 5240, 13, 51536], "temperature": 0.0, "avg_logprob": -0.19399524015538833, "compression_ratio": 1.5808080808080809, "no_speech_prob": 0.015066064894199371}, {"id": 86, "seek": 62224, "start": 623.04, "end": 632.24, "text": " Now, the previous one is the manual example. It works nicely, but you still have to do it as an", "tokens": [50404, 823, 11, 264, 3894, 472, 307, 264, 9688, 1365, 13, 467, 1985, 9594, 11, 457, 291, 920, 362, 281, 360, 309, 382, 364, 50864], "temperature": 0.0, "avg_logprob": -0.22525672074202652, "compression_ratio": 1.600896860986547, "no_speech_prob": 0.01151918713003397}, {"id": 87, "seek": 62224, "start": 632.24, "end": 639.44, "text": " administrator. As an administrator, you need to know that a pod or that a system started to fail.", "tokens": [50864, 25529, 13, 1018, 364, 25529, 11, 291, 643, 281, 458, 300, 257, 2497, 420, 300, 257, 1185, 1409, 281, 3061, 13, 51224], "temperature": 0.0, "avg_logprob": -0.22525672074202652, "compression_ratio": 1.600896860986547, "no_speech_prob": 0.01151918713003397}, {"id": 88, "seek": 62224, "start": 641.04, "end": 644.0, "text": " Then you have to figure out all these kinds of details, which is rather annoying.", "tokens": [51304, 1396, 291, 362, 281, 2573, 484, 439, 613, 3685, 295, 4365, 11, 597, 307, 2831, 11304, 13, 51452], "temperature": 0.0, "avg_logprob": -0.22525672074202652, "compression_ratio": 1.600896860986547, "no_speech_prob": 0.01151918713003397}, {"id": 89, "seek": 62224, "start": 644.0, "end": 646.48, "text": " It's already broken. Sorry?", "tokens": [51452, 467, 311, 1217, 5463, 13, 4919, 30, 51576], "temperature": 0.0, "avg_logprob": -0.22525672074202652, "compression_ratio": 1.600896860986547, "no_speech_prob": 0.01151918713003397}, {"id": 90, "seek": 62224, "start": 646.48, "end": 648.48, "text": " It's already broken before you can actually fence it.", "tokens": [51576, 467, 311, 1217, 5463, 949, 291, 393, 767, 15422, 309, 13, 51676], "temperature": 0.0, "avg_logprob": -0.22525672074202652, "compression_ratio": 1.600896860986547, "no_speech_prob": 0.01151918713003397}, {"id": 91, "seek": 64848, "start": 649.28, "end": 651.6800000000001, "text": " If you can just reschedule it in a couple of seconds.", "tokens": [50404, 759, 291, 393, 445, 725, 19318, 2271, 309, 294, 257, 1916, 295, 3949, 13, 50524], "temperature": 0.0, "avg_logprob": -0.2308014915103004, "compression_ratio": 1.565217391304348, "no_speech_prob": 0.007351646665483713}, {"id": 92, "seek": 64848, "start": 651.6800000000001, "end": 658.0, "text": " Yes, exactly. The remark is that it's already broken if you have to fence it.", "tokens": [50524, 1079, 11, 2293, 13, 440, 7942, 307, 300, 309, 311, 1217, 5463, 498, 291, 362, 281, 15422, 309, 13, 50840], "temperature": 0.0, "avg_logprob": -0.2308014915103004, "compression_ratio": 1.565217391304348, "no_speech_prob": 0.007351646665483713}, {"id": 93, "seek": 64848, "start": 658.96, "end": 665.6800000000001, "text": " Yes, so often, you might have a little bit of time, depending on your application and so on,", "tokens": [50888, 1079, 11, 370, 2049, 11, 291, 1062, 362, 257, 707, 857, 295, 565, 11, 5413, 322, 428, 3861, 293, 370, 322, 11, 51224], "temperature": 0.0, "avg_logprob": -0.2308014915103004, "compression_ratio": 1.565217391304348, "no_speech_prob": 0.007351646665483713}, {"id": 94, "seek": 64848, "start": 665.6800000000001, "end": 672.5600000000001, "text": " but yes, you are in a stressful situation because something broke in your environment and you don't", "tokens": [51224, 457, 2086, 11, 291, 366, 294, 257, 19108, 2590, 570, 746, 6902, 294, 428, 2823, 293, 291, 500, 380, 51568], "temperature": 0.0, "avg_logprob": -0.2308014915103004, "compression_ratio": 1.565217391304348, "no_speech_prob": 0.007351646665483713}, {"id": 95, "seek": 67256, "start": 672.56, "end": 678.0799999999999, "text": " want to hastily put some yaml together and make sure that you have the right IP addresses.", "tokens": [50364, 528, 281, 6581, 953, 829, 512, 288, 335, 75, 1214, 293, 652, 988, 300, 291, 362, 264, 558, 8671, 16862, 13, 50640], "temperature": 0.0, "avg_logprob": -0.12077838724309747, "compression_ratio": 1.5681818181818181, "no_speech_prob": 0.07799948006868362}, {"id": 96, "seek": 67256, "start": 678.0799999999999, "end": 681.8399999999999, "text": " If you do wrong IP addresses, you might break your cluster even more.", "tokens": [50640, 759, 291, 360, 2085, 8671, 16862, 11, 291, 1062, 1821, 428, 13630, 754, 544, 13, 50828], "temperature": 0.0, "avg_logprob": -0.12077838724309747, "compression_ratio": 1.5681818181818181, "no_speech_prob": 0.07799948006868362}, {"id": 97, "seek": 67256, "start": 681.8399999999999, "end": 689.04, "text": " This is something you can do manually, but it's tricky. Definitely, if you're in a stressful", "tokens": [50828, 639, 307, 746, 291, 393, 360, 16945, 11, 457, 309, 311, 12414, 13, 12151, 11, 498, 291, 434, 294, 257, 19108, 51188], "temperature": 0.0, "avg_logprob": -0.12077838724309747, "compression_ratio": 1.5681818181818181, "no_speech_prob": 0.07799948006868362}, {"id": 98, "seek": 67256, "start": 689.04, "end": 693.4399999999999, "text": " situation with an outage or partial outage, then you really don't want to bother with this.", "tokens": [51188, 2590, 365, 364, 484, 609, 420, 14641, 484, 609, 11, 550, 291, 534, 500, 380, 528, 281, 8677, 365, 341, 13, 51408], "temperature": 0.0, "avg_logprob": -0.12077838724309747, "compression_ratio": 1.5681818181818181, "no_speech_prob": 0.07799948006868362}, {"id": 99, "seek": 69344, "start": 694.4000000000001, "end": 703.0400000000001, "text": " So the enhancement for the network fencing that we have is we include support in RUG.", "tokens": [50412, 407, 264, 40776, 337, 264, 3209, 283, 13644, 300, 321, 362, 307, 321, 4090, 1406, 294, 497, 52, 38, 13, 50844], "temperature": 0.0, "avg_logprob": -0.1996151973039676, "compression_ratio": 1.497142857142857, "no_speech_prob": 0.03140115365386009}, {"id": 100, "seek": 69344, "start": 703.0400000000001, "end": 708.6400000000001, "text": " RUG already supports a form of network fencing for CepRBD, which uses the same kind of yaml.", "tokens": [50844, 497, 52, 38, 1217, 9346, 257, 1254, 295, 3209, 283, 13644, 337, 383, 595, 49, 33, 35, 11, 597, 4960, 264, 912, 733, 295, 288, 335, 75, 13, 51124], "temperature": 0.0, "avg_logprob": -0.1996151973039676, "compression_ratio": 1.497142857142857, "no_speech_prob": 0.03140115365386009}, {"id": 101, "seek": 69344, "start": 709.7600000000001, "end": 716.24, "text": " For CepFS, it's new and it requires a little bit of a twist, a little bit different", "tokens": [51180, 1171, 383, 595, 29318, 11, 309, 311, 777, 293, 309, 7029, 257, 707, 857, 295, 257, 8203, 11, 257, 707, 857, 819, 51504], "temperature": 0.0, "avg_logprob": -0.1996151973039676, "compression_ratio": 1.497142857142857, "no_speech_prob": 0.03140115365386009}, {"id": 102, "seek": 71624, "start": 716.96, "end": 725.52, "text": " commands, for example, with RBD. RBD is the image storage, so the block device is similar to Iscasi.", "tokens": [50400, 16901, 11, 337, 1365, 11, 365, 40302, 35, 13, 40302, 35, 307, 264, 3256, 6725, 11, 370, 264, 3461, 4302, 307, 2531, 281, 1119, 66, 8483, 13, 50828], "temperature": 0.0, "avg_logprob": -0.2486241830361856, "compression_ratio": 1.4357541899441342, "no_speech_prob": 0.029345238581299782}, {"id": 103, "seek": 71624, "start": 726.48, "end": 735.76, "text": " And RBD only mainly talks to the OSDs. There's no metadata server, so the OSDs are", "tokens": [50876, 400, 40302, 35, 787, 8704, 6686, 281, 264, 12731, 35, 82, 13, 821, 311, 572, 26603, 7154, 11, 370, 264, 12731, 35, 82, 366, 51340], "temperature": 0.0, "avg_logprob": -0.2486241830361856, "compression_ratio": 1.4357541899441342, "no_speech_prob": 0.029345238581299782}, {"id": 104, "seek": 71624, "start": 737.52, "end": 741.04, "text": " what you want to communicate with, so you have only a single service type", "tokens": [51428, 437, 291, 528, 281, 7890, 365, 11, 370, 291, 362, 787, 257, 2167, 2643, 2010, 51604], "temperature": 0.0, "avg_logprob": -0.2486241830361856, "compression_ratio": 1.4357541899441342, "no_speech_prob": 0.029345238581299782}, {"id": 105, "seek": 74104, "start": 741.5999999999999, "end": 746.64, "text": " that you need to book access to. With CepFS, you have also the MDS metadata server,", "tokens": [50392, 300, 291, 643, 281, 1446, 2105, 281, 13, 2022, 383, 595, 29318, 11, 291, 362, 611, 264, 376, 11844, 26603, 7154, 11, 50644], "temperature": 0.0, "avg_logprob": -0.11962991602280561, "compression_ratio": 1.5588235294117647, "no_speech_prob": 0.008814964443445206}, {"id": 106, "seek": 74104, "start": 747.28, "end": 754.9599999999999, "text": " and this is the server that keeps, for example, file system logs. So in the first example,", "tokens": [50676, 293, 341, 307, 264, 7154, 300, 5965, 11, 337, 1365, 11, 3991, 1185, 20820, 13, 407, 294, 264, 700, 1365, 11, 51060], "temperature": 0.0, "avg_logprob": -0.11962991602280561, "compression_ratio": 1.5588235294117647, "no_speech_prob": 0.008814964443445206}, {"id": 107, "seek": 74104, "start": 758.0, "end": 762.24, "text": " where you have two databases running and the database is smart enough to use a file system", "tokens": [51212, 689, 291, 362, 732, 22380, 2614, 293, 264, 8149, 307, 4069, 1547, 281, 764, 257, 3991, 1185, 51424], "temperature": 0.0, "avg_logprob": -0.11962991602280561, "compression_ratio": 1.5588235294117647, "no_speech_prob": 0.008814964443445206}, {"id": 108, "seek": 76224, "start": 762.24, "end": 769.44, "text": " log, even if you would network fence the broken node, the broken node had the file system log.", "tokens": [50364, 3565, 11, 754, 498, 291, 576, 3209, 15422, 264, 5463, 9984, 11, 264, 5463, 9984, 632, 264, 3991, 1185, 3565, 13, 50724], "temperature": 0.0, "avg_logprob": -0.0987089176972707, "compression_ratio": 1.705069124423963, "no_speech_prob": 0.04979994520545006}, {"id": 109, "seek": 76224, "start": 770.4, "end": 778.5600000000001, "text": " The second node doesn't immediately get the file system log if the first node", "tokens": [50772, 440, 1150, 9984, 1177, 380, 4258, 483, 264, 3991, 1185, 3565, 498, 264, 700, 9984, 51180], "temperature": 0.0, "avg_logprob": -0.0987089176972707, "compression_ratio": 1.705069124423963, "no_speech_prob": 0.04979994520545006}, {"id": 110, "seek": 76224, "start": 778.5600000000001, "end": 783.52, "text": " completely gets down. There will be a timeout and it might take, depending on the kind of issue", "tokens": [51180, 2584, 2170, 760, 13, 821, 486, 312, 257, 565, 346, 293, 309, 1062, 747, 11, 5413, 322, 264, 733, 295, 2734, 51428], "temperature": 0.0, "avg_logprob": -0.0987089176972707, "compression_ratio": 1.705069124423963, "no_speech_prob": 0.04979994520545006}, {"id": 111, "seek": 76224, "start": 783.52, "end": 790.64, "text": " that you had, it might take a while. So for CepFS, we actually evict CepFS clients, which is a little", "tokens": [51428, 300, 291, 632, 11, 309, 1062, 747, 257, 1339, 13, 407, 337, 383, 595, 29318, 11, 321, 767, 1073, 985, 383, 595, 29318, 6982, 11, 597, 307, 257, 707, 51784], "temperature": 0.0, "avg_logprob": -0.0987089176972707, "compression_ratio": 1.705069124423963, "no_speech_prob": 0.04979994520545006}, {"id": 112, "seek": 79064, "start": 790.64, "end": 799.92, "text": " bit different than block listing a client from the OSDs. That's for the background information,", "tokens": [50364, 857, 819, 813, 3461, 22161, 257, 6423, 490, 264, 12731, 35, 82, 13, 663, 311, 337, 264, 3678, 1589, 11, 50828], "temperature": 0.0, "avg_logprob": -0.12300902605056763, "compression_ratio": 1.5435684647302905, "no_speech_prob": 0.007244558539241552}, {"id": 113, "seek": 79064, "start": 799.92, "end": 808.72, "text": " but for RUK, it is relatively simple to detect if a node is out. RUK doesn't have its own logic", "tokens": [50828, 457, 337, 497, 52, 42, 11, 309, 307, 7226, 2199, 281, 5531, 498, 257, 9984, 307, 484, 13, 497, 52, 42, 1177, 380, 362, 1080, 1065, 9952, 51268], "temperature": 0.0, "avg_logprob": -0.12300902605056763, "compression_ratio": 1.5435684647302905, "no_speech_prob": 0.007244558539241552}, {"id": 114, "seek": 79064, "start": 808.72, "end": 812.48, "text": " to verify if a node is working correctly. There are dedicated projects for that.", "tokens": [51268, 281, 16888, 498, 257, 9984, 307, 1364, 8944, 13, 821, 366, 8374, 4455, 337, 300, 13, 51456], "temperature": 0.0, "avg_logprob": -0.12300902605056763, "compression_ratio": 1.5435684647302905, "no_speech_prob": 0.007244558539241552}, {"id": 115, "seek": 79064, "start": 814.48, "end": 819.92, "text": " I think a project like MediCADES is specialized in detecting the health of a node, and if something", "tokens": [51556, 286, 519, 257, 1716, 411, 3982, 72, 34, 6112, 2358, 307, 19813, 294, 40237, 264, 1585, 295, 257, 9984, 11, 293, 498, 746, 51828], "temperature": 0.0, "avg_logprob": -0.12300902605056763, "compression_ratio": 1.5435684647302905, "no_speech_prob": 0.007244558539241552}, {"id": 116, "seek": 81992, "start": 819.92, "end": 828.8, "text": " goes wrong, MediCADES can set a taint on a node. You can also set as an administrator a taint manually,", "tokens": [50364, 1709, 2085, 11, 3982, 72, 34, 6112, 2358, 393, 992, 257, 256, 5114, 322, 257, 9984, 13, 509, 393, 611, 992, 382, 364, 25529, 257, 256, 5114, 16945, 11, 50808], "temperature": 0.0, "avg_logprob": -0.09971946623267197, "compression_ratio": 1.5508021390374331, "no_speech_prob": 0.004637320525944233}, {"id": 117, "seek": 81992, "start": 828.8, "end": 836.0, "text": " and in this case, you put the out of service taint, and when RUK notices that a node is tainted", "tokens": [50808, 293, 294, 341, 1389, 11, 291, 829, 264, 484, 295, 2643, 256, 5114, 11, 293, 562, 497, 52, 42, 32978, 300, 257, 9984, 307, 256, 26278, 51168], "temperature": 0.0, "avg_logprob": -0.09971946623267197, "compression_ratio": 1.5508021390374331, "no_speech_prob": 0.004637320525944233}, {"id": 118, "seek": 81992, "start": 836.0, "end": 844.24, "text": " with out of service, it will start the network fencing for the drivers of the volumes that", "tokens": [51168, 365, 484, 295, 2643, 11, 309, 486, 722, 264, 3209, 283, 13644, 337, 264, 11590, 295, 264, 22219, 300, 51580], "temperature": 0.0, "avg_logprob": -0.09971946623267197, "compression_ratio": 1.5508021390374331, "no_speech_prob": 0.004637320525944233}, {"id": 119, "seek": 84424, "start": 844.24, "end": 850.48, "text": " are used on that particular node. So if your node is not using a CepFS volume, it's not going to", "tokens": [50364, 366, 1143, 322, 300, 1729, 9984, 13, 407, 498, 428, 9984, 307, 406, 1228, 257, 383, 595, 29318, 5523, 11, 309, 311, 406, 516, 281, 50676], "temperature": 0.0, "avg_logprob": -0.11453269904767963, "compression_ratio": 1.572972972972973, "no_speech_prob": 0.027392664924263954}, {"id": 120, "seek": 84424, "start": 850.48, "end": 860.24, "text": " network fence this particular node, because that node might still be used, or ideally, that will have", "tokens": [50676, 3209, 15422, 341, 1729, 9984, 11, 570, 300, 9984, 1062, 920, 312, 1143, 11, 420, 22915, 11, 300, 486, 362, 51164], "temperature": 0.0, "avg_logprob": -0.11453269904767963, "compression_ratio": 1.572972972972973, "no_speech_prob": 0.027392664924263954}, {"id": 121, "seek": 84424, "start": 860.24, "end": 871.28, "text": " the second database instance that should work correctly. This is then what you would see. So", "tokens": [51164, 264, 1150, 8149, 5197, 300, 820, 589, 8944, 13, 639, 307, 550, 437, 291, 576, 536, 13, 407, 51716], "temperature": 0.0, "avg_logprob": -0.11453269904767963, "compression_ratio": 1.572972972972973, "no_speech_prob": 0.027392664924263954}, {"id": 122, "seek": 87128, "start": 871.28, "end": 880.3199999999999, "text": " if you edit the taint, or if you manually created this YAML, this is what is shown. If you check", "tokens": [50364, 498, 291, 8129, 264, 256, 5114, 11, 420, 498, 291, 16945, 2942, 341, 398, 2865, 43, 11, 341, 307, 437, 307, 4898, 13, 759, 291, 1520, 50816], "temperature": 0.0, "avg_logprob": -0.19334709076654344, "compression_ratio": 1.5945945945945945, "no_speech_prob": 0.028963230550289154}, {"id": 123, "seek": 87128, "start": 880.3199999999999, "end": 890.16, "text": " the state of the network fence objects, and this is the host name, and whatnot, this is the IP", "tokens": [50816, 264, 1785, 295, 264, 3209, 15422, 6565, 11, 293, 341, 307, 264, 3975, 1315, 11, 293, 25882, 11, 341, 307, 264, 8671, 51308], "temperature": 0.0, "avg_logprob": -0.19334709076654344, "compression_ratio": 1.5945945945945945, "no_speech_prob": 0.028963230550289154}, {"id": 124, "seek": 87128, "start": 890.16, "end": 896.9599999999999, "text": " resisted defense, in this case, it's just a single one, and it was fenced 20 seconds ago. In this case,", "tokens": [51308, 4597, 292, 7654, 11, 294, 341, 1389, 11, 309, 311, 445, 257, 2167, 472, 11, 293, 309, 390, 283, 14672, 945, 3949, 2057, 13, 682, 341, 1389, 11, 51648], "temperature": 0.0, "avg_logprob": -0.19334709076654344, "compression_ratio": 1.5945945945945945, "no_speech_prob": 0.028963230550289154}, {"id": 125, "seek": 89696, "start": 897.44, "end": 906.32, "text": " and blocklisted from the OSDs, and the client was evicted from the MDSs. So another client can", "tokens": [50388, 293, 3461, 34890, 490, 264, 12731, 35, 82, 11, 293, 264, 6423, 390, 1073, 11254, 490, 264, 376, 11844, 82, 13, 407, 1071, 6423, 393, 50832], "temperature": 0.0, "avg_logprob": -0.1588078056062971, "compression_ratio": 1.4803149606299213, "no_speech_prob": 0.05619020760059357}, {"id": 126, "seek": 89696, "start": 906.32, "end": 915.2, "text": " resume operation with the MDS, it can obtain file logs, and it can talk to the OSDs as usual.", "tokens": [50832, 15358, 6916, 365, 264, 376, 11844, 11, 309, 393, 12701, 3991, 20820, 11, 293, 309, 393, 751, 281, 264, 12731, 35, 82, 382, 7713, 13, 51276], "temperature": 0.0, "avg_logprob": -0.1588078056062971, "compression_ratio": 1.4803149606299213, "no_speech_prob": 0.05619020760059357}, {"id": 127, "seek": 91520, "start": 916.08, "end": 926.4000000000001, "text": " If you recover this node, you can edit the network fence CR and mark it as unfenced.", "tokens": [50408, 759, 291, 8114, 341, 9984, 11, 291, 393, 8129, 264, 3209, 15422, 14123, 293, 1491, 309, 382, 3971, 14672, 13, 50924], "temperature": 0.0, "avg_logprob": -0.21435434045925947, "compression_ratio": 1.6845238095238095, "no_speech_prob": 0.08725544810295105}, {"id": 128, "seek": 91520, "start": 927.2800000000001, "end": 936.32, "text": " Yes, sure. The network fence is always a blacklist. The question is if the network fence is always a", "tokens": [50968, 1079, 11, 988, 13, 440, 3209, 15422, 307, 1009, 257, 2211, 8264, 13, 440, 1168, 307, 498, 264, 3209, 15422, 307, 1009, 257, 51420], "temperature": 0.0, "avg_logprob": -0.21435434045925947, "compression_ratio": 1.6845238095238095, "no_speech_prob": 0.08725544810295105}, {"id": 129, "seek": 91520, "start": 936.32, "end": 944.4000000000001, "text": " blacklist, and that is right. So usually everything is allowed, so the whole cluster is basically", "tokens": [51420, 2211, 8264, 11, 293, 300, 307, 558, 13, 407, 2673, 1203, 307, 4350, 11, 370, 264, 1379, 13630, 307, 1936, 51824], "temperature": 0.0, "avg_logprob": -0.21435434045925947, "compression_ratio": 1.6845238095238095, "no_speech_prob": 0.08725544810295105}, {"id": 130, "seek": 94440, "start": 944.4, "end": 948.0, "text": " allowed to communicate with the CEP cluster, the whole Kubernetes cluster in this case.", "tokens": [50364, 4350, 281, 7890, 365, 264, 383, 8929, 13630, 11, 264, 1379, 23145, 13630, 294, 341, 1389, 13, 50544], "temperature": 0.0, "avg_logprob": -0.16573629274473087, "compression_ratio": 1.587962962962963, "no_speech_prob": 0.012247670441865921}, {"id": 131, "seek": 94440, "start": 948.88, "end": 958.72, "text": " And we call it blocklist now, but yes, it's a blocklist. You can have an allow list, but that's", "tokens": [50588, 400, 321, 818, 309, 3461, 8264, 586, 11, 457, 2086, 11, 309, 311, 257, 3461, 8264, 13, 509, 393, 362, 364, 2089, 1329, 11, 457, 300, 311, 51080], "temperature": 0.0, "avg_logprob": -0.16573629274473087, "compression_ratio": 1.587962962962963, "no_speech_prob": 0.012247670441865921}, {"id": 132, "seek": 94440, "start": 958.72, "end": 963.92, "text": " less practical. If you want to secure an environment, then that's probably something you want to do,", "tokens": [51080, 1570, 8496, 13, 759, 291, 528, 281, 7144, 364, 2823, 11, 550, 300, 311, 1391, 746, 291, 528, 281, 360, 11, 51340], "temperature": 0.0, "avg_logprob": -0.16573629274473087, "compression_ratio": 1.587962962962963, "no_speech_prob": 0.012247670441865921}, {"id": 133, "seek": 94440, "start": 963.92, "end": 968.48, "text": " but for network fencing, we only do the blocklisting. Yes.", "tokens": [51340, 457, 337, 3209, 283, 13644, 11, 321, 787, 360, 264, 3461, 8264, 278, 13, 1079, 13, 51568], "temperature": 0.0, "avg_logprob": -0.16573629274473087, "compression_ratio": 1.587962962962963, "no_speech_prob": 0.012247670441865921}, {"id": 134, "seek": 96848, "start": 969.2, "end": 975.84, "text": " Basically two operations at the same time is evicting the client and also doing the network fence.", "tokens": [50400, 8537, 732, 7705, 412, 264, 912, 565, 307, 1073, 21490, 264, 6423, 293, 611, 884, 264, 3209, 15422, 13, 50732], "temperature": 0.0, "avg_logprob": -0.2576239142619388, "compression_ratio": 1.680473372781065, "no_speech_prob": 0.015207215212285519}, {"id": 135, "seek": 96848, "start": 975.84, "end": 986.16, "text": " So yes, so the question is if this happens with CEPFS, if network fencing is done,", "tokens": [50732, 407, 2086, 11, 370, 264, 1168, 307, 498, 341, 2314, 365, 383, 8929, 29318, 11, 498, 3209, 283, 13644, 307, 1096, 11, 51248], "temperature": 0.0, "avg_logprob": -0.2576239142619388, "compression_ratio": 1.680473372781065, "no_speech_prob": 0.015207215212285519}, {"id": 136, "seek": 96848, "start": 986.16, "end": 991.52, "text": " there are two operations and that's true. So there are two operations. The first operation is to evict", "tokens": [51248, 456, 366, 732, 7705, 293, 300, 311, 2074, 13, 407, 456, 366, 732, 7705, 13, 440, 700, 6916, 307, 281, 1073, 985, 51516], "temperature": 0.0, "avg_logprob": -0.2576239142619388, "compression_ratio": 1.680473372781065, "no_speech_prob": 0.015207215212285519}, {"id": 137, "seek": 99152, "start": 992.48, "end": 999.12, "text": " the client. If you evict on the CEP level, it actually already does the blocklisting,", "tokens": [50412, 264, 6423, 13, 759, 291, 1073, 985, 322, 264, 383, 8929, 1496, 11, 309, 767, 1217, 775, 264, 3461, 8264, 278, 11, 50744], "temperature": 0.0, "avg_logprob": -0.17050913546947724, "compression_ratio": 1.6883720930232557, "no_speech_prob": 0.06781340390443802}, {"id": 138, "seek": 99152, "start": 1000.96, "end": 1006.8, "text": " but we only evict the client if the client is actually connected. If you want to network fence", "tokens": [50836, 457, 321, 787, 1073, 985, 264, 6423, 498, 264, 6423, 307, 767, 4582, 13, 759, 291, 528, 281, 3209, 15422, 51128], "temperature": 0.0, "avg_logprob": -0.17050913546947724, "compression_ratio": 1.6883720930232557, "no_speech_prob": 0.06781340390443802}, {"id": 139, "seek": 99152, "start": 1006.8, "end": 1013.28, "text": " a client that does not have a CEPFS fast and connected at that time, we still blocklisted", "tokens": [51128, 257, 6423, 300, 775, 406, 362, 257, 383, 8929, 29318, 2370, 293, 4582, 412, 300, 565, 11, 321, 920, 3461, 34890, 51452], "temperature": 0.0, "avg_logprob": -0.17050913546947724, "compression_ratio": 1.6883720930232557, "no_speech_prob": 0.06781340390443802}, {"id": 140, "seek": 99152, "start": 1013.28, "end": 1019.76, "text": " additionally just to make sure that nothing happens in the future. Yes, yes. So we try to be", "tokens": [51452, 43181, 445, 281, 652, 988, 300, 1825, 2314, 294, 264, 2027, 13, 1079, 11, 2086, 13, 407, 321, 853, 281, 312, 51776], "temperature": 0.0, "avg_logprob": -0.17050913546947724, "compression_ratio": 1.6883720930232557, "no_speech_prob": 0.06781340390443802}, {"id": 141, "seek": 101976, "start": 1019.76, "end": 1024.72, "text": " as safe as possible and make sure that it's consistent. What the output here is, if it's", "tokens": [50364, 382, 3273, 382, 1944, 293, 652, 988, 300, 309, 311, 8398, 13, 708, 264, 5598, 510, 307, 11, 498, 309, 311, 50612], "temperature": 0.0, "avg_logprob": -0.14396007086641044, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.013632180169224739}, {"id": 142, "seek": 101976, "start": 1024.72, "end": 1030.64, "text": " fenced, then it really should not be not fenced. So even if you did not have CEPFS mounted,", "tokens": [50612, 283, 14672, 11, 550, 309, 534, 820, 406, 312, 406, 283, 14672, 13, 407, 754, 498, 291, 630, 406, 362, 383, 8929, 29318, 19138, 11, 50908], "temperature": 0.0, "avg_logprob": -0.14396007086641044, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.013632180169224739}, {"id": 143, "seek": 101976, "start": 1030.64, "end": 1036.64, "text": " it will still fence your node or your whole subnet or whatnot.", "tokens": [50908, 309, 486, 920, 15422, 428, 9984, 420, 428, 1379, 1422, 7129, 420, 25882, 13, 51208], "temperature": 0.0, "avg_logprob": -0.14396007086641044, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.013632180169224739}, {"id": 144, "seek": 101976, "start": 1041.76, "end": 1048.96, "text": " Yes, oh yes. So the fencing is done on the CEPF cluster and that means that any client", "tokens": [51464, 1079, 11, 1954, 2086, 13, 407, 264, 283, 13644, 307, 1096, 322, 264, 383, 8929, 37, 13630, 293, 300, 1355, 300, 604, 6423, 51824], "temperature": 0.0, "avg_logprob": -0.14396007086641044, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.013632180169224739}, {"id": 145, "seek": 104896, "start": 1049.04, "end": 1053.52, "text": " on the particular node won't be able to access the cluster anymore. So that's the whole goal.", "tokens": [50368, 322, 264, 1729, 9984, 1582, 380, 312, 1075, 281, 2105, 264, 13630, 3602, 13, 407, 300, 311, 264, 1379, 3387, 13, 50592], "temperature": 0.0, "avg_logprob": -0.12277228561873288, "compression_ratio": 1.7222222222222223, "no_speech_prob": 0.007314668502658606}, {"id": 146, "seek": 104896, "start": 1053.52, "end": 1058.16, "text": " It doesn't matter what kind of client it is. It can be a kernel mount file system. It can be", "tokens": [50592, 467, 1177, 380, 1871, 437, 733, 295, 6423, 309, 307, 13, 467, 393, 312, 257, 28256, 3746, 3991, 1185, 13, 467, 393, 312, 50824], "temperature": 0.0, "avg_logprob": -0.12277228561873288, "compression_ratio": 1.7222222222222223, "no_speech_prob": 0.007314668502658606}, {"id": 147, "seek": 104896, "start": 1058.16, "end": 1065.68, "text": " the fuse mount or it can be LibcFFS, which is also used in fuse. So none of these clients", "tokens": [50824, 264, 31328, 3746, 420, 309, 393, 312, 15834, 66, 6345, 50, 11, 597, 307, 611, 1143, 294, 31328, 13, 407, 6022, 295, 613, 6982, 51200], "temperature": 0.0, "avg_logprob": -0.12277228561873288, "compression_ratio": 1.7222222222222223, "no_speech_prob": 0.007314668502658606}, {"id": 148, "seek": 104896, "start": 1065.68, "end": 1071.92, "text": " will be able to use the file system anymore and that's just the security measure to prevent any", "tokens": [51200, 486, 312, 1075, 281, 764, 264, 3991, 1185, 3602, 293, 300, 311, 445, 264, 3825, 3481, 281, 4871, 604, 51512], "temperature": 0.0, "avg_logprob": -0.12277228561873288, "compression_ratio": 1.7222222222222223, "no_speech_prob": 0.007314668502658606}, {"id": 149, "seek": 107192, "start": 1071.92, "end": 1085.1200000000001, "text": " data inconsistencies. This is in fact what we do. So we evict the client. We figure out the client", "tokens": [50364, 1412, 22039, 4821, 4629, 13, 639, 307, 294, 1186, 437, 321, 360, 13, 407, 321, 1073, 985, 264, 6423, 13, 492, 2573, 484, 264, 6423, 51024], "temperature": 0.0, "avg_logprob": -0.1175287771916044, "compression_ratio": 1.7018633540372672, "no_speech_prob": 0.009350038133561611}, {"id": 150, "seek": 107192, "start": 1086.0800000000002, "end": 1092.24, "text": " on the worker node or from the worker node that is connected has a particular client ID.", "tokens": [51072, 322, 264, 11346, 9984, 420, 490, 264, 11346, 9984, 300, 307, 4582, 575, 257, 1729, 6423, 7348, 13, 51380], "temperature": 0.0, "avg_logprob": -0.1175287771916044, "compression_ratio": 1.7018633540372672, "no_speech_prob": 0.009350038133561611}, {"id": 151, "seek": 107192, "start": 1093.6000000000001, "end": 1097.2, "text": " We figure out this client ID for this particular IP address. It might be more than one", "tokens": [51448, 492, 2573, 484, 341, 6423, 7348, 337, 341, 1729, 8671, 2985, 13, 467, 1062, 312, 544, 813, 472, 51628], "temperature": 0.0, "avg_logprob": -0.1175287771916044, "compression_ratio": 1.7018633540372672, "no_speech_prob": 0.009350038133561611}, {"id": 152, "seek": 109720, "start": 1097.92, "end": 1101.44, "text": " and the network fencing will evict all of these clients", "tokens": [50400, 293, 264, 3209, 283, 13644, 486, 1073, 985, 439, 295, 613, 6982, 50576], "temperature": 0.0, "avg_logprob": -0.2514143753051758, "compression_ratio": 1.5185185185185186, "no_speech_prob": 0.007347968406975269}, {"id": 153, "seek": 109720, "start": 1104.0, "end": 1107.6000000000001, "text": " and then eventually it will also block list the clients and you can check with this", "tokens": [50704, 293, 550, 4728, 309, 486, 611, 3461, 1329, 264, 6982, 293, 291, 393, 1520, 365, 341, 50884], "temperature": 0.0, "avg_logprob": -0.2514143753051758, "compression_ratio": 1.5185185185185186, "no_speech_prob": 0.007347968406975269}, {"id": 154, "seek": 109720, "start": 1108.24, "end": 1112.32, "text": " OSD block list command if everything was fenced correctly or not.", "tokens": [50916, 12731, 35, 3461, 1329, 5622, 498, 1203, 390, 283, 14672, 8944, 420, 406, 13, 51120], "temperature": 0.0, "avg_logprob": -0.2514143753051758, "compression_ratio": 1.5185185185185186, "no_speech_prob": 0.007347968406975269}, {"id": 155, "seek": 111232, "start": 1112.96, "end": 1130.1599999999999, "text": " And yes, so this is the summary how RUG protects you or can protect you more from data inconsistencies", "tokens": [50396, 400, 2086, 11, 370, 341, 307, 264, 12691, 577, 497, 52, 38, 22583, 291, 420, 393, 2371, 291, 544, 490, 1412, 22039, 4821, 4629, 51256], "temperature": 0.0, "avg_logprob": -0.20942271096365792, "compression_ratio": 1.4615384615384615, "no_speech_prob": 0.008694545365869999}, {"id": 156, "seek": 111232, "start": 1130.1599999999999, "end": 1135.6799999999998, "text": " if you have multiple or potentially multiple workloads running on the same CEPFS file system.", "tokens": [51256, 498, 291, 362, 3866, 420, 7263, 3866, 32452, 2614, 322, 264, 912, 383, 8929, 37, 50, 3991, 1185, 13, 51532], "temperature": 0.0, "avg_logprob": -0.20942271096365792, "compression_ratio": 1.4615384615384615, "no_speech_prob": 0.008694545365869999}, {"id": 157, "seek": 111232, "start": 1136.56, "end": 1142.1599999999999, "text": " It's a very important feature not only for CEPFS but also for other storage environments", "tokens": [51576, 467, 311, 257, 588, 1021, 4111, 406, 787, 337, 383, 8929, 37, 50, 457, 611, 337, 661, 6725, 12388, 51856], "temperature": 0.0, "avg_logprob": -0.20942271096365792, "compression_ratio": 1.4615384615384615, "no_speech_prob": 0.008694545365869999}, {"id": 158, "seek": 114216, "start": 1142.16, "end": 1149.8400000000001, "text": " because silently corrupting your data is not what you really want. This can further be automated", "tokens": [50364, 570, 40087, 17366, 278, 428, 1412, 307, 406, 437, 291, 534, 528, 13, 639, 393, 3052, 312, 18473, 50748], "temperature": 0.0, "avg_logprob": -0.1741852609734786, "compression_ratio": 1.7342342342342343, "no_speech_prob": 0.011994012631475925}, {"id": 159, "seek": 114216, "start": 1149.8400000000001, "end": 1155.68, "text": " with additional operators like medecates and that do the health checking of nodes and if they", "tokens": [50748, 365, 4497, 19077, 411, 1205, 3045, 1024, 293, 300, 360, 264, 1585, 8568, 295, 13891, 293, 498, 436, 51040], "temperature": 0.0, "avg_logprob": -0.1741852609734786, "compression_ratio": 1.7342342342342343, "no_speech_prob": 0.011994012631475925}, {"id": 160, "seek": 114216, "start": 1155.68, "end": 1161.76, "text": " figure out that the node is not working they can taint the node. RUG then figures out the taint", "tokens": [51040, 2573, 484, 300, 264, 9984, 307, 406, 1364, 436, 393, 256, 5114, 264, 9984, 13, 497, 52, 38, 550, 9624, 484, 264, 256, 5114, 51344], "temperature": 0.0, "avg_logprob": -0.1741852609734786, "compression_ratio": 1.7342342342342343, "no_speech_prob": 0.011994012631475925}, {"id": 161, "seek": 114216, "start": 1161.76, "end": 1168.48, "text": " and RUG then starts the network fence CR. The network fence CR is then executed by the CSI add-ons", "tokens": [51344, 293, 497, 52, 38, 550, 3719, 264, 3209, 15422, 14123, 13, 440, 3209, 15422, 14123, 307, 550, 17577, 538, 264, 9460, 40, 909, 12, 892, 51680], "temperature": 0.0, "avg_logprob": -0.1741852609734786, "compression_ratio": 1.7342342342342343, "no_speech_prob": 0.011994012631475925}, {"id": 162, "seek": 116848, "start": 1169.04, "end": 1173.04, "text": " operator talking to the CEPF cluster and the CEPF cluster will not be able", "tokens": [50392, 12973, 1417, 281, 264, 383, 8929, 37, 13630, 293, 264, 383, 8929, 37, 13630, 486, 406, 312, 1075, 50592], "temperature": 0.0, "avg_logprob": -0.19594976251775567, "compression_ratio": 1.7246963562753037, "no_speech_prob": 0.03480250760912895}, {"id": 163, "seek": 116848, "start": 1174.88, "end": 1177.28, "text": " to communicate with the worker out anymore. There's a question.", "tokens": [50684, 281, 7890, 365, 264, 11346, 484, 3602, 13, 821, 311, 257, 1168, 13, 50804], "temperature": 0.0, "avg_logprob": -0.19594976251775567, "compression_ratio": 1.7246963562753037, "no_speech_prob": 0.03480250760912895}, {"id": 164, "seek": 116848, "start": 1178.56, "end": 1186.0, "text": " So it sounds like it has to be the case that CEPF is in the final position to control whether the", "tokens": [50868, 407, 309, 3263, 411, 309, 575, 281, 312, 264, 1389, 300, 383, 8929, 37, 307, 294, 264, 2572, 2535, 281, 1969, 1968, 264, 51240], "temperature": 0.0, "avg_logprob": -0.19594976251775567, "compression_ratio": 1.7246963562753037, "no_speech_prob": 0.03480250760912895}, {"id": 165, "seek": 116848, "start": 1186.0, "end": 1190.88, "text": " next pod is going to be able to use the same CEPFS file system otherwise there's no way to guarantee", "tokens": [51240, 958, 2497, 307, 516, 281, 312, 1075, 281, 764, 264, 912, 383, 8929, 37, 50, 3991, 1185, 5911, 456, 311, 572, 636, 281, 10815, 51484], "temperature": 0.0, "avg_logprob": -0.19594976251775567, "compression_ratio": 1.7246963562753037, "no_speech_prob": 0.03480250760912895}, {"id": 166, "seek": 116848, "start": 1190.88, "end": 1197.44, "text": " that the proper ordering occurs. Is that correct? So the question is that is CEPF is the", "tokens": [51484, 300, 264, 2296, 21739, 11843, 13, 1119, 300, 3006, 30, 407, 264, 1168, 307, 300, 307, 383, 8929, 37, 307, 264, 51812], "temperature": 0.0, "avg_logprob": -0.19594976251775567, "compression_ratio": 1.7246963562753037, "no_speech_prob": 0.03480250760912895}, {"id": 167, "seek": 119848, "start": 1199.28, "end": 1208.48, "text": " final source or the decision maker in fencing? It is but you also want to fence,", "tokens": [50404, 2572, 4009, 420, 264, 3537, 17127, 294, 283, 13644, 30, 467, 307, 457, 291, 611, 528, 281, 15422, 11, 50864], "temperature": 0.0, "avg_logprob": -0.13116907304333103, "compression_ratio": 1.7044025157232705, "no_speech_prob": 0.00962434895336628}, {"id": 168, "seek": 119848, "start": 1209.1200000000001, "end": 1215.44, "text": " you ideally want to fence on different levels but in order to have your data consistent not", "tokens": [50896, 291, 22915, 528, 281, 15422, 322, 819, 4358, 457, 294, 1668, 281, 362, 428, 1412, 8398, 406, 51212], "temperature": 0.0, "avg_logprob": -0.13116907304333103, "compression_ratio": 1.7044025157232705, "no_speech_prob": 0.00962434895336628}, {"id": 169, "seek": 119848, "start": 1215.44, "end": 1221.76, "text": " necessarily only your workloads but if you want to have your data consistent then that needs to be", "tokens": [51212, 4725, 787, 428, 32452, 457, 498, 291, 528, 281, 362, 428, 1412, 8398, 550, 300, 2203, 281, 312, 51528], "temperature": 0.0, "avg_logprob": -0.13116907304333103, "compression_ratio": 1.7044025157232705, "no_speech_prob": 0.00962434895336628}, {"id": 170, "seek": 122176, "start": 1221.76, "end": 1228.96, "text": " done on the storage level as low as possible. So CEPF is the one that decides who is allowed to", "tokens": [50364, 1096, 322, 264, 6725, 1496, 382, 2295, 382, 1944, 13, 407, 383, 8929, 37, 307, 264, 472, 300, 14898, 567, 307, 4350, 281, 50724], "temperature": 0.0, "avg_logprob": -0.09447934779715031, "compression_ratio": 1.819905213270142, "no_speech_prob": 0.2895043194293976}, {"id": 171, "seek": 122176, "start": 1228.96, "end": 1235.68, "text": " use your data and if there is a broken worker node a broken worker node should not be allowed to use", "tokens": [50724, 764, 428, 1412, 293, 498, 456, 307, 257, 5463, 11346, 9984, 257, 5463, 11346, 9984, 820, 406, 312, 4350, 281, 764, 51060], "temperature": 0.0, "avg_logprob": -0.09447934779715031, "compression_ratio": 1.819905213270142, "no_speech_prob": 0.2895043194293976}, {"id": 172, "seek": 122176, "start": 1235.68, "end": 1243.12, "text": " it the best way to prevent the broken worker node from using or modifying the data is by blocking", "tokens": [51060, 309, 264, 1151, 636, 281, 4871, 264, 5463, 11346, 9984, 490, 1228, 420, 42626, 264, 1412, 307, 538, 17776, 51432], "temperature": 0.0, "avg_logprob": -0.09447934779715031, "compression_ratio": 1.819905213270142, "no_speech_prob": 0.2895043194293976}, {"id": 173, "seek": 122176, "start": 1243.12, "end": 1248.24, "text": " it on the storage level on CEPF. Right but my question was neither should be the next pod", "tokens": [51432, 309, 322, 264, 6725, 1496, 322, 383, 8929, 37, 13, 1779, 457, 452, 1168, 390, 9662, 820, 312, 264, 958, 2497, 51688], "temperature": 0.0, "avg_logprob": -0.09447934779715031, "compression_ratio": 1.819905213270142, "no_speech_prob": 0.2895043194293976}, {"id": 174, "seek": 124824, "start": 1248.24, "end": 1252.8, "text": " was able to schedule because even step one that you missed it could cause a new pod to come.", "tokens": [50364, 390, 1075, 281, 7567, 570, 754, 1823, 472, 300, 291, 6721, 309, 727, 3082, 257, 777, 2497, 281, 808, 13, 50592], "temperature": 0.0, "avg_logprob": -0.308201775622012, "compression_ratio": 1.641025641025641, "no_speech_prob": 0.03383150324225426}, {"id": 175, "seek": 124824, "start": 1254.56, "end": 1261.84, "text": " So that would be allowed to happen because what? So the first step is that", "tokens": [50680, 407, 300, 576, 312, 4350, 281, 1051, 570, 437, 30, 407, 264, 700, 1823, 307, 300, 51044], "temperature": 0.0, "avg_logprob": -0.308201775622012, "compression_ratio": 1.641025641025641, "no_speech_prob": 0.03383150324225426}, {"id": 176, "seek": 124824, "start": 1264.4, "end": 1274.08, "text": " I'll rephrase it. The first step is that step zero is the broken out breaks. Step one is", "tokens": [51172, 286, 603, 319, 44598, 651, 309, 13, 440, 700, 1823, 307, 300, 1823, 4018, 307, 264, 5463, 484, 9857, 13, 5470, 472, 307, 51656], "temperature": 0.0, "avg_logprob": -0.308201775622012, "compression_ratio": 1.641025641025641, "no_speech_prob": 0.03383150324225426}, {"id": 177, "seek": 127408, "start": 1274.1599999999999, "end": 1281.52, "text": " Kubernetes detects some breakage and starts the pod on another node. Right and that's where you are", "tokens": [50368, 23145, 5531, 82, 512, 1821, 609, 293, 3719, 264, 2497, 322, 1071, 9984, 13, 1779, 293, 300, 311, 689, 291, 366, 50736], "temperature": 0.0, "avg_logprob": -0.18327377211879675, "compression_ratio": 1.598901098901099, "no_speech_prob": 0.022316567599773407}, {"id": 178, "seek": 127408, "start": 1281.52, "end": 1292.72, "text": " going to. Right in that case you're already late because the next pod might start to disrupt your", "tokens": [50736, 516, 281, 13, 1779, 294, 300, 1389, 291, 434, 1217, 3469, 570, 264, 958, 2497, 1062, 722, 281, 14124, 428, 51296], "temperature": 0.0, "avg_logprob": -0.18327377211879675, "compression_ratio": 1.598901098901099, "no_speech_prob": 0.022316567599773407}, {"id": 179, "seek": 127408, "start": 1292.72, "end": 1298.56, "text": " data and write in the same things and that is correct. Yes, yes so there's still in this case", "tokens": [51296, 1412, 293, 2464, 294, 264, 912, 721, 293, 300, 307, 3006, 13, 1079, 11, 2086, 370, 456, 311, 920, 294, 341, 1389, 51588], "temperature": 0.0, "avg_logprob": -0.18327377211879675, "compression_ratio": 1.598901098901099, "no_speech_prob": 0.022316567599773407}, {"id": 180, "seek": 129856, "start": 1298.6399999999999, "end": 1307.04, "text": " there's still a window where things might not go right and that is in this case a Kubernetes", "tokens": [50368, 456, 311, 920, 257, 4910, 689, 721, 1062, 406, 352, 558, 293, 300, 307, 294, 341, 1389, 257, 23145, 50788], "temperature": 0.0, "avg_logprob": -0.11896620099506681, "compression_ratio": 1.615819209039548, "no_speech_prob": 0.015392613597214222}, {"id": 181, "seek": 129856, "start": 1307.84, "end": 1317.36, "text": " issue and hopefully by automating more things like enabling like medicaid to detect a broken", "tokens": [50828, 2734, 293, 4696, 538, 3553, 990, 544, 721, 411, 23148, 411, 1205, 23840, 281, 5531, 257, 5463, 51304], "temperature": 0.0, "avg_logprob": -0.11896620099506681, "compression_ratio": 1.615819209039548, "no_speech_prob": 0.015392613597214222}, {"id": 182, "seek": 129856, "start": 1317.36, "end": 1324.1599999999999, "text": " pod or broken worker node immediately tainted and then make sure that it fails over. Kubernetes also", "tokens": [51304, 2497, 420, 5463, 11346, 9984, 4258, 256, 26278, 293, 550, 652, 988, 300, 309, 18199, 670, 13, 23145, 611, 51644], "temperature": 0.0, "avg_logprob": -0.11896620099506681, "compression_ratio": 1.615819209039548, "no_speech_prob": 0.015392613597214222}, {"id": 183, "seek": 132416, "start": 1324.16, "end": 1331.92, "text": " has a timeout in detecting if for example, Kuplet doesn't respond or so it doesn't immediately", "tokens": [50364, 575, 257, 565, 346, 294, 40237, 498, 337, 1365, 11, 20311, 14657, 1177, 380, 4196, 420, 370, 309, 1177, 380, 4258, 50752], "temperature": 0.0, "avg_logprob": -0.17148702600029078, "compression_ratio": 1.7061611374407584, "no_speech_prob": 0.019594160839915276}, {"id": 184, "seek": 132416, "start": 1331.92, "end": 1340.64, "text": " reschedule so you still have time to actually do some operations but you should not reschedule. Yes,", "tokens": [50752, 725, 19318, 2271, 370, 291, 920, 362, 565, 281, 767, 360, 512, 7705, 457, 291, 820, 406, 725, 19318, 2271, 13, 1079, 11, 51188], "temperature": 0.0, "avg_logprob": -0.17148702600029078, "compression_ratio": 1.7061611374407584, "no_speech_prob": 0.019594160839915276}, {"id": 185, "seek": 132416, "start": 1340.64, "end": 1345.3600000000001, "text": " it depends on the failure behavior that you see but you still need to be very fast on", "tokens": [51188, 309, 5946, 322, 264, 7763, 5223, 300, 291, 536, 457, 291, 920, 643, 281, 312, 588, 2370, 322, 51424], "temperature": 0.0, "avg_logprob": -0.17148702600029078, "compression_ratio": 1.7061611374407584, "no_speech_prob": 0.019594160839915276}, {"id": 186, "seek": 132416, "start": 1346.72, "end": 1350.8000000000002, "text": " automating it so if you have automation around it then that's the best but you", "tokens": [51492, 3553, 990, 309, 370, 498, 291, 362, 17769, 926, 309, 550, 300, 311, 264, 1151, 457, 291, 51696], "temperature": 0.0, "avg_logprob": -0.17148702600029078, "compression_ratio": 1.7061611374407584, "no_speech_prob": 0.019594160839915276}, {"id": 187, "seek": 135080, "start": 1351.2, "end": 1356.56, "text": " should try to have a large enough timeout for the rescheduling after a failure.", "tokens": [50384, 820, 853, 281, 362, 257, 2416, 1547, 565, 346, 337, 264, 725, 19318, 425, 278, 934, 257, 7763, 13, 50652], "temperature": 0.0, "avg_logprob": -0.14765764366496692, "compression_ratio": 1.7429906542056075, "no_speech_prob": 0.03234472498297691}, {"id": 188, "seek": 135080, "start": 1360.56, "end": 1365.9199999999998, "text": " Exactly so the comment is that you should check your timeouts and the ordering should be sufficient", "tokens": [50852, 7587, 370, 264, 2871, 307, 300, 291, 820, 1520, 428, 565, 7711, 293, 264, 21739, 820, 312, 11563, 51120], "temperature": 0.0, "avg_logprob": -0.14765764366496692, "compression_ratio": 1.7429906542056075, "no_speech_prob": 0.03234472498297691}, {"id": 189, "seek": 135080, "start": 1365.9199999999998, "end": 1372.6399999999999, "text": " so if you have long enough timeouts then you can be very safe and if you have very short timeouts", "tokens": [51120, 370, 498, 291, 362, 938, 1547, 565, 7711, 550, 291, 393, 312, 588, 3273, 293, 498, 291, 362, 588, 2099, 565, 7711, 51456], "temperature": 0.0, "avg_logprob": -0.14765764366496692, "compression_ratio": 1.7429906542056075, "no_speech_prob": 0.03234472498297691}, {"id": 190, "seek": 135080, "start": 1372.6399999999999, "end": 1378.56, "text": " then the challenge on problems is just bigger. It's not always good to have your application up", "tokens": [51456, 550, 264, 3430, 322, 2740, 307, 445, 3801, 13, 467, 311, 406, 1009, 665, 281, 362, 428, 3861, 493, 51752], "temperature": 0.0, "avg_logprob": -0.14765764366496692, "compression_ratio": 1.7429906542056075, "no_speech_prob": 0.03234472498297691}, {"id": 191, "seek": 137856, "start": 1379.28, "end": 1387.04, "text": " like five nines and sometimes a little bit lower but more safety is encouraged. This was it for my", "tokens": [50400, 411, 1732, 297, 1652, 293, 2171, 257, 707, 857, 3126, 457, 544, 4514, 307, 14658, 13, 639, 390, 309, 337, 452, 50788], "temperature": 0.0, "avg_logprob": -0.20073049110278748, "compression_ratio": 1.4472049689440993, "no_speech_prob": 0.0416124127805233}, {"id": 192, "seek": 137856, "start": 1387.04, "end": 1391.76, "text": " talk. I'm not sure if we still have we have two minutes for questions if there's anything", "tokens": [50788, 751, 13, 286, 478, 406, 988, 498, 321, 920, 362, 321, 362, 732, 2077, 337, 1651, 498, 456, 311, 1340, 51024], "temperature": 0.0, "avg_logprob": -0.20073049110278748, "compression_ratio": 1.4472049689440993, "no_speech_prob": 0.0416124127805233}, {"id": 193, "seek": 137856, "start": 1392.72, "end": 1402.56, "text": " and otherwise I thank you all for listening.", "tokens": [51072, 293, 5911, 286, 1309, 291, 439, 337, 4764, 13, 51564], "temperature": 0.0, "avg_logprob": -0.20073049110278748, "compression_ratio": 1.4472049689440993, "no_speech_prob": 0.0416124127805233}], "language": "en"}